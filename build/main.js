// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = import.meta.require;

// node_modules/decamelize/index.js
var require_decamelize = __commonJS((exports, module) => {
  module.exports = function(str, sep) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    sep = typeof sep === "undefined" ? "_" : sep;
    return str.replace(/([a-z\d])([A-Z])/g, "$1" + sep + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + sep + "$2").toLowerCase();
  };
});

// node_modules/camelcase/index.js
var require_camelcase = __commonJS((exports, module) => {
  var UPPERCASE = /[\p{Lu}]/u;
  var LOWERCASE = /[\p{Ll}]/u;
  var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
  var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
  var SEPARATORS = /[_.\- ]+/;
  var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
  var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
  var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
  var preserveCamelCase = (string, toLowerCase, toUpperCase) => {
    let isLastCharLower = false;
    let isLastCharUpper = false;
    let isLastLastCharUpper = false;
    for (let i = 0;i < string.length; i++) {
      const character = string[i];
      if (isLastCharLower && UPPERCASE.test(character)) {
        string = string.slice(0, i) + "-" + string.slice(i);
        isLastCharLower = false;
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = true;
        i++;
      } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
        string = string.slice(0, i - 1) + "-" + string.slice(i - 1);
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = false;
        isLastCharLower = true;
      } else {
        isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
      }
    }
    return string;
  };
  var preserveConsecutiveUppercase = (input, toLowerCase) => {
    LEADING_CAPITAL.lastIndex = 0;
    return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
  };
  var postProcess = (input, toUpperCase) => {
    SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
    NUMBERS_AND_IDENTIFIER.lastIndex = 0;
    return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
  };
  var camelCase = (input, options) => {
    if (!(typeof input === "string" || Array.isArray(input))) {
      throw new TypeError("Expected the input to be `string | string[]`");
    }
    options = {
      pascalCase: false,
      preserveConsecutiveUppercase: false,
      ...options
    };
    if (Array.isArray(input)) {
      input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
    } else {
      input = input.trim();
    }
    if (input.length === 0) {
      return "";
    }
    const toLowerCase = options.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options.locale);
    const toUpperCase = options.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options.locale);
    if (input.length === 1) {
      return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
    }
    const hasUpperCase = input !== toLowerCase(input);
    if (hasUpperCase) {
      input = preserveCamelCase(input, toLowerCase, toUpperCase);
    }
    input = input.replace(LEADING_SEPARATORS, "");
    if (options.preserveConsecutiveUppercase) {
      input = preserveConsecutiveUppercase(input, toLowerCase);
    } else {
      input = toLowerCase(input);
    }
    if (options.pascalCase) {
      input = toUpperCase(input.charAt(0)) + input.slice(1);
    }
    return postProcess(input, toUpperCase);
  };
  module.exports = camelCase;
  module.exports.default = camelCase;
});

// node_modules/uuid/dist/max.js
var require_max = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = exports.default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
});

// node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = exports.default = "00000000-0000-0000-0000-000000000000";
});

// node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
});

// node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function validate(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  }
  var _default = exports.default = validate;
});

// node_modules/uuid/dist/parse.js
var require_parse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function parse(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  }
  var _default = exports.default = parse;
});

// node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.unsafeStringify = unsafeStringify;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }
  function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  var _default = exports.default = stringify;
});

// node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _nodeCrypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
  function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
      _nodeCrypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }
});

// node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  function v1(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node;
    let clockseq = options.clockseq;
    if (!options._v6) {
      if (!node) {
        node = _nodeId;
      }
      if (clockseq == null) {
        clockseq = _clockseq;
      }
    }
    if (node == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node == null) {
        node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        if (!_nodeId && !options._v6) {
          node[0] |= 1;
          _nodeId = node;
        }
      }
      if (clockseq == null) {
        clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        if (_clockseq === undefined && !options._v6) {
          _clockseq = clockseq;
        }
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (let n = 0;n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf || (0, _stringify.unsafeStringify)(b);
  }
  var _default = exports.default = v1;
});

// node_modules/uuid/dist/v1ToV6.js
var require_v1ToV6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = v1ToV6;
  var _parse = _interopRequireDefault(require_parse());
  var _stringify = require_stringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function v1ToV6(uuid) {
    const v1Bytes = typeof uuid === "string" ? (0, _parse.default)(uuid) : uuid;
    const v6Bytes = _v1ToV6(v1Bytes);
    return typeof uuid === "string" ? (0, _stringify.unsafeStringify)(v6Bytes) : v6Bytes;
  }
  function _v1ToV6(v1Bytes, randomize = false) {
    return Uint8Array.of((v1Bytes[6] & 15) << 4 | v1Bytes[7] >> 4 & 15, (v1Bytes[7] & 15) << 4 | (v1Bytes[4] & 240) >> 4, (v1Bytes[4] & 15) << 4 | (v1Bytes[5] & 240) >> 4, (v1Bytes[5] & 15) << 4 | (v1Bytes[0] & 240) >> 4, (v1Bytes[0] & 15) << 4 | (v1Bytes[1] & 240) >> 4, (v1Bytes[1] & 15) << 4 | (v1Bytes[2] & 240) >> 4, 96 | v1Bytes[2] & 15, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
  }
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.URL = exports.DNS = undefined;
  exports.default = v35;
  var _stringify = require_stringify();
  var _parse = _interopRequireDefault(require_parse());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i = 0;i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  }
  var DNS = exports.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  var URL2 = exports.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  function v35(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      var _namespace;
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === undefined ? undefined : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0;i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {}
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  }
});

// node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _nodeCrypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function md5(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _nodeCrypto.default.createHash("md5").update(bytes).digest();
  }
  var _default = exports.default = md5;
});

// node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = exports.default = v3;
});

// node_modules/uuid/dist/native.js
var require_native = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _nodeCrypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var _default = exports.default = {
    randomUUID: _nodeCrypto.default.randomUUID
  };
});

// node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _native = _interopRequireDefault(require_native());
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function v4(options, buf, offset) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  }
  var _default = exports.default = v4;
});

// node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _nodeCrypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function sha1(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _nodeCrypto.default.createHash("sha1").update(bytes).digest();
  }
  var _default = exports.default = sha1;
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = exports.default = v5;
});

// node_modules/uuid/dist/v6.js
var require_v6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = v6;
  var _stringify = require_stringify();
  var _v = _interopRequireDefault(require_v1());
  var _v1ToV = _interopRequireDefault(require_v1ToV6());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function v6(options = {}, buf, offset = 0) {
    let bytes = (0, _v.default)({
      ...options,
      _v6: true
    }, new Uint8Array(16));
    bytes = (0, _v1ToV.default)(bytes);
    if (buf) {
      for (let i = 0;i < 16; i++) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(bytes);
  }
});

// node_modules/uuid/dist/v6ToV1.js
var require_v6ToV1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = v6ToV1;
  var _parse = _interopRequireDefault(require_parse());
  var _stringify = require_stringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function v6ToV1(uuid) {
    const v6Bytes = typeof uuid === "string" ? (0, _parse.default)(uuid) : uuid;
    const v1Bytes = _v6ToV1(v6Bytes);
    return typeof uuid === "string" ? (0, _stringify.unsafeStringify)(v1Bytes) : v1Bytes;
  }
  function _v6ToV1(v6Bytes) {
    return Uint8Array.of((v6Bytes[3] & 15) << 4 | v6Bytes[4] >> 4 & 15, (v6Bytes[4] & 15) << 4 | (v6Bytes[5] & 240) >> 4, (v6Bytes[5] & 15) << 4 | v6Bytes[6] & 15, v6Bytes[7], (v6Bytes[1] & 15) << 4 | (v6Bytes[2] & 240) >> 4, (v6Bytes[2] & 15) << 4 | (v6Bytes[3] & 240) >> 4, 16 | (v6Bytes[0] & 240) >> 4, (v6Bytes[0] & 15) << 4 | (v6Bytes[1] & 240) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
  }
});

// node_modules/uuid/dist/v7.js
var require_v7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var _seqLow = null;
  var _seqHigh = null;
  var _msecs = 0;
  function v7(options, buf, offset) {
    options = options || {};
    let i = buf && offset || 0;
    const b = buf || new Uint8Array(16);
    const rnds = options.random || (options.rng || _rng.default)();
    const msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let seq = options.seq !== undefined ? options.seq : null;
    let seqHigh = _seqHigh;
    let seqLow = _seqLow;
    if (msecs > _msecs && options.msecs === undefined) {
      _msecs = msecs;
      if (seq !== null) {
        seqHigh = null;
        seqLow = null;
      }
    }
    if (seq !== null) {
      if (seq > 2147483647) {
        seq = 2147483647;
      }
      seqHigh = seq >>> 19 & 4095;
      seqLow = seq & 524287;
    }
    if (seqHigh === null || seqLow === null) {
      seqHigh = rnds[6] & 127;
      seqHigh = seqHigh << 8 | rnds[7];
      seqLow = rnds[8] & 63;
      seqLow = seqLow << 8 | rnds[9];
      seqLow = seqLow << 5 | rnds[10] >>> 3;
    }
    if (msecs + 1e4 > _msecs && seq === null) {
      if (++seqLow > 524287) {
        seqLow = 0;
        if (++seqHigh > 4095) {
          seqHigh = 0;
          _msecs++;
        }
      }
    } else {
      _msecs = msecs;
    }
    _seqHigh = seqHigh;
    _seqLow = seqLow;
    b[i++] = _msecs / 1099511627776 & 255;
    b[i++] = _msecs / 4294967296 & 255;
    b[i++] = _msecs / 16777216 & 255;
    b[i++] = _msecs / 65536 & 255;
    b[i++] = _msecs / 256 & 255;
    b[i++] = _msecs & 255;
    b[i++] = seqHigh >>> 4 & 15 | 112;
    b[i++] = seqHigh & 255;
    b[i++] = seqLow >>> 13 & 63 | 128;
    b[i++] = seqLow >>> 5 & 255;
    b[i++] = seqLow << 3 & 255 | rnds[10] & 7;
    b[i++] = rnds[11];
    b[i++] = rnds[12];
    b[i++] = rnds[13];
    b[i++] = rnds[14];
    b[i++] = rnds[15];
    return buf || (0, _stringify.unsafeStringify)(b);
  }
  var _default = exports.default = v7;
});

// node_modules/uuid/dist/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function version(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.slice(14, 15), 16);
  }
  var _default = exports.default = version;
});

// node_modules/uuid/dist/index.js
var require_dist = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "MAX", {
    enumerable: true,
    get: function() {
      return _max.default;
    }
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v1ToV6", {
    enumerable: true,
    get: function() {
      return _v1ToV.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "v6", {
    enumerable: true,
    get: function() {
      return _v5.default;
    }
  });
  Object.defineProperty(exports, "v6ToV1", {
    enumerable: true,
    get: function() {
      return _v6ToV.default;
    }
  });
  Object.defineProperty(exports, "v7", {
    enumerable: true,
    get: function() {
      return _v6.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  var _max = _interopRequireDefault(require_max());
  var _nil = _interopRequireDefault(require_nil());
  var _parse = _interopRequireDefault(require_parse());
  var _stringify = _interopRequireDefault(require_stringify());
  var _v = _interopRequireDefault(require_v1());
  var _v1ToV = _interopRequireDefault(require_v1ToV6());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _v5 = _interopRequireDefault(require_v6());
  var _v6ToV = _interopRequireDefault(require_v6ToV1());
  var _v6 = _interopRequireDefault(require_v7());
  var _validate = _interopRequireDefault(require_validate());
  var _version = _interopRequireDefault(require_version());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS((exports, module) => {
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  function Events() {}
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events;
    else
      delete emitter._events[evt];
  }
  function EventEmitter() {
    this._events = new Events;
    this._eventsCount = 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l);i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1);i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0;i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1);j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length;i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter;
  }
});

// node_modules/p-finally/index.js
var require_p_finally = __commonJS((exports, module) => {
  module.exports = (promise, onFinally) => {
    onFinally = onFinally || (() => {});
    return promise.then((val) => new Promise((resolve) => {
      resolve(onFinally());
    }).then(() => val), (err) => new Promise((resolve) => {
      resolve(onFinally());
    }).then(() => {
      throw err;
    }));
  };
});

// node_modules/p-queue/node_modules/p-timeout/index.js
var require_p_timeout = __commonJS((exports, module) => {
  var pFinally = require_p_finally();

  class TimeoutError extends Error {
    constructor(message) {
      super(message);
      this.name = "TimeoutError";
    }
  }
  var pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || milliseconds < 0) {
      throw new TypeError("Expected `milliseconds` to be a positive number");
    }
    if (milliseconds === Infinity) {
      resolve(promise);
      return;
    }
    const timer = setTimeout(() => {
      if (typeof fallback === "function") {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError);
    }, milliseconds);
    pFinally(promise.then(resolve, reject), () => {
      clearTimeout(timer);
    });
  });
  module.exports = pTimeout;
  module.exports.default = pTimeout;
  module.exports.TimeoutError = TimeoutError;
});

// node_modules/p-queue/dist/lower-bound.js
var require_lower_bound = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function lowerBound(array, value, comparator) {
    let first = 0;
    let count = array.length;
    while (count > 0) {
      const step = count / 2 | 0;
      let it = first + step;
      if (comparator(array[it], value) <= 0) {
        first = ++it;
        count -= step + 1;
      } else {
        count = step;
      }
    }
    return first;
  }
  exports.default = lowerBound;
});

// node_modules/p-queue/dist/priority-queue.js
var require_priority_queue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var lower_bound_1 = require_lower_bound();

  class PriorityQueue {
    constructor() {
      this._queue = [];
    }
    enqueue(run, options) {
      options = Object.assign({ priority: 0 }, options);
      const element = {
        priority: options.priority,
        run
      };
      if (this.size && this._queue[this.size - 1].priority >= options.priority) {
        this._queue.push(element);
        return;
      }
      const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);
      this._queue.splice(index, 0, element);
    }
    dequeue() {
      const item = this._queue.shift();
      return item === null || item === undefined ? undefined : item.run;
    }
    filter(options) {
      return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);
    }
    get size() {
      return this._queue.length;
    }
  }
  exports.default = PriorityQueue;
});

// node_modules/p-queue/dist/index.js
var require_dist2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var EventEmitter = require_eventemitter3();
  var p_timeout_1 = require_p_timeout();
  var priority_queue_1 = require_priority_queue();
  var empty = () => {};
  var timeoutError = new p_timeout_1.TimeoutError;

  class PQueue extends EventEmitter {
    constructor(options) {
      var _a, _b, _c, _d;
      super();
      this._intervalCount = 0;
      this._intervalEnd = 0;
      this._pendingCount = 0;
      this._resolveEmpty = empty;
      this._resolveIdle = empty;
      options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);
      if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
        throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === undefined ? undefined : _a.toString()) !== null && _b !== undefined ? _b : ""}\` (${typeof options.intervalCap})`);
      }
      if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {
        throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === undefined ? undefined : _c.toString()) !== null && _d !== undefined ? _d : ""}\` (${typeof options.interval})`);
      }
      this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
      this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
      this._intervalCap = options.intervalCap;
      this._interval = options.interval;
      this._queue = new options.queueClass;
      this._queueClass = options.queueClass;
      this.concurrency = options.concurrency;
      this._timeout = options.timeout;
      this._throwOnTimeout = options.throwOnTimeout === true;
      this._isPaused = options.autoStart === false;
    }
    get _doesIntervalAllowAnother() {
      return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
    }
    get _doesConcurrentAllowAnother() {
      return this._pendingCount < this._concurrency;
    }
    _next() {
      this._pendingCount--;
      this._tryToStartAnother();
      this.emit("next");
    }
    _resolvePromises() {
      this._resolveEmpty();
      this._resolveEmpty = empty;
      if (this._pendingCount === 0) {
        this._resolveIdle();
        this._resolveIdle = empty;
        this.emit("idle");
      }
    }
    _onResumeInterval() {
      this._onInterval();
      this._initializeIntervalIfNeeded();
      this._timeoutId = undefined;
    }
    _isIntervalPaused() {
      const now = Date.now();
      if (this._intervalId === undefined) {
        const delay = this._intervalEnd - now;
        if (delay < 0) {
          this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        } else {
          if (this._timeoutId === undefined) {
            this._timeoutId = setTimeout(() => {
              this._onResumeInterval();
            }, delay);
          }
          return true;
        }
      }
      return false;
    }
    _tryToStartAnother() {
      if (this._queue.size === 0) {
        if (this._intervalId) {
          clearInterval(this._intervalId);
        }
        this._intervalId = undefined;
        this._resolvePromises();
        return false;
      }
      if (!this._isPaused) {
        const canInitializeInterval = !this._isIntervalPaused();
        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
          const job = this._queue.dequeue();
          if (!job) {
            return false;
          }
          this.emit("active");
          job();
          if (canInitializeInterval) {
            this._initializeIntervalIfNeeded();
          }
          return true;
        }
      }
      return false;
    }
    _initializeIntervalIfNeeded() {
      if (this._isIntervalIgnored || this._intervalId !== undefined) {
        return;
      }
      this._intervalId = setInterval(() => {
        this._onInterval();
      }, this._interval);
      this._intervalEnd = Date.now() + this._interval;
    }
    _onInterval() {
      if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
        clearInterval(this._intervalId);
        this._intervalId = undefined;
      }
      this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
      this._processQueue();
    }
    _processQueue() {
      while (this._tryToStartAnother()) {}
    }
    get concurrency() {
      return this._concurrency;
    }
    set concurrency(newConcurrency) {
      if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
      }
      this._concurrency = newConcurrency;
      this._processQueue();
    }
    async add(fn, options = {}) {
      return new Promise((resolve, reject) => {
        const run = async () => {
          this._pendingCount++;
          this._intervalCount++;
          try {
            const operation = this._timeout === undefined && options.timeout === undefined ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === undefined ? this._timeout : options.timeout, () => {
              if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {
                reject(timeoutError);
              }
              return;
            });
            resolve(await operation);
          } catch (error) {
            reject(error);
          }
          this._next();
        };
        this._queue.enqueue(run, options);
        this._tryToStartAnother();
        this.emit("add");
      });
    }
    async addAll(functions, options) {
      return Promise.all(functions.map(async (function_) => this.add(function_, options)));
    }
    start() {
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      this._processQueue();
      return this;
    }
    pause() {
      this._isPaused = true;
    }
    clear() {
      this._queue = new this._queueClass;
    }
    async onEmpty() {
      if (this._queue.size === 0) {
        return;
      }
      return new Promise((resolve) => {
        const existingResolve = this._resolveEmpty;
        this._resolveEmpty = () => {
          existingResolve();
          resolve();
        };
      });
    }
    async onIdle() {
      if (this._pendingCount === 0 && this._queue.size === 0) {
        return;
      }
      return new Promise((resolve) => {
        const existingResolve = this._resolveIdle;
        this._resolveIdle = () => {
          existingResolve();
          resolve();
        };
      });
    }
    get size() {
      return this._queue.size;
    }
    sizeBy(options) {
      return this._queue.filter(options).length;
    }
    get pending() {
      return this._pendingCount;
    }
    get isPaused() {
      return this._isPaused;
    }
    get timeout() {
      return this._timeout;
    }
    set timeout(milliseconds) {
      this._timeout = milliseconds;
    }
  }
  exports.default = PQueue;
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS((exports, module) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {};
  module.exports = debug;
});

// node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants();
  var debug = require_debug();
  exports = module.exports = {};
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var safeSrc = exports.safeSrc = [];
  var t = exports.t = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  var createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    safeSrc[index] = safe;
    re[index] = new RegExp(value, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])" + "(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
  createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + `(?:$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("COERCERTLFULL", src[t.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  module.exports = parseOptions;
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a, b) => {
    if (typeof a === "number" && typeof b === "number") {
      return a === b ? 0 : a < b ? -1 : 1;
    }
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports, module) => {
  var debug = require_debug();
  var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
  var { safeRe: re, t } = require_re();
  var parseOptions = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version2, options) {
      options = parseOptions(options);
      if (version2 instanceof SemVer) {
        if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version2}`);
      }
      this.raw = version2;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.major < other.major) {
        return -1;
      }
      if (this.major > other.major) {
        return 1;
      }
      if (this.minor < other.minor) {
        return -1;
      }
      if (this.minor > other.minor) {
        return 1;
      }
      if (this.patch < other.patch) {
        return -1;
      }
      if (this.patch > other.patch) {
        return 1;
      }
      return 0;
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug("prerelease compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug("build compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    inc(release, identifier, identifierBase) {
      if (release.startsWith("pre")) {
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (identifier) {
          const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
          if (!match || match[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`);
          }
        }
      }
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "release":
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`);
          }
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module.exports = SemVer;
});

// node_modules/semver/functions/parse.js
var require_parse2 = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse2 = (version2, options, throwErrors = false) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    try {
      return new SemVer(version2, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  module.exports = parse2;
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports, module) => {
  var parse2 = require_parse2();
  var valid = (version2, options) => {
    const v = parse2(version2, options);
    return v ? v.version : null;
  };
  module.exports = valid;
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports, module) => {
  var parse2 = require_parse2();
  var clean = (version2, options) => {
    const s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  module.exports = clean;
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var inc = (version2, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = undefined;
    }
    try {
      return new SemVer(version2 instanceof SemVer ? version2.version : version2, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  module.exports = inc;
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports, module) => {
  var parse2 = require_parse2();
  var diff = (version1, version2) => {
    const v12 = parse2(version1, null, true);
    const v2 = parse2(version2, null, true);
    const comparison = v12.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v12 : v2;
    const lowVersion = v1Higher ? v2 : v12;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (lowVersion.compareMain(highVersion) === 0) {
        if (lowVersion.minor && !lowVersion.patch) {
          return "minor";
        }
        return "patch";
      }
    }
    const prefix = highHasPre ? "pre" : "";
    if (v12.major !== v2.major) {
      return prefix + "major";
    }
    if (v12.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v12.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  module.exports = diff;
});

// node_modules/semver/functions/major.js
var require_major = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var major = (a, loose) => new SemVer(a, loose).major;
  module.exports = major;
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var minor = (a, loose) => new SemVer(a, loose).minor;
  module.exports = minor;
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var patch = (a, loose) => new SemVer(a, loose).patch;
  module.exports = patch;
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports, module) => {
  var parse2 = require_parse2();
  var prerelease = (version2, options) => {
    const parsed = parse2(version2, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module.exports = prerelease;
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  module.exports = compare;
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports, module) => {
  var compare = require_compare();
  var rcompare = (a, b, loose) => compare(b, a, loose);
  module.exports = rcompare;
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports, module) => {
  var compare = require_compare();
  var compareLoose = (a, b) => compare(a, b, true);
  module.exports = compareLoose;
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module.exports = compareBuild;
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
  module.exports = sort;
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
  module.exports = rsort;
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module) => {
  var compare = require_compare();
  var gt = (a, b, loose) => compare(a, b, loose) > 0;
  module.exports = gt;
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module) => {
  var compare = require_compare();
  var lt = (a, b, loose) => compare(a, b, loose) < 0;
  module.exports = lt;
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module) => {
  var compare = require_compare();
  var eq = (a, b, loose) => compare(a, b, loose) === 0;
  module.exports = eq;
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module) => {
  var compare = require_compare();
  var neq = (a, b, loose) => compare(a, b, loose) !== 0;
  module.exports = neq;
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module) => {
  var compare = require_compare();
  var gte = (a, b, loose) => compare(a, b, loose) >= 0;
  module.exports = gte;
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module) => {
  var compare = require_compare();
  var lte = (a, b, loose) => compare(a, b, loose) <= 0;
  module.exports = lte;
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module.exports = cmp;
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse2 = require_parse2();
  var { safeRe: re, t } = require_re();
  var coerce = (version2, options) => {
    if (version2 instanceof SemVer) {
      return version2;
    }
    if (typeof version2 === "number") {
      version2 = String(version2);
    }
    if (typeof version2 !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version2.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  module.exports = coerce;
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS((exports, module) => {
  class LRUCache {
    constructor() {
      this.max = 1000;
      this.map = new Map;
    }
    get(key) {
      const value = this.map.get(key);
      if (value === undefined) {
        return;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== undefined) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }
  module.exports = LRUCache;
});

// node_modules/semver/classes/range.js
var require_range = __commonJS((exports, module) => {
  var SPACE_CHARACTERS = /\s+/g;

  class Range {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.formatted = undefined;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = undefined;
    }
    get range() {
      if (this.formatted === undefined) {
        this.formatted = "";
        for (let i = 0;i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0;k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      debug("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re[t.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0;i < this.set.length; i++) {
        if (testSet(this.set[i], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module.exports = Range;
  var LRU = require_lrucache();
  var cache = new LRU;
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug = require_debug();
  var SemVer = require_semver();
  var {
    safeRe: re,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
  var isNullSet = (c) => c.value === "<0.0.0-0";
  var isAny = (c) => c.value === "";
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    comp = comp.replace(re[t.BUILD], "");
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  var replaceTilde = (comp, options) => {
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  var replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set, version2, options) => {
    for (let i = 0;i < set.length; i++) {
      if (!set[i].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i = 0;i < set.length; i++) {
        debug(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== undefined ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY || version2 === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module.exports = Comparator;
  var parseOptions = require_parse_options();
  var { safeRe: re, t } = require_re();
  var cmp = require_cmp();
  var debug = require_debug();
  var SemVer = require_semver();
  var Range = require_range();
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module) => {
  var Range = require_range();
  var satisfies = (version2, range, options) => {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version2);
  };
  module.exports = satisfies;
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports, module) => {
  var Range = require_range();
  var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  module.exports = toComparators;
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var maxSatisfying = (versions, range, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module.exports = maxSatisfying;
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var minSatisfying = (versions, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module.exports = minSatisfying;
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var gt = require_gt();
  var minVersion = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module.exports = minVersion;
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports, module) => {
  var Range = require_range();
  var validRange = (range, options) => {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module.exports = validRange;
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var Range = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version2, range, hilo, options) => {
    version2 = new SemVer(version2, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version2, range, options)) {
      return false;
    }
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module.exports = outside;
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports, module) => {
  var outside = require_outside();
  var gtr = (version2, range, options) => outside(version2, range, ">", options);
  module.exports = gtr;
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports, module) => {
  var outside = require_outside();
  var ltr = (version2, range, options) => outside(version2, range, "<", options);
  module.exports = ltr;
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports, module) => {
  var Range = require_range();
  var intersects = (r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
  };
  module.exports = intersects;
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports, module) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module.exports = (versions, range, options) => {
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options));
    for (const version2 of v) {
      const included = satisfies(version2, range, options);
      if (included) {
        prev = version2;
        if (!first) {
          first = version2;
        }
      } else {
        if (prev) {
          set.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports, module) => {
  var Range = require_range();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
    return true;
  };
  var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  var minimumVersion = [new Comparator(">=0.0.0")];
  var simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = new Set;
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=") {
        gt = higherGT(gt, c, options);
      } else if (c.operator === "<" || c.operator === "<=") {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      for (const c of dom) {
        if (!satisfies(eq, String(c), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
          return false;
        }
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  var higherGT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  var lowerLT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  module.exports = subset;
});

// node_modules/semver/index.js
var require_semver2 = __commonJS((exports, module) => {
  var internalRe = require_re();
  var constants = require_constants();
  var SemVer = require_semver();
  var identifiers = require_identifiers();
  var parse2 = require_parse2();
  var valid = require_valid();
  var clean = require_clean();
  var inc = require_inc();
  var diff = require_diff();
  var major = require_major();
  var minor = require_minor();
  var patch = require_patch();
  var prerelease = require_prerelease();
  var compare = require_compare();
  var rcompare = require_rcompare();
  var compareLoose = require_compare_loose();
  var compareBuild = require_compare_build();
  var sort = require_sort();
  var rsort = require_rsort();
  var gt = require_gt();
  var lt = require_lt();
  var eq = require_eq();
  var neq = require_neq();
  var gte = require_gte();
  var lte = require_lte();
  var cmp = require_cmp();
  var coerce = require_coerce();
  var Comparator = require_comparator();
  var Range = require_range();
  var satisfies = require_satisfies();
  var toComparators = require_to_comparators();
  var maxSatisfying = require_max_satisfying();
  var minSatisfying = require_min_satisfying();
  var minVersion = require_min_version();
  var validRange = require_valid2();
  var outside = require_outside();
  var gtr = require_gtr();
  var ltr = require_ltr();
  var intersects = require_intersects();
  var simplifyRange = require_simplify();
  var subset = require_subset();
  module.exports = {
    parse: parse2,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS((exports, module) => {
  var ANSI_BACKGROUND_OFFSET = 10;
  var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
  var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
  function assembleStyles() {
    const codes = new Map;
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        overline: [53, 55],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles, "codes", {
      value: codes,
      enumerable: false
    });
    styles.color.close = "\x1B[39m";
    styles.bgColor.close = "\x1B[49m";
    styles.color.ansi256 = wrapAnsi256();
    styles.color.ansi16m = wrapAnsi16m();
    styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
    Object.defineProperties(styles, {
      rgbToAnsi256: {
        value: (red, green, blue) => {
          if (red === green && green === blue) {
            if (red < 8) {
              return 16;
            }
            if (red > 248) {
              return 231;
            }
            return Math.round((red - 8) / 247 * 24) + 232;
          }
          return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
        },
        enumerable: false
      },
      hexToRgb: {
        value: (hex) => {
          const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
          if (!matches) {
            return [0, 0, 0];
          }
          let { colorString } = matches.groups;
          if (colorString.length === 3) {
            colorString = colorString.split("").map((character) => character + character).join("");
          }
          const integer = Number.parseInt(colorString, 16);
          return [
            integer >> 16 & 255,
            integer >> 8 & 255,
            integer & 255
          ];
        },
        enumerable: false
      },
      hexToAnsi256: {
        value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
        enumerable: false
      }
    });
    return styles;
  }
  Object.defineProperty(module, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});

// node_modules/zod/v4/core/core.js
function $constructor(name, initializer, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: new Set
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0;i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a;
    const inst = params?.Parent ? new Definition : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
var NEVER, $brand, $ZodAsyncError, $ZodEncodeError, globalConfig;
var init_core = __esm(() => {
  NEVER = Object.freeze({
    status: "aborted"
  });
  $brand = Symbol("zod_brand");
  $ZodAsyncError = class $ZodAsyncError extends Error {
    constructor() {
      super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
    }
  };
  $ZodEncodeError = class $ZodEncodeError extends Error {
    constructor(name) {
      super(`Encountered unidirectional transform during encode: ${name}`);
      this.name = "ZodEncodeError";
    }
  };
  globalConfig = {};
});

// node_modules/zod/v4/core/util.js
var exports_util = {};
__export(exports_util, {
  unwrapMessage: () => unwrapMessage,
  uint8ArrayToHex: () => uint8ArrayToHex,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  stringifyPrimitive: () => stringifyPrimitive,
  slugify: () => slugify,
  shallowClone: () => shallowClone,
  safeExtend: () => safeExtend,
  required: () => required,
  randomString: () => randomString,
  propertyKeyTypes: () => propertyKeyTypes,
  promiseAllObject: () => promiseAllObject,
  primitiveTypes: () => primitiveTypes,
  prefixIssues: () => prefixIssues,
  pick: () => pick,
  partial: () => partial,
  optionalKeys: () => optionalKeys,
  omit: () => omit,
  objectClone: () => objectClone,
  numKeys: () => numKeys,
  nullish: () => nullish,
  normalizeParams: () => normalizeParams,
  mergeDefs: () => mergeDefs,
  merge: () => merge,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  joinValues: () => joinValues,
  issue: () => issue,
  isPlainObject: () => isPlainObject,
  isObject: () => isObject,
  hexToUint8Array: () => hexToUint8Array,
  getSizableOrigin: () => getSizableOrigin,
  getParsedType: () => getParsedType,
  getLengthableOrigin: () => getLengthableOrigin,
  getEnumValues: () => getEnumValues,
  getElementAtPath: () => getElementAtPath,
  floatSafeRemainder: () => floatSafeRemainder,
  finalizeIssue: () => finalizeIssue,
  extend: () => extend,
  escapeRegex: () => escapeRegex,
  esc: () => esc,
  defineLazy: () => defineLazy,
  createTransparentProxy: () => createTransparentProxy,
  cloneDef: () => cloneDef,
  clone: () => clone,
  cleanRegex: () => cleanRegex,
  cleanEnum: () => cleanEnum,
  captureStackTrace: () => captureStackTrace,
  cached: () => cached,
  base64urlToUint8Array: () => base64urlToUint8Array,
  base64ToUint8Array: () => base64ToUint8Array,
  assignProp: () => assignProp,
  assertNotEqual: () => assertNotEqual,
  assertNever: () => assertNever,
  assertIs: () => assertIs,
  assertEqual: () => assertEqual,
  assert: () => assert,
  allowsEval: () => allowsEval,
  aborted: () => aborted,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  Class: () => Class,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {}
function assertNever(_x) {
  throw new Error;
}
function assert(_) {}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array, separator = "|") {
  return array.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === undefined;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object, key, getter) {
  let value = undefined;
  Object.defineProperty(object, key, {
    get() {
      if (value === EVALUATING) {
        return;
      }
      if (value === undefined) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object, key, {
        value: v
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0;i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0;i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === undefined)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks
  };
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
  });
  return clone(a, def);
}
function partial(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex;i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base64) {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0;i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0;i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url) {
  const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base64.length % 4) % 4);
  return base64ToUint8Array(base64 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex) {
  const cleanHex = hex.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0;i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}

class Class {
  constructor(..._args) {}
}
var EVALUATING, captureStackTrace, allowsEval, getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
}, propertyKeyTypes, primitiveTypes, NUMBER_FORMAT_RANGES, BIGINT_FORMAT_RANGES;
var init_util = __esm(() => {
  EVALUATING = Symbol("evaluating");
  captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
  allowsEval = cached(() => {
    if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
      return false;
    }
    try {
      const F = Function;
      new F("");
      return true;
    } catch (_) {
      return false;
    }
  });
  propertyKeyTypes = new Set(["string", "number", "symbol"]);
  primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
  NUMBER_FORMAT_RANGES = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
  };
  BIGINT_FORMAT_RANGES = {
    int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
    uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
  };
});

// node_modules/zod/v4/core/errors.js
function flattenError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error2) => {
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}
function treeifyError(error, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error2, path = []) => {
    var _a, _b;
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error) {
  const lines = [];
  const issues = [...error.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join(`
`);
}
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
}, $ZodError, $ZodRealError;
var init_errors = __esm(() => {
  init_core();
  init_util();
  $ZodError = $constructor("$ZodError", initializer);
  $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
});

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
}, parse2, _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
}, parseAsync, _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
}, safeParse, _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
}, safeParseAsync, _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
}, encode, _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
}, decode, _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
}, encodeAsync, _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
}, decodeAsync, _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
}, safeEncode, _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
}, safeDecode, _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
}, safeEncodeAsync, _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
}, safeDecodeAsync;
var init_parse = __esm(() => {
  init_core();
  init_errors();
  init_util();
  parse2 = /* @__PURE__ */ _parse($ZodRealError);
  parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
  safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
  safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
  encode = /* @__PURE__ */ _encode($ZodRealError);
  decode = /* @__PURE__ */ _decode($ZodRealError);
  encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
  decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
  safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
  safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
  safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
  safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);
});

// node_modules/zod/v4/core/regexes.js
var exports_regexes = {};
__export(exports_regexes, {
  xid: () => xid,
  uuid7: () => uuid72,
  uuid6: () => uuid6,
  uuid4: () => uuid4,
  uuid: () => uuid2,
  uppercase: () => uppercase,
  unicodeEmail: () => unicodeEmail,
  undefined: () => _undefined,
  ulid: () => ulid,
  time: () => time,
  string: () => string,
  sha512_hex: () => sha512_hex,
  sha512_base64url: () => sha512_base64url,
  sha512_base64: () => sha512_base64,
  sha384_hex: () => sha384_hex,
  sha384_base64url: () => sha384_base64url,
  sha384_base64: () => sha384_base64,
  sha256_hex: () => sha256_hex,
  sha256_base64url: () => sha256_base64url,
  sha256_base64: () => sha256_base64,
  sha1_hex: () => sha1_hex,
  sha1_base64url: () => sha1_base64url,
  sha1_base64: () => sha1_base64,
  rfc5322Email: () => rfc5322Email,
  number: () => number,
  null: () => _null,
  nanoid: () => nanoid,
  md5_hex: () => md5_hex,
  md5_base64url: () => md5_base64url,
  md5_base64: () => md5_base64,
  mac: () => mac,
  lowercase: () => lowercase,
  ksuid: () => ksuid,
  ipv6: () => ipv6,
  ipv4: () => ipv4,
  integer: () => integer,
  idnEmail: () => idnEmail,
  html5Email: () => html5Email,
  hostname: () => hostname,
  hex: () => hex,
  guid: () => guid,
  extendedDuration: () => extendedDuration,
  emoji: () => emoji,
  email: () => email,
  e164: () => e164,
  duration: () => duration,
  domain: () => domain,
  datetime: () => datetime,
  date: () => date,
  cuid2: () => cuid2,
  cuid: () => cuid,
  cidrv6: () => cidrv6,
  cidrv4: () => cidrv4,
  browserEmail: () => browserEmail,
  boolean: () => boolean,
  bigint: () => bigint,
  base64url: () => base64url,
  base64: () => base64
});
function emoji() {
  return new RegExp(_emoji, "u");
}
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time2 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var cuid, cuid2, ulid, xid, ksuid, nanoid, duration, extendedDuration, guid, uuid2 = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
}, uuid4, uuid6, uuid72, email, html5Email, rfc5322Email, unicodeEmail, idnEmail, browserEmail, _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`, ipv4, ipv6, mac = (delimiter) => {
  const escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
}, cidrv4, cidrv6, base64, base64url, hostname, domain, e164, dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`, date, string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
}, bigint, integer, number, boolean, _null, _undefined, lowercase, uppercase, hex, md5_hex, md5_base64, md5_base64url, sha1_hex, sha1_base64, sha1_base64url, sha256_hex, sha256_base64, sha256_base64url, sha384_hex, sha384_base64, sha384_base64url, sha512_hex, sha512_base64, sha512_base64url;
var init_regexes = __esm(() => {
  init_util();
  cuid = /^[cC][^\s-]{8,}$/;
  cuid2 = /^[0-9a-z]+$/;
  ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
  xid = /^[0-9a-vA-V]{20}$/;
  ksuid = /^[A-Za-z0-9]{27}$/;
  nanoid = /^[a-zA-Z0-9_-]{21}$/;
  duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
  extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
  uuid4 = /* @__PURE__ */ uuid2(4);
  uuid6 = /* @__PURE__ */ uuid2(6);
  uuid72 = /* @__PURE__ */ uuid2(7);
  email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
  html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
  idnEmail = unicodeEmail;
  browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
  cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
  cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
  base64url = /^[A-Za-z0-9_-]*$/;
  hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
  domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
  e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
  date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
  bigint = /^-?\d+n?$/;
  integer = /^-?\d+$/;
  number = /^-?\d+(?:\.\d+)?/;
  boolean = /^(?:true|false)$/i;
  _null = /^null$/i;
  _undefined = /^undefined$/i;
  lowercase = /^[^A-Z]*$/;
  uppercase = /^[^a-z]*$/;
  hex = /^[0-9a-fA-F]*$/;
  md5_hex = /^[0-9a-fA-F]{32}$/;
  md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
  md5_base64url = /* @__PURE__ */ fixedBase64url(22);
  sha1_hex = /^[0-9a-fA-F]{40}$/;
  sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
  sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
  sha256_hex = /^[0-9a-fA-F]{64}$/;
  sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
  sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
  sha384_hex = /^[0-9a-fA-F]{96}$/;
  sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
  sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
  sha512_hex = /^[0-9a-fA-F]{128}$/;
  sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
  sha512_base64url = /* @__PURE__ */ fixedBase64url(86);
});

// node_modules/zod/v4/core/checks.js
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheck, numericOriginMap, $ZodCheckLessThan, $ZodCheckGreaterThan, $ZodCheckMultipleOf, $ZodCheckNumberFormat, $ZodCheckBigIntFormat, $ZodCheckMaxSize, $ZodCheckMinSize, $ZodCheckSizeEquals, $ZodCheckMaxLength, $ZodCheckMinLength, $ZodCheckLengthEquals, $ZodCheckStringFormat, $ZodCheckRegex, $ZodCheckLowerCase, $ZodCheckUpperCase, $ZodCheckIncludes, $ZodCheckStartsWith, $ZodCheckEndsWith, $ZodCheckProperty, $ZodCheckMimeType, $ZodCheckOverwrite;
var init_checks = __esm(() => {
  init_core();
  init_regexes();
  init_util();
  $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
    var _a;
    inst._zod ?? (inst._zod = {});
    inst._zod.def = def;
    (_a = inst._zod).onattach ?? (_a.onattach = []);
  });
  numericOriginMap = {
    number: "number",
    bigint: "bigint",
    object: "date"
  };
  $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
      if (def.value < curr) {
        if (def.inclusive)
          bag.maximum = def.value;
        else
          bag.exclusiveMaximum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
      if (def.value > curr) {
        if (def.inclusive)
          bag.minimum = def.value;
        else
          bag.exclusiveMinimum = def.value;
      }
    });
    inst._zod.check = (payload) => {
      if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
        return;
      }
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: def.value,
        input: payload.value,
        inclusive: def.inclusive,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      var _a;
      (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
    });
    inst._zod.check = (payload) => {
      if (typeof payload.value !== typeof def.value)
        throw new Error("Cannot mix number and bigint in multiple_of check.");
      const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
      if (isMultiple)
        return;
      payload.issues.push({
        origin: typeof payload.value,
        code: "not_multiple_of",
        divisor: def.value,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
    $ZodCheck.init(inst, def);
    def.format = def.format || "float64";
    const isInt = def.format?.includes("int");
    const origin = isInt ? "int" : "number";
    const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
      if (isInt)
        bag.pattern = integer;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      if (isInt) {
        if (!Number.isInteger(input)) {
          payload.issues.push({
            expected: origin,
            format: def.format,
            code: "invalid_type",
            continue: false,
            input,
            inst
          });
          return;
        }
        if (!Number.isSafeInteger(input)) {
          if (input > 0) {
            payload.issues.push({
              input,
              code: "too_big",
              maximum: Number.MAX_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              continue: !def.abort
            });
          } else {
            payload.issues.push({
              input,
              code: "too_small",
              minimum: Number.MIN_SAFE_INTEGER,
              note: "Integers must be within the safe integer range.",
              inst,
              origin,
              continue: !def.abort
            });
          }
          return;
        }
      }
      if (input < minimum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_small",
          minimum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: "number",
          input,
          code: "too_big",
          maximum,
          inst
        });
      }
    };
  });
  $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
    $ZodCheck.init(inst, def);
    const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      if (input < minimum) {
        payload.issues.push({
          origin: "bigint",
          input,
          code: "too_small",
          minimum,
          inclusive: true,
          inst,
          continue: !def.abort
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: "bigint",
          input,
          code: "too_big",
          maximum,
          inst
        });
      }
    };
  });
  $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr)
        inst2._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size <= def.maximum)
        return;
      payload.issues.push({
        origin: getSizableOrigin(input),
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr)
        inst2._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size >= def.minimum)
        return;
      payload.issues.push({
        origin: getSizableOrigin(input),
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.size !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.minimum = def.size;
      bag.maximum = def.size;
      bag.size = def.size;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const size = input.size;
      if (size === def.size)
        return;
      const tooBig = size > def.size;
      payload.issues.push({
        origin: getSizableOrigin(input),
        ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr)
        inst2._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length <= def.maximum)
        return;
      const origin = getLengthableOrigin(input);
      payload.issues.push({
        origin,
        code: "too_big",
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr)
        inst2._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length >= def.minimum)
        return;
      const origin = getLengthableOrigin(input);
      payload.issues.push({
        origin,
        code: "too_small",
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
      const val = payload.value;
      return !nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.minimum = def.length;
      bag.maximum = def.length;
      bag.length = def.length;
    });
    inst._zod.check = (payload) => {
      const input = payload.value;
      const length = input.length;
      if (length === def.length)
        return;
      const origin = getLengthableOrigin(input);
      const tooBig = length > def.length;
      payload.issues.push({
        origin,
        ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
    var _a, _b;
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.format = def.format;
      if (def.pattern) {
        bag.patterns ?? (bag.patterns = new Set);
        bag.patterns.add(def.pattern);
      }
    });
    if (def.pattern)
      (_a = inst._zod).check ?? (_a.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          ...def.pattern ? { pattern: def.pattern.toString() } : {},
          inst,
          continue: !def.abort
        });
      });
    else
      (_b = inst._zod).check ?? (_b.check = () => {});
  });
  $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
    $ZodCheckStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "regex",
        input: payload.value,
        pattern: def.pattern.toString(),
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
    def.pattern ?? (def.pattern = lowercase);
    $ZodCheckStringFormat.init(inst, def);
  });
  $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
    def.pattern ?? (def.pattern = uppercase);
    $ZodCheckStringFormat.init(inst, def);
  });
  $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
    $ZodCheck.init(inst, def);
    const escapedRegex = escapeRegex(def.includes);
    const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
    def.pattern = pattern;
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.includes(def.includes, def.position))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "includes",
        includes: def.includes,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.startsWith(def.prefix))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "starts_with",
        prefix: def.prefix,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst2) => {
      const bag = inst2._zod.bag;
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
      if (payload.value.endsWith(def.suffix))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: "ends_with",
        suffix: def.suffix,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
      const result = def.schema._zod.run({
        value: payload.value[def.property],
        issues: []
      }, {});
      if (result instanceof Promise) {
        return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
      }
      handleCheckPropertyResult(result, payload, def.property);
      return;
    };
  });
  $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
    $ZodCheck.init(inst, def);
    const mimeSet = new Set(def.mime);
    inst._zod.onattach.push((inst2) => {
      inst2._zod.bag.mime = def.mime;
    });
    inst._zod.check = (payload) => {
      if (mimeSet.has(payload.value.type))
        return;
      payload.issues.push({
        code: "invalid_value",
        values: def.mime,
        input: payload.value.type,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
      payload.value = def.tx(payload.value);
    };
  });
});

// node_modules/zod/v4/core/doc.js
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
}

// node_modules/zod/v4/core/versions.js
var version2;
var init_versions = __esm(() => {
  version2 = {
    major: 4,
    minor: 1,
    patch: 13
  };
});

// node_modules/zod/v4/core/schemas.js
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
function handlePropertyResult(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === undefined) {
    if (key in input) {
      final.value[key] = undefined;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
    } else {
      handlePropertyResult(r, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
function handleOptionalResult(result, input) {
  if (result.issues.length && input === undefined) {
    return { issues: [], value: undefined };
  }
  return result;
}
function handleDefaultResult(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
var $ZodType, $ZodString, $ZodStringFormat, $ZodGUID, $ZodUUID, $ZodEmail, $ZodURL, $ZodEmoji, $ZodNanoID, $ZodCUID, $ZodCUID2, $ZodULID, $ZodXID, $ZodKSUID, $ZodISODateTime, $ZodISODate, $ZodISOTime, $ZodISODuration, $ZodIPv4, $ZodIPv6, $ZodMAC, $ZodCIDRv4, $ZodCIDRv6, $ZodBase64, $ZodBase64URL, $ZodE164, $ZodJWT, $ZodCustomStringFormat, $ZodNumber, $ZodNumberFormat, $ZodBoolean, $ZodBigInt, $ZodBigIntFormat, $ZodSymbol, $ZodUndefined, $ZodNull, $ZodAny, $ZodUnknown, $ZodNever, $ZodVoid, $ZodDate, $ZodArray, $ZodObject, $ZodObjectJIT, $ZodUnion, $ZodDiscriminatedUnion, $ZodIntersection, $ZodTuple, $ZodRecord, $ZodMap, $ZodSet, $ZodEnum, $ZodLiteral, $ZodFile, $ZodTransform, $ZodOptional, $ZodNullable, $ZodDefault, $ZodPrefault, $ZodNonOptional, $ZodSuccess, $ZodCatch, $ZodNaN, $ZodPipe, $ZodCodec, $ZodReadonly, $ZodTemplateLiteral, $ZodFunction, $ZodPromise, $ZodLazy, $ZodCustom;
var init_schemas = __esm(() => {
  init_checks();
  init_core();
  init_parse();
  init_regexes();
  init_util();
  init_versions();
  init_util();
  $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
    var _a;
    inst ?? (inst = {});
    inst._zod.def = def;
    inst._zod.bag = inst._zod.bag || {};
    inst._zod.version = version2;
    const checks = [...inst._zod.def.checks ?? []];
    if (inst._zod.traits.has("$ZodCheck")) {
      checks.unshift(inst);
    }
    for (const ch of checks) {
      for (const fn of ch._zod.onattach) {
        fn(inst);
      }
    }
    if (checks.length === 0) {
      (_a = inst._zod).deferred ?? (_a.deferred = []);
      inst._zod.deferred?.push(() => {
        inst._zod.run = inst._zod.parse;
      });
    } else {
      const runChecks = (payload, checks2, ctx) => {
        let isAborted = aborted(payload);
        let asyncResult;
        for (const ch of checks2) {
          if (ch._zod.def.when) {
            const shouldRun = ch._zod.def.when(payload);
            if (!shouldRun)
              continue;
          } else if (isAborted) {
            continue;
          }
          const currLen = payload.issues.length;
          const _ = ch._zod.check(payload);
          if (_ instanceof Promise && ctx?.async === false) {
            throw new $ZodAsyncError;
          }
          if (asyncResult || _ instanceof Promise) {
            asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
              await _;
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                return;
              if (!isAborted)
                isAborted = aborted(payload, currLen);
            });
          } else {
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              continue;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          }
        }
        if (asyncResult) {
          return asyncResult.then(() => {
            return payload;
          });
        }
        return payload;
      };
      const handleCanaryResult = (canary, payload, ctx) => {
        if (aborted(canary)) {
          canary.aborted = true;
          return canary;
        }
        const checkResult = runChecks(payload, checks, ctx);
        if (checkResult instanceof Promise) {
          if (ctx.async === false)
            throw new $ZodAsyncError;
          return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
        }
        return inst._zod.parse(checkResult, ctx);
      };
      inst._zod.run = (payload, ctx) => {
        if (ctx.skipChecks) {
          return inst._zod.parse(payload, ctx);
        }
        if (ctx.direction === "backward") {
          const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
          if (canary instanceof Promise) {
            return canary.then((canary2) => {
              return handleCanaryResult(canary2, payload, ctx);
            });
          }
          return handleCanaryResult(canary, payload, ctx);
        }
        const result = inst._zod.parse(payload, ctx);
        if (result instanceof Promise) {
          if (ctx.async === false)
            throw new $ZodAsyncError;
          return result.then((result2) => runChecks(result2, checks, ctx));
        }
        return runChecks(result, checks, ctx);
      };
    }
    inst["~standard"] = {
      validate: (value) => {
        try {
          const r = safeParse(inst, value);
          return r.success ? { value: r.data } : { issues: r.error?.issues };
        } catch (_) {
          return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
        }
      },
      vendor: "zod",
      version: 1
    };
  });
  $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
    inst._zod.parse = (payload, _) => {
      if (def.coerce)
        try {
          payload.value = String(payload.value);
        } catch (_2) {}
      if (typeof payload.value === "string")
        return payload;
      payload.issues.push({
        expected: "string",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
    $ZodCheckStringFormat.init(inst, def);
    $ZodString.init(inst, def);
  });
  $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
    def.pattern ?? (def.pattern = guid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
    if (def.version) {
      const versionMap = {
        v1: 1,
        v2: 2,
        v3: 3,
        v4: 4,
        v5: 5,
        v6: 6,
        v7: 7,
        v8: 8
      };
      const v = versionMap[def.version];
      if (v === undefined)
        throw new Error(`Invalid UUID version: "${def.version}"`);
      def.pattern ?? (def.pattern = uuid2(v));
    } else
      def.pattern ?? (def.pattern = uuid2());
    $ZodStringFormat.init(inst, def);
  });
  $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
    def.pattern ?? (def.pattern = email);
    $ZodStringFormat.init(inst, def);
  });
  $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      try {
        const trimmed = payload.value.trim();
        const url = new URL(trimmed);
        if (def.hostname) {
          def.hostname.lastIndex = 0;
          if (!def.hostname.test(url.hostname)) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              note: "Invalid hostname",
              pattern: def.hostname.source,
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        }
        if (def.protocol) {
          def.protocol.lastIndex = 0;
          if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
            payload.issues.push({
              code: "invalid_format",
              format: "url",
              note: "Invalid protocol",
              pattern: def.protocol.source,
              input: payload.value,
              inst,
              continue: !def.abort
            });
          }
        }
        if (def.normalize) {
          payload.value = url.href;
        } else {
          payload.value = trimmed;
        }
        return;
      } catch (_) {
        payload.issues.push({
          code: "invalid_format",
          format: "url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
    def.pattern ?? (def.pattern = emoji());
    $ZodStringFormat.init(inst, def);
  });
  $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
    def.pattern ?? (def.pattern = nanoid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
    def.pattern ?? (def.pattern = cuid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
    def.pattern ?? (def.pattern = cuid2);
    $ZodStringFormat.init(inst, def);
  });
  $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
    def.pattern ?? (def.pattern = ulid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
    def.pattern ?? (def.pattern = xid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
    def.pattern ?? (def.pattern = ksuid);
    $ZodStringFormat.init(inst, def);
  });
  $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
    def.pattern ?? (def.pattern = datetime(def));
    $ZodStringFormat.init(inst, def);
  });
  $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
    def.pattern ?? (def.pattern = date);
    $ZodStringFormat.init(inst, def);
  });
  $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
    def.pattern ?? (def.pattern = time(def));
    $ZodStringFormat.init(inst, def);
  });
  $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
    def.pattern ?? (def.pattern = duration);
    $ZodStringFormat.init(inst, def);
  });
  $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
    def.pattern ?? (def.pattern = ipv4);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.format = `ipv4`;
  });
  $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
    def.pattern ?? (def.pattern = ipv6);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.format = `ipv6`;
    inst._zod.check = (payload) => {
      try {
        new URL(`http://[${payload.value}]`);
      } catch {
        payload.issues.push({
          code: "invalid_format",
          format: "ipv6",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
    def.pattern ?? (def.pattern = mac(def.delimiter));
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.format = `mac`;
  });
  $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv4);
    $ZodStringFormat.init(inst, def);
  });
  $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv6);
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      const parts = payload.value.split("/");
      try {
        if (parts.length !== 2)
          throw new Error;
        const [address, prefix] = parts;
        if (!prefix)
          throw new Error;
        const prefixNum = Number(prefix);
        if (`${prefixNum}` !== prefix)
          throw new Error;
        if (prefixNum < 0 || prefixNum > 128)
          throw new Error;
        new URL(`http://[${address}]`);
      } catch {
        payload.issues.push({
          code: "invalid_format",
          format: "cidrv6",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      }
    };
  });
  $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
    def.pattern ?? (def.pattern = base64);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.contentEncoding = "base64";
    inst._zod.check = (payload) => {
      if (isValidBase64(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
    def.pattern ?? (def.pattern = base64url);
    $ZodStringFormat.init(inst, def);
    inst._zod.bag.contentEncoding = "base64url";
    inst._zod.check = (payload) => {
      if (isValidBase64URL(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "base64url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
    def.pattern ?? (def.pattern = e164);
    $ZodStringFormat.init(inst, def);
  });
  $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      if (isValidJWT(payload.value, def.alg))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: "jwt",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
      if (def.fn(payload.value))
        return;
      payload.issues.push({
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        inst,
        continue: !def.abort
      });
    };
  });
  $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = inst._zod.bag.pattern ?? number;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = Number(payload.value);
        } catch (_) {}
      const input = payload.value;
      if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
        return payload;
      }
      const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
      payload.issues.push({
        expected: "number",
        code: "invalid_type",
        input,
        inst,
        ...received ? { received } : {}
      });
      return payload;
    };
  });
  $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
    $ZodCheckNumberFormat.init(inst, def);
    $ZodNumber.init(inst, def);
  });
  $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = boolean;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = Boolean(payload.value);
        } catch (_) {}
      const input = payload.value;
      if (typeof input === "boolean")
        return payload;
      payload.issues.push({
        expected: "boolean",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = bigint;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = BigInt(payload.value);
        } catch (_) {}
      if (typeof payload.value === "bigint")
        return payload;
      payload.issues.push({
        expected: "bigint",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
    $ZodCheckBigIntFormat.init(inst, def);
    $ZodBigInt.init(inst, def);
  });
  $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "symbol")
        return payload;
      payload.issues.push({
        expected: "symbol",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = _undefined;
    inst._zod.values = new Set([undefined]);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "undefined")
        return payload;
      payload.issues.push({
        expected: "undefined",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = _null;
    inst._zod.values = new Set([null]);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (input === null)
        return payload;
      payload.issues.push({
        expected: "null",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload) => payload;
  });
  $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload) => payload;
  });
  $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      payload.issues.push({
        expected: "never",
        code: "invalid_type",
        input: payload.value,
        inst
      });
      return payload;
    };
  });
  $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === "undefined")
        return payload;
      payload.issues.push({
        expected: "void",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce) {
        try {
          payload.value = new Date(payload.value);
        } catch (_err) {}
      }
      const input = payload.value;
      const isDate = input instanceof Date;
      const isValidDate = isDate && !Number.isNaN(input.getTime());
      if (isValidDate)
        return payload;
      payload.issues.push({
        expected: "date",
        code: "invalid_type",
        input,
        ...isDate ? { received: "Invalid Date" } : {},
        inst
      });
      return payload;
    };
  });
  $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!Array.isArray(input)) {
        payload.issues.push({
          expected: "array",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      payload.value = Array(input.length);
      const proms = [];
      for (let i = 0;i < input.length; i++) {
        const item = input[i];
        const result = def.element._zod.run({
          value: item,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
        } else {
          handleArrayResult(result, payload, i);
        }
      }
      if (proms.length) {
        return Promise.all(proms).then(() => payload);
      }
      return payload;
    };
  });
  $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
    $ZodType.init(inst, def);
    const desc = Object.getOwnPropertyDescriptor(def, "shape");
    if (!desc?.get) {
      const sh = def.shape;
      Object.defineProperty(def, "shape", {
        get: () => {
          const newSh = { ...sh };
          Object.defineProperty(def, "shape", {
            value: newSh
          });
          return newSh;
        }
      });
    }
    const _normalized = cached(() => normalizeDef(def));
    defineLazy(inst._zod, "propValues", () => {
      const shape = def.shape;
      const propValues = {};
      for (const key in shape) {
        const field = shape[key]._zod;
        if (field.values) {
          propValues[key] ?? (propValues[key] = new Set);
          for (const v of field.values)
            propValues[key].add(v);
        }
      }
      return propValues;
    });
    const isObject2 = isObject;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
      value ?? (value = _normalized.value);
      const input = payload.value;
      if (!isObject2(input)) {
        payload.issues.push({
          expected: "object",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      payload.value = {};
      const proms = [];
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        if (r instanceof Promise) {
          proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
        } else {
          handlePropertyResult(r, payload, key, input);
        }
      }
      if (!catchall) {
        return proms.length ? Promise.all(proms).then(() => payload) : payload;
      }
      return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
    };
  });
  $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
    $ZodObject.init(inst, def);
    const superParse = inst._zod.parse;
    const _normalized = cached(() => normalizeDef(def));
    const generateFastpass = (shape) => {
      const doc = new Doc(["shape", "payload", "ctx"]);
      const normalized = _normalized.value;
      const parseStr = (key) => {
        const k = esc(key);
        return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
      };
      doc.write(`const input = payload.value;`);
      const ids = Object.create(null);
      let counter = 0;
      for (const key of normalized.keys) {
        ids[key] = `key_${counter++}`;
      }
      doc.write(`const newResult = {};`);
      for (const key of normalized.keys) {
        const id = ids[key];
        const k = esc(key);
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      }
      doc.write(`payload.value = newResult;`);
      doc.write(`return payload;`);
      const fn = doc.compile();
      return (payload, ctx) => fn(shape, payload, ctx);
    };
    let fastpass;
    const isObject2 = isObject;
    const jit = !globalConfig.jitless;
    const allowsEval2 = allowsEval;
    const fastEnabled = jit && allowsEval2.value;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
      value ?? (value = _normalized.value);
      const input = payload.value;
      if (!isObject2(input)) {
        payload.issues.push({
          expected: "object",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
        if (!fastpass)
          fastpass = generateFastpass(def.shape);
        payload = fastpass(payload, ctx);
        if (!catchall)
          return payload;
        return handleCatchall([], input, payload, ctx, value, inst);
      }
      return superParse(payload, ctx);
    };
  });
  $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
    defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
    defineLazy(inst._zod, "values", () => {
      if (def.options.every((o) => o._zod.values)) {
        return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
      }
      return;
    });
    defineLazy(inst._zod, "pattern", () => {
      if (def.options.every((o) => o._zod.pattern)) {
        const patterns = def.options.map((o) => o._zod.pattern);
        return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
      }
      return;
    });
    const single = def.options.length === 1;
    const first = def.options[0]._zod.run;
    inst._zod.parse = (payload, ctx) => {
      if (single) {
        return first(payload, ctx);
      }
      let async = false;
      const results = [];
      for (const option of def.options) {
        const result = option._zod.run({
          value: payload.value,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          results.push(result);
          async = true;
        } else {
          if (result.issues.length === 0)
            return result;
          results.push(result);
        }
      }
      if (!async)
        return handleUnionResults(results, payload, inst, ctx);
      return Promise.all(results).then((results2) => {
        return handleUnionResults(results2, payload, inst, ctx);
      });
    };
  });
  $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
    $ZodUnion.init(inst, def);
    const _super = inst._zod.parse;
    defineLazy(inst._zod, "propValues", () => {
      const propValues = {};
      for (const option of def.options) {
        const pv = option._zod.propValues;
        if (!pv || Object.keys(pv).length === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
        for (const [k, v] of Object.entries(pv)) {
          if (!propValues[k])
            propValues[k] = new Set;
          for (const val of v) {
            propValues[k].add(val);
          }
        }
      }
      return propValues;
    });
    const disc = cached(() => {
      const opts = def.options;
      const map = new Map;
      for (const o of opts) {
        const values = o._zod.propValues?.[def.discriminator];
        if (!values || values.size === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
        for (const v of values) {
          if (map.has(v)) {
            throw new Error(`Duplicate discriminator value "${String(v)}"`);
          }
          map.set(v, o);
        }
      }
      return map;
    });
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!isObject(input)) {
        payload.issues.push({
          code: "invalid_type",
          expected: "object",
          input,
          inst
        });
        return payload;
      }
      const opt = disc.value.get(input?.[def.discriminator]);
      if (opt) {
        return opt._zod.run(payload, ctx);
      }
      if (def.unionFallback) {
        return _super(payload, ctx);
      }
      payload.issues.push({
        code: "invalid_union",
        errors: [],
        note: "No matching discriminator",
        discriminator: def.discriminator,
        input,
        path: [def.discriminator],
        inst
      });
      return payload;
    };
  });
  $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      const left = def.left._zod.run({ value: input, issues: [] }, ctx);
      const right = def.right._zod.run({ value: input, issues: [] }, ctx);
      const async = left instanceof Promise || right instanceof Promise;
      if (async) {
        return Promise.all([left, right]).then(([left2, right2]) => {
          return handleIntersectionResults(payload, left2, right2);
        });
      }
      return handleIntersectionResults(payload, left, right);
    };
  });
  $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
    $ZodType.init(inst, def);
    const items = def.items;
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!Array.isArray(input)) {
        payload.issues.push({
          input,
          inst,
          expected: "tuple",
          code: "invalid_type"
        });
        return payload;
      }
      payload.value = [];
      const proms = [];
      const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
      const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
      if (!def.rest) {
        const tooBig = input.length > items.length;
        const tooSmall = input.length < optStart - 1;
        if (tooBig || tooSmall) {
          payload.issues.push({
            ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length },
            input,
            inst,
            origin: "array"
          });
          return payload;
        }
      }
      let i = -1;
      for (const item of items) {
        i++;
        if (i >= input.length) {
          if (i >= optStart)
            continue;
        }
        const result = item._zod.run({
          value: input[i],
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
      if (def.rest) {
        const rest = input.slice(items.length);
        for (const el of rest) {
          i++;
          const result = def.rest._zod.run({
            value: el,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
          } else {
            handleTupleResult(result, payload, i);
          }
        }
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!isPlainObject(input)) {
        payload.issues.push({
          expected: "record",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      const proms = [];
      const values = def.keyType._zod.values;
      if (values) {
        payload.value = {};
        const recordKeys = new Set;
        for (const key of values) {
          if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
            recordKeys.add(typeof key === "number" ? key.toString() : key);
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues(key, result2.issues));
                }
                payload.value[key] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues(key, result.issues));
              }
              payload.value[key] = result.value;
            }
          }
        }
        let unrecognized;
        for (const key in input) {
          if (!recordKeys.has(key)) {
            unrecognized = unrecognized ?? [];
            unrecognized.push(key);
          }
        }
        if (unrecognized && unrecognized.length > 0) {
          payload.issues.push({
            code: "unrecognized_keys",
            input,
            inst,
            keys: unrecognized
          });
        }
      } else {
        payload.value = {};
        for (const key of Reflect.ownKeys(input)) {
          if (key === "__proto__")
            continue;
          const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          if (keyResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          if (keyResult.issues.length) {
            payload.issues.push({
              code: "invalid_key",
              origin: "record",
              issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
              input: key,
              path: [key],
              inst
            });
            payload.value[keyResult.value] = keyResult.value;
            continue;
          }
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[keyResult.value] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[keyResult.value] = result.value;
          }
        }
      }
      if (proms.length) {
        return Promise.all(proms).then(() => payload);
      }
      return payload;
    };
  });
  $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!(input instanceof Map)) {
        payload.issues.push({
          expected: "map",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      }
      const proms = [];
      payload.value = new Map;
      for (const [key, value] of input) {
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
        if (keyResult instanceof Promise || valueResult instanceof Promise) {
          proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
            handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
          }));
        } else {
          handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
        }
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!(input instanceof Set)) {
        payload.issues.push({
          input,
          inst,
          expected: "set",
          code: "invalid_type"
        });
        return payload;
      }
      const proms = [];
      payload.value = new Set;
      for (const item of input) {
        const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleSetResult(result2, payload)));
        } else
          handleSetResult(result, payload);
      }
      if (proms.length)
        return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
  $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
    $ZodType.init(inst, def);
    const values = getEnumValues(def.entries);
    const valuesSet = new Set(values);
    inst._zod.values = valuesSet;
    inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (valuesSet.has(input)) {
        return payload;
      }
      payload.issues.push({
        code: "invalid_value",
        values,
        input,
        inst
      });
      return payload;
    };
  });
  $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
    $ZodType.init(inst, def);
    if (def.values.length === 0) {
      throw new Error("Cannot create literal schema with no valid values");
    }
    const values = new Set(def.values);
    inst._zod.values = values;
    inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (values.has(input)) {
        return payload;
      }
      payload.issues.push({
        code: "invalid_value",
        values: def.values,
        input,
        inst
      });
      return payload;
    };
  });
  $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (input instanceof File)
        return payload;
      payload.issues.push({
        expected: "file",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    };
  });
  $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        throw new $ZodEncodeError(inst.constructor.name);
      }
      const _out = def.transform(payload.value, payload);
      if (ctx.async) {
        const output = _out instanceof Promise ? _out : Promise.resolve(_out);
        return output.then((output2) => {
          payload.value = output2;
          return payload;
        });
      }
      if (_out instanceof Promise) {
        throw new $ZodAsyncError;
      }
      payload.value = _out;
      return payload;
    };
  });
  $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    defineLazy(inst._zod, "values", () => {
      return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
    });
    defineLazy(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
      if (def.innerType._zod.optin === "optional") {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise)
          return result.then((r) => handleOptionalResult(r, payload.value));
        return handleOptionalResult(result, payload.value);
      }
      if (payload.value === undefined) {
        return payload;
      }
      return def.innerType._zod.run(payload, ctx);
    };
  });
  $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy(inst._zod, "pattern", () => {
      const pattern = def.innerType._zod.pattern;
      return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
    });
    defineLazy(inst._zod, "values", () => {
      return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
      if (payload.value === null)
        return payload;
      return def.innerType._zod.run(payload, ctx);
    };
  });
  $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      if (payload.value === undefined) {
        payload.value = def.defaultValue;
        return payload;
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => handleDefaultResult(result2, def));
      }
      return handleDefaultResult(result, def);
    };
  });
  $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      if (payload.value === undefined) {
        payload.value = def.defaultValue;
      }
      return def.innerType._zod.run(payload, ctx);
    };
  });
  $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => {
      const v = def.innerType._zod.values;
      return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => handleNonOptionalResult(result2, inst));
      }
      return handleNonOptionalResult(result, inst);
    };
  });
  $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        throw new $ZodEncodeError("ZodSuccess");
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => {
          payload.value = result2.issues.length === 0;
          return payload;
        });
      }
      payload.value = result.issues.length === 0;
      return payload;
    };
  });
  $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then((result2) => {
          payload.value = result2.value;
          if (result2.issues.length) {
            payload.value = def.catchValue({
              ...payload,
              error: {
                issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
              },
              input: payload.value
            });
            payload.issues = [];
          }
          return payload;
        });
      }
      payload.value = result.value;
      if (result.issues.length) {
        payload.value = def.catchValue({
          ...payload,
          error: {
            issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
          },
          input: payload.value
        });
        payload.issues = [];
      }
      return payload;
    };
  });
  $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
        payload.issues.push({
          input: payload.value,
          inst,
          expected: "nan",
          code: "invalid_type"
        });
        return payload;
      }
      return payload;
    };
  });
  $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => def.in._zod.values);
    defineLazy(inst._zod, "optin", () => def.in._zod.optin);
    defineLazy(inst._zod, "optout", () => def.out._zod.optout);
    defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        const right = def.out._zod.run(payload, ctx);
        if (right instanceof Promise) {
          return right.then((right2) => handlePipeResult(right2, def.in, ctx));
        }
        return handlePipeResult(right, def.in, ctx);
      }
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handlePipeResult(left2, def.out, ctx));
      }
      return handlePipeResult(left, def.out, ctx);
    };
  });
  $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => def.in._zod.values);
    defineLazy(inst._zod, "optin", () => def.in._zod.optin);
    defineLazy(inst._zod, "optout", () => def.out._zod.optout);
    defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
      const direction = ctx.direction || "forward";
      if (direction === "forward") {
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handleCodecAResult(left2, def, ctx));
        }
        return handleCodecAResult(left, def, ctx);
      } else {
        const right = def.out._zod.run(payload, ctx);
        if (right instanceof Promise) {
          return right.then((right2) => handleCodecAResult(right2, def, ctx));
        }
        return handleCodecAResult(right, def, ctx);
      }
    };
  });
  $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
    defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === "backward") {
        return def.innerType._zod.run(payload, ctx);
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then(handleReadonlyResult);
      }
      return handleReadonlyResult(result);
    };
  });
  $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
    $ZodType.init(inst, def);
    const regexParts = [];
    for (const part of def.parts) {
      if (typeof part === "object" && part !== null) {
        if (!part._zod.pattern) {
          throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
        }
        const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
        if (!source)
          throw new Error(`Invalid template literal part: ${part._zod.traits}`);
        const start = source.startsWith("^") ? 1 : 0;
        const end = source.endsWith("$") ? source.length - 1 : source.length;
        regexParts.push(source.slice(start, end));
      } else if (part === null || primitiveTypes.has(typeof part)) {
        regexParts.push(escapeRegex(`${part}`));
      } else {
        throw new Error(`Invalid template literal part: ${part}`);
      }
    }
    inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "string") {
        payload.issues.push({
          input: payload.value,
          inst,
          expected: "template_literal",
          code: "invalid_type"
        });
        return payload;
      }
      inst._zod.pattern.lastIndex = 0;
      if (!inst._zod.pattern.test(payload.value)) {
        payload.issues.push({
          input: payload.value,
          inst,
          code: "invalid_format",
          format: def.format ?? "template_literal",
          pattern: inst._zod.pattern.source
        });
        return payload;
      }
      return payload;
    };
  });
  $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
    $ZodType.init(inst, def);
    inst._def = def;
    inst._zod.def = def;
    inst.implement = (func) => {
      if (typeof func !== "function") {
        throw new Error("implement() must be called with a function");
      }
      return function(...args) {
        const parsedArgs = inst._def.input ? parse2(inst._def.input, args) : args;
        const result = Reflect.apply(func, this, parsedArgs);
        if (inst._def.output) {
          return parse2(inst._def.output, result);
        }
        return result;
      };
    };
    inst.implementAsync = (func) => {
      if (typeof func !== "function") {
        throw new Error("implementAsync() must be called with a function");
      }
      return async function(...args) {
        const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
        const result = await Reflect.apply(func, this, parsedArgs);
        if (inst._def.output) {
          return await parseAsync(inst._def.output, result);
        }
        return result;
      };
    };
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== "function") {
        payload.issues.push({
          code: "invalid_type",
          expected: "function",
          input: payload.value,
          inst
        });
        return payload;
      }
      const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
      if (hasPromiseOutput) {
        payload.value = inst.implementAsync(payload.value);
      } else {
        payload.value = inst.implement(payload.value);
      }
      return payload;
    };
    inst.input = (...args) => {
      const F = inst.constructor;
      if (Array.isArray(args[0])) {
        return new F({
          type: "function",
          input: new $ZodTuple({
            type: "tuple",
            items: args[0],
            rest: args[1]
          }),
          output: inst._def.output
        });
      }
      return new F({
        type: "function",
        input: args[0],
        output: inst._def.output
      });
    };
    inst.output = (output) => {
      const F = inst.constructor;
      return new F({
        type: "function",
        input: inst._def.input,
        output
      });
    };
    return inst;
  });
  $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
    };
  });
  $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "innerType", () => def.getter());
    defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
    defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
    defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? undefined);
    defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? undefined);
    inst._zod.parse = (payload, ctx) => {
      const inner = inst._zod.innerType;
      return inner._zod.run(payload, ctx);
    };
  });
  $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
    $ZodCheck.init(inst, def);
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _) => {
      return payload;
    };
    inst._zod.check = (payload) => {
      const input = payload.value;
      const r = def.fn(input);
      if (r instanceof Promise) {
        return r.then((r2) => handleRefineResult(r2, payload, input, inst));
      }
      handleRefineResult(r, payload, input, inst);
      return;
    };
  });
});

// node_modules/zod/v4/locales/ar.js
function ar_default() {
  return {
    localeError: error()
  };
}
var error = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
var init_ar = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/az.js
function az_default() {
  return {
    localeError: error2()
  };
}
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue2.expected}, daxil olan ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
};
var init_az = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function be_default() {
  return {
    localeError: error3()
  };
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0456\u045E";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
};
var init_be = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/bg.js
function bg_default() {
  return {
    localeError: error4()
  };
}
var parsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "\u043C\u0430\u0441\u0438\u0432";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
}, error4 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "\u0432\u0445\u043E\u0434",
    email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    json_string: "JSON \u043D\u0438\u0437",
    e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
        let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
        if (_issue.format === "emoji")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "datetime")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "date")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        if (_issue.format === "time")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "duration")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        return `${invalid_adj} ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
    }
  };
};
var init_bg = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ca.js
function ca_default() {
  return {
    localeError: error5()
  };
}
var error5 = () => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipus inv\xE0lid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      case "invalid_element":
        return `Element inv\xE0lid a ${issue2.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
};
var init_ca = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/cs.js
function cs_default() {
  return {
    localeError: error6()
  };
}
var error6 = () => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
      }
      case "string": {
        return "\u0159et\u011Bzec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue2.expected}, obdr\u017Eeno ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue2.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
};
var init_cs = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/da.js
function da_default() {
  return {
    localeError: error7()
  };
}
var error7 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  const TypeNames = {
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
        return "objekt";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${getTypeName(issue2.expected)}, fik ${getTypeName(parsedType2(issue2.input))}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
var init_da = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/de.js
function de_default() {
  return {
    localeError: error8()
  };
}
var error8 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType2 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ung\xFCltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue2.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
};
var init_de = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/en.js
function en_default() {
  return {
    localeError: error9()
  };
}
var parsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
}, error9 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
var init_en = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/eo.js
function eo_default() {
  return {
    localeError: error10()
  };
}
var parsedType3 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
}, error10 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nevalida enigo: atendi\u011Dis ${issue2.expected}, ricevi\u011Dis ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
var init_eo = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/es.js
function es_default() {
  return {
    localeError: error11()
  };
}
var error11 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  const TypeNames = {
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
        return "object";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrada inv\xE1lida: se esperaba ${getTypeName(issue2.expected)}, recibido ${getTypeName(parsedType4(issue2.input))}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${getTypeName(issue2.origin)}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${getTypeName(issue2.origin)}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
};
var init_es = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/fa.js
function fa_default() {
  return {
    localeError: error12()
  };
}
var error12 = () => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u0627\u06CC\u0647";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType4(issue2.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
};
var init_fa = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/fi.js
function fi_default() {
  return {
    localeError: error13()
  };
}
var error13 = () => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
};
var init_fi = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/fr.js
function fr_default() {
  return {
    localeError: error14()
  };
}
var error14 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : ${issue2.expected} attendu, ${parsedType4(issue2.input)} re\xE7u`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
var init_fr = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/fr-CA.js
function fr_CA_default() {
  return {
    localeError: error15()
  };
}
var error15 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : attendu ${issue2.expected}, re\xE7u ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
var init_fr_CA = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/he.js
function he_default() {
  return {
    localeError: error16()
  };
}
var error16 = () => {
  const TypeNames = {
    string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
    number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
    boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
    array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
    object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
    null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
    undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
    symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
    function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
    map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
    set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
    file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
    value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
  };
  const Sizable = {
    string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
  };
  const typeEntry = (t) => t ? TypeNames[t] : undefined;
  const typeLabel = (t) => {
    const e = typeEntry(t);
    if (e)
      return e.label;
    return t ?? TypeNames.unknown.label;
  };
  const withDefinite = (t) => `\u05D4${typeLabel(t)}`;
  const verbFor = (t) => {
    const e = typeEntry(t);
    const gender = e?.gender ?? "m";
    return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
  };
  const getSizing = (origin) => {
    if (!origin)
      return null;
    return Sizable[origin] ?? null;
  };
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number":
        return Number.isNaN(data) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(data))
          return "array";
        if (data === null)
          return "null";
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
        return "object";
      }
      default:
        return t;
    }
  };
  const Nouns = {
    regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
    url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
    time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
    duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
    ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
    ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
    cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
    cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
    base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
    base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
    e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expectedKey = issue2.expected;
        const expected = typeLabel(expectedKey);
        const receivedKey = parsedType4(issue2.input);
        const received = TypeNames[receivedKey]?.label ?? receivedKey;
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
      }
      case "invalid_value": {
        if (issue2.values.length === 1) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive(issue2.values[0])}`;
        }
        const stringified = issue2.values.map((v) => stringifyPrimitive(v));
        if (issue2.values.length === 2) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
        }
        const lastValue = stringified[stringified.length - 1];
        const restValues = stringified.slice(0, -1).join(", ");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
      }
      case "too_big": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue2.maximum}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue2.maximum} ${sizing?.unit ?? ""}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? "<=" : "<";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue2.minimum}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          if (issue2.minimum === 1 && issue2.inclusive) {
            const singularPhrase = issue2.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
          }
          const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue2.minimum} ${sizing?.unit ?? ""}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? ">=" : ">";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        const nounEntry = Nouns[_issue.format];
        const noun = nounEntry?.label ?? _issue.format;
        const gender = nounEntry?.gender ?? "m";
        const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
        return `${noun} \u05DC\u05D0 ${adjective}`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key": {
        return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
      }
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element": {
        const place = withDefinite(issue2.origin ?? "array");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
      }
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
};
var init_he = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/hu.js
function hu_default() {
  return {
    localeError: error17()
  };
}
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "sz\xE1m";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "t\xF6mb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue2.expected}, a kapott \xE9rt\xE9k ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
};
var init_hu = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/id.js
function id_default() {
  return {
    localeError: error18()
  };
}
var error18 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
var init_id = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/is.js
function is_default() {
  return {
    localeError: error19()
  };
}
var parsedType4 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "n\xFAmer";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "fylki";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
}, error19 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a\xF0 hafa" },
    file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
    array: { unit: "hluti", verb: "a\xF0 hafa" },
    set: { unit: "hluti", verb: "a\xF0 hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${parsedType4(issue2.input)} \xFEar sem \xE1 a\xF0 vera ${issue2.expected}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
var init_is = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/it.js
function it_default() {
  return {
    localeError: error20()
  };
}
var error20 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType5 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType5(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
var init_it = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ja.js
function ja_default() {
  return {
    localeError: error21()
  };
}
var error21 = () => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType5 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u914D\u5217";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u7121\u52B9\u306A\u5165\u529B: ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType5(issue2.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
};
var init_ja = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ka.js
function ka_default() {
  return {
    localeError: error22()
  };
}
var parsedType5 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  const typeMap = {
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    undefined: "undefined",
    bigint: "bigint",
    symbol: "symbol",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0"
  };
  return typeMap[t] ?? t;
}, error22 = () => {
  const Sizable = {
    string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${parsedType5(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
};
var init_ka = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/km.js
function km_default() {
  return {
    localeError: error23()
  };
}
var error23 = () => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u17A2\u17B6\u179A\u17C1 (Array)";
        }
        if (data === null) {
          return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
};
var init_km = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}
var init_kh = __esm(() => {
  init_km();
});

// node_modules/zod/v4/locales/ko.js
function ko_default() {
  return {
    localeError: error24()
  };
}
var error24 = () => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType6(issue2.input)}\uC785\uB2C8\uB2E4`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
};
var init_ko = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/lt.js
function getUnitTypeFromNumber(number2) {
  const abs = Math.abs(number2);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
function lt_default() {
  return {
    localeError: error25()
  };
}
var parsedType6 = (data) => {
  const t = typeof data;
  return parsedTypeFromType(t, data);
}, parsedTypeFromType = (t, data = undefined) => {
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "skai\u010Dius";
    }
    case "bigint": {
      return "sveikasis skai\u010Dius";
    }
    case "string": {
      return "eilut\u0117";
    }
    case "boolean": {
      return "login\u0117 reik\u0161m\u0117";
    }
    case "undefined":
    case "void": {
      return "neapibr\u0117\u017Eta reik\u0161m\u0117";
    }
    case "function": {
      return "funkcija";
    }
    case "symbol": {
      return "simbolis";
    }
    case "object": {
      if (data === undefined)
        return "ne\u017Einomas objektas";
      if (data === null)
        return "nulin\u0117 reik\u0161m\u0117";
      if (Array.isArray(data))
        return "masyvas";
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
      return "objektas";
    }
    case "null": {
      return "nulin\u0117 reik\u0161m\u0117";
    }
  }
  return t;
}, capitalizeFirstCharacter = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
}, error25 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const Nouns = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Gautas tipas ${parsedType6(issue2.input)}, o tik\u0117tasi - ${parsedTypeFromType(issue2.expected)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = parsedTypeFromType(issue2.origin);
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = parsedTypeFromType(issue2.origin);
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = parsedTypeFromType(issue2.origin);
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
};
var init_lt = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/mk.js
function mk_default() {
  return {
    localeError: error26()
  };
}
var error26 = () => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043D\u0438\u0437\u0430";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
};
var init_mk = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ms.js
function ms_default() {
  return {
    localeError: error27()
  };
}
var error27 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
var init_ms = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/nl.js
function nl_default() {
  return {
    localeError: error28()
  };
}
var error28 = () => {
  const Sizable = {
    string: { unit: "tekens", verb: "te hebben" },
    file: { unit: "bytes", verb: "te hebben" },
    array: { unit: "elementen", verb: "te hebben" },
    set: { unit: "elementen", verb: "te hebben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Te groot: verwacht dat ${issue2.origin ?? "waarde"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"}`;
        return `Te groot: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Te klein: verwacht dat ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Te klein: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
var init_nl = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/no.js
function no_default() {
  return {
    localeError: error29()
  };
}
var error29 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
var init_no = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ota.js
function ota_default() {
  return {
    localeError: error30()
  };
}
var error30 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `F\xE2sit giren: umulan ${issue2.expected}, al\u0131nan ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
};
var init_ota = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ps.js
function ps_default() {
  return {
    localeError: error31()
  };
}
var error31 = () => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0627\u0631\u06D0";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType7(issue2.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
};
var init_ps = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/pl.js
function pl_default() {
  return {
    localeError: error32()
  };
}
var error32 = () => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
};
var init_pl = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/pt.js
function pt_default() {
  return {
    localeError: error33()
  };
}
var error33 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\xFAmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipo inv\xE1lido: esperado ${issue2.expected}, recebido ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue2.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
};
var init_pt = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function ru_default() {
  return {
    localeError: error34()
  };
}
var error34 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
};
var init_ru = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/sl.js
function sl_default() {
  return {
    localeError: error35()
  };
}
var error35 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neveljaven vnos: pri\u010Dakovano ${issue2.expected}, prejeto ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
var init_sl = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/sv.js
function sv_default() {
  return {
    localeError: error36()
  };
}
var error36 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue2.expected}, fick ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
var init_sv = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ta.js
function ta_default() {
  return {
    localeError: error37()
  };
}
var error37 = () => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0B85\u0BA3\u0BBF";
        }
        if (data === null) {
          return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
};
var init_ta = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/th.js
function th_default() {
  return {
    localeError: error38()
  };
}
var error38 = () => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
        }
        if (data === null) {
          return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
};
var init_th = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/tr.js
function tr_default() {
  return {
    localeError: error39()
  };
}
var parsedType7 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
}, error39 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ge\xE7ersiz de\u011Fer: beklenen ${issue2.expected}, al\u0131nan ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
};
var init_tr = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/uk.js
function uk_default() {
  return {
    localeError: error40()
  };
}
var error40 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
};
var init_uk = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}
var init_ua = __esm(() => {
  init_uk();
});

// node_modules/zod/v4/locales/ur.js
function ur_default() {
  return {
    localeError: error41()
  };
}
var error41 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u06D2";
        }
        if (data === null) {
          return "\u0646\u0644";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType8(issue2.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
};
var init_ur = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/vi.js
function vi_default() {
  return {
    localeError: error42()
  };
}
var error42 = () => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "s\u1ED1";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "m\u1EA3ng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
};
var init_vi = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/zh-CN.js
function zh_CN_default() {
  return {
    localeError: error43()
  };
}
var error43 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u6570\u7EC4";
        }
        if (data === null) {
          return "\u7A7A\u503C(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
};
var init_zh_CN = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/zh-TW.js
function zh_TW_default() {
  return {
    localeError: error44()
  };
}
var error44 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
};
var init_zh_TW = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/yo.js
function yo_default() {
  return {
    localeError: error45()
  };
}
var error45 = () => {
  const Sizable = {
    string: { unit: "\xE0mi", verb: "n\xED" },
    file: { unit: "bytes", verb: "n\xED" },
    array: { unit: "nkan", verb: "n\xED" },
    set: { unit: "nkan", verb: "n\xED" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\u1ECD\u0301mb\xE0";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "akop\u1ECD";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
};
var init_yo = __esm(() => {
  init_util();
});

// node_modules/zod/v4/locales/index.js
var exports_locales = {};
__export(exports_locales, {
  zhTW: () => zh_TW_default,
  zhCN: () => zh_CN_default,
  yo: () => yo_default,
  vi: () => vi_default,
  ur: () => ur_default,
  uk: () => uk_default,
  ua: () => ua_default,
  tr: () => tr_default,
  th: () => th_default,
  ta: () => ta_default,
  sv: () => sv_default,
  sl: () => sl_default,
  ru: () => ru_default,
  pt: () => pt_default,
  ps: () => ps_default,
  pl: () => pl_default,
  ota: () => ota_default,
  no: () => no_default,
  nl: () => nl_default,
  ms: () => ms_default,
  mk: () => mk_default,
  lt: () => lt_default,
  ko: () => ko_default,
  km: () => km_default,
  kh: () => kh_default,
  ka: () => ka_default,
  ja: () => ja_default,
  it: () => it_default,
  is: () => is_default,
  id: () => id_default,
  hu: () => hu_default,
  he: () => he_default,
  frCA: () => fr_CA_default,
  fr: () => fr_default,
  fi: () => fi_default,
  fa: () => fa_default,
  es: () => es_default,
  eo: () => eo_default,
  en: () => en_default,
  de: () => de_default,
  da: () => da_default,
  cs: () => cs_default,
  ca: () => ca_default,
  bg: () => bg_default,
  be: () => be_default,
  az: () => az_default,
  ar: () => ar_default
});
var init_locales = __esm(() => {
  init_ar();
  init_az();
  init_be();
  init_bg();
  init_ca();
  init_cs();
  init_da();
  init_de();
  init_en();
  init_eo();
  init_es();
  init_fa();
  init_fi();
  init_fr();
  init_fr_CA();
  init_he();
  init_hu();
  init_id();
  init_is();
  init_it();
  init_ja();
  init_ka();
  init_kh();
  init_km();
  init_ko();
  init_lt();
  init_mk();
  init_ms();
  init_nl();
  init_no();
  init_ota();
  init_ps();
  init_pl();
  init_pt();
  init_ru();
  init_sl();
  init_sv();
  init_ta();
  init_th();
  init_tr();
  init_ua();
  init_uk();
  init_ur();
  init_vi();
  init_zh_CN();
  init_zh_TW();
  init_yo();
});

// node_modules/zod/v4/core/registries.js
class $ZodRegistry {
  constructor() {
    this._map = new WeakMap;
    this._idmap = new Map;
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = new WeakMap;
    this._idmap = new Map;
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : undefined;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry;
}
var _a, $output, $input, globalRegistry;
var init_registries = __esm(() => {
  $output = Symbol("ZodOutput");
  $input = Symbol("ZodInput");
  (_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
  globalRegistry = globalThis.__zod_globalRegistry;
});

// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _slugify() {
  return _overwrite((input) => slugify(input));
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    ...normalizeParams(params)
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _superRefine(fn) {
  const ch = _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
function describe(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {};
  return ch;
}
function meta(metadata) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {};
  return ch;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec,
          continue: false
        });
        return {};
      }
    },
    reverseTransform: (input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    },
    error: params.error
  });
  return codec;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}
var TimePrecision;
var init_api = __esm(() => {
  init_checks();
  init_registries();
  init_schemas();
  init_util();
  TimePrecision = {
    Any: null,
    Minute: -1,
    Second: 0,
    Millisecond: 3,
    Microsecond: 6
  };
});

// node_modules/zod/v4/core/to-json-schema.js
class JSONSchemaGenerator {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {});
    this.io = params?.io ?? "output";
    this.seen = new Map;
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a2;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json = _json;
            json.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minLength = minimum;
            if (typeof maximum === "number")
              json.maxLength = maximum;
            if (format) {
              json.format = formatMap[format] ?? format;
              if (json.format === "")
                delete json.format;
            }
            if (contentEncoding)
              json.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json.type = "integer";
            else
              json.type = "number";
            if (typeof exclusiveMinimum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json.minimum = exclusiveMinimum;
                json.exclusiveMinimum = true;
              } else {
                json.exclusiveMinimum = exclusiveMinimum;
              }
            }
            if (typeof minimum === "number") {
              json.minimum = minimum;
              if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                if (exclusiveMinimum >= minimum)
                  delete json.minimum;
                else
                  delete json.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json.maximum = exclusiveMaximum;
                json.exclusiveMaximum = true;
              } else {
                json.exclusiveMaximum = exclusiveMaximum;
              }
            }
            if (typeof maximum === "number") {
              json.maximum = maximum;
              if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                if (exclusiveMaximum <= maximum)
                  delete json.maximum;
                else
                  delete json.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            if (this.target === "openapi-3.0") {
              _json.type = "string";
              _json.nullable = true;
              _json.enum = [null];
            } else
              _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            json.type = "array";
            json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json = _json;
            json.type = "object";
            json.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === undefined;
              } else {
                return v.optout === undefined;
              }
            }));
            if (requiredKeys.size > 0) {
              json.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json.additionalProperties = false;
            } else if (def.catchall) {
              json.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json = _json;
            const isDiscriminated = def.discriminator !== undefined;
            const options = def.options.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, isDiscriminated ? "oneOf" : "anyOf", i]
            }));
            if (isDiscriminated) {
              json.oneOf = options;
            } else {
              json.anyOf = options;
            }
            break;
          }
          case "intersection": {
            const json = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json.allOf = allOf;
            break;
          }
          case "tuple": {
            const json = _json;
            json.type = "array";
            const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
            const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
            const prefixItems = def.items.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, prefixPath, i]
            }));
            const rest = def.rest ? this.process(def.rest, {
              ...params,
              path: [...params.path, restPath, ...this.target === "openapi-3.0" ? [def.items.length] : []]
            }) : null;
            if (this.target === "draft-2020-12") {
              json.prefixItems = prefixItems;
              if (rest) {
                json.items = rest;
              }
            } else if (this.target === "openapi-3.0") {
              json.items = {
                anyOf: prefixItems
              };
              if (rest) {
                json.items.anyOf.push(rest);
              }
              json.minItems = prefixItems.length;
              if (!rest) {
                json.maxItems = prefixItems.length;
              }
            } else {
              json.items = prefixItems;
              if (rest) {
                json.additionalItems = rest;
              }
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            break;
          }
          case "record": {
            const json = _json;
            json.type = "object";
            if (this.target === "draft-7" || this.target === "draft-2020-12") {
              json.propertyNames = this.process(def.keyType, {
                ...params,
                path: [...params.path, "propertyNames"]
              });
            }
            json.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v) => typeof v === "number"))
              json.type = "number";
            if (values.every((v) => typeof v === "string"))
              json.type = "string";
            json.enum = values;
            break;
          }
          case "literal": {
            const json = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === undefined) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {}
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {} else if (vals.length === 1) {
              const val = vals[0];
              json.type = val === null ? "null" : typeof val;
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json.enum = [val];
              } else {
                json.const = val;
              }
            } else {
              if (vals.every((v) => typeof v === "number"))
                json.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json.type = "string";
              if (vals.every((v) => v === null))
                json.type = "null";
              json.enum = vals;
            }
            break;
          }
          case "file": {
            const json = _json;
            const file = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== undefined)
              file.minLength = minimum;
            if (maximum !== undefined)
              file.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file.contentMediaType = mime[0];
                Object.assign(json, file);
              } else {
                json.anyOf = mime.map((m) => {
                  const mFile = { ...file, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json, file);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            if (this.target === "openapi-3.0") {
              result.ref = def.innerType;
              _json.nullable = true;
            } else {
              _json.anyOf = [inner, { type: "null" }];
            }
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(undefined);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json.type = "string";
            json.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw") {
              throw new Error("Function types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {}
        }
      }
    }
    const meta2 = this.metadataRegistry.get(schema);
    if (meta2)
      Object.assign(result.schema, meta2);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      external: _params?.external ?? undefined
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry[0])?.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (this.target === "draft-4") {
      result.$schema = "http://json-schema.org/draft-04/schema#";
    } else if (this.target === "openapi-3.0") {} else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema)?.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {} else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
}
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: new Set };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
var init_to_json_schema = __esm(() => {
  init_registries();
  init_util();
});

// node_modules/zod/v4/core/json-schema.js
var exports_json_schema = {};
var init_json_schema = () => {};

// node_modules/zod/v4/core/index.js
var exports_core2 = {};
__export(exports_core2, {
  version: () => version2,
  util: () => exports_util,
  treeifyError: () => treeifyError,
  toJSONSchema: () => toJSONSchema,
  toDotPath: () => toDotPath,
  safeParseAsync: () => safeParseAsync,
  safeParse: () => safeParse,
  safeEncodeAsync: () => safeEncodeAsync,
  safeEncode: () => safeEncode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeDecode: () => safeDecode,
  registry: () => registry,
  regexes: () => exports_regexes,
  prettifyError: () => prettifyError,
  parseAsync: () => parseAsync,
  parse: () => parse2,
  meta: () => meta,
  locales: () => exports_locales,
  isValidJWT: () => isValidJWT,
  isValidBase64URL: () => isValidBase64URL,
  isValidBase64: () => isValidBase64,
  globalRegistry: () => globalRegistry,
  globalConfig: () => globalConfig,
  formatError: () => formatError,
  flattenError: () => flattenError,
  encodeAsync: () => encodeAsync,
  encode: () => encode,
  describe: () => describe,
  decodeAsync: () => decodeAsync,
  decode: () => decode,
  config: () => config,
  clone: () => clone,
  _xid: () => _xid,
  _void: () => _void,
  _uuidv7: () => _uuidv7,
  _uuidv6: () => _uuidv6,
  _uuidv4: () => _uuidv4,
  _uuid: () => _uuid,
  _url: () => _url,
  _uppercase: () => _uppercase,
  _unknown: () => _unknown,
  _union: () => _union,
  _undefined: () => _undefined2,
  _ulid: () => _ulid,
  _uint64: () => _uint64,
  _uint32: () => _uint32,
  _tuple: () => _tuple,
  _trim: () => _trim,
  _transform: () => _transform,
  _toUpperCase: () => _toUpperCase,
  _toLowerCase: () => _toLowerCase,
  _templateLiteral: () => _templateLiteral,
  _symbol: () => _symbol,
  _superRefine: () => _superRefine,
  _success: () => _success,
  _stringbool: () => _stringbool,
  _stringFormat: () => _stringFormat,
  _string: () => _string,
  _startsWith: () => _startsWith,
  _slugify: () => _slugify,
  _size: () => _size,
  _set: () => _set,
  _safeParseAsync: () => _safeParseAsync,
  _safeParse: () => _safeParse,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeEncode: () => _safeEncode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeDecode: () => _safeDecode,
  _regex: () => _regex,
  _refine: () => _refine,
  _record: () => _record,
  _readonly: () => _readonly,
  _property: () => _property,
  _promise: () => _promise,
  _positive: () => _positive,
  _pipe: () => _pipe,
  _parseAsync: () => _parseAsync,
  _parse: () => _parse,
  _overwrite: () => _overwrite,
  _optional: () => _optional,
  _number: () => _number,
  _nullable: () => _nullable,
  _null: () => _null2,
  _normalize: () => _normalize,
  _nonpositive: () => _nonpositive,
  _nonoptional: () => _nonoptional,
  _nonnegative: () => _nonnegative,
  _never: () => _never,
  _negative: () => _negative,
  _nativeEnum: () => _nativeEnum,
  _nanoid: () => _nanoid,
  _nan: () => _nan,
  _multipleOf: () => _multipleOf,
  _minSize: () => _minSize,
  _minLength: () => _minLength,
  _min: () => _gte,
  _mime: () => _mime,
  _maxSize: () => _maxSize,
  _maxLength: () => _maxLength,
  _max: () => _lte,
  _map: () => _map,
  _mac: () => _mac,
  _lte: () => _lte,
  _lt: () => _lt,
  _lowercase: () => _lowercase,
  _literal: () => _literal,
  _length: () => _length,
  _lazy: () => _lazy,
  _ksuid: () => _ksuid,
  _jwt: () => _jwt,
  _isoTime: () => _isoTime,
  _isoDuration: () => _isoDuration,
  _isoDateTime: () => _isoDateTime,
  _isoDate: () => _isoDate,
  _ipv6: () => _ipv6,
  _ipv4: () => _ipv4,
  _intersection: () => _intersection,
  _int64: () => _int64,
  _int32: () => _int32,
  _int: () => _int,
  _includes: () => _includes,
  _guid: () => _guid,
  _gte: () => _gte,
  _gt: () => _gt,
  _float64: () => _float64,
  _float32: () => _float32,
  _file: () => _file,
  _enum: () => _enum,
  _endsWith: () => _endsWith,
  _encodeAsync: () => _encodeAsync,
  _encode: () => _encode,
  _emoji: () => _emoji2,
  _email: () => _email,
  _e164: () => _e164,
  _discriminatedUnion: () => _discriminatedUnion,
  _default: () => _default,
  _decodeAsync: () => _decodeAsync,
  _decode: () => _decode,
  _date: () => _date,
  _custom: () => _custom,
  _cuid2: () => _cuid2,
  _cuid: () => _cuid,
  _coercedString: () => _coercedString,
  _coercedNumber: () => _coercedNumber,
  _coercedDate: () => _coercedDate,
  _coercedBoolean: () => _coercedBoolean,
  _coercedBigint: () => _coercedBigint,
  _cidrv6: () => _cidrv6,
  _cidrv4: () => _cidrv4,
  _check: () => _check,
  _catch: () => _catch,
  _boolean: () => _boolean,
  _bigint: () => _bigint,
  _base64url: () => _base64url,
  _base64: () => _base64,
  _array: () => _array,
  _any: () => _any,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  JSONSchema: () => exports_json_schema,
  Doc: () => Doc,
  $output: () => $output,
  $input: () => $input,
  $constructor: () => $constructor,
  $brand: () => $brand,
  $ZodXID: () => $ZodXID,
  $ZodVoid: () => $ZodVoid,
  $ZodUnknown: () => $ZodUnknown,
  $ZodUnion: () => $ZodUnion,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUUID: () => $ZodUUID,
  $ZodURL: () => $ZodURL,
  $ZodULID: () => $ZodULID,
  $ZodType: () => $ZodType,
  $ZodTuple: () => $ZodTuple,
  $ZodTransform: () => $ZodTransform,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodSymbol: () => $ZodSymbol,
  $ZodSuccess: () => $ZodSuccess,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodString: () => $ZodString,
  $ZodSet: () => $ZodSet,
  $ZodRegistry: () => $ZodRegistry,
  $ZodRecord: () => $ZodRecord,
  $ZodRealError: () => $ZodRealError,
  $ZodReadonly: () => $ZodReadonly,
  $ZodPromise: () => $ZodPromise,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPipe: () => $ZodPipe,
  $ZodOptional: () => $ZodOptional,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodObject: () => $ZodObject,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodNumber: () => $ZodNumber,
  $ZodNullable: () => $ZodNullable,
  $ZodNull: () => $ZodNull,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNever: () => $ZodNever,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNaN: () => $ZodNaN,
  $ZodMap: () => $ZodMap,
  $ZodMAC: () => $ZodMAC,
  $ZodLiteral: () => $ZodLiteral,
  $ZodLazy: () => $ZodLazy,
  $ZodKSUID: () => $ZodKSUID,
  $ZodJWT: () => $ZodJWT,
  $ZodIntersection: () => $ZodIntersection,
  $ZodISOTime: () => $ZodISOTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODate: () => $ZodISODate,
  $ZodIPv6: () => $ZodIPv6,
  $ZodIPv4: () => $ZodIPv4,
  $ZodGUID: () => $ZodGUID,
  $ZodFunction: () => $ZodFunction,
  $ZodFile: () => $ZodFile,
  $ZodError: () => $ZodError,
  $ZodEnum: () => $ZodEnum,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEmail: () => $ZodEmail,
  $ZodE164: () => $ZodE164,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodDefault: () => $ZodDefault,
  $ZodDate: () => $ZodDate,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodCustom: () => $ZodCustom,
  $ZodCodec: () => $ZodCodec,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheck: () => $ZodCheck,
  $ZodCatch: () => $ZodCatch,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCUID: () => $ZodCUID,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodBoolean: () => $ZodBoolean,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBase64: () => $ZodBase64,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodArray: () => $ZodArray,
  $ZodAny: () => $ZodAny
});
var init_core2 = __esm(() => {
  init_core();
  init_parse();
  init_errors();
  init_schemas();
  init_checks();
  init_versions();
  init_util();
  init_regexes();
  init_locales();
  init_registries();
  init_api();
  init_to_json_schema();
  init_json_schema();
});

// node_modules/zod/v3/helpers/util.js
var util, objectUtil, ZodParsedType, getParsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var init_util2 = __esm(() => {
  (function(util2) {
    util2.assertEqual = (_) => {};
    function assertIs2(_arg) {}
    util2.assertIs = assertIs2;
    function assertNever2(_x) {
      throw new Error;
    }
    util2.assertNever = assertNever2;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr2, checker) => {
      for (const item of arr2) {
        if (checker(item))
          return item;
      }
      return;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues2(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues2;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
      };
    };
  })(objectUtil || (objectUtil = {}));
  ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
});

// node_modules/zod/v3/ZodError.js
var ZodIssueCode, quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, ZodError;
var init_ZodError = __esm(() => {
  init_util2();
  ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  ZodError = class ZodError extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue2) {
        return issue2.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error46) => {
        for (const issue2 of error46.issues) {
          if (issue2.code === "invalid_union") {
            issue2.unionErrors.map(processError);
          } else if (issue2.code === "invalid_return_type") {
            processError(issue2.returnTypeError);
          } else if (issue2.code === "invalid_arguments") {
            processError(issue2.argumentsError);
          } else if (issue2.path.length === 0) {
            fieldErrors._errors.push(mapper(issue2));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue2.path.length) {
              const el = issue2.path[i];
              const terminal = i === issue2.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue2));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue2) => issue2.message) {
      const fieldErrors = Object.create(null);
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          const firstEl = sub.path[0];
          fieldErrors[firstEl] = fieldErrors[firstEl] || [];
          fieldErrors[firstEl].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.create = (issues) => {
    const error46 = new ZodError(issues);
    return error46;
  };
});

// node_modules/zod/v3/locales/en.js
var errorMap = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode.invalid_type:
      if (issue2.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue2);
  }
  return { message };
}, en_default2;
var init_en2 = __esm(() => {
  init_ZodError();
  init_util2();
  en_default2 = errorMap;
});

// node_modules/zod/v3/errors.js
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var overrideErrorMap;
var init_errors2 = __esm(() => {
  init_en2();
  overrideErrorMap = en_default2;
});

// node_modules/zod/v3/helpers/parseUtil.js
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue2 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === en_default2 ? undefined : en_default2
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue2);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
}, EMPTY_PATH, INVALID, DIRTY = (value) => ({ status: "dirty", value }), OK = (value) => ({ status: "valid", value }), isAborted = (x) => x.status === "aborted", isDirty = (x) => x.status === "dirty", isValid = (x) => x.status === "valid", isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var init_parseUtil = __esm(() => {
  init_errors2();
  init_en2();
  EMPTY_PATH = [];
  INVALID = Object.freeze({
    status: "aborted"
  });
});

// node_modules/zod/v3/helpers/typeAliases.js
var init_typeAliases = () => {};

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
var init_errorUtil = __esm(() => {
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
  })(errorUtil || (errorUtil = {}));
});

// node_modules/zod/v3/types.js
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType2(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType2(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType2(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT2(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues2(a, b) {
  const aType = getParsedType2(a);
  const bType = getParsedType2(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error46 = new ZodError(ctx.common.issues);
        this._error = error46;
        return this._error;
      }
    };
  }
}, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring = () => stringType().optional(), onumber = () => numberType().optional(), oboolean = () => booleanType().optional(), coerce, NEVER2;
var init_types = __esm(() => {
  init_ZodError();
  init_errors2();
  init_errorUtil();
  init_parseUtil();
  init_util2();
  cuidRegex = /^c[^\s-]{8,}$/i;
  cuid2Regex = /^[0-9a-z]+$/;
  ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  nanoidRegex = /^[a-z0-9_-]{21}$/i;
  jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  dateRegex = new RegExp(`^${dateRegexSource}$`);
  ZodString = class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT2(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "jwt",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cidr",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        offset: options?.offset ?? false,
        local: options?.local ?? false,
        ...errorUtil.errToObj(options?.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        ...errorUtil.errToObj(options?.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options?.position,
        ...errorUtil.errToObj(options?.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString.create = (params) => {
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  ZodNumber = class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = undefined;
      const status = new ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder2(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null;
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  ZodBigInt = class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch {
          return this._getInvalidInput(input);
        }
      }
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = undefined;
      const status = new ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt.create = (params) => {
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  ZodBoolean = class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  ZodDate = class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (Number.isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: params?.coerce || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  ZodSymbol = class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  ZodUndefined = class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  ZodNull = class ZodNull extends ZodType {
    _parse(input) {
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  ZodAny = class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  ZodUnknown = class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  ZodNever = class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  ZodVoid = class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  ZodArray = class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : undefined,
            maximum: tooBig ? def.exactLength.value : undefined,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  ZodObject = class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      this._cached = { shape, keys };
      return this._cached;
    }
    _parse(input) {
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") {} else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== undefined ? {
          errorMap: (issue2, ctx) => {
            const defaultError = this._def.errorMap?.(issue2, ctx).message ?? ctx.defaultError;
            if (issue2.code === "unrecognized_keys")
              return {
                message: errorUtil.errToObj(message).message ?? defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    catchall(index) {
      return new ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      for (const key of util.objectKeys(mask)) {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodUnion = class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = undefined;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  ZodDiscriminatedUnion = class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(discriminator, options, params) {
      const optionsMap = new Map;
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  };
  ZodIntersection = class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues2(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  ZodTuple = class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple.create = (schemas2, params) => {
    if (!Array.isArray(schemas2)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas2,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  ZodRecord = class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  };
  ZodMap = class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = new Map;
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = new Map;
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  ZodSet = class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = new Set;
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  ZodFunction = class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error46) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default2].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error46
          }
        });
      }
      function makeReturnsIssue(returns, error46) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default2].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error46
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error46 = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error46.addIssue(makeArgsIssue(args, e));
            throw error46;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error46.addIssue(makeReturnsIssue(result, e));
            throw error46;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  };
  ZodLazy = class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  ZodLiteral = class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  ZodEnum = class ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(this._def.values);
      }
      if (!this._cache.has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  };
  ZodEnum.create = createZodEnum;
  ZodNativeEnum = class ZodNativeEnum extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(util.getValidEnumValues(this._def.values));
      }
      if (!this._cache.has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  ZodPromise = class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  ZodEffects = class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return INVALID;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return INVALID;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
              status: status.value,
              value: result
            }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  ZodOptional = class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType8 = this._getType(input);
      if (parsedType8 === ZodParsedType.undefined) {
        return OK(undefined);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  ZodNullable = class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType8 = this._getType(input);
      if (parsedType8 === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  ZodDefault = class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  ZodCatch = class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  ZodNaN = class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType8 = this._getType(input);
      if (parsedType8 !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  BRAND = Symbol("zod_brand");
  ZodBranded = class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  ZodPipeline = class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  };
  ZodReadonly = class ZodReadonly extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  late = {
    object: ZodObject.lazycreate
  };
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  stringType = ZodString.create;
  numberType = ZodNumber.create;
  nanType = ZodNaN.create;
  bigIntType = ZodBigInt.create;
  booleanType = ZodBoolean.create;
  dateType = ZodDate.create;
  symbolType = ZodSymbol.create;
  undefinedType = ZodUndefined.create;
  nullType = ZodNull.create;
  anyType = ZodAny.create;
  unknownType = ZodUnknown.create;
  neverType = ZodNever.create;
  voidType = ZodVoid.create;
  arrayType = ZodArray.create;
  objectType = ZodObject.create;
  strictObjectType = ZodObject.strictCreate;
  unionType = ZodUnion.create;
  discriminatedUnionType = ZodDiscriminatedUnion.create;
  intersectionType = ZodIntersection.create;
  tupleType = ZodTuple.create;
  recordType = ZodRecord.create;
  mapType = ZodMap.create;
  setType = ZodSet.create;
  functionType = ZodFunction.create;
  lazyType = ZodLazy.create;
  literalType = ZodLiteral.create;
  enumType = ZodEnum.create;
  nativeEnumType = ZodNativeEnum.create;
  promiseType = ZodPromise.create;
  effectsType = ZodEffects.create;
  optionalType = ZodOptional.create;
  nullableType = ZodNullable.create;
  preprocessType = ZodEffects.createWithPreprocess;
  pipelineType = ZodPipeline.create;
  coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  NEVER2 = INVALID;
});

// node_modules/zod/v3/external.js
var exports_external = {};
__export(exports_external, {
  void: () => voidType,
  util: () => util,
  unknown: () => unknownType,
  union: () => unionType,
  undefined: () => undefinedType,
  tuple: () => tupleType,
  transformer: () => effectsType,
  symbol: () => symbolType,
  string: () => stringType,
  strictObject: () => strictObjectType,
  setErrorMap: () => setErrorMap,
  set: () => setType,
  record: () => recordType,
  quotelessJson: () => quotelessJson,
  promise: () => promiseType,
  preprocess: () => preprocessType,
  pipeline: () => pipelineType,
  ostring: () => ostring,
  optional: () => optionalType,
  onumber: () => onumber,
  oboolean: () => oboolean,
  objectUtil: () => objectUtil,
  object: () => objectType,
  number: () => numberType,
  nullable: () => nullableType,
  null: () => nullType,
  never: () => neverType,
  nativeEnum: () => nativeEnumType,
  nan: () => nanType,
  map: () => mapType,
  makeIssue: () => makeIssue,
  literal: () => literalType,
  lazy: () => lazyType,
  late: () => late,
  isValid: () => isValid,
  isDirty: () => isDirty,
  isAsync: () => isAsync,
  isAborted: () => isAborted,
  intersection: () => intersectionType,
  instanceof: () => instanceOfType,
  getParsedType: () => getParsedType2,
  getErrorMap: () => getErrorMap,
  function: () => functionType,
  enum: () => enumType,
  effect: () => effectsType,
  discriminatedUnion: () => discriminatedUnionType,
  defaultErrorMap: () => en_default2,
  datetimeRegex: () => datetimeRegex,
  date: () => dateType,
  custom: () => custom,
  coerce: () => coerce,
  boolean: () => booleanType,
  bigint: () => bigIntType,
  array: () => arrayType,
  any: () => anyType,
  addIssueToContext: () => addIssueToContext,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransformer: () => ZodEffects,
  ZodSymbol: () => ZodSymbol,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodSchema: () => ZodType,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPipeline: () => ZodPipeline,
  ZodParsedType: () => ZodParsedType,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNever: () => ZodNever,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEffects: () => ZodEffects,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCatch: () => ZodCatch,
  ZodBranded: () => ZodBranded,
  ZodBoolean: () => ZodBoolean,
  ZodBigInt: () => ZodBigInt,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  Schema: () => ZodType,
  ParseStatus: () => ParseStatus,
  OK: () => OK,
  NEVER: () => NEVER2,
  INVALID: () => INVALID,
  EMPTY_PATH: () => EMPTY_PATH,
  DIRTY: () => DIRTY,
  BRAND: () => BRAND
});
var init_external = __esm(() => {
  init_errors2();
  init_parseUtil();
  init_typeAliases();
  init_util2();
  init_types();
  init_ZodError();
});

// node_modules/zod/v3/index.js
var init_v3 = __esm(() => {
  init_external();
  init_external();
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS((exports) => {
  exports.byteLength = byteLength;
  exports.toByteArray = toByteArray;
  exports.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (i = 0, len = code.length;i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  var i;
  var len;
  revLookup[45] = 62;
  revLookup[95] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr2 = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0;i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr2[curByte++] = tmp >> 16 & 255;
      arr2[curByte++] = tmp >> 8 & 255;
      arr2[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr2[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr2[curByte++] = tmp >> 8 & 255;
      arr2[curByte++] = tmp & 255;
    }
    return arr2;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start;i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes;i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/constant/has-own-property.js
var require_has_own_property = __commonJS((exports, module) => {
  var own = {}.hasOwnProperty;
  module.exports = own;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/constant/splice.js
var require_splice = __commonJS((exports, module) => {
  var splice = [].splice;
  module.exports = splice;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/util/chunked-splice.js
var require_chunked_splice = __commonJS((exports, module) => {
  var splice = require_splice();
  function chunkedSplice(list, start, remove, items) {
    var end = list.length;
    var chunkStart = 0;
    var parameters;
    if (start < 0) {
      start = -start > end ? 0 : end + start;
    } else {
      start = start > end ? end : start;
    }
    remove = remove > 0 ? remove : 0;
    if (items.length < 1e4) {
      parameters = Array.from(items);
      parameters.unshift(start, remove);
      splice.apply(list, parameters);
    } else {
      if (remove)
        splice.apply(list, [start, remove]);
      while (chunkStart < items.length) {
        parameters = items.slice(chunkStart, chunkStart + 1e4);
        parameters.unshift(start, 0);
        splice.apply(list, parameters);
        chunkStart += 1e4;
        start += 1e4;
      }
    }
  }
  module.exports = chunkedSplice;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/util/miniflat.js
var require_miniflat = __commonJS((exports, module) => {
  function miniflat(value) {
    return value === null || value === undefined ? [] : ("length" in value) ? value : [value];
  }
  module.exports = miniflat;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/util/combine-extensions.js
var require_combine_extensions = __commonJS((exports, module) => {
  var hasOwnProperty2 = require_has_own_property();
  var chunkedSplice = require_chunked_splice();
  var miniflat = require_miniflat();
  function combineExtensions(extensions) {
    var all = {};
    var index = -1;
    while (++index < extensions.length) {
      extension(all, extensions[index]);
    }
    return all;
  }
  function extension(all, extension2) {
    var hook;
    var left;
    var right;
    var code;
    for (hook in extension2) {
      left = hasOwnProperty2.call(all, hook) ? all[hook] : all[hook] = {};
      right = extension2[hook];
      for (code in right) {
        left[code] = constructs(miniflat(right[code]), hasOwnProperty2.call(left, code) ? left[code] : []);
      }
    }
  }
  function constructs(list, existing) {
    var index = -1;
    var before = [];
    while (++index < list.length) {
      (list[index].add === "after" ? existing : before).push(list[index]);
    }
    chunkedSplice(existing, 0, 0, before);
    return existing;
  }
  module.exports = combineExtensions;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/constant/from-char-code.js
var require_from_char_code = __commonJS((exports, module) => {
  var fromCharCode = String.fromCharCode;
  module.exports = fromCharCode;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/util/regex-check.js
var require_regex_check = __commonJS((exports, module) => {
  var fromCharCode = require_from_char_code();
  function regexCheck(regex2) {
    return check;
    function check(code) {
      return regex2.test(fromCharCode(code));
    }
  }
  module.exports = regexCheck;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/character/ascii-alpha.js
var require_ascii_alpha = __commonJS((exports, module) => {
  var regexCheck = require_regex_check();
  var asciiAlpha = regexCheck(/[A-Za-z]/);
  module.exports = asciiAlpha;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/character/ascii-alphanumeric.js
var require_ascii_alphanumeric = __commonJS((exports, module) => {
  var regexCheck = require_regex_check();
  var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
  module.exports = asciiAlphanumeric;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/character/ascii-control.js
var require_ascii_control = __commonJS((exports, module) => {
  function asciiControl(code) {
    return code < 32 || code === 127;
  }
  module.exports = asciiControl;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/character/markdown-line-ending.js
var require_markdown_line_ending = __commonJS((exports, module) => {
  function markdownLineEnding(code) {
    return code < -2;
  }
  module.exports = markdownLineEnding;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/constant/unicode-punctuation-regex.js
var require_unicode_punctuation_regex = __commonJS((exports, module) => {
  var unicodePunctuation = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
  module.exports = unicodePunctuation;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/character/unicode-punctuation.js
var require_unicode_punctuation = __commonJS((exports, module) => {
  var unicodePunctuationRegex = require_unicode_punctuation_regex();
  var regexCheck = require_regex_check();
  var unicodePunctuation = regexCheck(unicodePunctuationRegex);
  module.exports = unicodePunctuation;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/character/unicode-whitespace.js
var require_unicode_whitespace = __commonJS((exports, module) => {
  var regexCheck = require_regex_check();
  var unicodeWhitespace = regexCheck(/\s/);
  module.exports = unicodeWhitespace;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark-extension-gfm-autolink-literal/syntax.js
var require_syntax = __commonJS((exports) => {
  var asciiAlpha = require_ascii_alpha();
  var asciiAlphanumeric = require_ascii_alphanumeric();
  var asciiControl = require_ascii_control();
  var markdownLineEnding = require_markdown_line_ending();
  var unicodePunctuation = require_unicode_punctuation();
  var unicodeWhitespace = require_unicode_whitespace();
  var www = { tokenize: tokenizeWww, partial: true };
  var domain2 = { tokenize: tokenizeDomain, partial: true };
  var path = { tokenize: tokenizePath, partial: true };
  var punctuation = { tokenize: tokenizePunctuation, partial: true };
  var namedCharacterReference = {
    tokenize: tokenizeNamedCharacterReference,
    partial: true
  };
  var wwwAutolink = { tokenize: tokenizeWwwAutolink, previous: previousWww };
  var httpAutolink = { tokenize: tokenizeHttpAutolink, previous: previousHttp };
  var emailAutolink = { tokenize: tokenizeEmailAutolink, previous: previousEmail };
  var text = {};
  exports.text = text;
  var code = 48;
  while (code < 123) {
    text[code] = emailAutolink;
    code++;
    if (code === 58)
      code = 65;
    else if (code === 91)
      code = 97;
  }
  text[43] = emailAutolink;
  text[45] = emailAutolink;
  text[46] = emailAutolink;
  text[95] = emailAutolink;
  text[72] = [emailAutolink, httpAutolink];
  text[104] = [emailAutolink, httpAutolink];
  text[87] = [emailAutolink, wwwAutolink];
  text[119] = [emailAutolink, wwwAutolink];
  function tokenizeEmailAutolink(effects, ok, nok) {
    var self2 = this;
    var hasDot;
    return start;
    function start(code2) {
      if (!gfmAtext(code2) || !previousEmail(self2.previous) || previous(self2.events)) {
        return nok(code2);
      }
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkEmail");
      return atext(code2);
    }
    function atext(code2) {
      if (gfmAtext(code2)) {
        effects.consume(code2);
        return atext;
      }
      if (code2 === 64) {
        effects.consume(code2);
        return label;
      }
      return nok(code2);
    }
    function label(code2) {
      if (code2 === 46) {
        return effects.check(punctuation, done, dotContinuation)(code2);
      }
      if (code2 === 45 || code2 === 95) {
        return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code2);
      }
      if (asciiAlphanumeric(code2)) {
        effects.consume(code2);
        return label;
      }
      return done(code2);
    }
    function dotContinuation(code2) {
      effects.consume(code2);
      hasDot = true;
      return label;
    }
    function dashOrUnderscoreContinuation(code2) {
      effects.consume(code2);
      return afterDashOrUnderscore;
    }
    function afterDashOrUnderscore(code2) {
      if (code2 === 46) {
        return effects.check(punctuation, nok, dotContinuation)(code2);
      }
      return label(code2);
    }
    function done(code2) {
      if (hasDot) {
        effects.exit("literalAutolinkEmail");
        effects.exit("literalAutolink");
        return ok(code2);
      }
      return nok(code2);
    }
  }
  function tokenizeWwwAutolink(effects, ok, nok) {
    var self2 = this;
    return start;
    function start(code2) {
      if (code2 !== 87 && code2 - 32 !== 87 || !previousWww(self2.previous) || previous(self2.events)) {
        return nok(code2);
      }
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkWww");
      return effects.check(www, effects.attempt(domain2, effects.attempt(path, done), nok), nok)(code2);
    }
    function done(code2) {
      effects.exit("literalAutolinkWww");
      effects.exit("literalAutolink");
      return ok(code2);
    }
  }
  function tokenizeHttpAutolink(effects, ok, nok) {
    var self2 = this;
    return start;
    function start(code2) {
      if (code2 !== 72 && code2 - 32 !== 72 || !previousHttp(self2.previous) || previous(self2.events)) {
        return nok(code2);
      }
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkHttp");
      effects.consume(code2);
      return t1;
    }
    function t1(code2) {
      if (code2 === 84 || code2 - 32 === 84) {
        effects.consume(code2);
        return t2;
      }
      return nok(code2);
    }
    function t2(code2) {
      if (code2 === 84 || code2 - 32 === 84) {
        effects.consume(code2);
        return p;
      }
      return nok(code2);
    }
    function p(code2) {
      if (code2 === 80 || code2 - 32 === 80) {
        effects.consume(code2);
        return s;
      }
      return nok(code2);
    }
    function s(code2) {
      if (code2 === 83 || code2 - 32 === 83) {
        effects.consume(code2);
        return colon;
      }
      return colon(code2);
    }
    function colon(code2) {
      if (code2 === 58) {
        effects.consume(code2);
        return slash1;
      }
      return nok(code2);
    }
    function slash1(code2) {
      if (code2 === 47) {
        effects.consume(code2);
        return slash2;
      }
      return nok(code2);
    }
    function slash2(code2) {
      if (code2 === 47) {
        effects.consume(code2);
        return after;
      }
      return nok(code2);
    }
    function after(code2) {
      return asciiControl(code2) || unicodeWhitespace(code2) || unicodePunctuation(code2) ? nok(code2) : effects.attempt(domain2, effects.attempt(path, done), nok)(code2);
    }
    function done(code2) {
      effects.exit("literalAutolinkHttp");
      effects.exit("literalAutolink");
      return ok(code2);
    }
  }
  function tokenizeWww(effects, ok, nok) {
    return start;
    function start(code2) {
      effects.consume(code2);
      return w2;
    }
    function w2(code2) {
      if (code2 === 87 || code2 - 32 === 87) {
        effects.consume(code2);
        return w3;
      }
      return nok(code2);
    }
    function w3(code2) {
      if (code2 === 87 || code2 - 32 === 87) {
        effects.consume(code2);
        return dot;
      }
      return nok(code2);
    }
    function dot(code2) {
      if (code2 === 46) {
        effects.consume(code2);
        return after;
      }
      return nok(code2);
    }
    function after(code2) {
      return code2 === null || markdownLineEnding(code2) ? nok(code2) : ok(code2);
    }
  }
  function tokenizeDomain(effects, ok, nok) {
    var hasUnderscoreInLastSegment;
    var hasUnderscoreInLastLastSegment;
    return domain3;
    function domain3(code2) {
      if (code2 === 38) {
        return effects.check(namedCharacterReference, done, punctuationContinuation)(code2);
      }
      if (code2 === 46 || code2 === 95) {
        return effects.check(punctuation, done, punctuationContinuation)(code2);
      }
      if (asciiControl(code2) || unicodeWhitespace(code2) || code2 !== 45 && unicodePunctuation(code2)) {
        return done(code2);
      }
      effects.consume(code2);
      return domain3;
    }
    function punctuationContinuation(code2) {
      if (code2 === 46) {
        hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;
        hasUnderscoreInLastSegment = undefined;
        effects.consume(code2);
        return domain3;
      }
      if (code2 === 95)
        hasUnderscoreInLastSegment = true;
      effects.consume(code2);
      return domain3;
    }
    function done(code2) {
      if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {
        return ok(code2);
      }
      return nok(code2);
    }
  }
  function tokenizePath(effects, ok) {
    var balance = 0;
    return inPath;
    function inPath(code2) {
      if (code2 === 38) {
        return effects.check(namedCharacterReference, ok, continuedPunctuation)(code2);
      }
      if (code2 === 40) {
        balance++;
      }
      if (code2 === 41) {
        return effects.check(punctuation, parenAtPathEnd, continuedPunctuation)(code2);
      }
      if (pathEnd(code2)) {
        return ok(code2);
      }
      if (trailingPunctuation(code2)) {
        return effects.check(punctuation, ok, continuedPunctuation)(code2);
      }
      effects.consume(code2);
      return inPath;
    }
    function continuedPunctuation(code2) {
      effects.consume(code2);
      return inPath;
    }
    function parenAtPathEnd(code2) {
      balance--;
      return balance < 0 ? ok(code2) : continuedPunctuation(code2);
    }
  }
  function tokenizeNamedCharacterReference(effects, ok, nok) {
    return start;
    function start(code2) {
      effects.consume(code2);
      return inside;
    }
    function inside(code2) {
      if (asciiAlpha(code2)) {
        effects.consume(code2);
        return inside;
      }
      if (code2 === 59) {
        effects.consume(code2);
        return after;
      }
      return nok(code2);
    }
    function after(code2) {
      return pathEnd(code2) ? ok(code2) : nok(code2);
    }
  }
  function tokenizePunctuation(effects, ok, nok) {
    return start;
    function start(code2) {
      effects.consume(code2);
      return after;
    }
    function after(code2) {
      if (trailingPunctuation(code2)) {
        effects.consume(code2);
        return after;
      }
      return pathEnd(code2) ? ok(code2) : nok(code2);
    }
  }
  function trailingPunctuation(code2) {
    return code2 === 33 || code2 === 34 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 60 || code2 === 63 || code2 === 95 || code2 === 126;
  }
  function pathEnd(code2) {
    return code2 === null || code2 < 0 || code2 === 32 || code2 === 60;
  }
  function gfmAtext(code2) {
    return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
  }
  function previousWww(code2) {
    return code2 === null || code2 < 0 || code2 === 32 || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 126;
  }
  function previousHttp(code2) {
    return code2 === null || !asciiAlpha(code2);
  }
  function previousEmail(code2) {
    return code2 !== 47 && previousHttp(code2);
  }
  function previous(events) {
    var index = events.length;
    while (index--) {
      if ((events[index][1].type === "labelLink" || events[index][1].type === "labelImage") && !events[index][1]._balanced) {
        return true;
      }
    }
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/character/markdown-line-ending-or-space.js
var require_markdown_line_ending_or_space = __commonJS((exports, module) => {
  function markdownLineEndingOrSpace(code) {
    return code < 0 || code === 32;
  }
  module.exports = markdownLineEndingOrSpace;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/util/classify-character.js
var require_classify_character = __commonJS((exports, module) => {
  var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
  var unicodePunctuation = require_unicode_punctuation();
  var unicodeWhitespace = require_unicode_whitespace();
  function classifyCharacter(code) {
    if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {
      return 1;
    }
    if (unicodePunctuation(code)) {
      return 2;
    }
  }
  module.exports = classifyCharacter;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/util/resolve-all.js
var require_resolve_all = __commonJS((exports, module) => {
  function resolveAll(constructs, events, context) {
    var called = [];
    var index = -1;
    var resolve;
    while (++index < constructs.length) {
      resolve = constructs[index].resolveAll;
      if (resolve && called.indexOf(resolve) < 0) {
        events = resolve(events, context);
        called.push(resolve);
      }
    }
    return events;
  }
  module.exports = resolveAll;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/constant/assign.js
var require_assign = __commonJS((exports, module) => {
  var assign = Object.assign;
  module.exports = assign;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/util/shallow.js
var require_shallow = __commonJS((exports, module) => {
  var assign = require_assign();
  function shallow(object) {
    return assign({}, object);
  }
  module.exports = shallow;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark-extension-gfm-strikethrough/index.js
var require_micromark_extension_gfm_strikethrough = __commonJS((exports, module) => {
  module.exports = create;
  var classifyCharacter = require_classify_character();
  var chunkedSplice = require_chunked_splice();
  var resolveAll = require_resolve_all();
  var shallow = require_shallow();
  function create(options) {
    var settings = options || {};
    var single = settings.singleTilde;
    var tokenizer = {
      tokenize: tokenizeStrikethrough,
      resolveAll: resolveAllStrikethrough
    };
    if (single === null || single === undefined) {
      single = true;
    }
    return { text: { 126: tokenizer }, insideSpan: { null: tokenizer } };
    function resolveAllStrikethrough(events, context) {
      var index = -1;
      var strikethrough;
      var text;
      var open;
      var nextEvents;
      while (++index < events.length) {
        if (events[index][0] === "enter" && events[index][1].type === "strikethroughSequenceTemporary" && events[index][1]._close) {
          open = index;
          while (open--) {
            if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
              events[index][1].type = "strikethroughSequence";
              events[open][1].type = "strikethroughSequence";
              strikethrough = {
                type: "strikethrough",
                start: shallow(events[open][1].start),
                end: shallow(events[index][1].end)
              };
              text = {
                type: "strikethroughText",
                start: shallow(events[open][1].end),
                end: shallow(events[index][1].start)
              };
              nextEvents = [
                ["enter", strikethrough, context],
                ["enter", events[open][1], context],
                ["exit", events[open][1], context],
                ["enter", text, context]
              ];
              chunkedSplice(nextEvents, nextEvents.length, 0, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index), context));
              chunkedSplice(nextEvents, nextEvents.length, 0, [
                ["exit", text, context],
                ["enter", events[index][1], context],
                ["exit", events[index][1], context],
                ["exit", strikethrough, context]
              ]);
              chunkedSplice(events, open - 1, index - open + 3, nextEvents);
              index = open + nextEvents.length - 2;
              break;
            }
          }
        }
      }
      return removeRemainingSequences(events);
    }
    function removeRemainingSequences(events) {
      var index = -1;
      var length = events.length;
      while (++index < length) {
        if (events[index][1].type === "strikethroughSequenceTemporary") {
          events[index][1].type = "data";
        }
      }
      return events;
    }
    function tokenizeStrikethrough(effects, ok, nok) {
      var previous = this.previous;
      var events = this.events;
      var size = 0;
      return start;
      function start(code) {
        if (code !== 126 || previous === 126 && events[events.length - 1][1].type !== "characterEscape") {
          return nok(code);
        }
        effects.enter("strikethroughSequenceTemporary");
        return more(code);
      }
      function more(code) {
        var before = classifyCharacter(previous);
        var token;
        var after;
        if (code === 126) {
          if (size > 1)
            return nok(code);
          effects.consume(code);
          size++;
          return more;
        }
        if (size < 2 && !single)
          return nok(code);
        token = effects.exit("strikethroughSequenceTemporary");
        after = classifyCharacter(code);
        token._open = !after || after === 2 && before;
        token._close = !before || before === 2 && after;
        return ok(code);
      }
    }
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/character/markdown-space.js
var require_markdown_space = __commonJS((exports, module) => {
  function markdownSpace(code) {
    return code === -2 || code === -1 || code === 32;
  }
  module.exports = markdownSpace;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/tokenize/factory-space.js
var require_factory_space = __commonJS((exports, module) => {
  var markdownSpace = require_markdown_space();
  function spaceFactory(effects, ok, type, max) {
    var limit = max ? max - 1 : Infinity;
    var size = 0;
    return start;
    function start(code) {
      if (markdownSpace(code)) {
        effects.enter(type);
        return prefix(code);
      }
      return ok(code);
    }
    function prefix(code) {
      if (markdownSpace(code) && size++ < limit) {
        effects.consume(code);
        return prefix;
      }
      effects.exit(type);
      return ok(code);
    }
  }
  module.exports = spaceFactory;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark-extension-gfm-table/syntax.js
var require_syntax2 = __commonJS((exports) => {
  exports.flow = {
    null: { tokenize: tokenizeTable, resolve: resolveTable, interruptible: true }
  };
  var createSpace = require_factory_space();
  var setextUnderlineMini = { tokenize: tokenizeSetextUnderlineMini, partial: true };
  var nextPrefixedOrBlank = { tokenize: tokenizeNextPrefixedOrBlank, partial: true };
  function resolveTable(events, context) {
    var length = events.length;
    var index = -1;
    var token;
    var inHead;
    var inDelimiterRow;
    var inRow;
    var cell;
    var content;
    var text;
    var contentStart;
    var contentEnd;
    var cellStart;
    while (++index < length) {
      token = events[index][1];
      if (inRow) {
        if (token.type === "temporaryTableCellContent") {
          contentStart = contentStart || index;
          contentEnd = index;
        }
        if ((token.type === "tableCellDivider" || token.type === "tableRow") && contentEnd) {
          content = {
            type: "tableContent",
            start: events[contentStart][1].start,
            end: events[contentEnd][1].end
          };
          text = {
            type: "chunkText",
            start: content.start,
            end: content.end,
            contentType: "text"
          };
          events.splice(contentStart, contentEnd - contentStart + 1, ["enter", content, context], ["enter", text, context], ["exit", text, context], ["exit", content, context]);
          index -= contentEnd - contentStart - 3;
          length = events.length;
          contentStart = undefined;
          contentEnd = undefined;
        }
      }
      if (events[index][0] === "exit" && cellStart && cellStart + 1 < index && (token.type === "tableCellDivider" || token.type === "tableRow" && (cellStart + 3 < index || events[cellStart][1].type !== "whitespace"))) {
        cell = {
          type: inDelimiterRow ? "tableDelimiter" : inHead ? "tableHeader" : "tableData",
          start: events[cellStart][1].start,
          end: events[index][1].end
        };
        events.splice(index + (token.type === "tableCellDivider" ? 1 : 0), 0, [
          "exit",
          cell,
          context
        ]);
        events.splice(cellStart, 0, ["enter", cell, context]);
        index += 2;
        length = events.length;
        cellStart = index + 1;
      }
      if (token.type === "tableRow") {
        inRow = events[index][0] === "enter";
        if (inRow) {
          cellStart = index + 1;
        }
      }
      if (token.type === "tableDelimiterRow") {
        inDelimiterRow = events[index][0] === "enter";
        if (inDelimiterRow) {
          cellStart = index + 1;
        }
      }
      if (token.type === "tableHead") {
        inHead = events[index][0] === "enter";
      }
    }
    return events;
  }
  function tokenizeTable(effects, ok, nok) {
    var align = [];
    var tableHeaderCount = 0;
    var seenDelimiter;
    var hasDash;
    return start;
    function start(code) {
      if (code === null || code === -5 || code === -4 || code === -3) {
        return nok(code);
      }
      effects.enter("table")._align = align;
      effects.enter("tableHead");
      effects.enter("tableRow");
      if (code === 124) {
        return cellDividerHead(code);
      }
      tableHeaderCount++;
      effects.enter("temporaryTableCellContent");
      return inCellContentHead(code);
    }
    function cellDividerHead(code) {
      effects.enter("tableCellDivider");
      effects.consume(code);
      effects.exit("tableCellDivider");
      seenDelimiter = true;
      return cellBreakHead;
    }
    function cellBreakHead(code) {
      if (code === null || code === -5 || code === -4 || code === -3) {
        return atRowEndHead(code);
      }
      if (code === -2 || code === -1 || code === 32) {
        effects.enter("whitespace");
        effects.consume(code);
        return inWhitespaceHead;
      }
      if (seenDelimiter) {
        seenDelimiter = undefined;
        tableHeaderCount++;
      }
      if (code === 124) {
        return cellDividerHead(code);
      }
      effects.enter("temporaryTableCellContent");
      return inCellContentHead(code);
    }
    function inWhitespaceHead(code) {
      if (code === -2 || code === -1 || code === 32) {
        effects.consume(code);
        return inWhitespaceHead;
      }
      effects.exit("whitespace");
      return cellBreakHead(code);
    }
    function inCellContentHead(code) {
      if (code === null || code < 0 || code === 32 || code === 124) {
        effects.exit("temporaryTableCellContent");
        return cellBreakHead(code);
      }
      effects.consume(code);
      return code === 92 ? inCellContentEscapeHead : inCellContentHead;
    }
    function inCellContentEscapeHead(code) {
      if (code === 92 || code === 124) {
        effects.consume(code);
        return inCellContentHead;
      }
      return inCellContentHead(code);
    }
    function atRowEndHead(code) {
      if (code === null) {
        return nok(code);
      }
      effects.exit("tableRow");
      effects.exit("tableHead");
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return effects.check(setextUnderlineMini, nok, createSpace(effects, rowStartDelimiter, "linePrefix", 4));
    }
    function rowStartDelimiter(code) {
      if (code === null || code < 0 || code === 32) {
        return nok(code);
      }
      effects.enter("tableDelimiterRow");
      return atDelimiterRowBreak(code);
    }
    function atDelimiterRowBreak(code) {
      if (code === null || code === -5 || code === -4 || code === -3) {
        return rowEndDelimiter(code);
      }
      if (code === -2 || code === -1 || code === 32) {
        effects.enter("whitespace");
        effects.consume(code);
        return inWhitespaceDelimiter;
      }
      if (code === 45) {
        effects.enter("tableDelimiterFiller");
        effects.consume(code);
        hasDash = true;
        align.push(null);
        return inFillerDelimiter;
      }
      if (code === 58) {
        effects.enter("tableDelimiterAlignment");
        effects.consume(code);
        effects.exit("tableDelimiterAlignment");
        align.push("left");
        return afterLeftAlignment;
      }
      if (code === 124) {
        effects.enter("tableCellDivider");
        effects.consume(code);
        effects.exit("tableCellDivider");
        return atDelimiterRowBreak;
      }
      return nok(code);
    }
    function inWhitespaceDelimiter(code) {
      if (code === -2 || code === -1 || code === 32) {
        effects.consume(code);
        return inWhitespaceDelimiter;
      }
      effects.exit("whitespace");
      return atDelimiterRowBreak(code);
    }
    function inFillerDelimiter(code) {
      if (code === 45) {
        effects.consume(code);
        return inFillerDelimiter;
      }
      effects.exit("tableDelimiterFiller");
      if (code === 58) {
        effects.enter("tableDelimiterAlignment");
        effects.consume(code);
        effects.exit("tableDelimiterAlignment");
        align[align.length - 1] = align[align.length - 1] === "left" ? "center" : "right";
        return afterRightAlignment;
      }
      return atDelimiterRowBreak(code);
    }
    function afterLeftAlignment(code) {
      if (code === 45) {
        effects.enter("tableDelimiterFiller");
        effects.consume(code);
        hasDash = true;
        return inFillerDelimiter;
      }
      return nok(code);
    }
    function afterRightAlignment(code) {
      if (code === null || code === -5 || code === -4 || code === -3) {
        return rowEndDelimiter(code);
      }
      if (code === -2 || code === -1 || code === 32) {
        effects.enter("whitespace");
        effects.consume(code);
        return inWhitespaceDelimiter;
      }
      if (code === 124) {
        effects.enter("tableCellDivider");
        effects.consume(code);
        effects.exit("tableCellDivider");
        return atDelimiterRowBreak;
      }
      return nok(code);
    }
    function rowEndDelimiter(code) {
      effects.exit("tableDelimiterRow");
      if (!hasDash || tableHeaderCount !== align.length) {
        return nok(code);
      }
      if (code === null) {
        return tableClose(code);
      }
      return effects.check(nextPrefixedOrBlank, tableClose, tableContinue)(code);
    }
    function tableClose(code) {
      effects.exit("table");
      return ok(code);
    }
    function tableContinue(code) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return createSpace(effects, bodyStart, "linePrefix", 4);
    }
    function bodyStart(code) {
      effects.enter("tableBody");
      return rowStartBody(code);
    }
    function rowStartBody(code) {
      effects.enter("tableRow");
      if (code === 124) {
        return cellDividerBody(code);
      }
      effects.enter("temporaryTableCellContent");
      return inCellContentBody(code);
    }
    function cellDividerBody(code) {
      effects.enter("tableCellDivider");
      effects.consume(code);
      effects.exit("tableCellDivider");
      return cellBreakBody;
    }
    function cellBreakBody(code) {
      if (code === null || code === -5 || code === -4 || code === -3) {
        return atRowEndBody(code);
      }
      if (code === -2 || code === -1 || code === 32) {
        effects.enter("whitespace");
        effects.consume(code);
        return inWhitespaceBody;
      }
      if (code === 124) {
        return cellDividerBody(code);
      }
      effects.enter("temporaryTableCellContent");
      return inCellContentBody(code);
    }
    function inWhitespaceBody(code) {
      if (code === -2 || code === -1 || code === 32) {
        effects.consume(code);
        return inWhitespaceBody;
      }
      effects.exit("whitespace");
      return cellBreakBody(code);
    }
    function inCellContentBody(code) {
      if (code === null || code < 0 || code === 32 || code === 124) {
        effects.exit("temporaryTableCellContent");
        return cellBreakBody(code);
      }
      effects.consume(code);
      return code === 92 ? inCellContentEscapeBody : inCellContentBody;
    }
    function inCellContentEscapeBody(code) {
      if (code === 92 || code === 124) {
        effects.consume(code);
        return inCellContentBody;
      }
      return inCellContentBody(code);
    }
    function atRowEndBody(code) {
      effects.exit("tableRow");
      if (code === null) {
        return tableBodyClose(code);
      }
      return effects.check(nextPrefixedOrBlank, tableBodyClose, tableBodyContinue)(code);
    }
    function tableBodyClose(code) {
      effects.exit("tableBody");
      return tableClose(code);
    }
    function tableBodyContinue(code) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return createSpace(effects, rowStartBody, "linePrefix", 4);
    }
  }
  function tokenizeSetextUnderlineMini(effects, ok, nok) {
    return start;
    function start(code) {
      if (code !== 45) {
        return nok(code);
      }
      effects.enter("setextUnderline");
      return sequence(code);
    }
    function sequence(code) {
      if (code === 45) {
        effects.consume(code);
        return sequence;
      }
      return whitespace(code);
    }
    function whitespace(code) {
      if (code === -2 || code === -1 || code === 32) {
        effects.consume(code);
        return whitespace;
      }
      if (code === null || code === -5 || code === -4 || code === -3) {
        return ok(code);
      }
      return nok(code);
    }
  }
  function tokenizeNextPrefixedOrBlank(effects, ok, nok) {
    var size = 0;
    return start;
    function start(code) {
      effects.enter("check");
      effects.consume(code);
      return whitespace;
    }
    function whitespace(code) {
      if (code === -1 || code === 32) {
        effects.consume(code);
        size++;
        return size === 4 ? ok : whitespace;
      }
      if (code === null || code < 0) {
        return ok(code);
      }
      return nok(code);
    }
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/util/size-chunks.js
var require_size_chunks = __commonJS((exports, module) => {
  function sizeChunks(chunks) {
    var index = -1;
    var size = 0;
    while (++index < chunks.length) {
      size += typeof chunks[index] === "string" ? chunks[index].length : 1;
    }
    return size;
  }
  module.exports = sizeChunks;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark/dist/util/prefix-size.js
var require_prefix_size = __commonJS((exports, module) => {
  var sizeChunks = require_size_chunks();
  function prefixSize(events, type) {
    var tail = events[events.length - 1];
    if (!tail || tail[1].type !== type)
      return 0;
    return sizeChunks(tail[2].sliceStream(tail[1]));
  }
  module.exports = prefixSize;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/node_modules/micromark-extension-gfm-task-list-item/syntax.js
var require_syntax3 = __commonJS((exports) => {
  var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
  var spaceFactory = require_factory_space();
  var prefixSize = require_prefix_size();
  var tasklistCheck = { tokenize: tokenizeTasklistCheck };
  exports.text = { 91: tasklistCheck };
  function tokenizeTasklistCheck(effects, ok, nok) {
    var self2 = this;
    return open;
    function open(code) {
      if (code !== 91 || self2.previous !== null || !self2._gfmTasklistFirstContentOfListItem) {
        return nok(code);
      }
      effects.enter("taskListCheck");
      effects.enter("taskListCheckMarker");
      effects.consume(code);
      effects.exit("taskListCheckMarker");
      return inside;
    }
    function inside(code) {
      if (code === -2 || code === 32) {
        effects.enter("taskListCheckValueUnchecked");
        effects.consume(code);
        effects.exit("taskListCheckValueUnchecked");
        return close;
      }
      if (code === 88 || code === 120) {
        effects.enter("taskListCheckValueChecked");
        effects.consume(code);
        effects.exit("taskListCheckValueChecked");
        return close;
      }
      return nok(code);
    }
    function close(code) {
      if (code === 93) {
        effects.enter("taskListCheckMarker");
        effects.consume(code);
        effects.exit("taskListCheckMarker");
        effects.exit("taskListCheck");
        return effects.check({ tokenize: spaceThenNonSpace }, ok, nok);
      }
      return nok(code);
    }
  }
  function spaceThenNonSpace(effects, ok, nok) {
    var self2 = this;
    return spaceFactory(effects, after, "whitespace");
    function after(code) {
      return prefixSize(self2.events, "whitespace") && code !== null && !markdownLineEndingOrSpace(code) ? ok(code) : nok(code);
    }
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/micromark-extension-gfm/syntax.js
var require_syntax4 = __commonJS((exports, module) => {
  var combine = require_combine_extensions();
  var autolink = require_syntax();
  var strikethrough = require_micromark_extension_gfm_strikethrough();
  var table = require_syntax2();
  var tasklist = require_syntax3();
  module.exports = create;
  function create(options) {
    return combine([autolink, strikethrough(options), table, tasklist]);
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/node_modules/mdast-util-gfm-autolink-literal/node_modules/ccount/index.js
var require_ccount = __commonJS((exports, module) => {
  module.exports = ccount;
  function ccount(source, character) {
    var value = String(source);
    var count = 0;
    var index;
    if (typeof character !== "string") {
      throw new Error("Expected character");
    }
    index = value.indexOf(character);
    while (index !== -1) {
      count++;
      index = value.indexOf(character, index + character.length);
    }
    return count;
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/node_modules/mdast-util-gfm-autolink-literal/node_modules/mdast-util-find-and-replace/node_modules/unist-util-is/convert.js
var require_convert = __commonJS((exports, module) => {
  module.exports = convert;
  function convert(test) {
    if (test == null) {
      return ok;
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    if (typeof test === "object") {
      return "length" in test ? anyFactory(test) : allFactory(test);
    }
    if (typeof test === "function") {
      return test;
    }
    throw new Error("Expected function, string, or object as test");
  }
  function allFactory(test) {
    return all;
    function all(node) {
      var key;
      for (key in test) {
        if (node[key] !== test[key])
          return false;
      }
      return true;
    }
  }
  function anyFactory(tests) {
    var checks2 = [];
    var index = -1;
    while (++index < tests.length) {
      checks2[index] = convert(tests[index]);
    }
    return any;
    function any() {
      var index2 = -1;
      while (++index2 < checks2.length) {
        if (checks2[index2].apply(this, arguments)) {
          return true;
        }
      }
      return false;
    }
  }
  function typeFactory(test) {
    return type;
    function type(node) {
      return Boolean(node && node.type === test);
    }
  }
  function ok() {
    return true;
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/node_modules/mdast-util-gfm-autolink-literal/node_modules/mdast-util-find-and-replace/node_modules/unist-util-visit-parents/color.js
var require_color = __commonJS((exports, module) => {
  module.exports = color2;
  function color2(d) {
    return "\x1B[33m" + d + "\x1B[39m";
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/node_modules/mdast-util-gfm-autolink-literal/node_modules/mdast-util-find-and-replace/node_modules/unist-util-visit-parents/index.js
var require_unist_util_visit_parents = __commonJS((exports, module) => {
  module.exports = visitParents;
  var convert = require_convert();
  var color2 = require_color();
  var CONTINUE = true;
  var SKIP = "skip";
  var EXIT = false;
  visitParents.CONTINUE = CONTINUE;
  visitParents.SKIP = SKIP;
  visitParents.EXIT = EXIT;
  function visitParents(tree, test, visitor, reverse) {
    var step;
    var is;
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    is = convert(test);
    step = reverse ? -1 : 1;
    factory(tree, null, [])();
    function factory(node, index, parents) {
      var value = typeof node === "object" && node !== null ? node : {};
      var name;
      if (typeof value.type === "string") {
        name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : undefined;
        visit.displayName = "node (" + color2(value.type + (name ? "<" + name + ">" : "")) + ")";
      }
      return visit;
      function visit() {
        var grandparents = parents.concat(node);
        var result = [];
        var subresult;
        var offset;
        if (!test || is(node, index, parents[parents.length - 1] || null)) {
          result = toResult(visitor(node, parents));
          if (result[0] === EXIT) {
            return result;
          }
        }
        if (node.children && result[0] !== SKIP) {
          offset = (reverse ? node.children.length : -1) + step;
          while (offset > -1 && offset < node.children.length) {
            subresult = factory(node.children[offset], offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
        return result;
      }
    }
  }
  function toResult(value) {
    if (value !== null && typeof value === "object" && "length" in value) {
      return value;
    }
    if (typeof value === "number") {
      return [CONTINUE, value];
    }
    return [value];
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/node_modules/mdast-util-gfm-autolink-literal/node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS((exports, module) => {
  module.exports = (string2) => {
    if (typeof string2 !== "string") {
      throw new TypeError("Expected a string");
    }
    return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  };
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/node_modules/mdast-util-gfm-autolink-literal/node_modules/mdast-util-find-and-replace/index.js
var require_mdast_util_find_and_replace = __commonJS((exports, module) => {
  module.exports = findAndReplace;
  var visit = require_unist_util_visit_parents();
  var convert = require_convert();
  var escape2 = require_escape_string_regexp();
  var splice = [].splice;
  function findAndReplace(tree, find, replace, options) {
    var settings;
    var schema;
    if (typeof find === "string" || find && typeof find.exec === "function") {
      schema = [[find, replace]];
    } else {
      schema = find;
      options = replace;
    }
    settings = options || {};
    search(tree, settings, handlerFactory(toPairs(schema)));
    return tree;
    function handlerFactory(pairs) {
      var pair = pairs[0];
      return handler;
      function handler(node, parent) {
        var find2 = pair[0];
        var replace2 = pair[1];
        var nodes = [];
        var start = 0;
        var index = parent.children.indexOf(node);
        var position;
        var match;
        var subhandler;
        var value;
        find2.lastIndex = 0;
        match = find2.exec(node.value);
        while (match) {
          position = match.index;
          value = replace2.apply(null, [].concat(match, { index: match.index, input: match.input }));
          if (value !== false) {
            if (start !== position) {
              nodes.push({ type: "text", value: node.value.slice(start, position) });
            }
            if (typeof value === "string" && value.length > 0) {
              value = { type: "text", value };
            }
            if (value) {
              nodes = [].concat(nodes, value);
            }
            start = position + match[0].length;
          }
          if (!find2.global) {
            break;
          }
          match = find2.exec(node.value);
        }
        if (position === undefined) {
          nodes = [node];
          index--;
        } else {
          if (start < node.value.length) {
            nodes.push({ type: "text", value: node.value.slice(start) });
          }
          nodes.unshift(index, 1);
          splice.apply(parent.children, nodes);
        }
        if (pairs.length > 1) {
          subhandler = handlerFactory(pairs.slice(1));
          position = -1;
          while (++position < nodes.length) {
            node = nodes[position];
            if (node.type === "text") {
              subhandler(node, parent);
            } else {
              search(node, settings, subhandler);
            }
          }
        }
        return index + nodes.length + 1;
      }
    }
  }
  function search(tree, settings, handler) {
    var ignored = convert(settings.ignore || []);
    var result = [];
    visit(tree, "text", visitor);
    return result;
    function visitor(node, parents) {
      var index = -1;
      var parent;
      var grandparent;
      while (++index < parents.length) {
        parent = parents[index];
        if (ignored(parent, grandparent ? grandparent.children.indexOf(parent) : undefined, grandparent)) {
          return;
        }
        grandparent = parent;
      }
      return handler(node, grandparent);
    }
  }
  function toPairs(schema) {
    var result = [];
    var key;
    var index;
    if (typeof schema !== "object") {
      throw new Error("Expected array or object as schema");
    }
    if ("length" in schema) {
      index = -1;
      while (++index < schema.length) {
        result.push([
          toExpression(schema[index][0]),
          toFunction(schema[index][1])
        ]);
      }
    } else {
      for (key in schema) {
        result.push([toExpression(key), toFunction(schema[key])]);
      }
    }
    return result;
  }
  function toExpression(find) {
    return typeof find === "string" ? new RegExp(escape2(find), "g") : find;
  }
  function toFunction(replace) {
    return typeof replace === "function" ? replace : returner;
    function returner() {
      return replace;
    }
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/node_modules/mdast-util-gfm-autolink-literal/node_modules/micromark/dist/constant/unicode-punctuation-regex.js
var require_unicode_punctuation_regex2 = __commonJS((exports, module) => {
  var unicodePunctuation = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
  module.exports = unicodePunctuation;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/node_modules/mdast-util-gfm-autolink-literal/node_modules/micromark/dist/constant/from-char-code.js
var require_from_char_code2 = __commonJS((exports, module) => {
  var fromCharCode = String.fromCharCode;
  module.exports = fromCharCode;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/node_modules/mdast-util-gfm-autolink-literal/node_modules/micromark/dist/util/regex-check.js
var require_regex_check2 = __commonJS((exports, module) => {
  var fromCharCode = require_from_char_code2();
  function regexCheck(regex2) {
    return check;
    function check(code) {
      return regex2.test(fromCharCode(code));
    }
  }
  module.exports = regexCheck;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/node_modules/mdast-util-gfm-autolink-literal/node_modules/micromark/dist/character/unicode-punctuation.js
var require_unicode_punctuation2 = __commonJS((exports, module) => {
  var unicodePunctuationRegex = require_unicode_punctuation_regex2();
  var regexCheck = require_regex_check2();
  var unicodePunctuation = regexCheck(unicodePunctuationRegex);
  module.exports = unicodePunctuation;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/node_modules/mdast-util-gfm-autolink-literal/node_modules/micromark/dist/character/unicode-whitespace.js
var require_unicode_whitespace2 = __commonJS((exports, module) => {
  var regexCheck = require_regex_check2();
  var unicodeWhitespace = regexCheck(/\s/);
  module.exports = unicodeWhitespace;
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/node_modules/mdast-util-gfm-autolink-literal/from-markdown.js
var require_from_markdown = __commonJS((exports) => {
  var ccount = require_ccount();
  var findAndReplace = require_mdast_util_find_and_replace();
  var unicodePunctuation = require_unicode_punctuation2();
  var unicodeWhitespace = require_unicode_whitespace2();
  exports.transforms = [transformGfmAutolinkLiterals];
  exports.enter = {
    literalAutolink: enterLiteralAutolink,
    literalAutolinkEmail: enterLiteralAutolinkValue,
    literalAutolinkHttp: enterLiteralAutolinkValue,
    literalAutolinkWww: enterLiteralAutolinkValue
  };
  exports.exit = {
    literalAutolink: exitLiteralAutolink,
    literalAutolinkEmail: exitLiteralAutolinkEmail,
    literalAutolinkHttp: exitLiteralAutolinkHttp,
    literalAutolinkWww: exitLiteralAutolinkWww
  };
  function enterLiteralAutolink(token) {
    this.enter({ type: "link", title: null, url: "", children: [] }, token);
  }
  function enterLiteralAutolinkValue(token) {
    this.config.enter.autolinkProtocol.call(this, token);
  }
  function exitLiteralAutolinkHttp(token) {
    this.config.exit.autolinkProtocol.call(this, token);
  }
  function exitLiteralAutolinkWww(token) {
    this.config.exit.data.call(this, token);
    this.stack[this.stack.length - 1].url = "http://" + this.sliceSerialize(token);
  }
  function exitLiteralAutolinkEmail(token) {
    this.config.exit.autolinkEmail.call(this, token);
  }
  function exitLiteralAutolink(token) {
    this.exit(token);
  }
  function transformGfmAutolinkLiterals(tree) {
    findAndReplace(tree, [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/i, findUrl],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/, findEmail]
    ], { ignore: ["link", "linkReference"] });
  }
  function findUrl($0, protocol, domain2, path, match) {
    var prefix = "";
    var parts;
    var result;
    if (!previous(match)) {
      return false;
    }
    if (/^w/i.test(protocol)) {
      domain2 = protocol + domain2;
      protocol = "";
      prefix = "http://";
    }
    if (!isCorrectDomain(domain2)) {
      return false;
    }
    parts = splitUrl(domain2 + path);
    if (!parts[0])
      return false;
    result = {
      type: "link",
      title: null,
      url: prefix + protocol + parts[0],
      children: [{ type: "text", value: protocol + parts[0] }]
    };
    if (parts[1]) {
      result = [result, { type: "text", value: parts[1] }];
    }
    return result;
  }
  function findEmail($0, atext, label, match) {
    if (!previous(match, true) || /[_-]$/.test(label)) {
      return false;
    }
    return {
      type: "link",
      title: null,
      url: "mailto:" + atext + "@" + label,
      children: [{ type: "text", value: atext + "@" + label }]
    };
  }
  function isCorrectDomain(domain2) {
    var parts = domain2.split(".");
    if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
      return false;
    }
    return true;
  }
  function splitUrl(url) {
    var trail = /[!"&'),.:;<>?\]}]+$/.exec(url);
    var closingParenIndex;
    var openingParens;
    var closingParens;
    if (trail) {
      url = url.slice(0, trail.index);
      trail = trail[0];
      closingParenIndex = trail.indexOf(")");
      openingParens = ccount(url, "(");
      closingParens = ccount(url, ")");
      while (closingParenIndex !== -1 && openingParens > closingParens) {
        url += trail.slice(0, closingParenIndex + 1);
        trail = trail.slice(closingParenIndex + 1);
        closingParenIndex = trail.indexOf(")");
        closingParens++;
      }
    }
    return [url, trail];
  }
  function previous(match, email2) {
    var code = match.input.charCodeAt(match.index - 1);
    return (code !== code || unicodeWhitespace(code) || unicodePunctuation(code)) && (!email2 || code !== 47);
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/node_modules/mdast-util-gfm-strikethrough/from-markdown.js
var require_from_markdown2 = __commonJS((exports) => {
  exports.canContainEols = ["delete"];
  exports.enter = { strikethrough: enterStrikethrough };
  exports.exit = { strikethrough: exitStrikethrough };
  function enterStrikethrough(token) {
    this.enter({ type: "delete", children: [] }, token);
  }
  function exitStrikethrough(token) {
    this.exit(token);
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-gfm-table/from-markdown.js
var require_from_markdown3 = __commonJS((exports) => {
  exports.enter = {
    table: enterTable,
    tableData: enterCell,
    tableHeader: enterCell,
    tableRow: enterRow
  };
  exports.exit = {
    codeText: exitCodeText,
    table: exitTable,
    tableData: exit,
    tableHeader: exit,
    tableRow: exit
  };
  function enterTable(token) {
    this.enter({ type: "table", align: token._align, children: [] }, token);
    this.setData("inTable", true);
  }
  function exitTable(token) {
    this.exit(token);
    this.setData("inTable");
  }
  function enterRow(token) {
    this.enter({ type: "tableRow", children: [] }, token);
  }
  function exit(token) {
    this.exit(token);
  }
  function enterCell(token) {
    this.enter({ type: "tableCell", children: [] }, token);
  }
  function exitCodeText(token) {
    var value = this.resume();
    if (this.getData("inTable")) {
      value = value.replace(/\\([\\|])/g, replace);
    }
    this.stack[this.stack.length - 1].value = value;
    this.exit(token);
  }
  function replace($0, $1) {
    return $1 === "|" ? $1 : $0;
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/node_modules/mdast-util-gfm-task-list-item/from-markdown.js
var require_from_markdown4 = __commonJS((exports) => {
  exports.exit = {
    taskListCheckValueChecked: exitCheck,
    taskListCheckValueUnchecked: exitCheck,
    paragraph: exitParagraphWithTaskListItem
  };
  function exitCheck(token) {
    this.stack[this.stack.length - 2].checked = token.type === "taskListCheckValueChecked";
  }
  function exitParagraphWithTaskListItem(token) {
    var parent = this.stack[this.stack.length - 2];
    var node = this.stack[this.stack.length - 1];
    var siblings = parent.children;
    var head = node.children[0];
    var index = -1;
    var firstParaghraph;
    if (parent && parent.type === "listItem" && typeof parent.checked === "boolean" && head && head.type === "text") {
      while (++index < siblings.length) {
        if (siblings[index].type === "paragraph") {
          firstParaghraph = siblings[index];
          break;
        }
      }
      if (firstParaghraph === node) {
        head.value = head.value.slice(1);
        if (head.value.length === 0) {
          node.children.shift();
        } else {
          head.position.start.column++;
          head.position.start.offset++;
          node.position.start = Object.assign({}, head.position.start);
        }
      }
    }
    this.exit(token);
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/from-markdown.js
var require_from_markdown5 = __commonJS((exports, module) => {
  var autolinkLiteral = require_from_markdown();
  var strikethrough = require_from_markdown2();
  var table = require_from_markdown3();
  var taskListItem = require_from_markdown4();
  var own = {}.hasOwnProperty;
  module.exports = configure([
    autolinkLiteral,
    strikethrough,
    table,
    taskListItem
  ]);
  function configure(extensions) {
    var config2 = { transforms: [], canContainEols: [] };
    var length = extensions.length;
    var index = -1;
    while (++index < length) {
      extension(config2, extensions[index]);
    }
    return config2;
  }
  function extension(config2, extension2) {
    var key;
    var left;
    var right;
    for (key in extension2) {
      left = own.call(config2, key) ? config2[key] : config2[key] = {};
      right = extension2[key];
      if (key === "canContainEols" || key === "transforms") {
        config2[key] = [].concat(left, right);
      } else {
        Object.assign(left, right);
      }
    }
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/node_modules/mdast-util-gfm-autolink-literal/to-markdown.js
var require_to_markdown = __commonJS((exports) => {
  var inConstruct = "phrasing";
  var notInConstruct = ["autolink", "link", "image", "label"];
  exports.unsafe = [
    {
      character: "@",
      before: "[+\\-.\\w]",
      after: "[\\-.\\w]",
      inConstruct,
      notInConstruct
    },
    {
      character: ".",
      before: "[Ww]",
      after: "[\\-.\\w]",
      inConstruct,
      notInConstruct
    },
    {
      character: ":",
      before: "[ps]",
      after: "\\/",
      inConstruct,
      notInConstruct
    }
  ];
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
var require_container_phrasing = __commonJS((exports, module) => {
  module.exports = phrasing;
  function phrasing(parent, context, safeOptions) {
    var children = parent.children || [];
    var results = [];
    var index = -1;
    var before = safeOptions.before;
    var after;
    var handle;
    var child;
    while (++index < children.length) {
      child = children[index];
      if (index + 1 < children.length) {
        handle = context.handle.handlers[children[index + 1].type];
        if (handle && handle.peek)
          handle = handle.peek;
        after = handle ? handle(children[index + 1], parent, context, {
          before: "",
          after: ""
        }).charAt(0) : "";
      } else {
        after = safeOptions.after;
      }
      if (results.length > 0 && (before === "\r" || before === `
`) && child.type === "html") {
        results[results.length - 1] = results[results.length - 1].replace(/(\r?\n|\r)$/, " ");
        before = " ";
      }
      results.push(context.handle(child, parent, context, {
        before,
        after
      }));
      before = results[results.length - 1].slice(-1);
    }
    return results.join("");
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/node_modules/mdast-util-gfm-strikethrough/to-markdown.js
var require_to_markdown2 = __commonJS((exports) => {
  var phrasing = require_container_phrasing();
  exports.unsafe = [{ character: "~", inConstruct: "phrasing" }];
  exports.handlers = { delete: handleDelete };
  handleDelete.peek = peekDelete;
  function handleDelete(node, _, context) {
    var exit = context.enter("emphasis");
    var value = phrasing(node, context, { before: "~", after: "~" });
    exit();
    return "~~" + value + "~~";
  }
  function peekDelete() {
    return "~";
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js
var require_pattern_compile = __commonJS((exports, module) => {
  module.exports = patternCompile;
  function patternCompile(pattern) {
    var before;
    var after;
    if (!pattern._compiled) {
      before = pattern.before ? "(?:" + pattern.before + ")" : "";
      after = pattern.after ? "(?:" + pattern.after + ")" : "";
      if (pattern.atBreak) {
        before = "[\\r\\n][\\t ]*" + before;
      }
      pattern._compiled = new RegExp((before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (after || ""), "g");
    }
    return pattern._compiled;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
var require_inline_code = __commonJS((exports, module) => {
  module.exports = inlineCode;
  inlineCode.peek = inlineCodePeek;
  var patternCompile = require_pattern_compile();
  function inlineCode(node, parent, context) {
    var value = node.value || "";
    var sequence = "`";
    var index = -1;
    var pattern;
    var expression;
    var match;
    var position;
    while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
      sequence += "`";
    }
    if (/[^ \r\n]/.test(value) && (/[ \r\n`]/.test(value.charAt(0)) || /[ \r\n`]/.test(value.charAt(value.length - 1)))) {
      value = " " + value + " ";
    }
    while (++index < context.unsafe.length) {
      pattern = context.unsafe[index];
      if (!pattern.atBreak)
        continue;
      expression = patternCompile(pattern);
      while (match = expression.exec(value)) {
        position = match.index;
        if (value.charCodeAt(position) === 10 && value.charCodeAt(position - 1) === 13) {
          position--;
        }
        value = value.slice(0, position) + " " + value.slice(match.index + 1);
      }
    }
    return sequence + value + sequence;
  }
  function inlineCodePeek() {
    return "`";
  }
});

// node_modules/repeat-string/index.js
var require_repeat_string = __commonJS((exports, module) => {
  /*!
   * repeat-string <https://github.com/jonschlinkert/repeat-string>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  var res = "";
  var cache2;
  module.exports = repeat;
  function repeat(str, num) {
    if (typeof str !== "string") {
      throw new TypeError("expected a string");
    }
    if (num === 1)
      return str;
    if (num === 2)
      return str + str;
    var max = str.length * num;
    if (cache2 !== str || typeof cache2 === "undefined") {
      cache2 = str;
      res = "";
    } else if (res.length >= max) {
      return res.substr(0, max);
    }
    while (max > res.length && num > 1) {
      if (num & 1) {
        res += str;
      }
      num >>= 1;
      str += str;
    }
    res += str;
    res = res.substr(0, max);
    return res;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-gfm-table/node_modules/markdown-table/index.js
var require_markdown_table = __commonJS((exports, module) => {
  var repeat = require_repeat_string();
  module.exports = markdownTable;
  var trailingWhitespace = / +$/;
  var space = " ";
  var lineFeed = `
`;
  var dash = "-";
  var colon = ":";
  var verticalBar = "|";
  var x = 0;
  var C = 67;
  var L = 76;
  var R = 82;
  var c = 99;
  var l = 108;
  var r = 114;
  function markdownTable(table, options) {
    var settings = options || {};
    var padding = settings.padding !== false;
    var start = settings.delimiterStart !== false;
    var end = settings.delimiterEnd !== false;
    var align = (settings.align || []).concat();
    var alignDelimiters = settings.alignDelimiters !== false;
    var alignments = [];
    var stringLength = settings.stringLength || defaultStringLength;
    var rowIndex = -1;
    var rowLength = table.length;
    var cellMatrix = [];
    var sizeMatrix = [];
    var row = [];
    var sizes = [];
    var longestCellByColumn = [];
    var mostCellsPerRow = 0;
    var cells;
    var columnIndex;
    var columnLength;
    var largest;
    var size;
    var cell;
    var lines;
    var line;
    var before;
    var after;
    var code;
    while (++rowIndex < rowLength) {
      cells = table[rowIndex];
      columnIndex = -1;
      columnLength = cells.length;
      row = [];
      sizes = [];
      if (columnLength > mostCellsPerRow) {
        mostCellsPerRow = columnLength;
      }
      while (++columnIndex < columnLength) {
        cell = serialize2(cells[columnIndex]);
        if (alignDelimiters === true) {
          size = stringLength(cell);
          sizes[columnIndex] = size;
          largest = longestCellByColumn[columnIndex];
          if (largest === undefined || size > largest) {
            longestCellByColumn[columnIndex] = size;
          }
        }
        row.push(cell);
      }
      cellMatrix[rowIndex] = row;
      sizeMatrix[rowIndex] = sizes;
    }
    columnIndex = -1;
    columnLength = mostCellsPerRow;
    if (typeof align === "object" && "length" in align) {
      while (++columnIndex < columnLength) {
        alignments[columnIndex] = toAlignment(align[columnIndex]);
      }
    } else {
      code = toAlignment(align);
      while (++columnIndex < columnLength) {
        alignments[columnIndex] = code;
      }
    }
    columnIndex = -1;
    columnLength = mostCellsPerRow;
    row = [];
    sizes = [];
    while (++columnIndex < columnLength) {
      code = alignments[columnIndex];
      before = "";
      after = "";
      if (code === l) {
        before = colon;
      } else if (code === r) {
        after = colon;
      } else if (code === c) {
        before = colon;
        after = colon;
      }
      size = alignDelimiters ? Math.max(1, longestCellByColumn[columnIndex] - before.length - after.length) : 1;
      cell = before + repeat(dash, size) + after;
      if (alignDelimiters === true) {
        size = before.length + size + after.length;
        if (size > longestCellByColumn[columnIndex]) {
          longestCellByColumn[columnIndex] = size;
        }
        sizes[columnIndex] = size;
      }
      row[columnIndex] = cell;
    }
    cellMatrix.splice(1, 0, row);
    sizeMatrix.splice(1, 0, sizes);
    rowIndex = -1;
    rowLength = cellMatrix.length;
    lines = [];
    while (++rowIndex < rowLength) {
      row = cellMatrix[rowIndex];
      sizes = sizeMatrix[rowIndex];
      columnIndex = -1;
      columnLength = mostCellsPerRow;
      line = [];
      while (++columnIndex < columnLength) {
        cell = row[columnIndex] || "";
        before = "";
        after = "";
        if (alignDelimiters === true) {
          size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0);
          code = alignments[columnIndex];
          if (code === r) {
            before = repeat(space, size);
          } else if (code === c) {
            if (size % 2 === 0) {
              before = repeat(space, size / 2);
              after = before;
            } else {
              before = repeat(space, size / 2 + 0.5);
              after = repeat(space, size / 2 - 0.5);
            }
          } else {
            after = repeat(space, size);
          }
        }
        if (start === true && columnIndex === 0) {
          line.push(verticalBar);
        }
        if (padding === true && !(alignDelimiters === false && cell === "") && (start === true || columnIndex !== 0)) {
          line.push(space);
        }
        if (alignDelimiters === true) {
          line.push(before);
        }
        line.push(cell);
        if (alignDelimiters === true) {
          line.push(after);
        }
        if (padding === true) {
          line.push(space);
        }
        if (end === true || columnIndex !== columnLength - 1) {
          line.push(verticalBar);
        }
      }
      line = line.join("");
      if (end === false) {
        line = line.replace(trailingWhitespace, "");
      }
      lines.push(line);
    }
    return lines.join(lineFeed);
  }
  function serialize2(value) {
    return value === null || value === undefined ? "" : String(value);
  }
  function defaultStringLength(value) {
    return value.length;
  }
  function toAlignment(value) {
    var code = typeof value === "string" ? value.charCodeAt(0) : x;
    return code === L || code === l ? l : code === R || code === r ? r : code === C || code === c ? c : x;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-gfm-table/to-markdown.js
var require_to_markdown3 = __commonJS((exports, module) => {
  var phrasing = require_container_phrasing();
  var defaultInlineCode = require_inline_code();
  var markdownTable = require_markdown_table();
  module.exports = toMarkdown;
  function toMarkdown(options) {
    var settings = options || {};
    var padding = settings.tableCellPadding;
    var alignDelimiters = settings.tablePipeAlign;
    var stringLength = settings.stringLength;
    var around = padding ? " " : "|";
    return {
      unsafe: [
        { character: "\r", inConstruct: "tableCell" },
        { character: `
`, inConstruct: "tableCell" },
        { atBreak: true, character: "|", after: "[	 :-]" },
        { character: "|", inConstruct: "tableCell" },
        { atBreak: true, character: ":", after: "-" },
        { atBreak: true, character: "-", after: "[:|-]" }
      ],
      handlers: {
        table: handleTable,
        tableRow: handleTableRow,
        tableCell: handleTableCell,
        inlineCode: inlineCodeWithTable
      }
    };
    function handleTable(node, _, context) {
      return serializeData(handleTableAsData(node, context), node.align);
    }
    function handleTableRow(node, _, context) {
      var row = handleTableRowAsData(node, context);
      var value = serializeData([row]);
      return value.slice(0, value.indexOf(`
`));
    }
    function handleTableCell(node, _, context) {
      var exit = context.enter("tableCell");
      var value = phrasing(node, context, { before: around, after: around });
      exit();
      return value;
    }
    function serializeData(matrix, align) {
      return markdownTable(matrix, {
        align,
        alignDelimiters,
        padding,
        stringLength
      });
    }
    function handleTableAsData(node, context) {
      var children = node.children;
      var index = -1;
      var length = children.length;
      var result = [];
      var subexit = context.enter("table");
      while (++index < length) {
        result[index] = handleTableRowAsData(children[index], context);
      }
      subexit();
      return result;
    }
    function handleTableRowAsData(node, context) {
      var children = node.children;
      var index = -1;
      var length = children.length;
      var result = [];
      var subexit = context.enter("tableRow");
      while (++index < length) {
        result[index] = handleTableCell(children[index], node, context);
      }
      subexit();
      return result;
    }
    function inlineCodeWithTable(node, parent, context) {
      var value = defaultInlineCode(node, parent, context);
      if (context.stack.indexOf("tableCell") !== -1) {
        value = value.replace(/\|/g, "\\$&");
      }
      return value;
    }
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
var require_check_bullet = __commonJS((exports, module) => {
  module.exports = checkBullet;
  function checkBullet(context) {
    var marker = context.options.bullet || "*";
    if (marker !== "*" && marker !== "+" && marker !== "-") {
      throw new Error("Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`");
    }
    return marker;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
var require_check_list_item_indent = __commonJS((exports, module) => {
  module.exports = checkListItemIndent;
  function checkListItemIndent(context) {
    var style = context.options.listItemIndent || "tab";
    if (style === 1 || style === "1") {
      return "one";
    }
    if (style !== "tab" && style !== "one" && style !== "mixed") {
      throw new Error("Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`");
    }
    return style;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/container-flow.js
var require_container_flow = __commonJS((exports, module) => {
  module.exports = flow;
  var repeat = require_repeat_string();
  function flow(parent, context) {
    var children = parent.children || [];
    var results = [];
    var index = -1;
    var child;
    while (++index < children.length) {
      child = children[index];
      results.push(context.handle(child, parent, context, { before: `
`, after: `
` }));
      if (index + 1 < children.length) {
        results.push(between(child, children[index + 1]));
      }
    }
    return results.join("");
    function between(left, right) {
      var index2 = -1;
      var result;
      while (++index2 < context.join.length) {
        result = context.join[index2](left, right, parent, context);
        if (result === true || result === 1) {
          break;
        }
        if (typeof result === "number") {
          return repeat(`
`, 1 + Number(result));
        }
        if (result === false) {
          return `

<!---->

`;
        }
      }
      return `

`;
    }
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/indent-lines.js
var require_indent_lines = __commonJS((exports, module) => {
  module.exports = indentLines;
  var eol = /\r?\n|\r/g;
  function indentLines(value, map) {
    var result = [];
    var start = 0;
    var line = 0;
    var match;
    while (match = eol.exec(value)) {
      one(value.slice(start, match.index));
      result.push(match[0]);
      start = match.index + match[0].length;
      line++;
    }
    one(value.slice(start));
    return result.join("");
    function one(value2) {
      result.push(map(value2, line, !value2));
    }
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/list-item.js
var require_list_item = __commonJS((exports, module) => {
  module.exports = listItem;
  var repeat = require_repeat_string();
  var checkBullet = require_check_bullet();
  var checkListItemIndent = require_check_list_item_indent();
  var flow = require_container_flow();
  var indentLines = require_indent_lines();
  function listItem(node, parent, context) {
    var bullet = checkBullet(context);
    var listItemIndent = checkListItemIndent(context);
    var size;
    var value;
    var exit;
    if (parent && parent.ordered) {
      bullet = (parent.start > -1 ? parent.start : 1) + (context.options.incrementListMarker === false ? 0 : parent.children.indexOf(node)) + ".";
    }
    size = bullet.length + 1;
    if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.spread || node.spread)) {
      size = Math.ceil(size / 4) * 4;
    }
    exit = context.enter("listItem");
    value = indentLines(flow(node, context), map);
    exit();
    return value;
    function map(line, index, blank) {
      if (index) {
        return (blank ? "" : repeat(" ", size)) + line;
      }
      return (blank ? bullet : bullet + repeat(" ", size - bullet.length)) + line;
    }
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/node_modules/mdast-util-gfm-task-list-item/to-markdown.js
var require_to_markdown4 = __commonJS((exports) => {
  var defaultListItem = require_list_item();
  exports.unsafe = [{ atBreak: true, character: "-", after: "[:|-]" }];
  exports.handlers = {
    listItem: listItemWithTaskListItem
  };
  function listItemWithTaskListItem(node, parent, context) {
    var value = defaultListItem(node, parent, context);
    var head = node.children[0];
    if (typeof node.checked === "boolean" && head && head.type === "paragraph") {
      value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
    }
    return value;
    function check($0) {
      return $0 + "[" + (node.checked ? "x" : " ") + "] ";
    }
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/configure.js
var require_configure = __commonJS((exports, module) => {
  module.exports = configure;
  function configure(base, extension) {
    var index = -1;
    var key;
    if (extension.extensions) {
      while (++index < extension.extensions.length) {
        configure(base, extension.extensions[index]);
      }
    }
    for (key in extension) {
      if (key === "extensions") {} else if (key === "unsafe" || key === "join") {
        base[key] = base[key].concat(extension[key] || []);
      } else if (key === "handlers") {
        base[key] = Object.assign(base[key], extension[key] || {});
      } else {
        base.options[key] = extension[key];
      }
    }
    return base;
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/node_modules/mdast-util-gfm/to-markdown.js
var require_to_markdown5 = __commonJS((exports, module) => {
  var autolinkLiteral = require_to_markdown();
  var strikethrough = require_to_markdown2();
  var table = require_to_markdown3();
  var taskListItem = require_to_markdown4();
  var configure = require_configure();
  module.exports = toMarkdown;
  function toMarkdown(options) {
    var config2 = configure({ handlers: {}, join: [], unsafe: [], options: {} }, {
      extensions: [autolinkLiteral, strikethrough, table(options), taskListItem]
    });
    return Object.assign(config2.options, {
      handlers: config2.handlers,
      join: config2.join,
      unsafe: config2.unsafe
    });
  }
});

// node_modules/telegramify-markdown/node_modules/remark-gfm/index.js
var require_remark_gfm = __commonJS((exports, module) => {
  var syntax = require_syntax4();
  var fromMarkdown = require_from_markdown5();
  var toMarkdown = require_to_markdown5();
  var warningIssued;
  module.exports = gfm;
  function gfm(options) {
    var data = this.data();
    if (!warningIssued && (this.Parser && this.Parser.prototype && this.Parser.prototype.blockTokenizers || this.Compiler && this.Compiler.prototype && this.Compiler.prototype.visitors)) {
      warningIssued = true;
      console.warn("[remark-gfm] Warning: please upgrade to remark 13 to use this plugin");
    }
    add("micromarkExtensions", syntax(options));
    add("fromMarkdownExtensions", fromMarkdown);
    add("toMarkdownExtensions", toMarkdown(options));
    function add(field, value) {
      if (data[field])
        data[field].push(value);
      else
        data[field] = [value];
    }
  }
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/mdast-util-to-string/index.js
var require_mdast_util_to_string = __commonJS((exports, module) => {
  module.exports = toString;
  function toString(node) {
    return node && (node.value || node.alt || node.title || ("children" in node) && all(node.children) || ("length" in node) && all(node)) || "";
  }
  function all(values) {
    var result = [];
    var index = -1;
    while (++index < values.length) {
      result[index] = toString(values[index]);
    }
    return result.join("");
  }
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/constant/assign.js
var require_assign2 = __commonJS((exports, module) => {
  var assign = Object.assign;
  module.exports = assign;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/constant/has-own-property.js
var require_has_own_property2 = __commonJS((exports, module) => {
  var own = {}.hasOwnProperty;
  module.exports = own;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/util/normalize-identifier.js
var require_normalize_identifier = __commonJS((exports, module) => {
  function normalizeIdentifier(value) {
    return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
  }
  module.exports = normalizeIdentifier;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/constant/from-char-code.js
var require_from_char_code3 = __commonJS((exports, module) => {
  var fromCharCode = String.fromCharCode;
  module.exports = fromCharCode;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/util/safe-from-int.js
var require_safe_from_int = __commonJS((exports, module) => {
  var fromCharCode = require_from_char_code3();
  function safeFromInt(value, base) {
    var code = parseInt(value, base);
    if (code < 9 || code === 11 || code > 13 && code < 32 || code > 126 && code < 160 || code > 55295 && code < 57344 || code > 64975 && code < 65008 || (code & 65535) === 65535 || (code & 65535) === 65534 || code > 1114111) {
      return "\uFFFD";
    }
    return fromCharCode(code);
  }
  module.exports = safeFromInt;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/character/markdown-line-ending.js
var require_markdown_line_ending2 = __commonJS((exports, module) => {
  function markdownLineEnding(code) {
    return code < -2;
  }
  module.exports = markdownLineEnding;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/character/markdown-space.js
var require_markdown_space2 = __commonJS((exports, module) => {
  function markdownSpace(code) {
    return code === -2 || code === -1 || code === 32;
  }
  module.exports = markdownSpace;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/factory-space.js
var require_factory_space2 = __commonJS((exports, module) => {
  var markdownSpace = require_markdown_space2();
  function spaceFactory(effects, ok, type, max) {
    var limit = max ? max - 1 : Infinity;
    var size = 0;
    return start;
    function start(code) {
      if (markdownSpace(code)) {
        effects.enter(type);
        return prefix(code);
      }
      return ok(code);
    }
    function prefix(code) {
      if (markdownSpace(code) && size++ < limit) {
        effects.consume(code);
        return prefix;
      }
      effects.exit(type);
      return ok(code);
    }
  }
  module.exports = spaceFactory;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/initialize/content.js
var require_content = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var markdownLineEnding = require_markdown_line_ending2();
  var factorySpace = require_factory_space2();
  var tokenize = initializeContent;
  function initializeContent(effects) {
    var contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
    var previous;
    return contentStart;
    function afterContentStartConstruct(code) {
      if (code === null) {
        effects.consume(code);
        return;
      }
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return factorySpace(effects, contentStart, "linePrefix");
    }
    function paragraphInitial(code) {
      effects.enter("paragraph");
      return lineStart(code);
    }
    function lineStart(code) {
      var token = effects.enter("chunkText", {
        contentType: "text",
        previous
      });
      if (previous) {
        previous.next = token;
      }
      previous = token;
      return data(code);
    }
    function data(code) {
      if (code === null) {
        effects.exit("chunkText");
        effects.exit("paragraph");
        effects.consume(code);
        return;
      }
      if (markdownLineEnding(code)) {
        effects.consume(code);
        effects.exit("chunkText");
        return lineStart;
      }
      effects.consume(code);
      return data;
    }
  }
  exports.tokenize = tokenize;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/partial-blank-line.js
var require_partial_blank_line = __commonJS((exports, module) => {
  var markdownLineEnding = require_markdown_line_ending2();
  var factorySpace = require_factory_space2();
  var partialBlankLine = {
    tokenize: tokenizePartialBlankLine,
    partial: true
  };
  function tokenizePartialBlankLine(effects, ok, nok) {
    return factorySpace(effects, afterWhitespace, "linePrefix");
    function afterWhitespace(code) {
      return code === null || markdownLineEnding(code) ? ok(code) : nok(code);
    }
  }
  module.exports = partialBlankLine;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/initialize/document.js
var require_document = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var markdownLineEnding = require_markdown_line_ending2();
  var factorySpace = require_factory_space2();
  var partialBlankLine = require_partial_blank_line();
  var tokenize = initializeDocument;
  var containerConstruct = {
    tokenize: tokenizeContainer
  };
  var lazyFlowConstruct = {
    tokenize: tokenizeLazyFlow
  };
  function initializeDocument(effects) {
    var self2 = this;
    var stack = [];
    var continued = 0;
    var inspectConstruct = {
      tokenize: tokenizeInspect,
      partial: true
    };
    var inspectResult;
    var childFlow;
    var childToken;
    return start;
    function start(code) {
      if (continued < stack.length) {
        self2.containerState = stack[continued][1];
        return effects.attempt(stack[continued][0].continuation, documentContinue, documentContinued)(code);
      }
      return documentContinued(code);
    }
    function documentContinue(code) {
      continued++;
      return start(code);
    }
    function documentContinued(code) {
      if (inspectResult && inspectResult.flowContinue) {
        return flowStart(code);
      }
      self2.interrupt = childFlow && childFlow.currentConstruct && childFlow.currentConstruct.interruptible;
      self2.containerState = {};
      return effects.attempt(containerConstruct, containerContinue, flowStart)(code);
    }
    function containerContinue(code) {
      stack.push([self2.currentConstruct, self2.containerState]);
      self2.containerState = undefined;
      return documentContinued(code);
    }
    function flowStart(code) {
      if (code === null) {
        exitContainers(0, true);
        effects.consume(code);
        return;
      }
      childFlow = childFlow || self2.parser.flow(self2.now());
      effects.enter("chunkFlow", {
        contentType: "flow",
        previous: childToken,
        _tokenizer: childFlow
      });
      return flowContinue(code);
    }
    function flowContinue(code) {
      if (code === null) {
        continueFlow(effects.exit("chunkFlow"));
        return flowStart(code);
      }
      if (markdownLineEnding(code)) {
        effects.consume(code);
        continueFlow(effects.exit("chunkFlow"));
        return effects.check(inspectConstruct, documentAfterPeek);
      }
      effects.consume(code);
      return flowContinue;
    }
    function documentAfterPeek(code) {
      exitContainers(inspectResult.continued, inspectResult && inspectResult.flowEnd);
      continued = 0;
      return start(code);
    }
    function continueFlow(token) {
      if (childToken)
        childToken.next = token;
      childToken = token;
      childFlow.lazy = inspectResult && inspectResult.lazy;
      childFlow.defineSkip(token.start);
      childFlow.write(self2.sliceStream(token));
    }
    function exitContainers(size, end) {
      var index = stack.length;
      if (childFlow && end) {
        childFlow.write([null]);
        childToken = childFlow = undefined;
      }
      while (index-- > size) {
        self2.containerState = stack[index][1];
        stack[index][0].exit.call(self2, effects);
      }
      stack.length = size;
    }
    function tokenizeInspect(effects2, ok) {
      var subcontinued = 0;
      inspectResult = {};
      return inspectStart;
      function inspectStart(code) {
        if (subcontinued < stack.length) {
          self2.containerState = stack[subcontinued][1];
          return effects2.attempt(stack[subcontinued][0].continuation, inspectContinue, inspectLess)(code);
        }
        if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
          inspectResult.flowContinue = true;
          return inspectDone(code);
        }
        self2.interrupt = childFlow.currentConstruct && childFlow.currentConstruct.interruptible;
        self2.containerState = {};
        return effects2.attempt(containerConstruct, inspectFlowEnd, inspectDone)(code);
      }
      function inspectContinue(code) {
        subcontinued++;
        return self2.containerState._closeFlow ? inspectFlowEnd(code) : inspectStart(code);
      }
      function inspectLess(code) {
        if (childFlow.currentConstruct && childFlow.currentConstruct.lazy) {
          self2.containerState = {};
          return effects2.attempt(containerConstruct, inspectFlowEnd, effects2.attempt(lazyFlowConstruct, inspectFlowEnd, effects2.check(partialBlankLine, inspectFlowEnd, inspectLazy)))(code);
        }
        return inspectFlowEnd(code);
      }
      function inspectLazy(code) {
        subcontinued = stack.length;
        inspectResult.lazy = true;
        inspectResult.flowContinue = true;
        return inspectDone(code);
      }
      function inspectFlowEnd(code) {
        inspectResult.flowEnd = true;
        return inspectDone(code);
      }
      function inspectDone(code) {
        inspectResult.continued = subcontinued;
        self2.interrupt = self2.containerState = undefined;
        return ok(code);
      }
    }
  }
  function tokenizeContainer(effects, ok, nok) {
    return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok, nok), "linePrefix", this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? undefined : 4);
  }
  function tokenizeLazyFlow(effects, ok, nok) {
    return factorySpace(effects, effects.lazy(this.parser.constructs.flow, ok, nok), "linePrefix", this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? undefined : 4);
  }
  exports.tokenize = tokenize;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/util/size-chunks.js
var require_size_chunks2 = __commonJS((exports, module) => {
  function sizeChunks(chunks) {
    var index = -1;
    var size = 0;
    while (++index < chunks.length) {
      size += typeof chunks[index] === "string" ? chunks[index].length : 1;
    }
    return size;
  }
  module.exports = sizeChunks;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/util/prefix-size.js
var require_prefix_size2 = __commonJS((exports, module) => {
  var sizeChunks = require_size_chunks2();
  function prefixSize(events, type) {
    var tail = events[events.length - 1];
    if (!tail || tail[1].type !== type)
      return 0;
    return sizeChunks(tail[2].sliceStream(tail[1]));
  }
  module.exports = prefixSize;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/constant/splice.js
var require_splice2 = __commonJS((exports, module) => {
  var splice = [].splice;
  module.exports = splice;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/util/chunked-splice.js
var require_chunked_splice2 = __commonJS((exports, module) => {
  var splice = require_splice2();
  function chunkedSplice(list, start, remove, items) {
    var end = list.length;
    var chunkStart = 0;
    var parameters;
    if (start < 0) {
      start = -start > end ? 0 : end + start;
    } else {
      start = start > end ? end : start;
    }
    remove = remove > 0 ? remove : 0;
    if (items.length < 1e4) {
      parameters = Array.from(items);
      parameters.unshift(start, remove);
      splice.apply(list, parameters);
    } else {
      if (remove)
        splice.apply(list, [start, remove]);
      while (chunkStart < items.length) {
        parameters = items.slice(chunkStart, chunkStart + 1e4);
        parameters.unshift(start, 0);
        splice.apply(list, parameters);
        chunkStart += 1e4;
        start += 1e4;
      }
    }
  }
  module.exports = chunkedSplice;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/util/shallow.js
var require_shallow2 = __commonJS((exports, module) => {
  var assign = require_assign2();
  function shallow(object) {
    return assign({}, object);
  }
  module.exports = shallow;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/util/subtokenize.js
var require_subtokenize = __commonJS((exports, module) => {
  var assign = require_assign2();
  var chunkedSplice = require_chunked_splice2();
  var shallow = require_shallow2();
  function subtokenize(events) {
    var jumps = {};
    var index = -1;
    var event;
    var lineIndex;
    var otherIndex;
    var otherEvent;
    var parameters;
    var subevents;
    var more;
    while (++index < events.length) {
      while (index in jumps) {
        index = jumps[index];
      }
      event = events[index];
      if (index && event[1].type === "chunkFlow" && events[index - 1][1].type === "listItemPrefix") {
        subevents = event[1]._tokenizer.events;
        otherIndex = 0;
        if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
          otherIndex += 2;
        }
        if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
          while (++otherIndex < subevents.length) {
            if (subevents[otherIndex][1].type === "content") {
              break;
            }
            if (subevents[otherIndex][1].type === "chunkText") {
              subevents[otherIndex][1].isInFirstContentOfListItem = true;
              otherIndex++;
            }
          }
        }
      }
      if (event[0] === "enter") {
        if (event[1].contentType) {
          assign(jumps, subcontent(events, index));
          index = jumps[index];
          more = true;
        }
      } else if (event[1]._container || event[1]._movePreviousLineEndings) {
        otherIndex = index;
        lineIndex = undefined;
        while (otherIndex--) {
          otherEvent = events[otherIndex];
          if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
            if (otherEvent[0] === "enter") {
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
              }
              otherEvent[1].type = "lineEnding";
              lineIndex = otherIndex;
            }
          } else {
            break;
          }
        }
        if (lineIndex) {
          event[1].end = shallow(events[lineIndex][1].start);
          parameters = events.slice(lineIndex, index);
          parameters.unshift(event);
          chunkedSplice(events, lineIndex, index - lineIndex + 1, parameters);
        }
      }
    }
    return !more;
  }
  function subcontent(events, eventIndex) {
    var token = events[eventIndex][1];
    var context = events[eventIndex][2];
    var startPosition = eventIndex - 1;
    var startPositions = [];
    var tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
    var childEvents = tokenizer.events;
    var jumps = [];
    var gaps = {};
    var stream;
    var previous;
    var index;
    var entered;
    var end;
    var adjust;
    while (token) {
      while (events[++startPosition][1] !== token) {}
      startPositions.push(startPosition);
      if (!token._tokenizer) {
        stream = context.sliceStream(token);
        if (!token.next) {
          stream.push(null);
        }
        if (previous) {
          tokenizer.defineSkip(token.start);
        }
        if (token.isInFirstContentOfListItem) {
          tokenizer._gfmTasklistFirstContentOfListItem = true;
        }
        tokenizer.write(stream);
        if (token.isInFirstContentOfListItem) {
          tokenizer._gfmTasklistFirstContentOfListItem = undefined;
        }
      }
      previous = token;
      token = token.next;
    }
    token = previous;
    index = childEvents.length;
    while (index--) {
      if (childEvents[index][0] === "enter") {
        entered = true;
      } else if (entered && childEvents[index][1].type === childEvents[index - 1][1].type && childEvents[index][1].start.line !== childEvents[index][1].end.line) {
        add(childEvents.slice(index + 1, end));
        token._tokenizer = token.next = undefined;
        token = token.previous;
        end = index + 1;
      }
    }
    tokenizer.events = token._tokenizer = token.next = undefined;
    add(childEvents.slice(0, end));
    index = -1;
    adjust = 0;
    while (++index < jumps.length) {
      gaps[adjust + jumps[index][0]] = adjust + jumps[index][1];
      adjust += jumps[index][1] - jumps[index][0] - 1;
    }
    return gaps;
    function add(slice) {
      var start = startPositions.pop();
      jumps.unshift([start, start + slice.length - 1]);
      chunkedSplice(events, start, 2, slice);
    }
  }
  module.exports = subtokenize;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/content.js
var require_content2 = __commonJS((exports, module) => {
  var markdownLineEnding = require_markdown_line_ending2();
  var prefixSize = require_prefix_size2();
  var subtokenize = require_subtokenize();
  var factorySpace = require_factory_space2();
  var content = {
    tokenize: tokenizeContent,
    resolve: resolveContent,
    interruptible: true,
    lazy: true
  };
  var continuationConstruct = {
    tokenize: tokenizeContinuation,
    partial: true
  };
  function resolveContent(events) {
    subtokenize(events);
    return events;
  }
  function tokenizeContent(effects, ok) {
    var previous;
    return start;
    function start(code) {
      effects.enter("content");
      previous = effects.enter("chunkContent", {
        contentType: "content"
      });
      return data(code);
    }
    function data(code) {
      if (code === null) {
        return contentEnd(code);
      }
      if (markdownLineEnding(code)) {
        return effects.check(continuationConstruct, contentContinue, contentEnd)(code);
      }
      effects.consume(code);
      return data;
    }
    function contentEnd(code) {
      effects.exit("chunkContent");
      effects.exit("content");
      return ok(code);
    }
    function contentContinue(code) {
      effects.consume(code);
      effects.exit("chunkContent");
      previous = previous.next = effects.enter("chunkContent", {
        contentType: "content",
        previous
      });
      return data;
    }
  }
  function tokenizeContinuation(effects, ok, nok) {
    var self2 = this;
    return startLookahead;
    function startLookahead(code) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return factorySpace(effects, prefixed, "linePrefix");
    }
    function prefixed(code) {
      if (code === null || markdownLineEnding(code)) {
        return nok(code);
      }
      if (self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 || prefixSize(self2.events, "linePrefix") < 4) {
        return effects.interrupt(self2.parser.constructs.flow, nok, ok)(code);
      }
      return ok(code);
    }
  }
  module.exports = content;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/initialize/flow.js
var require_flow = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var content = require_content2();
  var factorySpace = require_factory_space2();
  var partialBlankLine = require_partial_blank_line();
  var tokenize = initializeFlow;
  function initializeFlow(effects) {
    var self2 = this;
    var initial = effects.attempt(partialBlankLine, atBlankEnding, effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content, afterConstruct)), "linePrefix")));
    return initial;
    function atBlankEnding(code) {
      if (code === null) {
        effects.consume(code);
        return;
      }
      effects.enter("lineEndingBlank");
      effects.consume(code);
      effects.exit("lineEndingBlank");
      self2.currentConstruct = undefined;
      return initial;
    }
    function afterConstruct(code) {
      if (code === null) {
        effects.consume(code);
        return;
      }
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      self2.currentConstruct = undefined;
      return initial;
    }
  }
  exports.tokenize = tokenize;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/initialize/text.js
var require_text = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var assign = require_assign2();
  var shallow = require_shallow2();
  var text = initializeFactory("text");
  var string2 = initializeFactory("string");
  var resolver = {
    resolveAll: createResolver()
  };
  function initializeFactory(field) {
    return {
      tokenize: initializeText,
      resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : undefined)
    };
    function initializeText(effects) {
      var self2 = this;
      var constructs = this.parser.constructs[field];
      var text2 = effects.attempt(constructs, start, notText);
      return start;
      function start(code) {
        return atBreak(code) ? text2(code) : notText(code);
      }
      function notText(code) {
        if (code === null) {
          effects.consume(code);
          return;
        }
        effects.enter("data");
        effects.consume(code);
        return data;
      }
      function data(code) {
        if (atBreak(code)) {
          effects.exit("data");
          return text2(code);
        }
        effects.consume(code);
        return data;
      }
      function atBreak(code) {
        var list = constructs[code];
        var index = -1;
        if (code === null) {
          return true;
        }
        if (list) {
          while (++index < list.length) {
            if (!list[index].previous || list[index].previous.call(self2, self2.previous)) {
              return true;
            }
          }
        }
      }
    }
  }
  function createResolver(extraResolver) {
    return resolveAllText;
    function resolveAllText(events, context) {
      var index = -1;
      var enter;
      while (++index <= events.length) {
        if (enter === undefined) {
          if (events[index] && events[index][1].type === "data") {
            enter = index;
            index++;
          }
        } else if (!events[index] || events[index][1].type !== "data") {
          if (index !== enter + 2) {
            events[enter][1].end = events[index - 1][1].end;
            events.splice(enter + 2, index - enter - 2);
            index = enter + 2;
          }
          enter = undefined;
        }
      }
      return extraResolver ? extraResolver(events, context) : events;
    }
  }
  function resolveAllLineSuffixes(events, context) {
    var eventIndex = -1;
    var chunks;
    var data;
    var chunk;
    var index;
    var bufferIndex;
    var size;
    var tabs;
    var token;
    while (++eventIndex <= events.length) {
      if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
        data = events[eventIndex - 1][1];
        chunks = context.sliceStream(data);
        index = chunks.length;
        bufferIndex = -1;
        size = 0;
        tabs = undefined;
        while (index--) {
          chunk = chunks[index];
          if (typeof chunk === "string") {
            bufferIndex = chunk.length;
            while (chunk.charCodeAt(bufferIndex - 1) === 32) {
              size++;
              bufferIndex--;
            }
            if (bufferIndex)
              break;
            bufferIndex = -1;
          } else if (chunk === -2) {
            tabs = true;
            size++;
          } else if (chunk === -1)
            ;
          else {
            index++;
            break;
          }
        }
        if (size) {
          token = {
            type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
            start: {
              line: data.end.line,
              column: data.end.column - size,
              offset: data.end.offset - size,
              _index: data.start._index + index,
              _bufferIndex: index ? bufferIndex : data.start._bufferIndex + bufferIndex
            },
            end: shallow(data.end)
          };
          data.end = shallow(token.start);
          if (data.start.offset === data.end.offset) {
            assign(data, token);
          } else {
            events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]);
            eventIndex += 2;
          }
        }
        eventIndex++;
      }
    }
    return events;
  }
  exports.resolver = resolver;
  exports.string = string2;
  exports.text = text;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/util/miniflat.js
var require_miniflat2 = __commonJS((exports, module) => {
  function miniflat(value) {
    return value === null || value === undefined ? [] : ("length" in value) ? value : [value];
  }
  module.exports = miniflat;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/util/combine-extensions.js
var require_combine_extensions2 = __commonJS((exports, module) => {
  var hasOwnProperty2 = require_has_own_property2();
  var chunkedSplice = require_chunked_splice2();
  var miniflat = require_miniflat2();
  function combineExtensions(extensions) {
    var all = {};
    var index = -1;
    while (++index < extensions.length) {
      extension(all, extensions[index]);
    }
    return all;
  }
  function extension(all, extension2) {
    var hook;
    var left;
    var right;
    var code;
    for (hook in extension2) {
      left = hasOwnProperty2.call(all, hook) ? all[hook] : all[hook] = {};
      right = extension2[hook];
      for (code in right) {
        left[code] = constructs(miniflat(right[code]), hasOwnProperty2.call(left, code) ? left[code] : []);
      }
    }
  }
  function constructs(list, existing) {
    var index = -1;
    var before = [];
    while (++index < list.length) {
      (list[index].add === "after" ? existing : before).push(list[index]);
    }
    chunkedSplice(existing, 0, 0, before);
    return existing;
  }
  module.exports = combineExtensions;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/util/chunked-push.js
var require_chunked_push = __commonJS((exports, module) => {
  var chunkedSplice = require_chunked_splice2();
  function chunkedPush(list, items) {
    if (list.length) {
      chunkedSplice(list, list.length, 0, items);
      return list;
    }
    return items;
  }
  module.exports = chunkedPush;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/util/resolve-all.js
var require_resolve_all2 = __commonJS((exports, module) => {
  function resolveAll(constructs, events, context) {
    var called = [];
    var index = -1;
    var resolve;
    while (++index < constructs.length) {
      resolve = constructs[index].resolveAll;
      if (resolve && called.indexOf(resolve) < 0) {
        events = resolve(events, context);
        called.push(resolve);
      }
    }
    return events;
  }
  module.exports = resolveAll;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/util/serialize-chunks.js
var require_serialize_chunks = __commonJS((exports, module) => {
  var fromCharCode = require_from_char_code3();
  function serializeChunks(chunks) {
    var index = -1;
    var result = [];
    var chunk;
    var value;
    var atTab;
    while (++index < chunks.length) {
      chunk = chunks[index];
      if (typeof chunk === "string") {
        value = chunk;
      } else if (chunk === -5) {
        value = "\r";
      } else if (chunk === -4) {
        value = `
`;
      } else if (chunk === -3) {
        value = "\r" + `
`;
      } else if (chunk === -2) {
        value = "\t";
      } else if (chunk === -1) {
        if (atTab)
          continue;
        value = " ";
      } else {
        value = fromCharCode(chunk);
      }
      atTab = chunk === -2;
      result.push(value);
    }
    return result.join("");
  }
  module.exports = serializeChunks;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/util/slice-chunks.js
var require_slice_chunks = __commonJS((exports, module) => {
  function sliceChunks(chunks, token) {
    var startIndex = token.start._index;
    var startBufferIndex = token.start._bufferIndex;
    var endIndex = token.end._index;
    var endBufferIndex = token.end._bufferIndex;
    var view;
    if (startIndex === endIndex) {
      view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
    } else {
      view = chunks.slice(startIndex, endIndex);
      if (startBufferIndex > -1) {
        view[0] = view[0].slice(startBufferIndex);
      }
      if (endBufferIndex > 0) {
        view.push(chunks[endIndex].slice(0, endBufferIndex));
      }
    }
    return view;
  }
  module.exports = sliceChunks;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/util/create-tokenizer.js
var require_create_tokenizer = __commonJS((exports, module) => {
  var assign = require_assign2();
  var markdownLineEnding = require_markdown_line_ending2();
  var chunkedPush = require_chunked_push();
  var chunkedSplice = require_chunked_splice2();
  var miniflat = require_miniflat2();
  var resolveAll = require_resolve_all2();
  var serializeChunks = require_serialize_chunks();
  var shallow = require_shallow2();
  var sliceChunks = require_slice_chunks();
  function createTokenizer(parser, initialize, from) {
    var point = from ? shallow(from) : {
      line: 1,
      column: 1,
      offset: 0
    };
    var columnStart = {};
    var resolveAllConstructs = [];
    var chunks = [];
    var stack = [];
    var effects = {
      consume,
      enter,
      exit,
      attempt: constructFactory(onsuccessfulconstruct),
      check: constructFactory(onsuccessfulcheck),
      interrupt: constructFactory(onsuccessfulcheck, {
        interrupt: true
      }),
      lazy: constructFactory(onsuccessfulcheck, {
        lazy: true
      })
    };
    var context = {
      previous: null,
      events: [],
      parser,
      sliceStream,
      sliceSerialize,
      now,
      defineSkip: skip,
      write
    };
    var state = initialize.tokenize.call(context, effects);
    if (initialize.resolveAll) {
      resolveAllConstructs.push(initialize);
    }
    point._index = 0;
    point._bufferIndex = -1;
    return context;
    function write(slice) {
      chunks = chunkedPush(chunks, slice);
      main();
      if (chunks[chunks.length - 1] !== null) {
        return [];
      }
      addResult(initialize, 0);
      context.events = resolveAll(resolveAllConstructs, context.events, context);
      return context.events;
    }
    function sliceSerialize(token) {
      return serializeChunks(sliceStream(token));
    }
    function sliceStream(token) {
      return sliceChunks(chunks, token);
    }
    function now() {
      return shallow(point);
    }
    function skip(value) {
      columnStart[value.line] = value.column;
      accountForPotentialSkip();
    }
    function main() {
      var chunkIndex;
      var chunk;
      while (point._index < chunks.length) {
        chunk = chunks[point._index];
        if (typeof chunk === "string") {
          chunkIndex = point._index;
          if (point._bufferIndex < 0) {
            point._bufferIndex = 0;
          }
          while (point._index === chunkIndex && point._bufferIndex < chunk.length) {
            go(chunk.charCodeAt(point._bufferIndex));
          }
        } else {
          go(chunk);
        }
      }
    }
    function go(code) {
      state = state(code);
    }
    function consume(code) {
      if (markdownLineEnding(code)) {
        point.line++;
        point.column = 1;
        point.offset += code === -3 ? 2 : 1;
        accountForPotentialSkip();
      } else if (code !== -1) {
        point.column++;
        point.offset++;
      }
      if (point._bufferIndex < 0) {
        point._index++;
      } else {
        point._bufferIndex++;
        if (point._bufferIndex === chunks[point._index].length) {
          point._bufferIndex = -1;
          point._index++;
        }
      }
      context.previous = code;
    }
    function enter(type, fields) {
      var token = fields || {};
      token.type = type;
      token.start = now();
      context.events.push(["enter", token, context]);
      stack.push(token);
      return token;
    }
    function exit(type) {
      var token = stack.pop();
      token.end = now();
      context.events.push(["exit", token, context]);
      return token;
    }
    function onsuccessfulconstruct(construct, info) {
      addResult(construct, info.from);
    }
    function onsuccessfulcheck(construct, info) {
      info.restore();
    }
    function constructFactory(onreturn, fields) {
      return hook;
      function hook(constructs, returnState, bogusState) {
        var listOfConstructs;
        var constructIndex;
        var currentConstruct;
        var info;
        return constructs.tokenize || "length" in constructs ? handleListOfConstructs(miniflat(constructs)) : handleMapOfConstructs;
        function handleMapOfConstructs(code) {
          if (code in constructs || null in constructs) {
            return handleListOfConstructs(constructs.null ? miniflat(constructs[code]).concat(miniflat(constructs.null)) : constructs[code])(code);
          }
          return bogusState(code);
        }
        function handleListOfConstructs(list) {
          listOfConstructs = list;
          constructIndex = 0;
          return handleConstruct(list[constructIndex]);
        }
        function handleConstruct(construct) {
          return start;
          function start(code) {
            info = store();
            currentConstruct = construct;
            if (!construct.partial) {
              context.currentConstruct = construct;
            }
            if (construct.name && context.parser.constructs.disable.null.indexOf(construct.name) > -1) {
              return nok();
            }
            return construct.tokenize.call(fields ? assign({}, context, fields) : context, effects, ok, nok)(code);
          }
        }
        function ok(code) {
          onreturn(currentConstruct, info);
          return returnState;
        }
        function nok(code) {
          info.restore();
          if (++constructIndex < listOfConstructs.length) {
            return handleConstruct(listOfConstructs[constructIndex]);
          }
          return bogusState;
        }
      }
    }
    function addResult(construct, from2) {
      if (construct.resolveAll && resolveAllConstructs.indexOf(construct) < 0) {
        resolveAllConstructs.push(construct);
      }
      if (construct.resolve) {
        chunkedSplice(context.events, from2, context.events.length - from2, construct.resolve(context.events.slice(from2), context));
      }
      if (construct.resolveTo) {
        context.events = construct.resolveTo(context.events, context);
      }
    }
    function store() {
      var startPoint = now();
      var startPrevious = context.previous;
      var startCurrentConstruct = context.currentConstruct;
      var startEventsIndex = context.events.length;
      var startStack = Array.from(stack);
      return {
        restore,
        from: startEventsIndex
      };
      function restore() {
        point = startPoint;
        context.previous = startPrevious;
        context.currentConstruct = startCurrentConstruct;
        context.events.length = startEventsIndex;
        stack = startStack;
        accountForPotentialSkip();
      }
    }
    function accountForPotentialSkip() {
      if (point.line in columnStart && point.column < 2) {
        point.column = columnStart[point.line];
        point.offset += columnStart[point.line] - 1;
      }
    }
  }
  module.exports = createTokenizer;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/character/markdown-line-ending-or-space.js
var require_markdown_line_ending_or_space2 = __commonJS((exports, module) => {
  function markdownLineEndingOrSpace(code) {
    return code < 0 || code === 32;
  }
  module.exports = markdownLineEndingOrSpace;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/constant/unicode-punctuation-regex.js
var require_unicode_punctuation_regex3 = __commonJS((exports, module) => {
  var unicodePunctuation = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
  module.exports = unicodePunctuation;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/util/regex-check.js
var require_regex_check3 = __commonJS((exports, module) => {
  var fromCharCode = require_from_char_code3();
  function regexCheck(regex2) {
    return check;
    function check(code) {
      return regex2.test(fromCharCode(code));
    }
  }
  module.exports = regexCheck;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/character/unicode-punctuation.js
var require_unicode_punctuation3 = __commonJS((exports, module) => {
  var unicodePunctuationRegex = require_unicode_punctuation_regex3();
  var regexCheck = require_regex_check3();
  var unicodePunctuation = regexCheck(unicodePunctuationRegex);
  module.exports = unicodePunctuation;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/character/unicode-whitespace.js
var require_unicode_whitespace3 = __commonJS((exports, module) => {
  var regexCheck = require_regex_check3();
  var unicodeWhitespace = regexCheck(/\s/);
  module.exports = unicodeWhitespace;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/util/classify-character.js
var require_classify_character2 = __commonJS((exports, module) => {
  var markdownLineEndingOrSpace = require_markdown_line_ending_or_space2();
  var unicodePunctuation = require_unicode_punctuation3();
  var unicodeWhitespace = require_unicode_whitespace3();
  function classifyCharacter(code) {
    if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {
      return 1;
    }
    if (unicodePunctuation(code)) {
      return 2;
    }
  }
  module.exports = classifyCharacter;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/util/move-point.js
var require_move_point = __commonJS((exports, module) => {
  function movePoint(point, offset) {
    point.column += offset;
    point.offset += offset;
    point._bufferIndex += offset;
    return point;
  }
  module.exports = movePoint;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/attention.js
var require_attention = __commonJS((exports, module) => {
  var chunkedPush = require_chunked_push();
  var chunkedSplice = require_chunked_splice2();
  var classifyCharacter = require_classify_character2();
  var movePoint = require_move_point();
  var resolveAll = require_resolve_all2();
  var shallow = require_shallow2();
  var attention = {
    name: "attention",
    tokenize: tokenizeAttention,
    resolveAll: resolveAllAttention
  };
  function resolveAllAttention(events, context) {
    var index = -1;
    var open;
    var group;
    var text;
    var openingSequence;
    var closingSequence;
    var use;
    var nextEvents;
    var offset;
    while (++index < events.length) {
      if (events[index][0] === "enter" && events[index][1].type === "attentionSequence" && events[index][1]._close) {
        open = index;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index][1]).charCodeAt(0)) {
            if ((events[open][1]._close || events[index][1]._open) && (events[index][1].end.offset - events[index][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index][1].end.offset - events[index][1].start.offset) % 3)) {
              continue;
            }
            use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index][1].end.offset - events[index][1].start.offset > 1 ? 2 : 1;
            openingSequence = {
              type: use > 1 ? "strongSequence" : "emphasisSequence",
              start: movePoint(shallow(events[open][1].end), -use),
              end: shallow(events[open][1].end)
            };
            closingSequence = {
              type: use > 1 ? "strongSequence" : "emphasisSequence",
              start: shallow(events[index][1].start),
              end: movePoint(shallow(events[index][1].start), use)
            };
            text = {
              type: use > 1 ? "strongText" : "emphasisText",
              start: shallow(events[open][1].end),
              end: shallow(events[index][1].start)
            };
            group = {
              type: use > 1 ? "strong" : "emphasis",
              start: shallow(openingSequence.start),
              end: shallow(closingSequence.end)
            };
            events[open][1].end = shallow(openingSequence.start);
            events[index][1].start = shallow(closingSequence.end);
            nextEvents = [];
            if (events[open][1].end.offset - events[open][1].start.offset) {
              nextEvents = chunkedPush(nextEvents, [
                ["enter", events[open][1], context],
                ["exit", events[open][1], context]
              ]);
            }
            nextEvents = chunkedPush(nextEvents, [
              ["enter", group, context],
              ["enter", openingSequence, context],
              ["exit", openingSequence, context],
              ["enter", text, context]
            ]);
            nextEvents = chunkedPush(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index), context));
            nextEvents = chunkedPush(nextEvents, [
              ["exit", text, context],
              ["enter", closingSequence, context],
              ["exit", closingSequence, context],
              ["exit", group, context]
            ]);
            if (events[index][1].end.offset - events[index][1].start.offset) {
              offset = 2;
              nextEvents = chunkedPush(nextEvents, [
                ["enter", events[index][1], context],
                ["exit", events[index][1], context]
              ]);
            } else {
              offset = 0;
            }
            chunkedSplice(events, open - 1, index - open + 3, nextEvents);
            index = open + nextEvents.length - offset - 2;
            break;
          }
        }
      }
    }
    index = -1;
    while (++index < events.length) {
      if (events[index][1].type === "attentionSequence") {
        events[index][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeAttention(effects, ok) {
    var before = classifyCharacter(this.previous);
    var marker;
    return start;
    function start(code) {
      effects.enter("attentionSequence");
      marker = code;
      return sequence(code);
    }
    function sequence(code) {
      var token;
      var after;
      var open;
      var close;
      if (code === marker) {
        effects.consume(code);
        return sequence;
      }
      token = effects.exit("attentionSequence");
      after = classifyCharacter(code);
      open = !after || after === 2 && before;
      close = !before || before === 2 && after;
      token._open = marker === 42 ? open : open && (before || !close);
      token._close = marker === 42 ? close : close && (after || !open);
      return ok(code);
    }
  }
  module.exports = attention;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/character/ascii-alpha.js
var require_ascii_alpha2 = __commonJS((exports, module) => {
  var regexCheck = require_regex_check3();
  var asciiAlpha = regexCheck(/[A-Za-z]/);
  module.exports = asciiAlpha;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/character/ascii-alphanumeric.js
var require_ascii_alphanumeric2 = __commonJS((exports, module) => {
  var regexCheck = require_regex_check3();
  var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
  module.exports = asciiAlphanumeric;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/character/ascii-atext.js
var require_ascii_atext = __commonJS((exports, module) => {
  var regexCheck = require_regex_check3();
  var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
  module.exports = asciiAtext;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/character/ascii-control.js
var require_ascii_control2 = __commonJS((exports, module) => {
  function asciiControl(code) {
    return code < 32 || code === 127;
  }
  module.exports = asciiControl;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/autolink.js
var require_autolink = __commonJS((exports, module) => {
  var asciiAlpha = require_ascii_alpha2();
  var asciiAlphanumeric = require_ascii_alphanumeric2();
  var asciiAtext = require_ascii_atext();
  var asciiControl = require_ascii_control2();
  var autolink = {
    name: "autolink",
    tokenize: tokenizeAutolink
  };
  function tokenizeAutolink(effects, ok, nok) {
    var size = 1;
    return start;
    function start(code) {
      effects.enter("autolink");
      effects.enter("autolinkMarker");
      effects.consume(code);
      effects.exit("autolinkMarker");
      effects.enter("autolinkProtocol");
      return open;
    }
    function open(code) {
      if (asciiAlpha(code)) {
        effects.consume(code);
        return schemeOrEmailAtext;
      }
      return asciiAtext(code) ? emailAtext(code) : nok(code);
    }
    function schemeOrEmailAtext(code) {
      return code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code) ? schemeInsideOrEmailAtext(code) : emailAtext(code);
    }
    function schemeInsideOrEmailAtext(code) {
      if (code === 58) {
        effects.consume(code);
        return urlInside;
      }
      if ((code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) && size++ < 32) {
        effects.consume(code);
        return schemeInsideOrEmailAtext;
      }
      return emailAtext(code);
    }
    function urlInside(code) {
      if (code === 62) {
        effects.exit("autolinkProtocol");
        return end(code);
      }
      if (code === 32 || code === 60 || asciiControl(code)) {
        return nok(code);
      }
      effects.consume(code);
      return urlInside;
    }
    function emailAtext(code) {
      if (code === 64) {
        effects.consume(code);
        size = 0;
        return emailAtSignOrDot;
      }
      if (asciiAtext(code)) {
        effects.consume(code);
        return emailAtext;
      }
      return nok(code);
    }
    function emailAtSignOrDot(code) {
      return asciiAlphanumeric(code) ? emailLabel(code) : nok(code);
    }
    function emailLabel(code) {
      if (code === 46) {
        effects.consume(code);
        size = 0;
        return emailAtSignOrDot;
      }
      if (code === 62) {
        effects.exit("autolinkProtocol").type = "autolinkEmail";
        return end(code);
      }
      return emailValue(code);
    }
    function emailValue(code) {
      if ((code === 45 || asciiAlphanumeric(code)) && size++ < 63) {
        effects.consume(code);
        return code === 45 ? emailValue : emailLabel;
      }
      return nok(code);
    }
    function end(code) {
      effects.enter("autolinkMarker");
      effects.consume(code);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok;
    }
  }
  module.exports = autolink;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/block-quote.js
var require_block_quote = __commonJS((exports, module) => {
  var markdownSpace = require_markdown_space2();
  var factorySpace = require_factory_space2();
  var blockQuote = {
    name: "blockQuote",
    tokenize: tokenizeBlockQuoteStart,
    continuation: {
      tokenize: tokenizeBlockQuoteContinuation
    },
    exit
  };
  function tokenizeBlockQuoteStart(effects, ok, nok) {
    var self2 = this;
    return start;
    function start(code) {
      if (code === 62) {
        if (!self2.containerState.open) {
          effects.enter("blockQuote", {
            _container: true
          });
          self2.containerState.open = true;
        }
        effects.enter("blockQuotePrefix");
        effects.enter("blockQuoteMarker");
        effects.consume(code);
        effects.exit("blockQuoteMarker");
        return after;
      }
      return nok(code);
    }
    function after(code) {
      if (markdownSpace(code)) {
        effects.enter("blockQuotePrefixWhitespace");
        effects.consume(code);
        effects.exit("blockQuotePrefixWhitespace");
        effects.exit("blockQuotePrefix");
        return ok;
      }
      effects.exit("blockQuotePrefix");
      return ok(code);
    }
  }
  function tokenizeBlockQuoteContinuation(effects, ok, nok) {
    return factorySpace(effects, effects.attempt(blockQuote, ok, nok), "linePrefix", this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? undefined : 4);
  }
  function exit(effects) {
    effects.exit("blockQuote");
  }
  module.exports = blockQuote;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/character/ascii-punctuation.js
var require_ascii_punctuation = __commonJS((exports, module) => {
  var regexCheck = require_regex_check3();
  var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
  module.exports = asciiPunctuation;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/character-escape.js
var require_character_escape = __commonJS((exports, module) => {
  var asciiPunctuation = require_ascii_punctuation();
  var characterEscape = {
    name: "characterEscape",
    tokenize: tokenizeCharacterEscape
  };
  function tokenizeCharacterEscape(effects, ok, nok) {
    return start;
    function start(code) {
      effects.enter("characterEscape");
      effects.enter("escapeMarker");
      effects.consume(code);
      effects.exit("escapeMarker");
      return open;
    }
    function open(code) {
      if (asciiPunctuation(code)) {
        effects.enter("characterEscapeValue");
        effects.consume(code);
        effects.exit("characterEscapeValue");
        effects.exit("characterEscape");
        return ok;
      }
      return nok(code);
    }
  }
  module.exports = characterEscape;
});

// node_modules/character-entities/index.json
var require_character_entities = __commonJS((exports, module) => {
  module.exports = {
    AEli: "\xC6",
    AElig: "\xC6",
    AM: "&",
    AMP: "&",
    Aacut: "\xC1",
    Aacute: "\xC1",
    Abreve: "\u0102",
    Acir: "\xC2",
    Acirc: "\xC2",
    Acy: "\u0410",
    Afr: "\uD835\uDD04",
    Agrav: "\xC0",
    Agrave: "\xC0",
    Alpha: "\u0391",
    Amacr: "\u0100",
    And: "\u2A53",
    Aogon: "\u0104",
    Aopf: "\uD835\uDD38",
    ApplyFunction: "\u2061",
    Arin: "\xC5",
    Aring: "\xC5",
    Ascr: "\uD835\uDC9C",
    Assign: "\u2254",
    Atild: "\xC3",
    Atilde: "\xC3",
    Aum: "\xC4",
    Auml: "\xC4",
    Backslash: "\u2216",
    Barv: "\u2AE7",
    Barwed: "\u2306",
    Bcy: "\u0411",
    Because: "\u2235",
    Bernoullis: "\u212C",
    Beta: "\u0392",
    Bfr: "\uD835\uDD05",
    Bopf: "\uD835\uDD39",
    Breve: "\u02D8",
    Bscr: "\u212C",
    Bumpeq: "\u224E",
    CHcy: "\u0427",
    COP: "\xA9",
    COPY: "\xA9",
    Cacute: "\u0106",
    Cap: "\u22D2",
    CapitalDifferentialD: "\u2145",
    Cayleys: "\u212D",
    Ccaron: "\u010C",
    Ccedi: "\xC7",
    Ccedil: "\xC7",
    Ccirc: "\u0108",
    Cconint: "\u2230",
    Cdot: "\u010A",
    Cedilla: "\xB8",
    CenterDot: "\xB7",
    Cfr: "\u212D",
    Chi: "\u03A7",
    CircleDot: "\u2299",
    CircleMinus: "\u2296",
    CirclePlus: "\u2295",
    CircleTimes: "\u2297",
    ClockwiseContourIntegral: "\u2232",
    CloseCurlyDoubleQuote: "\u201D",
    CloseCurlyQuote: "\u2019",
    Colon: "\u2237",
    Colone: "\u2A74",
    Congruent: "\u2261",
    Conint: "\u222F",
    ContourIntegral: "\u222E",
    Copf: "\u2102",
    Coproduct: "\u2210",
    CounterClockwiseContourIntegral: "\u2233",
    Cross: "\u2A2F",
    Cscr: "\uD835\uDC9E",
    Cup: "\u22D3",
    CupCap: "\u224D",
    DD: "\u2145",
    DDotrahd: "\u2911",
    DJcy: "\u0402",
    DScy: "\u0405",
    DZcy: "\u040F",
    Dagger: "\u2021",
    Darr: "\u21A1",
    Dashv: "\u2AE4",
    Dcaron: "\u010E",
    Dcy: "\u0414",
    Del: "\u2207",
    Delta: "\u0394",
    Dfr: "\uD835\uDD07",
    DiacriticalAcute: "\xB4",
    DiacriticalDot: "\u02D9",
    DiacriticalDoubleAcute: "\u02DD",
    DiacriticalGrave: "`",
    DiacriticalTilde: "\u02DC",
    Diamond: "\u22C4",
    DifferentialD: "\u2146",
    Dopf: "\uD835\uDD3B",
    Dot: "\xA8",
    DotDot: "\u20DC",
    DotEqual: "\u2250",
    DoubleContourIntegral: "\u222F",
    DoubleDot: "\xA8",
    DoubleDownArrow: "\u21D3",
    DoubleLeftArrow: "\u21D0",
    DoubleLeftRightArrow: "\u21D4",
    DoubleLeftTee: "\u2AE4",
    DoubleLongLeftArrow: "\u27F8",
    DoubleLongLeftRightArrow: "\u27FA",
    DoubleLongRightArrow: "\u27F9",
    DoubleRightArrow: "\u21D2",
    DoubleRightTee: "\u22A8",
    DoubleUpArrow: "\u21D1",
    DoubleUpDownArrow: "\u21D5",
    DoubleVerticalBar: "\u2225",
    DownArrow: "\u2193",
    DownArrowBar: "\u2913",
    DownArrowUpArrow: "\u21F5",
    DownBreve: "\u0311",
    DownLeftRightVector: "\u2950",
    DownLeftTeeVector: "\u295E",
    DownLeftVector: "\u21BD",
    DownLeftVectorBar: "\u2956",
    DownRightTeeVector: "\u295F",
    DownRightVector: "\u21C1",
    DownRightVectorBar: "\u2957",
    DownTee: "\u22A4",
    DownTeeArrow: "\u21A7",
    Downarrow: "\u21D3",
    Dscr: "\uD835\uDC9F",
    Dstrok: "\u0110",
    ENG: "\u014A",
    ET: "\xD0",
    ETH: "\xD0",
    Eacut: "\xC9",
    Eacute: "\xC9",
    Ecaron: "\u011A",
    Ecir: "\xCA",
    Ecirc: "\xCA",
    Ecy: "\u042D",
    Edot: "\u0116",
    Efr: "\uD835\uDD08",
    Egrav: "\xC8",
    Egrave: "\xC8",
    Element: "\u2208",
    Emacr: "\u0112",
    EmptySmallSquare: "\u25FB",
    EmptyVerySmallSquare: "\u25AB",
    Eogon: "\u0118",
    Eopf: "\uD835\uDD3C",
    Epsilon: "\u0395",
    Equal: "\u2A75",
    EqualTilde: "\u2242",
    Equilibrium: "\u21CC",
    Escr: "\u2130",
    Esim: "\u2A73",
    Eta: "\u0397",
    Eum: "\xCB",
    Euml: "\xCB",
    Exists: "\u2203",
    ExponentialE: "\u2147",
    Fcy: "\u0424",
    Ffr: "\uD835\uDD09",
    FilledSmallSquare: "\u25FC",
    FilledVerySmallSquare: "\u25AA",
    Fopf: "\uD835\uDD3D",
    ForAll: "\u2200",
    Fouriertrf: "\u2131",
    Fscr: "\u2131",
    GJcy: "\u0403",
    G: ">",
    GT: ">",
    Gamma: "\u0393",
    Gammad: "\u03DC",
    Gbreve: "\u011E",
    Gcedil: "\u0122",
    Gcirc: "\u011C",
    Gcy: "\u0413",
    Gdot: "\u0120",
    Gfr: "\uD835\uDD0A",
    Gg: "\u22D9",
    Gopf: "\uD835\uDD3E",
    GreaterEqual: "\u2265",
    GreaterEqualLess: "\u22DB",
    GreaterFullEqual: "\u2267",
    GreaterGreater: "\u2AA2",
    GreaterLess: "\u2277",
    GreaterSlantEqual: "\u2A7E",
    GreaterTilde: "\u2273",
    Gscr: "\uD835\uDCA2",
    Gt: "\u226B",
    HARDcy: "\u042A",
    Hacek: "\u02C7",
    Hat: "^",
    Hcirc: "\u0124",
    Hfr: "\u210C",
    HilbertSpace: "\u210B",
    Hopf: "\u210D",
    HorizontalLine: "\u2500",
    Hscr: "\u210B",
    Hstrok: "\u0126",
    HumpDownHump: "\u224E",
    HumpEqual: "\u224F",
    IEcy: "\u0415",
    IJlig: "\u0132",
    IOcy: "\u0401",
    Iacut: "\xCD",
    Iacute: "\xCD",
    Icir: "\xCE",
    Icirc: "\xCE",
    Icy: "\u0418",
    Idot: "\u0130",
    Ifr: "\u2111",
    Igrav: "\xCC",
    Igrave: "\xCC",
    Im: "\u2111",
    Imacr: "\u012A",
    ImaginaryI: "\u2148",
    Implies: "\u21D2",
    Int: "\u222C",
    Integral: "\u222B",
    Intersection: "\u22C2",
    InvisibleComma: "\u2063",
    InvisibleTimes: "\u2062",
    Iogon: "\u012E",
    Iopf: "\uD835\uDD40",
    Iota: "\u0399",
    Iscr: "\u2110",
    Itilde: "\u0128",
    Iukcy: "\u0406",
    Ium: "\xCF",
    Iuml: "\xCF",
    Jcirc: "\u0134",
    Jcy: "\u0419",
    Jfr: "\uD835\uDD0D",
    Jopf: "\uD835\uDD41",
    Jscr: "\uD835\uDCA5",
    Jsercy: "\u0408",
    Jukcy: "\u0404",
    KHcy: "\u0425",
    KJcy: "\u040C",
    Kappa: "\u039A",
    Kcedil: "\u0136",
    Kcy: "\u041A",
    Kfr: "\uD835\uDD0E",
    Kopf: "\uD835\uDD42",
    Kscr: "\uD835\uDCA6",
    LJcy: "\u0409",
    L: "<",
    LT: "<",
    Lacute: "\u0139",
    Lambda: "\u039B",
    Lang: "\u27EA",
    Laplacetrf: "\u2112",
    Larr: "\u219E",
    Lcaron: "\u013D",
    Lcedil: "\u013B",
    Lcy: "\u041B",
    LeftAngleBracket: "\u27E8",
    LeftArrow: "\u2190",
    LeftArrowBar: "\u21E4",
    LeftArrowRightArrow: "\u21C6",
    LeftCeiling: "\u2308",
    LeftDoubleBracket: "\u27E6",
    LeftDownTeeVector: "\u2961",
    LeftDownVector: "\u21C3",
    LeftDownVectorBar: "\u2959",
    LeftFloor: "\u230A",
    LeftRightArrow: "\u2194",
    LeftRightVector: "\u294E",
    LeftTee: "\u22A3",
    LeftTeeArrow: "\u21A4",
    LeftTeeVector: "\u295A",
    LeftTriangle: "\u22B2",
    LeftTriangleBar: "\u29CF",
    LeftTriangleEqual: "\u22B4",
    LeftUpDownVector: "\u2951",
    LeftUpTeeVector: "\u2960",
    LeftUpVector: "\u21BF",
    LeftUpVectorBar: "\u2958",
    LeftVector: "\u21BC",
    LeftVectorBar: "\u2952",
    Leftarrow: "\u21D0",
    Leftrightarrow: "\u21D4",
    LessEqualGreater: "\u22DA",
    LessFullEqual: "\u2266",
    LessGreater: "\u2276",
    LessLess: "\u2AA1",
    LessSlantEqual: "\u2A7D",
    LessTilde: "\u2272",
    Lfr: "\uD835\uDD0F",
    Ll: "\u22D8",
    Lleftarrow: "\u21DA",
    Lmidot: "\u013F",
    LongLeftArrow: "\u27F5",
    LongLeftRightArrow: "\u27F7",
    LongRightArrow: "\u27F6",
    Longleftarrow: "\u27F8",
    Longleftrightarrow: "\u27FA",
    Longrightarrow: "\u27F9",
    Lopf: "\uD835\uDD43",
    LowerLeftArrow: "\u2199",
    LowerRightArrow: "\u2198",
    Lscr: "\u2112",
    Lsh: "\u21B0",
    Lstrok: "\u0141",
    Lt: "\u226A",
    Map: "\u2905",
    Mcy: "\u041C",
    MediumSpace: "\u205F",
    Mellintrf: "\u2133",
    Mfr: "\uD835\uDD10",
    MinusPlus: "\u2213",
    Mopf: "\uD835\uDD44",
    Mscr: "\u2133",
    Mu: "\u039C",
    NJcy: "\u040A",
    Nacute: "\u0143",
    Ncaron: "\u0147",
    Ncedil: "\u0145",
    Ncy: "\u041D",
    NegativeMediumSpace: "\u200B",
    NegativeThickSpace: "\u200B",
    NegativeThinSpace: "\u200B",
    NegativeVeryThinSpace: "\u200B",
    NestedGreaterGreater: "\u226B",
    NestedLessLess: "\u226A",
    NewLine: `
`,
    Nfr: "\uD835\uDD11",
    NoBreak: "\u2060",
    NonBreakingSpace: "\xA0",
    Nopf: "\u2115",
    Not: "\u2AEC",
    NotCongruent: "\u2262",
    NotCupCap: "\u226D",
    NotDoubleVerticalBar: "\u2226",
    NotElement: "\u2209",
    NotEqual: "\u2260",
    NotEqualTilde: "\u2242\u0338",
    NotExists: "\u2204",
    NotGreater: "\u226F",
    NotGreaterEqual: "\u2271",
    NotGreaterFullEqual: "\u2267\u0338",
    NotGreaterGreater: "\u226B\u0338",
    NotGreaterLess: "\u2279",
    NotGreaterSlantEqual: "\u2A7E\u0338",
    NotGreaterTilde: "\u2275",
    NotHumpDownHump: "\u224E\u0338",
    NotHumpEqual: "\u224F\u0338",
    NotLeftTriangle: "\u22EA",
    NotLeftTriangleBar: "\u29CF\u0338",
    NotLeftTriangleEqual: "\u22EC",
    NotLess: "\u226E",
    NotLessEqual: "\u2270",
    NotLessGreater: "\u2278",
    NotLessLess: "\u226A\u0338",
    NotLessSlantEqual: "\u2A7D\u0338",
    NotLessTilde: "\u2274",
    NotNestedGreaterGreater: "\u2AA2\u0338",
    NotNestedLessLess: "\u2AA1\u0338",
    NotPrecedes: "\u2280",
    NotPrecedesEqual: "\u2AAF\u0338",
    NotPrecedesSlantEqual: "\u22E0",
    NotReverseElement: "\u220C",
    NotRightTriangle: "\u22EB",
    NotRightTriangleBar: "\u29D0\u0338",
    NotRightTriangleEqual: "\u22ED",
    NotSquareSubset: "\u228F\u0338",
    NotSquareSubsetEqual: "\u22E2",
    NotSquareSuperset: "\u2290\u0338",
    NotSquareSupersetEqual: "\u22E3",
    NotSubset: "\u2282\u20D2",
    NotSubsetEqual: "\u2288",
    NotSucceeds: "\u2281",
    NotSucceedsEqual: "\u2AB0\u0338",
    NotSucceedsSlantEqual: "\u22E1",
    NotSucceedsTilde: "\u227F\u0338",
    NotSuperset: "\u2283\u20D2",
    NotSupersetEqual: "\u2289",
    NotTilde: "\u2241",
    NotTildeEqual: "\u2244",
    NotTildeFullEqual: "\u2247",
    NotTildeTilde: "\u2249",
    NotVerticalBar: "\u2224",
    Nscr: "\uD835\uDCA9",
    Ntild: "\xD1",
    Ntilde: "\xD1",
    Nu: "\u039D",
    OElig: "\u0152",
    Oacut: "\xD3",
    Oacute: "\xD3",
    Ocir: "\xD4",
    Ocirc: "\xD4",
    Ocy: "\u041E",
    Odblac: "\u0150",
    Ofr: "\uD835\uDD12",
    Ograv: "\xD2",
    Ograve: "\xD2",
    Omacr: "\u014C",
    Omega: "\u03A9",
    Omicron: "\u039F",
    Oopf: "\uD835\uDD46",
    OpenCurlyDoubleQuote: "\u201C",
    OpenCurlyQuote: "\u2018",
    Or: "\u2A54",
    Oscr: "\uD835\uDCAA",
    Oslas: "\xD8",
    Oslash: "\xD8",
    Otild: "\xD5",
    Otilde: "\xD5",
    Otimes: "\u2A37",
    Oum: "\xD6",
    Ouml: "\xD6",
    OverBar: "\u203E",
    OverBrace: "\u23DE",
    OverBracket: "\u23B4",
    OverParenthesis: "\u23DC",
    PartialD: "\u2202",
    Pcy: "\u041F",
    Pfr: "\uD835\uDD13",
    Phi: "\u03A6",
    Pi: "\u03A0",
    PlusMinus: "\xB1",
    Poincareplane: "\u210C",
    Popf: "\u2119",
    Pr: "\u2ABB",
    Precedes: "\u227A",
    PrecedesEqual: "\u2AAF",
    PrecedesSlantEqual: "\u227C",
    PrecedesTilde: "\u227E",
    Prime: "\u2033",
    Product: "\u220F",
    Proportion: "\u2237",
    Proportional: "\u221D",
    Pscr: "\uD835\uDCAB",
    Psi: "\u03A8",
    QUO: '"',
    QUOT: '"',
    Qfr: "\uD835\uDD14",
    Qopf: "\u211A",
    Qscr: "\uD835\uDCAC",
    RBarr: "\u2910",
    RE: "\xAE",
    REG: "\xAE",
    Racute: "\u0154",
    Rang: "\u27EB",
    Rarr: "\u21A0",
    Rarrtl: "\u2916",
    Rcaron: "\u0158",
    Rcedil: "\u0156",
    Rcy: "\u0420",
    Re: "\u211C",
    ReverseElement: "\u220B",
    ReverseEquilibrium: "\u21CB",
    ReverseUpEquilibrium: "\u296F",
    Rfr: "\u211C",
    Rho: "\u03A1",
    RightAngleBracket: "\u27E9",
    RightArrow: "\u2192",
    RightArrowBar: "\u21E5",
    RightArrowLeftArrow: "\u21C4",
    RightCeiling: "\u2309",
    RightDoubleBracket: "\u27E7",
    RightDownTeeVector: "\u295D",
    RightDownVector: "\u21C2",
    RightDownVectorBar: "\u2955",
    RightFloor: "\u230B",
    RightTee: "\u22A2",
    RightTeeArrow: "\u21A6",
    RightTeeVector: "\u295B",
    RightTriangle: "\u22B3",
    RightTriangleBar: "\u29D0",
    RightTriangleEqual: "\u22B5",
    RightUpDownVector: "\u294F",
    RightUpTeeVector: "\u295C",
    RightUpVector: "\u21BE",
    RightUpVectorBar: "\u2954",
    RightVector: "\u21C0",
    RightVectorBar: "\u2953",
    Rightarrow: "\u21D2",
    Ropf: "\u211D",
    RoundImplies: "\u2970",
    Rrightarrow: "\u21DB",
    Rscr: "\u211B",
    Rsh: "\u21B1",
    RuleDelayed: "\u29F4",
    SHCHcy: "\u0429",
    SHcy: "\u0428",
    SOFTcy: "\u042C",
    Sacute: "\u015A",
    Sc: "\u2ABC",
    Scaron: "\u0160",
    Scedil: "\u015E",
    Scirc: "\u015C",
    Scy: "\u0421",
    Sfr: "\uD835\uDD16",
    ShortDownArrow: "\u2193",
    ShortLeftArrow: "\u2190",
    ShortRightArrow: "\u2192",
    ShortUpArrow: "\u2191",
    Sigma: "\u03A3",
    SmallCircle: "\u2218",
    Sopf: "\uD835\uDD4A",
    Sqrt: "\u221A",
    Square: "\u25A1",
    SquareIntersection: "\u2293",
    SquareSubset: "\u228F",
    SquareSubsetEqual: "\u2291",
    SquareSuperset: "\u2290",
    SquareSupersetEqual: "\u2292",
    SquareUnion: "\u2294",
    Sscr: "\uD835\uDCAE",
    Star: "\u22C6",
    Sub: "\u22D0",
    Subset: "\u22D0",
    SubsetEqual: "\u2286",
    Succeeds: "\u227B",
    SucceedsEqual: "\u2AB0",
    SucceedsSlantEqual: "\u227D",
    SucceedsTilde: "\u227F",
    SuchThat: "\u220B",
    Sum: "\u2211",
    Sup: "\u22D1",
    Superset: "\u2283",
    SupersetEqual: "\u2287",
    Supset: "\u22D1",
    THOR: "\xDE",
    THORN: "\xDE",
    TRADE: "\u2122",
    TSHcy: "\u040B",
    TScy: "\u0426",
    Tab: "\t",
    Tau: "\u03A4",
    Tcaron: "\u0164",
    Tcedil: "\u0162",
    Tcy: "\u0422",
    Tfr: "\uD835\uDD17",
    Therefore: "\u2234",
    Theta: "\u0398",
    ThickSpace: "\u205F\u200A",
    ThinSpace: "\u2009",
    Tilde: "\u223C",
    TildeEqual: "\u2243",
    TildeFullEqual: "\u2245",
    TildeTilde: "\u2248",
    Topf: "\uD835\uDD4B",
    TripleDot: "\u20DB",
    Tscr: "\uD835\uDCAF",
    Tstrok: "\u0166",
    Uacut: "\xDA",
    Uacute: "\xDA",
    Uarr: "\u219F",
    Uarrocir: "\u2949",
    Ubrcy: "\u040E",
    Ubreve: "\u016C",
    Ucir: "\xDB",
    Ucirc: "\xDB",
    Ucy: "\u0423",
    Udblac: "\u0170",
    Ufr: "\uD835\uDD18",
    Ugrav: "\xD9",
    Ugrave: "\xD9",
    Umacr: "\u016A",
    UnderBar: "_",
    UnderBrace: "\u23DF",
    UnderBracket: "\u23B5",
    UnderParenthesis: "\u23DD",
    Union: "\u22C3",
    UnionPlus: "\u228E",
    Uogon: "\u0172",
    Uopf: "\uD835\uDD4C",
    UpArrow: "\u2191",
    UpArrowBar: "\u2912",
    UpArrowDownArrow: "\u21C5",
    UpDownArrow: "\u2195",
    UpEquilibrium: "\u296E",
    UpTee: "\u22A5",
    UpTeeArrow: "\u21A5",
    Uparrow: "\u21D1",
    Updownarrow: "\u21D5",
    UpperLeftArrow: "\u2196",
    UpperRightArrow: "\u2197",
    Upsi: "\u03D2",
    Upsilon: "\u03A5",
    Uring: "\u016E",
    Uscr: "\uD835\uDCB0",
    Utilde: "\u0168",
    Uum: "\xDC",
    Uuml: "\xDC",
    VDash: "\u22AB",
    Vbar: "\u2AEB",
    Vcy: "\u0412",
    Vdash: "\u22A9",
    Vdashl: "\u2AE6",
    Vee: "\u22C1",
    Verbar: "\u2016",
    Vert: "\u2016",
    VerticalBar: "\u2223",
    VerticalLine: "|",
    VerticalSeparator: "\u2758",
    VerticalTilde: "\u2240",
    VeryThinSpace: "\u200A",
    Vfr: "\uD835\uDD19",
    Vopf: "\uD835\uDD4D",
    Vscr: "\uD835\uDCB1",
    Vvdash: "\u22AA",
    Wcirc: "\u0174",
    Wedge: "\u22C0",
    Wfr: "\uD835\uDD1A",
    Wopf: "\uD835\uDD4E",
    Wscr: "\uD835\uDCB2",
    Xfr: "\uD835\uDD1B",
    Xi: "\u039E",
    Xopf: "\uD835\uDD4F",
    Xscr: "\uD835\uDCB3",
    YAcy: "\u042F",
    YIcy: "\u0407",
    YUcy: "\u042E",
    Yacut: "\xDD",
    Yacute: "\xDD",
    Ycirc: "\u0176",
    Ycy: "\u042B",
    Yfr: "\uD835\uDD1C",
    Yopf: "\uD835\uDD50",
    Yscr: "\uD835\uDCB4",
    Yuml: "\u0178",
    ZHcy: "\u0416",
    Zacute: "\u0179",
    Zcaron: "\u017D",
    Zcy: "\u0417",
    Zdot: "\u017B",
    ZeroWidthSpace: "\u200B",
    Zeta: "\u0396",
    Zfr: "\u2128",
    Zopf: "\u2124",
    Zscr: "\uD835\uDCB5",
    aacut: "\xE1",
    aacute: "\xE1",
    abreve: "\u0103",
    ac: "\u223E",
    acE: "\u223E\u0333",
    acd: "\u223F",
    acir: "\xE2",
    acirc: "\xE2",
    acut: "\xB4",
    acute: "\xB4",
    acy: "\u0430",
    aeli: "\xE6",
    aelig: "\xE6",
    af: "\u2061",
    afr: "\uD835\uDD1E",
    agrav: "\xE0",
    agrave: "\xE0",
    alefsym: "\u2135",
    aleph: "\u2135",
    alpha: "\u03B1",
    amacr: "\u0101",
    amalg: "\u2A3F",
    am: "&",
    amp: "&",
    and: "\u2227",
    andand: "\u2A55",
    andd: "\u2A5C",
    andslope: "\u2A58",
    andv: "\u2A5A",
    ang: "\u2220",
    ange: "\u29A4",
    angle: "\u2220",
    angmsd: "\u2221",
    angmsdaa: "\u29A8",
    angmsdab: "\u29A9",
    angmsdac: "\u29AA",
    angmsdad: "\u29AB",
    angmsdae: "\u29AC",
    angmsdaf: "\u29AD",
    angmsdag: "\u29AE",
    angmsdah: "\u29AF",
    angrt: "\u221F",
    angrtvb: "\u22BE",
    angrtvbd: "\u299D",
    angsph: "\u2222",
    angst: "\xC5",
    angzarr: "\u237C",
    aogon: "\u0105",
    aopf: "\uD835\uDD52",
    ap: "\u2248",
    apE: "\u2A70",
    apacir: "\u2A6F",
    ape: "\u224A",
    apid: "\u224B",
    apos: "'",
    approx: "\u2248",
    approxeq: "\u224A",
    arin: "\xE5",
    aring: "\xE5",
    ascr: "\uD835\uDCB6",
    ast: "*",
    asymp: "\u2248",
    asympeq: "\u224D",
    atild: "\xE3",
    atilde: "\xE3",
    aum: "\xE4",
    auml: "\xE4",
    awconint: "\u2233",
    awint: "\u2A11",
    bNot: "\u2AED",
    backcong: "\u224C",
    backepsilon: "\u03F6",
    backprime: "\u2035",
    backsim: "\u223D",
    backsimeq: "\u22CD",
    barvee: "\u22BD",
    barwed: "\u2305",
    barwedge: "\u2305",
    bbrk: "\u23B5",
    bbrktbrk: "\u23B6",
    bcong: "\u224C",
    bcy: "\u0431",
    bdquo: "\u201E",
    becaus: "\u2235",
    because: "\u2235",
    bemptyv: "\u29B0",
    bepsi: "\u03F6",
    bernou: "\u212C",
    beta: "\u03B2",
    beth: "\u2136",
    between: "\u226C",
    bfr: "\uD835\uDD1F",
    bigcap: "\u22C2",
    bigcirc: "\u25EF",
    bigcup: "\u22C3",
    bigodot: "\u2A00",
    bigoplus: "\u2A01",
    bigotimes: "\u2A02",
    bigsqcup: "\u2A06",
    bigstar: "\u2605",
    bigtriangledown: "\u25BD",
    bigtriangleup: "\u25B3",
    biguplus: "\u2A04",
    bigvee: "\u22C1",
    bigwedge: "\u22C0",
    bkarow: "\u290D",
    blacklozenge: "\u29EB",
    blacksquare: "\u25AA",
    blacktriangle: "\u25B4",
    blacktriangledown: "\u25BE",
    blacktriangleleft: "\u25C2",
    blacktriangleright: "\u25B8",
    blank: "\u2423",
    blk12: "\u2592",
    blk14: "\u2591",
    blk34: "\u2593",
    block: "\u2588",
    bne: "=\u20E5",
    bnequiv: "\u2261\u20E5",
    bnot: "\u2310",
    bopf: "\uD835\uDD53",
    bot: "\u22A5",
    bottom: "\u22A5",
    bowtie: "\u22C8",
    boxDL: "\u2557",
    boxDR: "\u2554",
    boxDl: "\u2556",
    boxDr: "\u2553",
    boxH: "\u2550",
    boxHD: "\u2566",
    boxHU: "\u2569",
    boxHd: "\u2564",
    boxHu: "\u2567",
    boxUL: "\u255D",
    boxUR: "\u255A",
    boxUl: "\u255C",
    boxUr: "\u2559",
    boxV: "\u2551",
    boxVH: "\u256C",
    boxVL: "\u2563",
    boxVR: "\u2560",
    boxVh: "\u256B",
    boxVl: "\u2562",
    boxVr: "\u255F",
    boxbox: "\u29C9",
    boxdL: "\u2555",
    boxdR: "\u2552",
    boxdl: "\u2510",
    boxdr: "\u250C",
    boxh: "\u2500",
    boxhD: "\u2565",
    boxhU: "\u2568",
    boxhd: "\u252C",
    boxhu: "\u2534",
    boxminus: "\u229F",
    boxplus: "\u229E",
    boxtimes: "\u22A0",
    boxuL: "\u255B",
    boxuR: "\u2558",
    boxul: "\u2518",
    boxur: "\u2514",
    boxv: "\u2502",
    boxvH: "\u256A",
    boxvL: "\u2561",
    boxvR: "\u255E",
    boxvh: "\u253C",
    boxvl: "\u2524",
    boxvr: "\u251C",
    bprime: "\u2035",
    breve: "\u02D8",
    brvba: "\xA6",
    brvbar: "\xA6",
    bscr: "\uD835\uDCB7",
    bsemi: "\u204F",
    bsim: "\u223D",
    bsime: "\u22CD",
    bsol: "\\",
    bsolb: "\u29C5",
    bsolhsub: "\u27C8",
    bull: "\u2022",
    bullet: "\u2022",
    bump: "\u224E",
    bumpE: "\u2AAE",
    bumpe: "\u224F",
    bumpeq: "\u224F",
    cacute: "\u0107",
    cap: "\u2229",
    capand: "\u2A44",
    capbrcup: "\u2A49",
    capcap: "\u2A4B",
    capcup: "\u2A47",
    capdot: "\u2A40",
    caps: "\u2229\uFE00",
    caret: "\u2041",
    caron: "\u02C7",
    ccaps: "\u2A4D",
    ccaron: "\u010D",
    ccedi: "\xE7",
    ccedil: "\xE7",
    ccirc: "\u0109",
    ccups: "\u2A4C",
    ccupssm: "\u2A50",
    cdot: "\u010B",
    cedi: "\xB8",
    cedil: "\xB8",
    cemptyv: "\u29B2",
    cen: "\xA2",
    cent: "\xA2",
    centerdot: "\xB7",
    cfr: "\uD835\uDD20",
    chcy: "\u0447",
    check: "\u2713",
    checkmark: "\u2713",
    chi: "\u03C7",
    cir: "\u25CB",
    cirE: "\u29C3",
    circ: "\u02C6",
    circeq: "\u2257",
    circlearrowleft: "\u21BA",
    circlearrowright: "\u21BB",
    circledR: "\xAE",
    circledS: "\u24C8",
    circledast: "\u229B",
    circledcirc: "\u229A",
    circleddash: "\u229D",
    cire: "\u2257",
    cirfnint: "\u2A10",
    cirmid: "\u2AEF",
    cirscir: "\u29C2",
    clubs: "\u2663",
    clubsuit: "\u2663",
    colon: ":",
    colone: "\u2254",
    coloneq: "\u2254",
    comma: ",",
    commat: "@",
    comp: "\u2201",
    compfn: "\u2218",
    complement: "\u2201",
    complexes: "\u2102",
    cong: "\u2245",
    congdot: "\u2A6D",
    conint: "\u222E",
    copf: "\uD835\uDD54",
    coprod: "\u2210",
    cop: "\xA9",
    copy: "\xA9",
    copysr: "\u2117",
    crarr: "\u21B5",
    cross: "\u2717",
    cscr: "\uD835\uDCB8",
    csub: "\u2ACF",
    csube: "\u2AD1",
    csup: "\u2AD0",
    csupe: "\u2AD2",
    ctdot: "\u22EF",
    cudarrl: "\u2938",
    cudarrr: "\u2935",
    cuepr: "\u22DE",
    cuesc: "\u22DF",
    cularr: "\u21B6",
    cularrp: "\u293D",
    cup: "\u222A",
    cupbrcap: "\u2A48",
    cupcap: "\u2A46",
    cupcup: "\u2A4A",
    cupdot: "\u228D",
    cupor: "\u2A45",
    cups: "\u222A\uFE00",
    curarr: "\u21B7",
    curarrm: "\u293C",
    curlyeqprec: "\u22DE",
    curlyeqsucc: "\u22DF",
    curlyvee: "\u22CE",
    curlywedge: "\u22CF",
    curre: "\xA4",
    curren: "\xA4",
    curvearrowleft: "\u21B6",
    curvearrowright: "\u21B7",
    cuvee: "\u22CE",
    cuwed: "\u22CF",
    cwconint: "\u2232",
    cwint: "\u2231",
    cylcty: "\u232D",
    dArr: "\u21D3",
    dHar: "\u2965",
    dagger: "\u2020",
    daleth: "\u2138",
    darr: "\u2193",
    dash: "\u2010",
    dashv: "\u22A3",
    dbkarow: "\u290F",
    dblac: "\u02DD",
    dcaron: "\u010F",
    dcy: "\u0434",
    dd: "\u2146",
    ddagger: "\u2021",
    ddarr: "\u21CA",
    ddotseq: "\u2A77",
    de: "\xB0",
    deg: "\xB0",
    delta: "\u03B4",
    demptyv: "\u29B1",
    dfisht: "\u297F",
    dfr: "\uD835\uDD21",
    dharl: "\u21C3",
    dharr: "\u21C2",
    diam: "\u22C4",
    diamond: "\u22C4",
    diamondsuit: "\u2666",
    diams: "\u2666",
    die: "\xA8",
    digamma: "\u03DD",
    disin: "\u22F2",
    div: "\xF7",
    divid: "\xF7",
    divide: "\xF7",
    divideontimes: "\u22C7",
    divonx: "\u22C7",
    djcy: "\u0452",
    dlcorn: "\u231E",
    dlcrop: "\u230D",
    dollar: "$",
    dopf: "\uD835\uDD55",
    dot: "\u02D9",
    doteq: "\u2250",
    doteqdot: "\u2251",
    dotminus: "\u2238",
    dotplus: "\u2214",
    dotsquare: "\u22A1",
    doublebarwedge: "\u2306",
    downarrow: "\u2193",
    downdownarrows: "\u21CA",
    downharpoonleft: "\u21C3",
    downharpoonright: "\u21C2",
    drbkarow: "\u2910",
    drcorn: "\u231F",
    drcrop: "\u230C",
    dscr: "\uD835\uDCB9",
    dscy: "\u0455",
    dsol: "\u29F6",
    dstrok: "\u0111",
    dtdot: "\u22F1",
    dtri: "\u25BF",
    dtrif: "\u25BE",
    duarr: "\u21F5",
    duhar: "\u296F",
    dwangle: "\u29A6",
    dzcy: "\u045F",
    dzigrarr: "\u27FF",
    eDDot: "\u2A77",
    eDot: "\u2251",
    eacut: "\xE9",
    eacute: "\xE9",
    easter: "\u2A6E",
    ecaron: "\u011B",
    ecir: "\xEA",
    ecirc: "\xEA",
    ecolon: "\u2255",
    ecy: "\u044D",
    edot: "\u0117",
    ee: "\u2147",
    efDot: "\u2252",
    efr: "\uD835\uDD22",
    eg: "\u2A9A",
    egrav: "\xE8",
    egrave: "\xE8",
    egs: "\u2A96",
    egsdot: "\u2A98",
    el: "\u2A99",
    elinters: "\u23E7",
    ell: "\u2113",
    els: "\u2A95",
    elsdot: "\u2A97",
    emacr: "\u0113",
    empty: "\u2205",
    emptyset: "\u2205",
    emptyv: "\u2205",
    emsp13: "\u2004",
    emsp14: "\u2005",
    emsp: "\u2003",
    eng: "\u014B",
    ensp: "\u2002",
    eogon: "\u0119",
    eopf: "\uD835\uDD56",
    epar: "\u22D5",
    eparsl: "\u29E3",
    eplus: "\u2A71",
    epsi: "\u03B5",
    epsilon: "\u03B5",
    epsiv: "\u03F5",
    eqcirc: "\u2256",
    eqcolon: "\u2255",
    eqsim: "\u2242",
    eqslantgtr: "\u2A96",
    eqslantless: "\u2A95",
    equals: "=",
    equest: "\u225F",
    equiv: "\u2261",
    equivDD: "\u2A78",
    eqvparsl: "\u29E5",
    erDot: "\u2253",
    erarr: "\u2971",
    escr: "\u212F",
    esdot: "\u2250",
    esim: "\u2242",
    eta: "\u03B7",
    et: "\xF0",
    eth: "\xF0",
    eum: "\xEB",
    euml: "\xEB",
    euro: "\u20AC",
    excl: "!",
    exist: "\u2203",
    expectation: "\u2130",
    exponentiale: "\u2147",
    fallingdotseq: "\u2252",
    fcy: "\u0444",
    female: "\u2640",
    ffilig: "\uFB03",
    fflig: "\uFB00",
    ffllig: "\uFB04",
    ffr: "\uD835\uDD23",
    filig: "\uFB01",
    fjlig: "fj",
    flat: "\u266D",
    fllig: "\uFB02",
    fltns: "\u25B1",
    fnof: "\u0192",
    fopf: "\uD835\uDD57",
    forall: "\u2200",
    fork: "\u22D4",
    forkv: "\u2AD9",
    fpartint: "\u2A0D",
    frac1: "\xBC",
    frac12: "\xBD",
    frac13: "\u2153",
    frac14: "\xBC",
    frac15: "\u2155",
    frac16: "\u2159",
    frac18: "\u215B",
    frac23: "\u2154",
    frac25: "\u2156",
    frac3: "\xBE",
    frac34: "\xBE",
    frac35: "\u2157",
    frac38: "\u215C",
    frac45: "\u2158",
    frac56: "\u215A",
    frac58: "\u215D",
    frac78: "\u215E",
    frasl: "\u2044",
    frown: "\u2322",
    fscr: "\uD835\uDCBB",
    gE: "\u2267",
    gEl: "\u2A8C",
    gacute: "\u01F5",
    gamma: "\u03B3",
    gammad: "\u03DD",
    gap: "\u2A86",
    gbreve: "\u011F",
    gcirc: "\u011D",
    gcy: "\u0433",
    gdot: "\u0121",
    ge: "\u2265",
    gel: "\u22DB",
    geq: "\u2265",
    geqq: "\u2267",
    geqslant: "\u2A7E",
    ges: "\u2A7E",
    gescc: "\u2AA9",
    gesdot: "\u2A80",
    gesdoto: "\u2A82",
    gesdotol: "\u2A84",
    gesl: "\u22DB\uFE00",
    gesles: "\u2A94",
    gfr: "\uD835\uDD24",
    gg: "\u226B",
    ggg: "\u22D9",
    gimel: "\u2137",
    gjcy: "\u0453",
    gl: "\u2277",
    glE: "\u2A92",
    gla: "\u2AA5",
    glj: "\u2AA4",
    gnE: "\u2269",
    gnap: "\u2A8A",
    gnapprox: "\u2A8A",
    gne: "\u2A88",
    gneq: "\u2A88",
    gneqq: "\u2269",
    gnsim: "\u22E7",
    gopf: "\uD835\uDD58",
    grave: "`",
    gscr: "\u210A",
    gsim: "\u2273",
    gsime: "\u2A8E",
    gsiml: "\u2A90",
    g: ">",
    gt: ">",
    gtcc: "\u2AA7",
    gtcir: "\u2A7A",
    gtdot: "\u22D7",
    gtlPar: "\u2995",
    gtquest: "\u2A7C",
    gtrapprox: "\u2A86",
    gtrarr: "\u2978",
    gtrdot: "\u22D7",
    gtreqless: "\u22DB",
    gtreqqless: "\u2A8C",
    gtrless: "\u2277",
    gtrsim: "\u2273",
    gvertneqq: "\u2269\uFE00",
    gvnE: "\u2269\uFE00",
    hArr: "\u21D4",
    hairsp: "\u200A",
    half: "\xBD",
    hamilt: "\u210B",
    hardcy: "\u044A",
    harr: "\u2194",
    harrcir: "\u2948",
    harrw: "\u21AD",
    hbar: "\u210F",
    hcirc: "\u0125",
    hearts: "\u2665",
    heartsuit: "\u2665",
    hellip: "\u2026",
    hercon: "\u22B9",
    hfr: "\uD835\uDD25",
    hksearow: "\u2925",
    hkswarow: "\u2926",
    hoarr: "\u21FF",
    homtht: "\u223B",
    hookleftarrow: "\u21A9",
    hookrightarrow: "\u21AA",
    hopf: "\uD835\uDD59",
    horbar: "\u2015",
    hscr: "\uD835\uDCBD",
    hslash: "\u210F",
    hstrok: "\u0127",
    hybull: "\u2043",
    hyphen: "\u2010",
    iacut: "\xED",
    iacute: "\xED",
    ic: "\u2063",
    icir: "\xEE",
    icirc: "\xEE",
    icy: "\u0438",
    iecy: "\u0435",
    iexc: "\xA1",
    iexcl: "\xA1",
    iff: "\u21D4",
    ifr: "\uD835\uDD26",
    igrav: "\xEC",
    igrave: "\xEC",
    ii: "\u2148",
    iiiint: "\u2A0C",
    iiint: "\u222D",
    iinfin: "\u29DC",
    iiota: "\u2129",
    ijlig: "\u0133",
    imacr: "\u012B",
    image: "\u2111",
    imagline: "\u2110",
    imagpart: "\u2111",
    imath: "\u0131",
    imof: "\u22B7",
    imped: "\u01B5",
    in: "\u2208",
    incare: "\u2105",
    infin: "\u221E",
    infintie: "\u29DD",
    inodot: "\u0131",
    int: "\u222B",
    intcal: "\u22BA",
    integers: "\u2124",
    intercal: "\u22BA",
    intlarhk: "\u2A17",
    intprod: "\u2A3C",
    iocy: "\u0451",
    iogon: "\u012F",
    iopf: "\uD835\uDD5A",
    iota: "\u03B9",
    iprod: "\u2A3C",
    iques: "\xBF",
    iquest: "\xBF",
    iscr: "\uD835\uDCBE",
    isin: "\u2208",
    isinE: "\u22F9",
    isindot: "\u22F5",
    isins: "\u22F4",
    isinsv: "\u22F3",
    isinv: "\u2208",
    it: "\u2062",
    itilde: "\u0129",
    iukcy: "\u0456",
    ium: "\xEF",
    iuml: "\xEF",
    jcirc: "\u0135",
    jcy: "\u0439",
    jfr: "\uD835\uDD27",
    jmath: "\u0237",
    jopf: "\uD835\uDD5B",
    jscr: "\uD835\uDCBF",
    jsercy: "\u0458",
    jukcy: "\u0454",
    kappa: "\u03BA",
    kappav: "\u03F0",
    kcedil: "\u0137",
    kcy: "\u043A",
    kfr: "\uD835\uDD28",
    kgreen: "\u0138",
    khcy: "\u0445",
    kjcy: "\u045C",
    kopf: "\uD835\uDD5C",
    kscr: "\uD835\uDCC0",
    lAarr: "\u21DA",
    lArr: "\u21D0",
    lAtail: "\u291B",
    lBarr: "\u290E",
    lE: "\u2266",
    lEg: "\u2A8B",
    lHar: "\u2962",
    lacute: "\u013A",
    laemptyv: "\u29B4",
    lagran: "\u2112",
    lambda: "\u03BB",
    lang: "\u27E8",
    langd: "\u2991",
    langle: "\u27E8",
    lap: "\u2A85",
    laqu: "\xAB",
    laquo: "\xAB",
    larr: "\u2190",
    larrb: "\u21E4",
    larrbfs: "\u291F",
    larrfs: "\u291D",
    larrhk: "\u21A9",
    larrlp: "\u21AB",
    larrpl: "\u2939",
    larrsim: "\u2973",
    larrtl: "\u21A2",
    lat: "\u2AAB",
    latail: "\u2919",
    late: "\u2AAD",
    lates: "\u2AAD\uFE00",
    lbarr: "\u290C",
    lbbrk: "\u2772",
    lbrace: "{",
    lbrack: "[",
    lbrke: "\u298B",
    lbrksld: "\u298F",
    lbrkslu: "\u298D",
    lcaron: "\u013E",
    lcedil: "\u013C",
    lceil: "\u2308",
    lcub: "{",
    lcy: "\u043B",
    ldca: "\u2936",
    ldquo: "\u201C",
    ldquor: "\u201E",
    ldrdhar: "\u2967",
    ldrushar: "\u294B",
    ldsh: "\u21B2",
    le: "\u2264",
    leftarrow: "\u2190",
    leftarrowtail: "\u21A2",
    leftharpoondown: "\u21BD",
    leftharpoonup: "\u21BC",
    leftleftarrows: "\u21C7",
    leftrightarrow: "\u2194",
    leftrightarrows: "\u21C6",
    leftrightharpoons: "\u21CB",
    leftrightsquigarrow: "\u21AD",
    leftthreetimes: "\u22CB",
    leg: "\u22DA",
    leq: "\u2264",
    leqq: "\u2266",
    leqslant: "\u2A7D",
    les: "\u2A7D",
    lescc: "\u2AA8",
    lesdot: "\u2A7F",
    lesdoto: "\u2A81",
    lesdotor: "\u2A83",
    lesg: "\u22DA\uFE00",
    lesges: "\u2A93",
    lessapprox: "\u2A85",
    lessdot: "\u22D6",
    lesseqgtr: "\u22DA",
    lesseqqgtr: "\u2A8B",
    lessgtr: "\u2276",
    lesssim: "\u2272",
    lfisht: "\u297C",
    lfloor: "\u230A",
    lfr: "\uD835\uDD29",
    lg: "\u2276",
    lgE: "\u2A91",
    lhard: "\u21BD",
    lharu: "\u21BC",
    lharul: "\u296A",
    lhblk: "\u2584",
    ljcy: "\u0459",
    ll: "\u226A",
    llarr: "\u21C7",
    llcorner: "\u231E",
    llhard: "\u296B",
    lltri: "\u25FA",
    lmidot: "\u0140",
    lmoust: "\u23B0",
    lmoustache: "\u23B0",
    lnE: "\u2268",
    lnap: "\u2A89",
    lnapprox: "\u2A89",
    lne: "\u2A87",
    lneq: "\u2A87",
    lneqq: "\u2268",
    lnsim: "\u22E6",
    loang: "\u27EC",
    loarr: "\u21FD",
    lobrk: "\u27E6",
    longleftarrow: "\u27F5",
    longleftrightarrow: "\u27F7",
    longmapsto: "\u27FC",
    longrightarrow: "\u27F6",
    looparrowleft: "\u21AB",
    looparrowright: "\u21AC",
    lopar: "\u2985",
    lopf: "\uD835\uDD5D",
    loplus: "\u2A2D",
    lotimes: "\u2A34",
    lowast: "\u2217",
    lowbar: "_",
    loz: "\u25CA",
    lozenge: "\u25CA",
    lozf: "\u29EB",
    lpar: "(",
    lparlt: "\u2993",
    lrarr: "\u21C6",
    lrcorner: "\u231F",
    lrhar: "\u21CB",
    lrhard: "\u296D",
    lrm: "\u200E",
    lrtri: "\u22BF",
    lsaquo: "\u2039",
    lscr: "\uD835\uDCC1",
    lsh: "\u21B0",
    lsim: "\u2272",
    lsime: "\u2A8D",
    lsimg: "\u2A8F",
    lsqb: "[",
    lsquo: "\u2018",
    lsquor: "\u201A",
    lstrok: "\u0142",
    l: "<",
    lt: "<",
    ltcc: "\u2AA6",
    ltcir: "\u2A79",
    ltdot: "\u22D6",
    lthree: "\u22CB",
    ltimes: "\u22C9",
    ltlarr: "\u2976",
    ltquest: "\u2A7B",
    ltrPar: "\u2996",
    ltri: "\u25C3",
    ltrie: "\u22B4",
    ltrif: "\u25C2",
    lurdshar: "\u294A",
    luruhar: "\u2966",
    lvertneqq: "\u2268\uFE00",
    lvnE: "\u2268\uFE00",
    mDDot: "\u223A",
    mac: "\xAF",
    macr: "\xAF",
    male: "\u2642",
    malt: "\u2720",
    maltese: "\u2720",
    map: "\u21A6",
    mapsto: "\u21A6",
    mapstodown: "\u21A7",
    mapstoleft: "\u21A4",
    mapstoup: "\u21A5",
    marker: "\u25AE",
    mcomma: "\u2A29",
    mcy: "\u043C",
    mdash: "\u2014",
    measuredangle: "\u2221",
    mfr: "\uD835\uDD2A",
    mho: "\u2127",
    micr: "\xB5",
    micro: "\xB5",
    mid: "\u2223",
    midast: "*",
    midcir: "\u2AF0",
    middo: "\xB7",
    middot: "\xB7",
    minus: "\u2212",
    minusb: "\u229F",
    minusd: "\u2238",
    minusdu: "\u2A2A",
    mlcp: "\u2ADB",
    mldr: "\u2026",
    mnplus: "\u2213",
    models: "\u22A7",
    mopf: "\uD835\uDD5E",
    mp: "\u2213",
    mscr: "\uD835\uDCC2",
    mstpos: "\u223E",
    mu: "\u03BC",
    multimap: "\u22B8",
    mumap: "\u22B8",
    nGg: "\u22D9\u0338",
    nGt: "\u226B\u20D2",
    nGtv: "\u226B\u0338",
    nLeftarrow: "\u21CD",
    nLeftrightarrow: "\u21CE",
    nLl: "\u22D8\u0338",
    nLt: "\u226A\u20D2",
    nLtv: "\u226A\u0338",
    nRightarrow: "\u21CF",
    nVDash: "\u22AF",
    nVdash: "\u22AE",
    nabla: "\u2207",
    nacute: "\u0144",
    nang: "\u2220\u20D2",
    nap: "\u2249",
    napE: "\u2A70\u0338",
    napid: "\u224B\u0338",
    napos: "\u0149",
    napprox: "\u2249",
    natur: "\u266E",
    natural: "\u266E",
    naturals: "\u2115",
    nbs: "\xA0",
    nbsp: "\xA0",
    nbump: "\u224E\u0338",
    nbumpe: "\u224F\u0338",
    ncap: "\u2A43",
    ncaron: "\u0148",
    ncedil: "\u0146",
    ncong: "\u2247",
    ncongdot: "\u2A6D\u0338",
    ncup: "\u2A42",
    ncy: "\u043D",
    ndash: "\u2013",
    ne: "\u2260",
    neArr: "\u21D7",
    nearhk: "\u2924",
    nearr: "\u2197",
    nearrow: "\u2197",
    nedot: "\u2250\u0338",
    nequiv: "\u2262",
    nesear: "\u2928",
    nesim: "\u2242\u0338",
    nexist: "\u2204",
    nexists: "\u2204",
    nfr: "\uD835\uDD2B",
    ngE: "\u2267\u0338",
    nge: "\u2271",
    ngeq: "\u2271",
    ngeqq: "\u2267\u0338",
    ngeqslant: "\u2A7E\u0338",
    nges: "\u2A7E\u0338",
    ngsim: "\u2275",
    ngt: "\u226F",
    ngtr: "\u226F",
    nhArr: "\u21CE",
    nharr: "\u21AE",
    nhpar: "\u2AF2",
    ni: "\u220B",
    nis: "\u22FC",
    nisd: "\u22FA",
    niv: "\u220B",
    njcy: "\u045A",
    nlArr: "\u21CD",
    nlE: "\u2266\u0338",
    nlarr: "\u219A",
    nldr: "\u2025",
    nle: "\u2270",
    nleftarrow: "\u219A",
    nleftrightarrow: "\u21AE",
    nleq: "\u2270",
    nleqq: "\u2266\u0338",
    nleqslant: "\u2A7D\u0338",
    nles: "\u2A7D\u0338",
    nless: "\u226E",
    nlsim: "\u2274",
    nlt: "\u226E",
    nltri: "\u22EA",
    nltrie: "\u22EC",
    nmid: "\u2224",
    nopf: "\uD835\uDD5F",
    no: "\xAC",
    not: "\xAC",
    notin: "\u2209",
    notinE: "\u22F9\u0338",
    notindot: "\u22F5\u0338",
    notinva: "\u2209",
    notinvb: "\u22F7",
    notinvc: "\u22F6",
    notni: "\u220C",
    notniva: "\u220C",
    notnivb: "\u22FE",
    notnivc: "\u22FD",
    npar: "\u2226",
    nparallel: "\u2226",
    nparsl: "\u2AFD\u20E5",
    npart: "\u2202\u0338",
    npolint: "\u2A14",
    npr: "\u2280",
    nprcue: "\u22E0",
    npre: "\u2AAF\u0338",
    nprec: "\u2280",
    npreceq: "\u2AAF\u0338",
    nrArr: "\u21CF",
    nrarr: "\u219B",
    nrarrc: "\u2933\u0338",
    nrarrw: "\u219D\u0338",
    nrightarrow: "\u219B",
    nrtri: "\u22EB",
    nrtrie: "\u22ED",
    nsc: "\u2281",
    nsccue: "\u22E1",
    nsce: "\u2AB0\u0338",
    nscr: "\uD835\uDCC3",
    nshortmid: "\u2224",
    nshortparallel: "\u2226",
    nsim: "\u2241",
    nsime: "\u2244",
    nsimeq: "\u2244",
    nsmid: "\u2224",
    nspar: "\u2226",
    nsqsube: "\u22E2",
    nsqsupe: "\u22E3",
    nsub: "\u2284",
    nsubE: "\u2AC5\u0338",
    nsube: "\u2288",
    nsubset: "\u2282\u20D2",
    nsubseteq: "\u2288",
    nsubseteqq: "\u2AC5\u0338",
    nsucc: "\u2281",
    nsucceq: "\u2AB0\u0338",
    nsup: "\u2285",
    nsupE: "\u2AC6\u0338",
    nsupe: "\u2289",
    nsupset: "\u2283\u20D2",
    nsupseteq: "\u2289",
    nsupseteqq: "\u2AC6\u0338",
    ntgl: "\u2279",
    ntild: "\xF1",
    ntilde: "\xF1",
    ntlg: "\u2278",
    ntriangleleft: "\u22EA",
    ntrianglelefteq: "\u22EC",
    ntriangleright: "\u22EB",
    ntrianglerighteq: "\u22ED",
    nu: "\u03BD",
    num: "#",
    numero: "\u2116",
    numsp: "\u2007",
    nvDash: "\u22AD",
    nvHarr: "\u2904",
    nvap: "\u224D\u20D2",
    nvdash: "\u22AC",
    nvge: "\u2265\u20D2",
    nvgt: ">\u20D2",
    nvinfin: "\u29DE",
    nvlArr: "\u2902",
    nvle: "\u2264\u20D2",
    nvlt: "<\u20D2",
    nvltrie: "\u22B4\u20D2",
    nvrArr: "\u2903",
    nvrtrie: "\u22B5\u20D2",
    nvsim: "\u223C\u20D2",
    nwArr: "\u21D6",
    nwarhk: "\u2923",
    nwarr: "\u2196",
    nwarrow: "\u2196",
    nwnear: "\u2927",
    oS: "\u24C8",
    oacut: "\xF3",
    oacute: "\xF3",
    oast: "\u229B",
    ocir: "\xF4",
    ocirc: "\xF4",
    ocy: "\u043E",
    odash: "\u229D",
    odblac: "\u0151",
    odiv: "\u2A38",
    odot: "\u2299",
    odsold: "\u29BC",
    oelig: "\u0153",
    ofcir: "\u29BF",
    ofr: "\uD835\uDD2C",
    ogon: "\u02DB",
    ograv: "\xF2",
    ograve: "\xF2",
    ogt: "\u29C1",
    ohbar: "\u29B5",
    ohm: "\u03A9",
    oint: "\u222E",
    olarr: "\u21BA",
    olcir: "\u29BE",
    olcross: "\u29BB",
    oline: "\u203E",
    olt: "\u29C0",
    omacr: "\u014D",
    omega: "\u03C9",
    omicron: "\u03BF",
    omid: "\u29B6",
    ominus: "\u2296",
    oopf: "\uD835\uDD60",
    opar: "\u29B7",
    operp: "\u29B9",
    oplus: "\u2295",
    or: "\u2228",
    orarr: "\u21BB",
    ord: "\xBA",
    order: "\u2134",
    orderof: "\u2134",
    ordf: "\xAA",
    ordm: "\xBA",
    origof: "\u22B6",
    oror: "\u2A56",
    orslope: "\u2A57",
    orv: "\u2A5B",
    oscr: "\u2134",
    oslas: "\xF8",
    oslash: "\xF8",
    osol: "\u2298",
    otild: "\xF5",
    otilde: "\xF5",
    otimes: "\u2297",
    otimesas: "\u2A36",
    oum: "\xF6",
    ouml: "\xF6",
    ovbar: "\u233D",
    par: "\xB6",
    para: "\xB6",
    parallel: "\u2225",
    parsim: "\u2AF3",
    parsl: "\u2AFD",
    part: "\u2202",
    pcy: "\u043F",
    percnt: "%",
    period: ".",
    permil: "\u2030",
    perp: "\u22A5",
    pertenk: "\u2031",
    pfr: "\uD835\uDD2D",
    phi: "\u03C6",
    phiv: "\u03D5",
    phmmat: "\u2133",
    phone: "\u260E",
    pi: "\u03C0",
    pitchfork: "\u22D4",
    piv: "\u03D6",
    planck: "\u210F",
    planckh: "\u210E",
    plankv: "\u210F",
    plus: "+",
    plusacir: "\u2A23",
    plusb: "\u229E",
    pluscir: "\u2A22",
    plusdo: "\u2214",
    plusdu: "\u2A25",
    pluse: "\u2A72",
    plusm: "\xB1",
    plusmn: "\xB1",
    plussim: "\u2A26",
    plustwo: "\u2A27",
    pm: "\xB1",
    pointint: "\u2A15",
    popf: "\uD835\uDD61",
    poun: "\xA3",
    pound: "\xA3",
    pr: "\u227A",
    prE: "\u2AB3",
    prap: "\u2AB7",
    prcue: "\u227C",
    pre: "\u2AAF",
    prec: "\u227A",
    precapprox: "\u2AB7",
    preccurlyeq: "\u227C",
    preceq: "\u2AAF",
    precnapprox: "\u2AB9",
    precneqq: "\u2AB5",
    precnsim: "\u22E8",
    precsim: "\u227E",
    prime: "\u2032",
    primes: "\u2119",
    prnE: "\u2AB5",
    prnap: "\u2AB9",
    prnsim: "\u22E8",
    prod: "\u220F",
    profalar: "\u232E",
    profline: "\u2312",
    profsurf: "\u2313",
    prop: "\u221D",
    propto: "\u221D",
    prsim: "\u227E",
    prurel: "\u22B0",
    pscr: "\uD835\uDCC5",
    psi: "\u03C8",
    puncsp: "\u2008",
    qfr: "\uD835\uDD2E",
    qint: "\u2A0C",
    qopf: "\uD835\uDD62",
    qprime: "\u2057",
    qscr: "\uD835\uDCC6",
    quaternions: "\u210D",
    quatint: "\u2A16",
    quest: "?",
    questeq: "\u225F",
    quo: '"',
    quot: '"',
    rAarr: "\u21DB",
    rArr: "\u21D2",
    rAtail: "\u291C",
    rBarr: "\u290F",
    rHar: "\u2964",
    race: "\u223D\u0331",
    racute: "\u0155",
    radic: "\u221A",
    raemptyv: "\u29B3",
    rang: "\u27E9",
    rangd: "\u2992",
    range: "\u29A5",
    rangle: "\u27E9",
    raqu: "\xBB",
    raquo: "\xBB",
    rarr: "\u2192",
    rarrap: "\u2975",
    rarrb: "\u21E5",
    rarrbfs: "\u2920",
    rarrc: "\u2933",
    rarrfs: "\u291E",
    rarrhk: "\u21AA",
    rarrlp: "\u21AC",
    rarrpl: "\u2945",
    rarrsim: "\u2974",
    rarrtl: "\u21A3",
    rarrw: "\u219D",
    ratail: "\u291A",
    ratio: "\u2236",
    rationals: "\u211A",
    rbarr: "\u290D",
    rbbrk: "\u2773",
    rbrace: "}",
    rbrack: "]",
    rbrke: "\u298C",
    rbrksld: "\u298E",
    rbrkslu: "\u2990",
    rcaron: "\u0159",
    rcedil: "\u0157",
    rceil: "\u2309",
    rcub: "}",
    rcy: "\u0440",
    rdca: "\u2937",
    rdldhar: "\u2969",
    rdquo: "\u201D",
    rdquor: "\u201D",
    rdsh: "\u21B3",
    real: "\u211C",
    realine: "\u211B",
    realpart: "\u211C",
    reals: "\u211D",
    rect: "\u25AD",
    re: "\xAE",
    reg: "\xAE",
    rfisht: "\u297D",
    rfloor: "\u230B",
    rfr: "\uD835\uDD2F",
    rhard: "\u21C1",
    rharu: "\u21C0",
    rharul: "\u296C",
    rho: "\u03C1",
    rhov: "\u03F1",
    rightarrow: "\u2192",
    rightarrowtail: "\u21A3",
    rightharpoondown: "\u21C1",
    rightharpoonup: "\u21C0",
    rightleftarrows: "\u21C4",
    rightleftharpoons: "\u21CC",
    rightrightarrows: "\u21C9",
    rightsquigarrow: "\u219D",
    rightthreetimes: "\u22CC",
    ring: "\u02DA",
    risingdotseq: "\u2253",
    rlarr: "\u21C4",
    rlhar: "\u21CC",
    rlm: "\u200F",
    rmoust: "\u23B1",
    rmoustache: "\u23B1",
    rnmid: "\u2AEE",
    roang: "\u27ED",
    roarr: "\u21FE",
    robrk: "\u27E7",
    ropar: "\u2986",
    ropf: "\uD835\uDD63",
    roplus: "\u2A2E",
    rotimes: "\u2A35",
    rpar: ")",
    rpargt: "\u2994",
    rppolint: "\u2A12",
    rrarr: "\u21C9",
    rsaquo: "\u203A",
    rscr: "\uD835\uDCC7",
    rsh: "\u21B1",
    rsqb: "]",
    rsquo: "\u2019",
    rsquor: "\u2019",
    rthree: "\u22CC",
    rtimes: "\u22CA",
    rtri: "\u25B9",
    rtrie: "\u22B5",
    rtrif: "\u25B8",
    rtriltri: "\u29CE",
    ruluhar: "\u2968",
    rx: "\u211E",
    sacute: "\u015B",
    sbquo: "\u201A",
    sc: "\u227B",
    scE: "\u2AB4",
    scap: "\u2AB8",
    scaron: "\u0161",
    sccue: "\u227D",
    sce: "\u2AB0",
    scedil: "\u015F",
    scirc: "\u015D",
    scnE: "\u2AB6",
    scnap: "\u2ABA",
    scnsim: "\u22E9",
    scpolint: "\u2A13",
    scsim: "\u227F",
    scy: "\u0441",
    sdot: "\u22C5",
    sdotb: "\u22A1",
    sdote: "\u2A66",
    seArr: "\u21D8",
    searhk: "\u2925",
    searr: "\u2198",
    searrow: "\u2198",
    sec: "\xA7",
    sect: "\xA7",
    semi: ";",
    seswar: "\u2929",
    setminus: "\u2216",
    setmn: "\u2216",
    sext: "\u2736",
    sfr: "\uD835\uDD30",
    sfrown: "\u2322",
    sharp: "\u266F",
    shchcy: "\u0449",
    shcy: "\u0448",
    shortmid: "\u2223",
    shortparallel: "\u2225",
    sh: "\xAD",
    shy: "\xAD",
    sigma: "\u03C3",
    sigmaf: "\u03C2",
    sigmav: "\u03C2",
    sim: "\u223C",
    simdot: "\u2A6A",
    sime: "\u2243",
    simeq: "\u2243",
    simg: "\u2A9E",
    simgE: "\u2AA0",
    siml: "\u2A9D",
    simlE: "\u2A9F",
    simne: "\u2246",
    simplus: "\u2A24",
    simrarr: "\u2972",
    slarr: "\u2190",
    smallsetminus: "\u2216",
    smashp: "\u2A33",
    smeparsl: "\u29E4",
    smid: "\u2223",
    smile: "\u2323",
    smt: "\u2AAA",
    smte: "\u2AAC",
    smtes: "\u2AAC\uFE00",
    softcy: "\u044C",
    sol: "/",
    solb: "\u29C4",
    solbar: "\u233F",
    sopf: "\uD835\uDD64",
    spades: "\u2660",
    spadesuit: "\u2660",
    spar: "\u2225",
    sqcap: "\u2293",
    sqcaps: "\u2293\uFE00",
    sqcup: "\u2294",
    sqcups: "\u2294\uFE00",
    sqsub: "\u228F",
    sqsube: "\u2291",
    sqsubset: "\u228F",
    sqsubseteq: "\u2291",
    sqsup: "\u2290",
    sqsupe: "\u2292",
    sqsupset: "\u2290",
    sqsupseteq: "\u2292",
    squ: "\u25A1",
    square: "\u25A1",
    squarf: "\u25AA",
    squf: "\u25AA",
    srarr: "\u2192",
    sscr: "\uD835\uDCC8",
    ssetmn: "\u2216",
    ssmile: "\u2323",
    sstarf: "\u22C6",
    star: "\u2606",
    starf: "\u2605",
    straightepsilon: "\u03F5",
    straightphi: "\u03D5",
    strns: "\xAF",
    sub: "\u2282",
    subE: "\u2AC5",
    subdot: "\u2ABD",
    sube: "\u2286",
    subedot: "\u2AC3",
    submult: "\u2AC1",
    subnE: "\u2ACB",
    subne: "\u228A",
    subplus: "\u2ABF",
    subrarr: "\u2979",
    subset: "\u2282",
    subseteq: "\u2286",
    subseteqq: "\u2AC5",
    subsetneq: "\u228A",
    subsetneqq: "\u2ACB",
    subsim: "\u2AC7",
    subsub: "\u2AD5",
    subsup: "\u2AD3",
    succ: "\u227B",
    succapprox: "\u2AB8",
    succcurlyeq: "\u227D",
    succeq: "\u2AB0",
    succnapprox: "\u2ABA",
    succneqq: "\u2AB6",
    succnsim: "\u22E9",
    succsim: "\u227F",
    sum: "\u2211",
    sung: "\u266A",
    sup: "\u2283",
    sup1: "\xB9",
    sup2: "\xB2",
    sup3: "\xB3",
    supE: "\u2AC6",
    supdot: "\u2ABE",
    supdsub: "\u2AD8",
    supe: "\u2287",
    supedot: "\u2AC4",
    suphsol: "\u27C9",
    suphsub: "\u2AD7",
    suplarr: "\u297B",
    supmult: "\u2AC2",
    supnE: "\u2ACC",
    supne: "\u228B",
    supplus: "\u2AC0",
    supset: "\u2283",
    supseteq: "\u2287",
    supseteqq: "\u2AC6",
    supsetneq: "\u228B",
    supsetneqq: "\u2ACC",
    supsim: "\u2AC8",
    supsub: "\u2AD4",
    supsup: "\u2AD6",
    swArr: "\u21D9",
    swarhk: "\u2926",
    swarr: "\u2199",
    swarrow: "\u2199",
    swnwar: "\u292A",
    szli: "\xDF",
    szlig: "\xDF",
    target: "\u2316",
    tau: "\u03C4",
    tbrk: "\u23B4",
    tcaron: "\u0165",
    tcedil: "\u0163",
    tcy: "\u0442",
    tdot: "\u20DB",
    telrec: "\u2315",
    tfr: "\uD835\uDD31",
    there4: "\u2234",
    therefore: "\u2234",
    theta: "\u03B8",
    thetasym: "\u03D1",
    thetav: "\u03D1",
    thickapprox: "\u2248",
    thicksim: "\u223C",
    thinsp: "\u2009",
    thkap: "\u2248",
    thksim: "\u223C",
    thor: "\xFE",
    thorn: "\xFE",
    tilde: "\u02DC",
    time: "\xD7",
    times: "\xD7",
    timesb: "\u22A0",
    timesbar: "\u2A31",
    timesd: "\u2A30",
    tint: "\u222D",
    toea: "\u2928",
    top: "\u22A4",
    topbot: "\u2336",
    topcir: "\u2AF1",
    topf: "\uD835\uDD65",
    topfork: "\u2ADA",
    tosa: "\u2929",
    tprime: "\u2034",
    trade: "\u2122",
    triangle: "\u25B5",
    triangledown: "\u25BF",
    triangleleft: "\u25C3",
    trianglelefteq: "\u22B4",
    triangleq: "\u225C",
    triangleright: "\u25B9",
    trianglerighteq: "\u22B5",
    tridot: "\u25EC",
    trie: "\u225C",
    triminus: "\u2A3A",
    triplus: "\u2A39",
    trisb: "\u29CD",
    tritime: "\u2A3B",
    trpezium: "\u23E2",
    tscr: "\uD835\uDCC9",
    tscy: "\u0446",
    tshcy: "\u045B",
    tstrok: "\u0167",
    twixt: "\u226C",
    twoheadleftarrow: "\u219E",
    twoheadrightarrow: "\u21A0",
    uArr: "\u21D1",
    uHar: "\u2963",
    uacut: "\xFA",
    uacute: "\xFA",
    uarr: "\u2191",
    ubrcy: "\u045E",
    ubreve: "\u016D",
    ucir: "\xFB",
    ucirc: "\xFB",
    ucy: "\u0443",
    udarr: "\u21C5",
    udblac: "\u0171",
    udhar: "\u296E",
    ufisht: "\u297E",
    ufr: "\uD835\uDD32",
    ugrav: "\xF9",
    ugrave: "\xF9",
    uharl: "\u21BF",
    uharr: "\u21BE",
    uhblk: "\u2580",
    ulcorn: "\u231C",
    ulcorner: "\u231C",
    ulcrop: "\u230F",
    ultri: "\u25F8",
    umacr: "\u016B",
    um: "\xA8",
    uml: "\xA8",
    uogon: "\u0173",
    uopf: "\uD835\uDD66",
    uparrow: "\u2191",
    updownarrow: "\u2195",
    upharpoonleft: "\u21BF",
    upharpoonright: "\u21BE",
    uplus: "\u228E",
    upsi: "\u03C5",
    upsih: "\u03D2",
    upsilon: "\u03C5",
    upuparrows: "\u21C8",
    urcorn: "\u231D",
    urcorner: "\u231D",
    urcrop: "\u230E",
    uring: "\u016F",
    urtri: "\u25F9",
    uscr: "\uD835\uDCCA",
    utdot: "\u22F0",
    utilde: "\u0169",
    utri: "\u25B5",
    utrif: "\u25B4",
    uuarr: "\u21C8",
    uum: "\xFC",
    uuml: "\xFC",
    uwangle: "\u29A7",
    vArr: "\u21D5",
    vBar: "\u2AE8",
    vBarv: "\u2AE9",
    vDash: "\u22A8",
    vangrt: "\u299C",
    varepsilon: "\u03F5",
    varkappa: "\u03F0",
    varnothing: "\u2205",
    varphi: "\u03D5",
    varpi: "\u03D6",
    varpropto: "\u221D",
    varr: "\u2195",
    varrho: "\u03F1",
    varsigma: "\u03C2",
    varsubsetneq: "\u228A\uFE00",
    varsubsetneqq: "\u2ACB\uFE00",
    varsupsetneq: "\u228B\uFE00",
    varsupsetneqq: "\u2ACC\uFE00",
    vartheta: "\u03D1",
    vartriangleleft: "\u22B2",
    vartriangleright: "\u22B3",
    vcy: "\u0432",
    vdash: "\u22A2",
    vee: "\u2228",
    veebar: "\u22BB",
    veeeq: "\u225A",
    vellip: "\u22EE",
    verbar: "|",
    vert: "|",
    vfr: "\uD835\uDD33",
    vltri: "\u22B2",
    vnsub: "\u2282\u20D2",
    vnsup: "\u2283\u20D2",
    vopf: "\uD835\uDD67",
    vprop: "\u221D",
    vrtri: "\u22B3",
    vscr: "\uD835\uDCCB",
    vsubnE: "\u2ACB\uFE00",
    vsubne: "\u228A\uFE00",
    vsupnE: "\u2ACC\uFE00",
    vsupne: "\u228B\uFE00",
    vzigzag: "\u299A",
    wcirc: "\u0175",
    wedbar: "\u2A5F",
    wedge: "\u2227",
    wedgeq: "\u2259",
    weierp: "\u2118",
    wfr: "\uD835\uDD34",
    wopf: "\uD835\uDD68",
    wp: "\u2118",
    wr: "\u2240",
    wreath: "\u2240",
    wscr: "\uD835\uDCCC",
    xcap: "\u22C2",
    xcirc: "\u25EF",
    xcup: "\u22C3",
    xdtri: "\u25BD",
    xfr: "\uD835\uDD35",
    xhArr: "\u27FA",
    xharr: "\u27F7",
    xi: "\u03BE",
    xlArr: "\u27F8",
    xlarr: "\u27F5",
    xmap: "\u27FC",
    xnis: "\u22FB",
    xodot: "\u2A00",
    xopf: "\uD835\uDD69",
    xoplus: "\u2A01",
    xotime: "\u2A02",
    xrArr: "\u27F9",
    xrarr: "\u27F6",
    xscr: "\uD835\uDCCD",
    xsqcup: "\u2A06",
    xuplus: "\u2A04",
    xutri: "\u25B3",
    xvee: "\u22C1",
    xwedge: "\u22C0",
    yacut: "\xFD",
    yacute: "\xFD",
    yacy: "\u044F",
    ycirc: "\u0177",
    ycy: "\u044B",
    ye: "\xA5",
    yen: "\xA5",
    yfr: "\uD835\uDD36",
    yicy: "\u0457",
    yopf: "\uD835\uDD6A",
    yscr: "\uD835\uDCCE",
    yucy: "\u044E",
    yum: "\xFF",
    yuml: "\xFF",
    zacute: "\u017A",
    zcaron: "\u017E",
    zcy: "\u0437",
    zdot: "\u017C",
    zeetrf: "\u2128",
    zeta: "\u03B6",
    zfr: "\uD835\uDD37",
    zhcy: "\u0436",
    zigrarr: "\u21DD",
    zopf: "\uD835\uDD6B",
    zscr: "\uD835\uDCCF",
    zwj: "\u200D",
    zwnj: "\u200C"
  };
});

// node_modules/parse-entities/decode-entity.js
var require_decode_entity = __commonJS((exports, module) => {
  var characterEntities = require_character_entities();
  module.exports = decodeEntity;
  var own = {}.hasOwnProperty;
  function decodeEntity(characters) {
    return own.call(characterEntities, characters) ? characterEntities[characters] : false;
  }
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/character/ascii-digit.js
var require_ascii_digit = __commonJS((exports, module) => {
  var regexCheck = require_regex_check3();
  var asciiDigit = regexCheck(/\d/);
  module.exports = asciiDigit;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/character/ascii-hex-digit.js
var require_ascii_hex_digit = __commonJS((exports, module) => {
  var regexCheck = require_regex_check3();
  var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
  module.exports = asciiHexDigit;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/character-reference.js
var require_character_reference = __commonJS((exports, module) => {
  var decodeEntity = require_decode_entity();
  var asciiAlphanumeric = require_ascii_alphanumeric2();
  var asciiDigit = require_ascii_digit();
  var asciiHexDigit = require_ascii_hex_digit();
  function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : { default: e };
  }
  var decodeEntity__default = /* @__PURE__ */ _interopDefaultLegacy(decodeEntity);
  var characterReference = {
    name: "characterReference",
    tokenize: tokenizeCharacterReference
  };
  function tokenizeCharacterReference(effects, ok, nok) {
    var self2 = this;
    var size = 0;
    var max;
    var test;
    return start;
    function start(code) {
      effects.enter("characterReference");
      effects.enter("characterReferenceMarker");
      effects.consume(code);
      effects.exit("characterReferenceMarker");
      return open;
    }
    function open(code) {
      if (code === 35) {
        effects.enter("characterReferenceMarkerNumeric");
        effects.consume(code);
        effects.exit("characterReferenceMarkerNumeric");
        return numeric;
      }
      effects.enter("characterReferenceValue");
      max = 31;
      test = asciiAlphanumeric;
      return value(code);
    }
    function numeric(code) {
      if (code === 88 || code === 120) {
        effects.enter("characterReferenceMarkerHexadecimal");
        effects.consume(code);
        effects.exit("characterReferenceMarkerHexadecimal");
        effects.enter("characterReferenceValue");
        max = 6;
        test = asciiHexDigit;
        return value;
      }
      effects.enter("characterReferenceValue");
      max = 7;
      test = asciiDigit;
      return value(code);
    }
    function value(code) {
      var token;
      if (code === 59 && size) {
        token = effects.exit("characterReferenceValue");
        if (test === asciiAlphanumeric && !decodeEntity__default["default"](self2.sliceSerialize(token))) {
          return nok(code);
        }
        effects.enter("characterReferenceMarker");
        effects.consume(code);
        effects.exit("characterReferenceMarker");
        effects.exit("characterReference");
        return ok;
      }
      if (test(code) && size++ < max) {
        effects.consume(code);
        return value;
      }
      return nok(code);
    }
  }
  module.exports = characterReference;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/code-fenced.js
var require_code_fenced = __commonJS((exports, module) => {
  var markdownLineEnding = require_markdown_line_ending2();
  var markdownLineEndingOrSpace = require_markdown_line_ending_or_space2();
  var prefixSize = require_prefix_size2();
  var factorySpace = require_factory_space2();
  var codeFenced = {
    name: "codeFenced",
    tokenize: tokenizeCodeFenced,
    concrete: true
  };
  function tokenizeCodeFenced(effects, ok, nok) {
    var self2 = this;
    var closingFenceConstruct = {
      tokenize: tokenizeClosingFence,
      partial: true
    };
    var initialPrefix = prefixSize(this.events, "linePrefix");
    var sizeOpen = 0;
    var marker;
    return start;
    function start(code) {
      effects.enter("codeFenced");
      effects.enter("codeFencedFence");
      effects.enter("codeFencedFenceSequence");
      marker = code;
      return sequenceOpen(code);
    }
    function sequenceOpen(code) {
      if (code === marker) {
        effects.consume(code);
        sizeOpen++;
        return sequenceOpen;
      }
      effects.exit("codeFencedFenceSequence");
      return sizeOpen < 3 ? nok(code) : factorySpace(effects, infoOpen, "whitespace")(code);
    }
    function infoOpen(code) {
      if (code === null || markdownLineEnding(code)) {
        return openAfter(code);
      }
      effects.enter("codeFencedFenceInfo");
      effects.enter("chunkString", {
        contentType: "string"
      });
      return info(code);
    }
    function info(code) {
      if (code === null || markdownLineEndingOrSpace(code)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceInfo");
        return factorySpace(effects, infoAfter, "whitespace")(code);
      }
      if (code === 96 && code === marker)
        return nok(code);
      effects.consume(code);
      return info;
    }
    function infoAfter(code) {
      if (code === null || markdownLineEnding(code)) {
        return openAfter(code);
      }
      effects.enter("codeFencedFenceMeta");
      effects.enter("chunkString", {
        contentType: "string"
      });
      return meta2(code);
    }
    function meta2(code) {
      if (code === null || markdownLineEnding(code)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceMeta");
        return openAfter(code);
      }
      if (code === 96 && code === marker)
        return nok(code);
      effects.consume(code);
      return meta2;
    }
    function openAfter(code) {
      effects.exit("codeFencedFence");
      return self2.interrupt ? ok(code) : content(code);
    }
    function content(code) {
      if (code === null) {
        return after(code);
      }
      if (markdownLineEnding(code)) {
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        return effects.attempt(closingFenceConstruct, after, initialPrefix ? factorySpace(effects, content, "linePrefix", initialPrefix + 1) : content);
      }
      effects.enter("codeFlowValue");
      return contentContinue(code);
    }
    function contentContinue(code) {
      if (code === null || markdownLineEnding(code)) {
        effects.exit("codeFlowValue");
        return content(code);
      }
      effects.consume(code);
      return contentContinue;
    }
    function after(code) {
      effects.exit("codeFenced");
      return ok(code);
    }
    function tokenizeClosingFence(effects2, ok2, nok2) {
      var size = 0;
      return factorySpace(effects2, closingSequenceStart, "linePrefix", this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? undefined : 4);
      function closingSequenceStart(code) {
        effects2.enter("codeFencedFence");
        effects2.enter("codeFencedFenceSequence");
        return closingSequence(code);
      }
      function closingSequence(code) {
        if (code === marker) {
          effects2.consume(code);
          size++;
          return closingSequence;
        }
        if (size < sizeOpen)
          return nok2(code);
        effects2.exit("codeFencedFenceSequence");
        return factorySpace(effects2, closingSequenceEnd, "whitespace")(code);
      }
      function closingSequenceEnd(code) {
        if (code === null || markdownLineEnding(code)) {
          effects2.exit("codeFencedFence");
          return ok2(code);
        }
        return nok2(code);
      }
    }
  }
  module.exports = codeFenced;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/code-indented.js
var require_code_indented = __commonJS((exports, module) => {
  var markdownLineEnding = require_markdown_line_ending2();
  var chunkedSplice = require_chunked_splice2();
  var prefixSize = require_prefix_size2();
  var factorySpace = require_factory_space2();
  var codeIndented = {
    name: "codeIndented",
    tokenize: tokenizeCodeIndented,
    resolve: resolveCodeIndented
  };
  var indentedContentConstruct = {
    tokenize: tokenizeIndentedContent,
    partial: true
  };
  function resolveCodeIndented(events, context) {
    var code = {
      type: "codeIndented",
      start: events[0][1].start,
      end: events[events.length - 1][1].end
    };
    chunkedSplice(events, 0, 0, [["enter", code, context]]);
    chunkedSplice(events, events.length, 0, [["exit", code, context]]);
    return events;
  }
  function tokenizeCodeIndented(effects, ok, nok) {
    return effects.attempt(indentedContentConstruct, afterPrefix, nok);
    function afterPrefix(code) {
      if (code === null) {
        return ok(code);
      }
      if (markdownLineEnding(code)) {
        return effects.attempt(indentedContentConstruct, afterPrefix, ok)(code);
      }
      effects.enter("codeFlowValue");
      return content(code);
    }
    function content(code) {
      if (code === null || markdownLineEnding(code)) {
        effects.exit("codeFlowValue");
        return afterPrefix(code);
      }
      effects.consume(code);
      return content;
    }
  }
  function tokenizeIndentedContent(effects, ok, nok) {
    var self2 = this;
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1);
    function afterPrefix(code) {
      if (markdownLineEnding(code)) {
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1);
      }
      return prefixSize(self2.events, "linePrefix") < 4 ? nok(code) : ok(code);
    }
  }
  module.exports = codeIndented;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/code-text.js
var require_code_text = __commonJS((exports, module) => {
  var markdownLineEnding = require_markdown_line_ending2();
  var codeText = {
    name: "codeText",
    tokenize: tokenizeCodeText,
    resolve: resolveCodeText,
    previous
  };
  function resolveCodeText(events) {
    var tailExitIndex = events.length - 4;
    var headEnterIndex = 3;
    var index;
    var enter;
    if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
      index = headEnterIndex;
      while (++index < tailExitIndex) {
        if (events[index][1].type === "codeTextData") {
          events[tailExitIndex][1].type = events[headEnterIndex][1].type = "codeTextPadding";
          headEnterIndex += 2;
          tailExitIndex -= 2;
          break;
        }
      }
    }
    index = headEnterIndex - 1;
    tailExitIndex++;
    while (++index <= tailExitIndex) {
      if (enter === undefined) {
        if (index !== tailExitIndex && events[index][1].type !== "lineEnding") {
          enter = index;
        }
      } else if (index === tailExitIndex || events[index][1].type === "lineEnding") {
        events[enter][1].type = "codeTextData";
        if (index !== enter + 2) {
          events[enter][1].end = events[index - 1][1].end;
          events.splice(enter + 2, index - enter - 2);
          tailExitIndex -= index - enter - 2;
          index = enter + 2;
        }
        enter = undefined;
      }
    }
    return events;
  }
  function previous(code) {
    return code !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
  }
  function tokenizeCodeText(effects, ok, nok) {
    var sizeOpen = 0;
    var size;
    var token;
    return start;
    function start(code) {
      effects.enter("codeText");
      effects.enter("codeTextSequence");
      return openingSequence(code);
    }
    function openingSequence(code) {
      if (code === 96) {
        effects.consume(code);
        sizeOpen++;
        return openingSequence;
      }
      effects.exit("codeTextSequence");
      return gap(code);
    }
    function gap(code) {
      if (code === null) {
        return nok(code);
      }
      if (code === 96) {
        token = effects.enter("codeTextSequence");
        size = 0;
        return closingSequence(code);
      }
      if (code === 32) {
        effects.enter("space");
        effects.consume(code);
        effects.exit("space");
        return gap;
      }
      if (markdownLineEnding(code)) {
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        return gap;
      }
      effects.enter("codeTextData");
      return data(code);
    }
    function data(code) {
      if (code === null || code === 32 || code === 96 || markdownLineEnding(code)) {
        effects.exit("codeTextData");
        return gap(code);
      }
      effects.consume(code);
      return data;
    }
    function closingSequence(code) {
      if (code === 96) {
        effects.consume(code);
        size++;
        return closingSequence;
      }
      if (size === sizeOpen) {
        effects.exit("codeTextSequence");
        effects.exit("codeText");
        return ok(code);
      }
      token.type = "codeTextData";
      return data(code);
    }
  }
  module.exports = codeText;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/factory-destination.js
var require_factory_destination = __commonJS((exports, module) => {
  var asciiControl = require_ascii_control2();
  var markdownLineEndingOrSpace = require_markdown_line_ending_or_space2();
  var markdownLineEnding = require_markdown_line_ending2();
  function destinationFactory(effects, ok, nok, type, literalType2, literalMarkerType, rawType, stringType2, max) {
    var limit = max || Infinity;
    var balance = 0;
    return start;
    function start(code) {
      if (code === 60) {
        effects.enter(type);
        effects.enter(literalType2);
        effects.enter(literalMarkerType);
        effects.consume(code);
        effects.exit(literalMarkerType);
        return destinationEnclosedBefore;
      }
      if (asciiControl(code) || code === 41) {
        return nok(code);
      }
      effects.enter(type);
      effects.enter(rawType);
      effects.enter(stringType2);
      effects.enter("chunkString", {
        contentType: "string"
      });
      return destinationRaw(code);
    }
    function destinationEnclosedBefore(code) {
      if (code === 62) {
        effects.enter(literalMarkerType);
        effects.consume(code);
        effects.exit(literalMarkerType);
        effects.exit(literalType2);
        effects.exit(type);
        return ok;
      }
      effects.enter(stringType2);
      effects.enter("chunkString", {
        contentType: "string"
      });
      return destinationEnclosed(code);
    }
    function destinationEnclosed(code) {
      if (code === 62) {
        effects.exit("chunkString");
        effects.exit(stringType2);
        return destinationEnclosedBefore(code);
      }
      if (code === null || code === 60 || markdownLineEnding(code)) {
        return nok(code);
      }
      effects.consume(code);
      return code === 92 ? destinationEnclosedEscape : destinationEnclosed;
    }
    function destinationEnclosedEscape(code) {
      if (code === 60 || code === 62 || code === 92) {
        effects.consume(code);
        return destinationEnclosed;
      }
      return destinationEnclosed(code);
    }
    function destinationRaw(code) {
      if (code === 40) {
        if (++balance > limit)
          return nok(code);
        effects.consume(code);
        return destinationRaw;
      }
      if (code === 41) {
        if (!balance--) {
          effects.exit("chunkString");
          effects.exit(stringType2);
          effects.exit(rawType);
          effects.exit(type);
          return ok(code);
        }
        effects.consume(code);
        return destinationRaw;
      }
      if (code === null || markdownLineEndingOrSpace(code)) {
        if (balance)
          return nok(code);
        effects.exit("chunkString");
        effects.exit(stringType2);
        effects.exit(rawType);
        effects.exit(type);
        return ok(code);
      }
      if (asciiControl(code))
        return nok(code);
      effects.consume(code);
      return code === 92 ? destinationRawEscape : destinationRaw;
    }
    function destinationRawEscape(code) {
      if (code === 40 || code === 41 || code === 92) {
        effects.consume(code);
        return destinationRaw;
      }
      return destinationRaw(code);
    }
  }
  module.exports = destinationFactory;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/factory-label.js
var require_factory_label = __commonJS((exports, module) => {
  var markdownLineEnding = require_markdown_line_ending2();
  var markdownSpace = require_markdown_space2();
  function labelFactory(effects, ok, nok, type, markerType, stringType2) {
    var self2 = this;
    var size = 0;
    var data;
    return start;
    function start(code) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      effects.enter(stringType2);
      return atBreak;
    }
    function atBreak(code) {
      if (code === null || code === 91 || code === 93 && !data || code === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs || size > 999) {
        return nok(code);
      }
      if (code === 93) {
        effects.exit(stringType2);
        effects.enter(markerType);
        effects.consume(code);
        effects.exit(markerType);
        effects.exit(type);
        return ok;
      }
      if (markdownLineEnding(code)) {
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        return atBreak;
      }
      effects.enter("chunkString", {
        contentType: "string"
      });
      return label(code);
    }
    function label(code) {
      if (code === null || code === 91 || code === 93 || markdownLineEnding(code) || size++ > 999) {
        effects.exit("chunkString");
        return atBreak(code);
      }
      effects.consume(code);
      data = data || !markdownSpace(code);
      return code === 92 ? labelEscape : label;
    }
    function labelEscape(code) {
      if (code === 91 || code === 92 || code === 93) {
        effects.consume(code);
        size++;
        return label;
      }
      return label(code);
    }
  }
  module.exports = labelFactory;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/factory-whitespace.js
var require_factory_whitespace = __commonJS((exports, module) => {
  var markdownLineEnding = require_markdown_line_ending2();
  var markdownSpace = require_markdown_space2();
  var factorySpace = require_factory_space2();
  function whitespaceFactory(effects, ok) {
    var seen;
    return start;
    function start(code) {
      if (markdownLineEnding(code)) {
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        seen = true;
        return start;
      }
      if (markdownSpace(code)) {
        return factorySpace(effects, start, seen ? "linePrefix" : "lineSuffix")(code);
      }
      return ok(code);
    }
  }
  module.exports = whitespaceFactory;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/factory-title.js
var require_factory_title = __commonJS((exports, module) => {
  var markdownLineEnding = require_markdown_line_ending2();
  var factorySpace = require_factory_space2();
  function titleFactory(effects, ok, nok, type, markerType, stringType2) {
    var marker;
    return start;
    function start(code) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      marker = code === 40 ? 41 : code;
      return atFirstTitleBreak;
    }
    function atFirstTitleBreak(code) {
      if (code === marker) {
        effects.enter(markerType);
        effects.consume(code);
        effects.exit(markerType);
        effects.exit(type);
        return ok;
      }
      effects.enter(stringType2);
      return atTitleBreak(code);
    }
    function atTitleBreak(code) {
      if (code === marker) {
        effects.exit(stringType2);
        return atFirstTitleBreak(marker);
      }
      if (code === null) {
        return nok(code);
      }
      if (markdownLineEnding(code)) {
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        return factorySpace(effects, atTitleBreak, "linePrefix");
      }
      effects.enter("chunkString", {
        contentType: "string"
      });
      return title(code);
    }
    function title(code) {
      if (code === marker || code === null || markdownLineEnding(code)) {
        effects.exit("chunkString");
        return atTitleBreak(code);
      }
      effects.consume(code);
      return code === 92 ? titleEscape : title;
    }
    function titleEscape(code) {
      if (code === marker || code === 92) {
        effects.consume(code);
        return title;
      }
      return title(code);
    }
  }
  module.exports = titleFactory;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/definition.js
var require_definition = __commonJS((exports, module) => {
  var markdownLineEnding = require_markdown_line_ending2();
  var markdownLineEndingOrSpace = require_markdown_line_ending_or_space2();
  var normalizeIdentifier = require_normalize_identifier();
  var factoryDestination = require_factory_destination();
  var factoryLabel = require_factory_label();
  var factorySpace = require_factory_space2();
  var factoryWhitespace = require_factory_whitespace();
  var factoryTitle = require_factory_title();
  var definition = {
    name: "definition",
    tokenize: tokenizeDefinition
  };
  var titleConstruct = {
    tokenize: tokenizeTitle,
    partial: true
  };
  function tokenizeDefinition(effects, ok, nok) {
    var self2 = this;
    var identifier;
    return start;
    function start(code) {
      effects.enter("definition");
      return factoryLabel.call(self2, effects, labelAfter, nok, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(code);
    }
    function labelAfter(code) {
      identifier = normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1));
      if (code === 58) {
        effects.enter("definitionMarker");
        effects.consume(code);
        effects.exit("definitionMarker");
        return factoryWhitespace(effects, factoryDestination(effects, effects.attempt(titleConstruct, factorySpace(effects, after, "whitespace"), factorySpace(effects, after, "whitespace")), nok, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString"));
      }
      return nok(code);
    }
    function after(code) {
      if (code === null || markdownLineEnding(code)) {
        effects.exit("definition");
        if (self2.parser.defined.indexOf(identifier) < 0) {
          self2.parser.defined.push(identifier);
        }
        return ok(code);
      }
      return nok(code);
    }
  }
  function tokenizeTitle(effects, ok, nok) {
    return start;
    function start(code) {
      return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, before)(code) : nok(code);
    }
    function before(code) {
      if (code === 34 || code === 39 || code === 40) {
        return factoryTitle(effects, factorySpace(effects, after, "whitespace"), nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code);
      }
      return nok(code);
    }
    function after(code) {
      return code === null || markdownLineEnding(code) ? ok(code) : nok(code);
    }
  }
  module.exports = definition;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/hard-break-escape.js
var require_hard_break_escape = __commonJS((exports, module) => {
  var markdownLineEnding = require_markdown_line_ending2();
  var hardBreakEscape = {
    name: "hardBreakEscape",
    tokenize: tokenizeHardBreakEscape
  };
  function tokenizeHardBreakEscape(effects, ok, nok) {
    return start;
    function start(code) {
      effects.enter("hardBreakEscape");
      effects.enter("escapeMarker");
      effects.consume(code);
      return open;
    }
    function open(code) {
      if (markdownLineEnding(code)) {
        effects.exit("escapeMarker");
        effects.exit("hardBreakEscape");
        return ok(code);
      }
      return nok(code);
    }
  }
  module.exports = hardBreakEscape;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/heading-atx.js
var require_heading_atx = __commonJS((exports, module) => {
  var markdownLineEnding = require_markdown_line_ending2();
  var markdownLineEndingOrSpace = require_markdown_line_ending_or_space2();
  var markdownSpace = require_markdown_space2();
  var chunkedSplice = require_chunked_splice2();
  var factorySpace = require_factory_space2();
  var headingAtx = {
    name: "headingAtx",
    tokenize: tokenizeHeadingAtx,
    resolve: resolveHeadingAtx
  };
  function resolveHeadingAtx(events, context) {
    var contentEnd = events.length - 2;
    var contentStart = 3;
    var content;
    var text;
    if (events[contentStart][1].type === "whitespace") {
      contentStart += 2;
    }
    if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
      contentEnd -= 2;
    }
    if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
      contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
    }
    if (contentEnd > contentStart) {
      content = {
        type: "atxHeadingText",
        start: events[contentStart][1].start,
        end: events[contentEnd][1].end
      };
      text = {
        type: "chunkText",
        start: events[contentStart][1].start,
        end: events[contentEnd][1].end,
        contentType: "text"
      };
      chunkedSplice(events, contentStart, contentEnd - contentStart + 1, [
        ["enter", content, context],
        ["enter", text, context],
        ["exit", text, context],
        ["exit", content, context]
      ]);
    }
    return events;
  }
  function tokenizeHeadingAtx(effects, ok, nok) {
    var self2 = this;
    var size = 0;
    return start;
    function start(code) {
      effects.enter("atxHeading");
      effects.enter("atxHeadingSequence");
      return fenceOpenInside(code);
    }
    function fenceOpenInside(code) {
      if (code === 35 && size++ < 6) {
        effects.consume(code);
        return fenceOpenInside;
      }
      if (code === null || markdownLineEndingOrSpace(code)) {
        effects.exit("atxHeadingSequence");
        return self2.interrupt ? ok(code) : headingBreak(code);
      }
      return nok(code);
    }
    function headingBreak(code) {
      if (code === 35) {
        effects.enter("atxHeadingSequence");
        return sequence(code);
      }
      if (code === null || markdownLineEnding(code)) {
        effects.exit("atxHeading");
        return ok(code);
      }
      if (markdownSpace(code)) {
        return factorySpace(effects, headingBreak, "whitespace")(code);
      }
      effects.enter("atxHeadingText");
      return data(code);
    }
    function sequence(code) {
      if (code === 35) {
        effects.consume(code);
        return sequence;
      }
      effects.exit("atxHeadingSequence");
      return headingBreak(code);
    }
    function data(code) {
      if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {
        effects.exit("atxHeadingText");
        return headingBreak(code);
      }
      effects.consume(code);
      return data;
    }
  }
  module.exports = headingAtx;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/constant/html-block-names.js
var require_html_block_names = __commonJS((exports, module) => {
  var basics = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "section",
    "source",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
  ];
  module.exports = basics;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/constant/html-raw-names.js
var require_html_raw_names = __commonJS((exports, module) => {
  var raws = ["pre", "script", "style", "textarea"];
  module.exports = raws;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/html-flow.js
var require_html_flow = __commonJS((exports, module) => {
  var asciiAlpha = require_ascii_alpha2();
  var asciiAlphanumeric = require_ascii_alphanumeric2();
  var markdownLineEnding = require_markdown_line_ending2();
  var markdownLineEndingOrSpace = require_markdown_line_ending_or_space2();
  var markdownSpace = require_markdown_space2();
  var fromCharCode = require_from_char_code3();
  var htmlBlockNames = require_html_block_names();
  var htmlRawNames = require_html_raw_names();
  var partialBlankLine = require_partial_blank_line();
  var htmlFlow = {
    name: "htmlFlow",
    tokenize: tokenizeHtmlFlow,
    resolveTo: resolveToHtmlFlow,
    concrete: true
  };
  var nextBlankConstruct = {
    tokenize: tokenizeNextBlank,
    partial: true
  };
  function resolveToHtmlFlow(events) {
    var index = events.length;
    while (index--) {
      if (events[index][0] === "enter" && events[index][1].type === "htmlFlow") {
        break;
      }
    }
    if (index > 1 && events[index - 2][1].type === "linePrefix") {
      events[index][1].start = events[index - 2][1].start;
      events[index + 1][1].start = events[index - 2][1].start;
      events.splice(index - 2, 2);
    }
    return events;
  }
  function tokenizeHtmlFlow(effects, ok, nok) {
    var self2 = this;
    var kind;
    var startTag;
    var buffer;
    var index;
    var marker;
    return start;
    function start(code) {
      effects.enter("htmlFlow");
      effects.enter("htmlFlowData");
      effects.consume(code);
      return open;
    }
    function open(code) {
      if (code === 33) {
        effects.consume(code);
        return declarationStart;
      }
      if (code === 47) {
        effects.consume(code);
        return tagCloseStart;
      }
      if (code === 63) {
        effects.consume(code);
        kind = 3;
        return self2.interrupt ? ok : continuationDeclarationInside;
      }
      if (asciiAlpha(code)) {
        effects.consume(code);
        buffer = fromCharCode(code);
        startTag = true;
        return tagName;
      }
      return nok(code);
    }
    function declarationStart(code) {
      if (code === 45) {
        effects.consume(code);
        kind = 2;
        return commentOpenInside;
      }
      if (code === 91) {
        effects.consume(code);
        kind = 5;
        buffer = "CDATA[";
        index = 0;
        return cdataOpenInside;
      }
      if (asciiAlpha(code)) {
        effects.consume(code);
        kind = 4;
        return self2.interrupt ? ok : continuationDeclarationInside;
      }
      return nok(code);
    }
    function commentOpenInside(code) {
      if (code === 45) {
        effects.consume(code);
        return self2.interrupt ? ok : continuationDeclarationInside;
      }
      return nok(code);
    }
    function cdataOpenInside(code) {
      if (code === buffer.charCodeAt(index++)) {
        effects.consume(code);
        return index === buffer.length ? self2.interrupt ? ok : continuation : cdataOpenInside;
      }
      return nok(code);
    }
    function tagCloseStart(code) {
      if (asciiAlpha(code)) {
        effects.consume(code);
        buffer = fromCharCode(code);
        return tagName;
      }
      return nok(code);
    }
    function tagName(code) {
      if (code === null || code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
        if (code !== 47 && startTag && htmlRawNames.indexOf(buffer.toLowerCase()) > -1) {
          kind = 1;
          return self2.interrupt ? ok(code) : continuation(code);
        }
        if (htmlBlockNames.indexOf(buffer.toLowerCase()) > -1) {
          kind = 6;
          if (code === 47) {
            effects.consume(code);
            return basicSelfClosing;
          }
          return self2.interrupt ? ok(code) : continuation(code);
        }
        kind = 7;
        return self2.interrupt ? nok(code) : startTag ? completeAttributeNameBefore(code) : completeClosingTagAfter(code);
      }
      if (code === 45 || asciiAlphanumeric(code)) {
        effects.consume(code);
        buffer += fromCharCode(code);
        return tagName;
      }
      return nok(code);
    }
    function basicSelfClosing(code) {
      if (code === 62) {
        effects.consume(code);
        return self2.interrupt ? ok : continuation;
      }
      return nok(code);
    }
    function completeClosingTagAfter(code) {
      if (markdownSpace(code)) {
        effects.consume(code);
        return completeClosingTagAfter;
      }
      return completeEnd(code);
    }
    function completeAttributeNameBefore(code) {
      if (code === 47) {
        effects.consume(code);
        return completeEnd;
      }
      if (code === 58 || code === 95 || asciiAlpha(code)) {
        effects.consume(code);
        return completeAttributeName;
      }
      if (markdownSpace(code)) {
        effects.consume(code);
        return completeAttributeNameBefore;
      }
      return completeEnd(code);
    }
    function completeAttributeName(code) {
      if (code === 45 || code === 46 || code === 58 || code === 95 || asciiAlphanumeric(code)) {
        effects.consume(code);
        return completeAttributeName;
      }
      return completeAttributeNameAfter(code);
    }
    function completeAttributeNameAfter(code) {
      if (code === 61) {
        effects.consume(code);
        return completeAttributeValueBefore;
      }
      if (markdownSpace(code)) {
        effects.consume(code);
        return completeAttributeNameAfter;
      }
      return completeAttributeNameBefore(code);
    }
    function completeAttributeValueBefore(code) {
      if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {
        return nok(code);
      }
      if (code === 34 || code === 39) {
        effects.consume(code);
        marker = code;
        return completeAttributeValueQuoted;
      }
      if (markdownSpace(code)) {
        effects.consume(code);
        return completeAttributeValueBefore;
      }
      marker = undefined;
      return completeAttributeValueUnquoted(code);
    }
    function completeAttributeValueQuoted(code) {
      if (code === marker) {
        effects.consume(code);
        return completeAttributeValueQuotedAfter;
      }
      if (code === null || markdownLineEnding(code)) {
        return nok(code);
      }
      effects.consume(code);
      return completeAttributeValueQuoted;
    }
    function completeAttributeValueUnquoted(code) {
      if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 62 || code === 96 || markdownLineEndingOrSpace(code)) {
        return completeAttributeNameAfter(code);
      }
      effects.consume(code);
      return completeAttributeValueUnquoted;
    }
    function completeAttributeValueQuotedAfter(code) {
      if (code === 47 || code === 62 || markdownSpace(code)) {
        return completeAttributeNameBefore(code);
      }
      return nok(code);
    }
    function completeEnd(code) {
      if (code === 62) {
        effects.consume(code);
        return completeAfter;
      }
      return nok(code);
    }
    function completeAfter(code) {
      if (markdownSpace(code)) {
        effects.consume(code);
        return completeAfter;
      }
      return code === null || markdownLineEnding(code) ? continuation(code) : nok(code);
    }
    function continuation(code) {
      if (code === 45 && kind === 2) {
        effects.consume(code);
        return continuationCommentInside;
      }
      if (code === 60 && kind === 1) {
        effects.consume(code);
        return continuationRawTagOpen;
      }
      if (code === 62 && kind === 4) {
        effects.consume(code);
        return continuationClose;
      }
      if (code === 63 && kind === 3) {
        effects.consume(code);
        return continuationDeclarationInside;
      }
      if (code === 93 && kind === 5) {
        effects.consume(code);
        return continuationCharacterDataInside;
      }
      if (markdownLineEnding(code) && (kind === 6 || kind === 7)) {
        return effects.check(nextBlankConstruct, continuationClose, continuationAtLineEnding)(code);
      }
      if (code === null || markdownLineEnding(code)) {
        return continuationAtLineEnding(code);
      }
      effects.consume(code);
      return continuation;
    }
    function continuationAtLineEnding(code) {
      effects.exit("htmlFlowData");
      return htmlContinueStart(code);
    }
    function htmlContinueStart(code) {
      if (code === null) {
        return done(code);
      }
      if (markdownLineEnding(code)) {
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        return htmlContinueStart;
      }
      effects.enter("htmlFlowData");
      return continuation(code);
    }
    function continuationCommentInside(code) {
      if (code === 45) {
        effects.consume(code);
        return continuationDeclarationInside;
      }
      return continuation(code);
    }
    function continuationRawTagOpen(code) {
      if (code === 47) {
        effects.consume(code);
        buffer = "";
        return continuationRawEndTag;
      }
      return continuation(code);
    }
    function continuationRawEndTag(code) {
      if (code === 62 && htmlRawNames.indexOf(buffer.toLowerCase()) > -1) {
        effects.consume(code);
        return continuationClose;
      }
      if (asciiAlpha(code) && buffer.length < 8) {
        effects.consume(code);
        buffer += fromCharCode(code);
        return continuationRawEndTag;
      }
      return continuation(code);
    }
    function continuationCharacterDataInside(code) {
      if (code === 93) {
        effects.consume(code);
        return continuationDeclarationInside;
      }
      return continuation(code);
    }
    function continuationDeclarationInside(code) {
      if (code === 62) {
        effects.consume(code);
        return continuationClose;
      }
      return continuation(code);
    }
    function continuationClose(code) {
      if (code === null || markdownLineEnding(code)) {
        effects.exit("htmlFlowData");
        return done(code);
      }
      effects.consume(code);
      return continuationClose;
    }
    function done(code) {
      effects.exit("htmlFlow");
      return ok(code);
    }
  }
  function tokenizeNextBlank(effects, ok, nok) {
    return start;
    function start(code) {
      effects.exit("htmlFlowData");
      effects.enter("lineEndingBlank");
      effects.consume(code);
      effects.exit("lineEndingBlank");
      return effects.attempt(partialBlankLine, ok, nok);
    }
  }
  module.exports = htmlFlow;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/html-text.js
var require_html_text = __commonJS((exports, module) => {
  var asciiAlpha = require_ascii_alpha2();
  var asciiAlphanumeric = require_ascii_alphanumeric2();
  var markdownLineEnding = require_markdown_line_ending2();
  var markdownLineEndingOrSpace = require_markdown_line_ending_or_space2();
  var markdownSpace = require_markdown_space2();
  var factorySpace = require_factory_space2();
  var htmlText = {
    name: "htmlText",
    tokenize: tokenizeHtmlText
  };
  function tokenizeHtmlText(effects, ok, nok) {
    var self2 = this;
    var marker;
    var buffer;
    var index;
    var returnState;
    return start;
    function start(code) {
      effects.enter("htmlText");
      effects.enter("htmlTextData");
      effects.consume(code);
      return open;
    }
    function open(code) {
      if (code === 33) {
        effects.consume(code);
        return declarationOpen;
      }
      if (code === 47) {
        effects.consume(code);
        return tagCloseStart;
      }
      if (code === 63) {
        effects.consume(code);
        return instruction;
      }
      if (asciiAlpha(code)) {
        effects.consume(code);
        return tagOpen;
      }
      return nok(code);
    }
    function declarationOpen(code) {
      if (code === 45) {
        effects.consume(code);
        return commentOpen;
      }
      if (code === 91) {
        effects.consume(code);
        buffer = "CDATA[";
        index = 0;
        return cdataOpen;
      }
      if (asciiAlpha(code)) {
        effects.consume(code);
        return declaration;
      }
      return nok(code);
    }
    function commentOpen(code) {
      if (code === 45) {
        effects.consume(code);
        return commentStart;
      }
      return nok(code);
    }
    function commentStart(code) {
      if (code === null || code === 62) {
        return nok(code);
      }
      if (code === 45) {
        effects.consume(code);
        return commentStartDash;
      }
      return comment(code);
    }
    function commentStartDash(code) {
      if (code === null || code === 62) {
        return nok(code);
      }
      return comment(code);
    }
    function comment(code) {
      if (code === null) {
        return nok(code);
      }
      if (code === 45) {
        effects.consume(code);
        return commentClose;
      }
      if (markdownLineEnding(code)) {
        returnState = comment;
        return atLineEnding(code);
      }
      effects.consume(code);
      return comment;
    }
    function commentClose(code) {
      if (code === 45) {
        effects.consume(code);
        return end;
      }
      return comment(code);
    }
    function cdataOpen(code) {
      if (code === buffer.charCodeAt(index++)) {
        effects.consume(code);
        return index === buffer.length ? cdata : cdataOpen;
      }
      return nok(code);
    }
    function cdata(code) {
      if (code === null) {
        return nok(code);
      }
      if (code === 93) {
        effects.consume(code);
        return cdataClose;
      }
      if (markdownLineEnding(code)) {
        returnState = cdata;
        return atLineEnding(code);
      }
      effects.consume(code);
      return cdata;
    }
    function cdataClose(code) {
      if (code === 93) {
        effects.consume(code);
        return cdataEnd;
      }
      return cdata(code);
    }
    function cdataEnd(code) {
      if (code === 62) {
        return end(code);
      }
      if (code === 93) {
        effects.consume(code);
        return cdataEnd;
      }
      return cdata(code);
    }
    function declaration(code) {
      if (code === null || code === 62) {
        return end(code);
      }
      if (markdownLineEnding(code)) {
        returnState = declaration;
        return atLineEnding(code);
      }
      effects.consume(code);
      return declaration;
    }
    function instruction(code) {
      if (code === null) {
        return nok(code);
      }
      if (code === 63) {
        effects.consume(code);
        return instructionClose;
      }
      if (markdownLineEnding(code)) {
        returnState = instruction;
        return atLineEnding(code);
      }
      effects.consume(code);
      return instruction;
    }
    function instructionClose(code) {
      return code === 62 ? end(code) : instruction(code);
    }
    function tagCloseStart(code) {
      if (asciiAlpha(code)) {
        effects.consume(code);
        return tagClose;
      }
      return nok(code);
    }
    function tagClose(code) {
      if (code === 45 || asciiAlphanumeric(code)) {
        effects.consume(code);
        return tagClose;
      }
      return tagCloseBetween(code);
    }
    function tagCloseBetween(code) {
      if (markdownLineEnding(code)) {
        returnState = tagCloseBetween;
        return atLineEnding(code);
      }
      if (markdownSpace(code)) {
        effects.consume(code);
        return tagCloseBetween;
      }
      return end(code);
    }
    function tagOpen(code) {
      if (code === 45 || asciiAlphanumeric(code)) {
        effects.consume(code);
        return tagOpen;
      }
      if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
        return tagOpenBetween(code);
      }
      return nok(code);
    }
    function tagOpenBetween(code) {
      if (code === 47) {
        effects.consume(code);
        return end;
      }
      if (code === 58 || code === 95 || asciiAlpha(code)) {
        effects.consume(code);
        return tagOpenAttributeName;
      }
      if (markdownLineEnding(code)) {
        returnState = tagOpenBetween;
        return atLineEnding(code);
      }
      if (markdownSpace(code)) {
        effects.consume(code);
        return tagOpenBetween;
      }
      return end(code);
    }
    function tagOpenAttributeName(code) {
      if (code === 45 || code === 46 || code === 58 || code === 95 || asciiAlphanumeric(code)) {
        effects.consume(code);
        return tagOpenAttributeName;
      }
      return tagOpenAttributeNameAfter(code);
    }
    function tagOpenAttributeNameAfter(code) {
      if (code === 61) {
        effects.consume(code);
        return tagOpenAttributeValueBefore;
      }
      if (markdownLineEnding(code)) {
        returnState = tagOpenAttributeNameAfter;
        return atLineEnding(code);
      }
      if (markdownSpace(code)) {
        effects.consume(code);
        return tagOpenAttributeNameAfter;
      }
      return tagOpenBetween(code);
    }
    function tagOpenAttributeValueBefore(code) {
      if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {
        return nok(code);
      }
      if (code === 34 || code === 39) {
        effects.consume(code);
        marker = code;
        return tagOpenAttributeValueQuoted;
      }
      if (markdownLineEnding(code)) {
        returnState = tagOpenAttributeValueBefore;
        return atLineEnding(code);
      }
      if (markdownSpace(code)) {
        effects.consume(code);
        return tagOpenAttributeValueBefore;
      }
      effects.consume(code);
      marker = undefined;
      return tagOpenAttributeValueUnquoted;
    }
    function tagOpenAttributeValueQuoted(code) {
      if (code === marker) {
        effects.consume(code);
        return tagOpenAttributeValueQuotedAfter;
      }
      if (code === null) {
        return nok(code);
      }
      if (markdownLineEnding(code)) {
        returnState = tagOpenAttributeValueQuoted;
        return atLineEnding(code);
      }
      effects.consume(code);
      return tagOpenAttributeValueQuoted;
    }
    function tagOpenAttributeValueQuotedAfter(code) {
      if (code === 62 || code === 47 || markdownLineEndingOrSpace(code)) {
        return tagOpenBetween(code);
      }
      return nok(code);
    }
    function tagOpenAttributeValueUnquoted(code) {
      if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 96) {
        return nok(code);
      }
      if (code === 62 || markdownLineEndingOrSpace(code)) {
        return tagOpenBetween(code);
      }
      effects.consume(code);
      return tagOpenAttributeValueUnquoted;
    }
    function atLineEnding(code) {
      effects.exit("htmlTextData");
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return factorySpace(effects, afterPrefix, "linePrefix", self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? undefined : 4);
    }
    function afterPrefix(code) {
      effects.enter("htmlTextData");
      return returnState(code);
    }
    function end(code) {
      if (code === 62) {
        effects.consume(code);
        effects.exit("htmlTextData");
        effects.exit("htmlText");
        return ok;
      }
      return nok(code);
    }
  }
  module.exports = htmlText;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/label-end.js
var require_label_end = __commonJS((exports, module) => {
  var markdownLineEndingOrSpace = require_markdown_line_ending_or_space2();
  var chunkedPush = require_chunked_push();
  var chunkedSplice = require_chunked_splice2();
  var normalizeIdentifier = require_normalize_identifier();
  var resolveAll = require_resolve_all2();
  var shallow = require_shallow2();
  var factoryDestination = require_factory_destination();
  var factoryLabel = require_factory_label();
  var factoryTitle = require_factory_title();
  var factoryWhitespace = require_factory_whitespace();
  var labelEnd = {
    name: "labelEnd",
    tokenize: tokenizeLabelEnd,
    resolveTo: resolveToLabelEnd,
    resolveAll: resolveAllLabelEnd
  };
  var resourceConstruct = {
    tokenize: tokenizeResource
  };
  var fullReferenceConstruct = {
    tokenize: tokenizeFullReference
  };
  var collapsedReferenceConstruct = {
    tokenize: tokenizeCollapsedReference
  };
  function resolveAllLabelEnd(events) {
    var index = -1;
    var token;
    while (++index < events.length) {
      token = events[index][1];
      if (!token._used && (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd")) {
        events.splice(index + 1, token.type === "labelImage" ? 4 : 2);
        token.type = "data";
        index++;
      }
    }
    return events;
  }
  function resolveToLabelEnd(events, context) {
    var index = events.length;
    var offset = 0;
    var group;
    var label;
    var text;
    var token;
    var open;
    var close;
    var media;
    while (index--) {
      token = events[index][1];
      if (open) {
        if (token.type === "link" || token.type === "labelLink" && token._inactive) {
          break;
        }
        if (events[index][0] === "enter" && token.type === "labelLink") {
          token._inactive = true;
        }
      } else if (close) {
        if (events[index][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
          open = index;
          if (token.type !== "labelLink") {
            offset = 2;
            break;
          }
        }
      } else if (token.type === "labelEnd") {
        close = index;
      }
    }
    group = {
      type: events[open][1].type === "labelLink" ? "link" : "image",
      start: shallow(events[open][1].start),
      end: shallow(events[events.length - 1][1].end)
    };
    label = {
      type: "label",
      start: shallow(events[open][1].start),
      end: shallow(events[close][1].end)
    };
    text = {
      type: "labelText",
      start: shallow(events[open + offset + 2][1].end),
      end: shallow(events[close - 2][1].start)
    };
    media = [
      ["enter", group, context],
      ["enter", label, context]
    ];
    media = chunkedPush(media, events.slice(open + 1, open + offset + 3));
    media = chunkedPush(media, [["enter", text, context]]);
    media = chunkedPush(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context));
    media = chunkedPush(media, [
      ["exit", text, context],
      events[close - 2],
      events[close - 1],
      ["exit", label, context]
    ]);
    media = chunkedPush(media, events.slice(close + 1));
    media = chunkedPush(media, [["exit", group, context]]);
    chunkedSplice(events, open, events.length, media);
    return events;
  }
  function tokenizeLabelEnd(effects, ok, nok) {
    var self2 = this;
    var index = self2.events.length;
    var labelStart;
    var defined;
    while (index--) {
      if ((self2.events[index][1].type === "labelImage" || self2.events[index][1].type === "labelLink") && !self2.events[index][1]._balanced) {
        labelStart = self2.events[index][1];
        break;
      }
    }
    return start;
    function start(code) {
      if (!labelStart) {
        return nok(code);
      }
      if (labelStart._inactive)
        return balanced(code);
      defined = self2.parser.defined.indexOf(normalizeIdentifier(self2.sliceSerialize({
        start: labelStart.end,
        end: self2.now()
      }))) > -1;
      effects.enter("labelEnd");
      effects.enter("labelMarker");
      effects.consume(code);
      effects.exit("labelMarker");
      effects.exit("labelEnd");
      return afterLabelEnd;
    }
    function afterLabelEnd(code) {
      if (code === 40) {
        return effects.attempt(resourceConstruct, ok, defined ? ok : balanced)(code);
      }
      if (code === 91) {
        return effects.attempt(fullReferenceConstruct, ok, defined ? effects.attempt(collapsedReferenceConstruct, ok, balanced) : balanced)(code);
      }
      return defined ? ok(code) : balanced(code);
    }
    function balanced(code) {
      labelStart._balanced = true;
      return nok(code);
    }
  }
  function tokenizeResource(effects, ok, nok) {
    return start;
    function start(code) {
      effects.enter("resource");
      effects.enter("resourceMarker");
      effects.consume(code);
      effects.exit("resourceMarker");
      return factoryWhitespace(effects, open);
    }
    function open(code) {
      if (code === 41) {
        return end(code);
      }
      return factoryDestination(effects, destinationAfter, nok, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 3)(code);
    }
    function destinationAfter(code) {
      return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, between)(code) : end(code);
    }
    function between(code) {
      if (code === 34 || code === 39 || code === 40) {
        return factoryTitle(effects, factoryWhitespace(effects, end), nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code);
      }
      return end(code);
    }
    function end(code) {
      if (code === 41) {
        effects.enter("resourceMarker");
        effects.consume(code);
        effects.exit("resourceMarker");
        effects.exit("resource");
        return ok;
      }
      return nok(code);
    }
  }
  function tokenizeFullReference(effects, ok, nok) {
    var self2 = this;
    return start;
    function start(code) {
      return factoryLabel.call(self2, effects, afterLabel, nok, "reference", "referenceMarker", "referenceString")(code);
    }
    function afterLabel(code) {
      return self2.parser.defined.indexOf(normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) < 0 ? nok(code) : ok(code);
    }
  }
  function tokenizeCollapsedReference(effects, ok, nok) {
    return start;
    function start(code) {
      effects.enter("reference");
      effects.enter("referenceMarker");
      effects.consume(code);
      effects.exit("referenceMarker");
      return open;
    }
    function open(code) {
      if (code === 93) {
        effects.enter("referenceMarker");
        effects.consume(code);
        effects.exit("referenceMarker");
        effects.exit("reference");
        return ok;
      }
      return nok(code);
    }
  }
  module.exports = labelEnd;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/label-start-image.js
var require_label_start_image = __commonJS((exports, module) => {
  var labelEnd = require_label_end();
  var labelStartImage = {
    name: "labelStartImage",
    tokenize: tokenizeLabelStartImage,
    resolveAll: labelEnd.resolveAll
  };
  function tokenizeLabelStartImage(effects, ok, nok) {
    var self2 = this;
    return start;
    function start(code) {
      effects.enter("labelImage");
      effects.enter("labelImageMarker");
      effects.consume(code);
      effects.exit("labelImageMarker");
      return open;
    }
    function open(code) {
      if (code === 91) {
        effects.enter("labelMarker");
        effects.consume(code);
        effects.exit("labelMarker");
        effects.exit("labelImage");
        return after;
      }
      return nok(code);
    }
    function after(code) {
      return code === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code) : ok(code);
    }
  }
  module.exports = labelStartImage;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/label-start-link.js
var require_label_start_link = __commonJS((exports, module) => {
  var labelEnd = require_label_end();
  var labelStartLink = {
    name: "labelStartLink",
    tokenize: tokenizeLabelStartLink,
    resolveAll: labelEnd.resolveAll
  };
  function tokenizeLabelStartLink(effects, ok, nok) {
    var self2 = this;
    return start;
    function start(code) {
      effects.enter("labelLink");
      effects.enter("labelMarker");
      effects.consume(code);
      effects.exit("labelMarker");
      effects.exit("labelLink");
      return after;
    }
    function after(code) {
      return code === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code) : ok(code);
    }
  }
  module.exports = labelStartLink;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/line-ending.js
var require_line_ending = __commonJS((exports, module) => {
  var factorySpace = require_factory_space2();
  var lineEnding = {
    name: "lineEnding",
    tokenize: tokenizeLineEnding
  };
  function tokenizeLineEnding(effects, ok) {
    return start;
    function start(code) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return factorySpace(effects, ok, "linePrefix");
    }
  }
  module.exports = lineEnding;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/thematic-break.js
var require_thematic_break = __commonJS((exports, module) => {
  var markdownLineEnding = require_markdown_line_ending2();
  var markdownSpace = require_markdown_space2();
  var factorySpace = require_factory_space2();
  var thematicBreak = {
    name: "thematicBreak",
    tokenize: tokenizeThematicBreak
  };
  function tokenizeThematicBreak(effects, ok, nok) {
    var size = 0;
    var marker;
    return start;
    function start(code) {
      effects.enter("thematicBreak");
      marker = code;
      return atBreak(code);
    }
    function atBreak(code) {
      if (code === marker) {
        effects.enter("thematicBreakSequence");
        return sequence(code);
      }
      if (markdownSpace(code)) {
        return factorySpace(effects, atBreak, "whitespace")(code);
      }
      if (size < 3 || code !== null && !markdownLineEnding(code)) {
        return nok(code);
      }
      effects.exit("thematicBreak");
      return ok(code);
    }
    function sequence(code) {
      if (code === marker) {
        effects.consume(code);
        size++;
        return sequence;
      }
      effects.exit("thematicBreakSequence");
      return atBreak(code);
    }
  }
  module.exports = thematicBreak;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/list.js
var require_list = __commonJS((exports, module) => {
  var asciiDigit = require_ascii_digit();
  var markdownSpace = require_markdown_space2();
  var prefixSize = require_prefix_size2();
  var sizeChunks = require_size_chunks2();
  var factorySpace = require_factory_space2();
  var partialBlankLine = require_partial_blank_line();
  var thematicBreak = require_thematic_break();
  var list = {
    name: "list",
    tokenize: tokenizeListStart,
    continuation: {
      tokenize: tokenizeListContinuation
    },
    exit: tokenizeListEnd
  };
  var listItemPrefixWhitespaceConstruct = {
    tokenize: tokenizeListItemPrefixWhitespace,
    partial: true
  };
  var indentConstruct = {
    tokenize: tokenizeIndent,
    partial: true
  };
  function tokenizeListStart(effects, ok, nok) {
    var self2 = this;
    var initialSize = prefixSize(self2.events, "linePrefix");
    var size = 0;
    return start;
    function start(code) {
      var kind = self2.containerState.type || (code === 42 || code === 43 || code === 45 ? "listUnordered" : "listOrdered");
      if (kind === "listUnordered" ? !self2.containerState.marker || code === self2.containerState.marker : asciiDigit(code)) {
        if (!self2.containerState.type) {
          self2.containerState.type = kind;
          effects.enter(kind, {
            _container: true
          });
        }
        if (kind === "listUnordered") {
          effects.enter("listItemPrefix");
          return code === 42 || code === 45 ? effects.check(thematicBreak, nok, atMarker)(code) : atMarker(code);
        }
        if (!self2.interrupt || code === 49) {
          effects.enter("listItemPrefix");
          effects.enter("listItemValue");
          return inside(code);
        }
      }
      return nok(code);
    }
    function inside(code) {
      if (asciiDigit(code) && ++size < 10) {
        effects.consume(code);
        return inside;
      }
      if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code === self2.containerState.marker : code === 41 || code === 46)) {
        effects.exit("listItemValue");
        return atMarker(code);
      }
      return nok(code);
    }
    function atMarker(code) {
      effects.enter("listItemMarker");
      effects.consume(code);
      effects.exit("listItemMarker");
      self2.containerState.marker = self2.containerState.marker || code;
      return effects.check(partialBlankLine, self2.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));
    }
    function onBlank(code) {
      self2.containerState.initialBlankLine = true;
      initialSize++;
      return endOfPrefix(code);
    }
    function otherPrefix(code) {
      if (markdownSpace(code)) {
        effects.enter("listItemPrefixWhitespace");
        effects.consume(code);
        effects.exit("listItemPrefixWhitespace");
        return endOfPrefix;
      }
      return nok(code);
    }
    function endOfPrefix(code) {
      self2.containerState.size = initialSize + sizeChunks(self2.sliceStream(effects.exit("listItemPrefix")));
      return ok(code);
    }
  }
  function tokenizeListContinuation(effects, ok, nok) {
    var self2 = this;
    self2.containerState._closeFlow = undefined;
    return effects.check(partialBlankLine, onBlank, notBlank);
    function onBlank(code) {
      self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
      return factorySpace(effects, ok, "listItemIndent", self2.containerState.size + 1)(code);
    }
    function notBlank(code) {
      if (self2.containerState.furtherBlankLines || !markdownSpace(code)) {
        self2.containerState.furtherBlankLines = self2.containerState.initialBlankLine = undefined;
        return notInCurrentItem(code);
      }
      self2.containerState.furtherBlankLines = self2.containerState.initialBlankLine = undefined;
      return effects.attempt(indentConstruct, ok, notInCurrentItem)(code);
    }
    function notInCurrentItem(code) {
      self2.containerState._closeFlow = true;
      self2.interrupt = undefined;
      return factorySpace(effects, effects.attempt(list, ok, nok), "linePrefix", self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? undefined : 4)(code);
    }
  }
  function tokenizeIndent(effects, ok, nok) {
    var self2 = this;
    return factorySpace(effects, afterPrefix, "listItemIndent", self2.containerState.size + 1);
    function afterPrefix(code) {
      return prefixSize(self2.events, "listItemIndent") === self2.containerState.size ? ok(code) : nok(code);
    }
  }
  function tokenizeListEnd(effects) {
    effects.exit(this.containerState.type);
  }
  function tokenizeListItemPrefixWhitespace(effects, ok, nok) {
    var self2 = this;
    return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? undefined : 4 + 1);
    function afterPrefix(code) {
      return markdownSpace(code) || !prefixSize(self2.events, "listItemPrefixWhitespace") ? nok(code) : ok(code);
    }
  }
  module.exports = list;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/tokenize/setext-underline.js
var require_setext_underline = __commonJS((exports, module) => {
  var markdownLineEnding = require_markdown_line_ending2();
  var shallow = require_shallow2();
  var factorySpace = require_factory_space2();
  var setextUnderline = {
    name: "setextUnderline",
    tokenize: tokenizeSetextUnderline,
    resolveTo: resolveToSetextUnderline
  };
  function resolveToSetextUnderline(events, context) {
    var index = events.length;
    var content;
    var text;
    var definition;
    var heading;
    while (index--) {
      if (events[index][0] === "enter") {
        if (events[index][1].type === "content") {
          content = index;
          break;
        }
        if (events[index][1].type === "paragraph") {
          text = index;
        }
      } else {
        if (events[index][1].type === "content") {
          events.splice(index, 1);
        }
        if (!definition && events[index][1].type === "definition") {
          definition = index;
        }
      }
    }
    heading = {
      type: "setextHeading",
      start: shallow(events[text][1].start),
      end: shallow(events[events.length - 1][1].end)
    };
    events[text][1].type = "setextHeadingText";
    if (definition) {
      events.splice(text, 0, ["enter", heading, context]);
      events.splice(definition + 1, 0, ["exit", events[content][1], context]);
      events[content][1].end = shallow(events[definition][1].end);
    } else {
      events[content][1] = heading;
    }
    events.push(["exit", heading, context]);
    return events;
  }
  function tokenizeSetextUnderline(effects, ok, nok) {
    var self2 = this;
    var index = self2.events.length;
    var marker;
    var paragraph;
    while (index--) {
      if (self2.events[index][1].type !== "lineEnding" && self2.events[index][1].type !== "linePrefix" && self2.events[index][1].type !== "content") {
        paragraph = self2.events[index][1].type === "paragraph";
        break;
      }
    }
    return start;
    function start(code) {
      if (!self2.lazy && (self2.interrupt || paragraph)) {
        effects.enter("setextHeadingLine");
        effects.enter("setextHeadingLineSequence");
        marker = code;
        return closingSequence(code);
      }
      return nok(code);
    }
    function closingSequence(code) {
      if (code === marker) {
        effects.consume(code);
        return closingSequence;
      }
      effects.exit("setextHeadingLineSequence");
      return factorySpace(effects, closingSequenceEnd, "lineSuffix")(code);
    }
    function closingSequenceEnd(code) {
      if (code === null || markdownLineEnding(code)) {
        effects.exit("setextHeadingLine");
        return ok(code);
      }
      return nok(code);
    }
  }
  module.exports = setextUnderline;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/constructs.js
var require_constructs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var text$1 = require_text();
  var attention = require_attention();
  var autolink = require_autolink();
  var blockQuote = require_block_quote();
  var characterEscape = require_character_escape();
  var characterReference = require_character_reference();
  var codeFenced = require_code_fenced();
  var codeIndented = require_code_indented();
  var codeText = require_code_text();
  var definition = require_definition();
  var hardBreakEscape = require_hard_break_escape();
  var headingAtx = require_heading_atx();
  var htmlFlow = require_html_flow();
  var htmlText = require_html_text();
  var labelEnd = require_label_end();
  var labelStartImage = require_label_start_image();
  var labelStartLink = require_label_start_link();
  var lineEnding = require_line_ending();
  var list = require_list();
  var setextUnderline = require_setext_underline();
  var thematicBreak = require_thematic_break();
  var document2 = {
    42: list,
    43: list,
    45: list,
    48: list,
    49: list,
    50: list,
    51: list,
    52: list,
    53: list,
    54: list,
    55: list,
    56: list,
    57: list,
    62: blockQuote
  };
  var contentInitial = {
    91: definition
  };
  var flowInitial = {
    "-2": codeIndented,
    "-1": codeIndented,
    32: codeIndented
  };
  var flow = {
    35: headingAtx,
    42: thematicBreak,
    45: [setextUnderline, thematicBreak],
    60: htmlFlow,
    61: setextUnderline,
    95: thematicBreak,
    96: codeFenced,
    126: codeFenced
  };
  var string2 = {
    38: characterReference,
    92: characterEscape
  };
  var text = {
    "-5": lineEnding,
    "-4": lineEnding,
    "-3": lineEnding,
    33: labelStartImage,
    38: characterReference,
    42: attention,
    60: [autolink, htmlText],
    91: labelStartLink,
    92: [hardBreakEscape, characterEscape],
    93: labelEnd,
    95: attention,
    96: codeText
  };
  var insideSpan = {
    null: [attention, text$1.resolver]
  };
  var disable = {
    null: []
  };
  exports.contentInitial = contentInitial;
  exports.disable = disable;
  exports.document = document2;
  exports.flow = flow;
  exports.flowInitial = flowInitial;
  exports.insideSpan = insideSpan;
  exports.string = string2;
  exports.text = text;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/parse.js
var require_parse3 = __commonJS((exports, module) => {
  var content = require_content();
  var document2 = require_document();
  var flow = require_flow();
  var text = require_text();
  var combineExtensions = require_combine_extensions2();
  var createTokenizer = require_create_tokenizer();
  var miniflat = require_miniflat2();
  var constructs = require_constructs();
  function parse4(options) {
    var settings = options || {};
    var parser = {
      defined: [],
      constructs: combineExtensions([constructs].concat(miniflat(settings.extensions))),
      content: create(content),
      document: create(document2),
      flow: create(flow),
      string: create(text.string),
      text: create(text.text)
    };
    return parser;
    function create(initializer2) {
      return creator;
      function creator(from) {
        return createTokenizer(parser, initializer2, from);
      }
    }
  }
  module.exports = parse4;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/preprocess.js
var require_preprocess = __commonJS((exports, module) => {
  var search = /[\0\t\n\r]/g;
  function preprocess() {
    var start = true;
    var column = 1;
    var buffer = "";
    var atCarriageReturn;
    return preprocessor;
    function preprocessor(value, encoding, end) {
      var chunks = [];
      var match;
      var next;
      var startPosition;
      var endPosition;
      var code;
      value = buffer + value.toString(encoding);
      startPosition = 0;
      buffer = "";
      if (start) {
        if (value.charCodeAt(0) === 65279) {
          startPosition++;
        }
        start = undefined;
      }
      while (startPosition < value.length) {
        search.lastIndex = startPosition;
        match = search.exec(value);
        endPosition = match ? match.index : value.length;
        code = value.charCodeAt(endPosition);
        if (!match) {
          buffer = value.slice(startPosition);
          break;
        }
        if (code === 10 && startPosition === endPosition && atCarriageReturn) {
          chunks.push(-3);
          atCarriageReturn = undefined;
        } else {
          if (atCarriageReturn) {
            chunks.push(-5);
            atCarriageReturn = undefined;
          }
          if (startPosition < endPosition) {
            chunks.push(value.slice(startPosition, endPosition));
            column += endPosition - startPosition;
          }
          if (code === 0) {
            chunks.push(65533);
            column++;
          } else if (code === 9) {
            next = Math.ceil(column / 4) * 4;
            chunks.push(-2);
            while (column++ < next)
              chunks.push(-1);
          } else if (code === 10) {
            chunks.push(-4);
            column = 1;
          } else {
            atCarriageReturn = true;
            column = 1;
          }
        }
        startPosition = endPosition + 1;
      }
      if (end) {
        if (atCarriageReturn)
          chunks.push(-5);
        if (buffer)
          chunks.push(buffer);
        chunks.push(null);
      }
      return chunks;
    }
  }
  module.exports = preprocess;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/micromark/dist/postprocess.js
var require_postprocess = __commonJS((exports, module) => {
  var subtokenize = require_subtokenize();
  function postprocess(events) {
    while (!subtokenize(events)) {}
    return events;
  }
  module.exports = postprocess;
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/node_modules/unist-util-stringify-position/index.js
var require_unist_util_stringify_position = __commonJS((exports, module) => {
  var own = {}.hasOwnProperty;
  module.exports = stringify2;
  function stringify2(value) {
    if (!value || typeof value !== "object") {
      return "";
    }
    if (own.call(value, "position") || own.call(value, "type")) {
      return position(value.position);
    }
    if (own.call(value, "start") || own.call(value, "end")) {
      return position(value);
    }
    if (own.call(value, "line") || own.call(value, "column")) {
      return point(value);
    }
    return "";
  }
  function point(point2) {
    if (!point2 || typeof point2 !== "object") {
      point2 = {};
    }
    return index(point2.line) + ":" + index(point2.column);
  }
  function position(pos) {
    if (!pos || typeof pos !== "object") {
      pos = {};
    }
    return point(pos.start) + "-" + point(pos.end);
  }
  function index(value) {
    return value && typeof value === "number" ? value : 1;
  }
});

// node_modules/telegramify-markdown/node_modules/remark-parse/node_modules/mdast-util-from-markdown/dist/index.js
var require_dist3 = __commonJS((exports, module) => {
  module.exports = fromMarkdown;
  var toString = require_mdast_util_to_string();
  var assign = require_assign2();
  var own = require_has_own_property2();
  var normalizeIdentifier = require_normalize_identifier();
  var safeFromInt = require_safe_from_int();
  var parser = require_parse3();
  var preprocessor = require_preprocess();
  var postprocess = require_postprocess();
  var decode2 = require_decode_entity();
  var stringifyPosition = require_unist_util_stringify_position();
  function fromMarkdown(value, encoding, options) {
    if (typeof encoding !== "string") {
      options = encoding;
      encoding = undefined;
    }
    return compiler(options)(postprocess(parser(options).document().write(preprocessor()(value, encoding, true))));
  }
  function compiler(options) {
    var settings = options || {};
    var config2 = configure({
      transforms: [],
      canContainEols: [
        "emphasis",
        "fragment",
        "heading",
        "paragraph",
        "strong"
      ],
      enter: {
        autolink: opener(link),
        autolinkProtocol: onenterdata,
        autolinkEmail: onenterdata,
        atxHeading: opener(heading),
        blockQuote: opener(blockQuote),
        characterEscape: onenterdata,
        characterReference: onenterdata,
        codeFenced: opener(codeFlow),
        codeFencedFenceInfo: buffer,
        codeFencedFenceMeta: buffer,
        codeIndented: opener(codeFlow, buffer),
        codeText: opener(codeText, buffer),
        codeTextData: onenterdata,
        data: onenterdata,
        codeFlowValue: onenterdata,
        definition: opener(definition),
        definitionDestinationString: buffer,
        definitionLabelString: buffer,
        definitionTitleString: buffer,
        emphasis: opener(emphasis),
        hardBreakEscape: opener(hardBreak),
        hardBreakTrailing: opener(hardBreak),
        htmlFlow: opener(html, buffer),
        htmlFlowData: onenterdata,
        htmlText: opener(html, buffer),
        htmlTextData: onenterdata,
        image: opener(image),
        label: buffer,
        link: opener(link),
        listItem: opener(listItem),
        listItemValue: onenterlistitemvalue,
        listOrdered: opener(list, onenterlistordered),
        listUnordered: opener(list),
        paragraph: opener(paragraph),
        reference: onenterreference,
        referenceString: buffer,
        resourceDestinationString: buffer,
        resourceTitleString: buffer,
        setextHeading: opener(heading),
        strong: opener(strong),
        thematicBreak: opener(thematicBreak)
      },
      exit: {
        atxHeading: closer(),
        atxHeadingSequence: onexitatxheadingsequence,
        autolink: closer(),
        autolinkEmail: onexitautolinkemail,
        autolinkProtocol: onexitautolinkprotocol,
        blockQuote: closer(),
        characterEscapeValue: onexitdata,
        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
        characterReferenceValue: onexitcharacterreferencevalue,
        codeFenced: closer(onexitcodefenced),
        codeFencedFence: onexitcodefencedfence,
        codeFencedFenceInfo: onexitcodefencedfenceinfo,
        codeFencedFenceMeta: onexitcodefencedfencemeta,
        codeFlowValue: onexitdata,
        codeIndented: closer(onexitcodeindented),
        codeText: closer(onexitcodetext),
        codeTextData: onexitdata,
        data: onexitdata,
        definition: closer(),
        definitionDestinationString: onexitdefinitiondestinationstring,
        definitionLabelString: onexitdefinitionlabelstring,
        definitionTitleString: onexitdefinitiontitlestring,
        emphasis: closer(),
        hardBreakEscape: closer(onexithardbreak),
        hardBreakTrailing: closer(onexithardbreak),
        htmlFlow: closer(onexithtmlflow),
        htmlFlowData: onexitdata,
        htmlText: closer(onexithtmltext),
        htmlTextData: onexitdata,
        image: closer(onexitimage),
        label: onexitlabel,
        labelText: onexitlabeltext,
        lineEnding: onexitlineending,
        link: closer(onexitlink),
        listItem: closer(),
        listOrdered: closer(),
        listUnordered: closer(),
        paragraph: closer(),
        referenceString: onexitreferencestring,
        resourceDestinationString: onexitresourcedestinationstring,
        resourceTitleString: onexitresourcetitlestring,
        resource: onexitresource,
        setextHeading: closer(onexitsetextheading),
        setextHeadingLineSequence: onexitsetextheadinglinesequence,
        setextHeadingText: onexitsetextheadingtext,
        strong: closer(),
        thematicBreak: closer()
      }
    }, settings.mdastExtensions || []);
    var data = {};
    return compile;
    function compile(events) {
      var tree = { type: "root", children: [] };
      var stack = [tree];
      var tokenStack = [];
      var listStack = [];
      var index = -1;
      var handler;
      var listStart;
      var context = {
        stack,
        tokenStack,
        config: config2,
        enter,
        exit,
        buffer,
        resume,
        setData,
        getData
      };
      while (++index < events.length) {
        if (events[index][1].type === "listOrdered" || events[index][1].type === "listUnordered") {
          if (events[index][0] === "enter") {
            listStack.push(index);
          } else {
            listStart = listStack.pop(index);
            index = prepareList(events, listStart, index);
          }
        }
      }
      index = -1;
      while (++index < events.length) {
        handler = config2[events[index][0]];
        if (own.call(handler, events[index][1].type)) {
          handler[events[index][1].type].call(assign({ sliceSerialize: events[index][2].sliceSerialize }, context), events[index][1]);
        }
      }
      if (tokenStack.length) {
        throw new Error("Cannot close document, a token (`" + tokenStack[tokenStack.length - 1].type + "`, " + stringifyPosition({
          start: tokenStack[tokenStack.length - 1].start,
          end: tokenStack[tokenStack.length - 1].end
        }) + ") is still open");
      }
      tree.position = {
        start: point(events.length ? events[0][1].start : { line: 1, column: 1, offset: 0 }),
        end: point(events.length ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 })
      };
      index = -1;
      while (++index < config2.transforms.length) {
        tree = config2.transforms[index](tree) || tree;
      }
      return tree;
    }
    function prepareList(events, start, length) {
      var index = start - 1;
      var containerBalance = -1;
      var listSpread = false;
      var listItem2;
      var tailIndex;
      var lineIndex;
      var tailEvent;
      var event;
      var firstBlankLineIndex;
      var atMarker;
      while (++index <= length) {
        event = events[index];
        if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = undefined;
        } else if (event[1].type === "lineEndingBlank") {
          if (event[0] === "enter") {
            if (listItem2 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index;
            }
            atMarker = undefined;
          }
        } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace") {} else {
          atMarker = undefined;
        }
        if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
          if (listItem2) {
            tailIndex = index;
            lineIndex = undefined;
            while (tailIndex--) {
              tailEvent = events[tailIndex];
              if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
                if (tailEvent[0] === "exit")
                  continue;
                if (lineIndex) {
                  events[lineIndex][1].type = "lineEndingBlank";
                  listSpread = true;
                }
                tailEvent[1].type = "lineEnding";
                lineIndex = tailIndex;
              } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {} else {
                break;
              }
            }
            if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
              listItem2._spread = true;
            }
            listItem2.end = point(lineIndex ? events[lineIndex][1].start : event[1].end);
            events.splice(lineIndex || index, 0, ["exit", listItem2, event[2]]);
            index++;
            length++;
          }
          if (event[1].type === "listItemPrefix") {
            listItem2 = {
              type: "listItem",
              _spread: false,
              start: point(event[1].start)
            };
            events.splice(index, 0, ["enter", listItem2, event[2]]);
            index++;
            length++;
            firstBlankLineIndex = undefined;
            atMarker = true;
          }
        }
      }
      events[start][1]._spread = listSpread;
      return length;
    }
    function setData(key, value) {
      data[key] = value;
    }
    function getData(key) {
      return data[key];
    }
    function point(d) {
      return { line: d.line, column: d.column, offset: d.offset };
    }
    function opener(create, and) {
      return open;
      function open(token) {
        enter.call(this, create(token), token);
        if (and)
          and.call(this, token);
      }
    }
    function buffer() {
      this.stack.push({ type: "fragment", children: [] });
    }
    function enter(node, token) {
      this.stack[this.stack.length - 1].children.push(node);
      this.stack.push(node);
      this.tokenStack.push(token);
      node.position = { start: point(token.start) };
      return node;
    }
    function closer(and) {
      return close;
      function close(token) {
        if (and)
          and.call(this, token);
        exit.call(this, token);
      }
    }
    function exit(token) {
      var node = this.stack.pop();
      var open = this.tokenStack.pop();
      if (!open) {
        throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): it\u2019s not open");
      } else if (open.type !== token.type) {
        throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): a different token (`" + open.type + "`, " + stringifyPosition({ start: open.start, end: open.end }) + ") is open");
      }
      node.position.end = point(token.end);
      return node;
    }
    function resume() {
      return toString(this.stack.pop());
    }
    function onenterlistordered() {
      setData("expectingFirstListItemValue", true);
    }
    function onenterlistitemvalue(token) {
      if (getData("expectingFirstListItemValue")) {
        this.stack[this.stack.length - 2].start = parseInt(this.sliceSerialize(token), 10);
        setData("expectingFirstListItemValue");
      }
    }
    function onexitcodefencedfenceinfo() {
      var data2 = this.resume();
      this.stack[this.stack.length - 1].lang = data2;
    }
    function onexitcodefencedfencemeta() {
      var data2 = this.resume();
      this.stack[this.stack.length - 1].meta = data2;
    }
    function onexitcodefencedfence() {
      if (getData("flowCodeInside"))
        return;
      this.buffer();
      setData("flowCodeInside", true);
    }
    function onexitcodefenced() {
      var data2 = this.resume();
      this.stack[this.stack.length - 1].value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
      setData("flowCodeInside");
    }
    function onexitcodeindented() {
      var data2 = this.resume();
      this.stack[this.stack.length - 1].value = data2;
    }
    function onexitdefinitionlabelstring(token) {
      var label = this.resume();
      this.stack[this.stack.length - 1].label = label;
      this.stack[this.stack.length - 1].identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    }
    function onexitdefinitiontitlestring() {
      var data2 = this.resume();
      this.stack[this.stack.length - 1].title = data2;
    }
    function onexitdefinitiondestinationstring() {
      var data2 = this.resume();
      this.stack[this.stack.length - 1].url = data2;
    }
    function onexitatxheadingsequence(token) {
      if (!this.stack[this.stack.length - 1].depth) {
        this.stack[this.stack.length - 1].depth = this.sliceSerialize(token).length;
      }
    }
    function onexitsetextheadingtext() {
      setData("setextHeadingSlurpLineEnding", true);
    }
    function onexitsetextheadinglinesequence(token) {
      this.stack[this.stack.length - 1].depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
    }
    function onexitsetextheading() {
      setData("setextHeadingSlurpLineEnding");
    }
    function onenterdata(token) {
      var siblings = this.stack[this.stack.length - 1].children;
      var tail = siblings[siblings.length - 1];
      if (!tail || tail.type !== "text") {
        tail = text();
        tail.position = { start: point(token.start) };
        this.stack[this.stack.length - 1].children.push(tail);
      }
      this.stack.push(tail);
    }
    function onexitdata(token) {
      var tail = this.stack.pop();
      tail.value += this.sliceSerialize(token);
      tail.position.end = point(token.end);
    }
    function onexitlineending(token) {
      var context = this.stack[this.stack.length - 1];
      if (getData("atHardBreak")) {
        context.children[context.children.length - 1].position.end = point(token.end);
        setData("atHardBreak");
        return;
      }
      if (!getData("setextHeadingSlurpLineEnding") && config2.canContainEols.indexOf(context.type) > -1) {
        onenterdata.call(this, token);
        onexitdata.call(this, token);
      }
    }
    function onexithardbreak() {
      setData("atHardBreak", true);
    }
    function onexithtmlflow() {
      var data2 = this.resume();
      this.stack[this.stack.length - 1].value = data2;
    }
    function onexithtmltext() {
      var data2 = this.resume();
      this.stack[this.stack.length - 1].value = data2;
    }
    function onexitcodetext() {
      var data2 = this.resume();
      this.stack[this.stack.length - 1].value = data2;
    }
    function onexitlink() {
      var context = this.stack[this.stack.length - 1];
      if (getData("inReference")) {
        context.type += "Reference";
        context.referenceType = getData("referenceType") || "shortcut";
        delete context.url;
        delete context.title;
      } else {
        delete context.identifier;
        delete context.label;
        delete context.referenceType;
      }
      setData("referenceType");
    }
    function onexitimage() {
      var context = this.stack[this.stack.length - 1];
      if (getData("inReference")) {
        context.type += "Reference";
        context.referenceType = getData("referenceType") || "shortcut";
        delete context.url;
        delete context.title;
      } else {
        delete context.identifier;
        delete context.label;
        delete context.referenceType;
      }
      setData("referenceType");
    }
    function onexitlabeltext(token) {
      this.stack[this.stack.length - 2].identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    }
    function onexitlabel() {
      var fragment = this.stack[this.stack.length - 1];
      var value = this.resume();
      this.stack[this.stack.length - 1].label = value;
      setData("inReference", true);
      if (this.stack[this.stack.length - 1].type === "link") {
        this.stack[this.stack.length - 1].children = fragment.children;
      } else {
        this.stack[this.stack.length - 1].alt = value;
      }
    }
    function onexitresourcedestinationstring() {
      var data2 = this.resume();
      this.stack[this.stack.length - 1].url = data2;
    }
    function onexitresourcetitlestring() {
      var data2 = this.resume();
      this.stack[this.stack.length - 1].title = data2;
    }
    function onexitresource() {
      setData("inReference");
    }
    function onenterreference() {
      setData("referenceType", "collapsed");
    }
    function onexitreferencestring(token) {
      var label = this.resume();
      this.stack[this.stack.length - 1].label = label;
      this.stack[this.stack.length - 1].identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
      setData("referenceType", "full");
    }
    function onexitcharacterreferencemarker(token) {
      setData("characterReferenceType", token.type);
    }
    function onexitcharacterreferencevalue(token) {
      var data2 = this.sliceSerialize(token);
      var type = getData("characterReferenceType");
      var value;
      var tail;
      if (type) {
        value = safeFromInt(data2, type === "characterReferenceMarkerNumeric" ? 10 : 16);
        setData("characterReferenceType");
      } else {
        value = decode2(data2);
      }
      tail = this.stack.pop();
      tail.value += value;
      tail.position.end = point(token.end);
    }
    function onexitautolinkprotocol(token) {
      onexitdata.call(this, token);
      this.stack[this.stack.length - 1].url = this.sliceSerialize(token);
    }
    function onexitautolinkemail(token) {
      onexitdata.call(this, token);
      this.stack[this.stack.length - 1].url = "mailto:" + this.sliceSerialize(token);
    }
    function blockQuote() {
      return { type: "blockquote", children: [] };
    }
    function codeFlow() {
      return { type: "code", lang: null, meta: null, value: "" };
    }
    function codeText() {
      return { type: "inlineCode", value: "" };
    }
    function definition() {
      return {
        type: "definition",
        identifier: "",
        label: null,
        title: null,
        url: ""
      };
    }
    function emphasis() {
      return { type: "emphasis", children: [] };
    }
    function heading() {
      return { type: "heading", depth: undefined, children: [] };
    }
    function hardBreak() {
      return { type: "break" };
    }
    function html() {
      return { type: "html", value: "" };
    }
    function image() {
      return { type: "image", title: null, url: "", alt: null };
    }
    function link() {
      return { type: "link", title: null, url: "", children: [] };
    }
    function list(token) {
      return {
        type: "list",
        ordered: token.type === "listOrdered",
        start: null,
        spread: token._spread,
        children: []
      };
    }
    function listItem(token) {
      return {
        type: "listItem",
        spread: token._spread,
        checked: null,
        children: []
      };
    }
    function paragraph() {
      return { type: "paragraph", children: [] };
    }
    function strong() {
      return { type: "strong", children: [] };
    }
    function text() {
      return { type: "text", value: "" };
    }
    function thematicBreak() {
      return { type: "thematicBreak" };
    }
  }
  function configure(config2, extensions) {
    var index = -1;
    while (++index < extensions.length) {
      extension(config2, extensions[index]);
    }
    return config2;
  }
  function extension(config2, extension2) {
    var key;
    var left;
    for (key in extension2) {
      left = own.call(config2, key) ? config2[key] : config2[key] = {};
      if (key === "canContainEols" || key === "transforms") {
        config2[key] = [].concat(left, extension2[key]);
      } else {
        Object.assign(left, extension2[key]);
      }
    }
  }
});

// node_modules/telegramify-markdown/node_modules/remark-parse/index.js
var require_remark_parse = __commonJS((exports, module) => {
  module.exports = parse4;
  var fromMarkdown = require_dist3();
  function parse4(options) {
    var self2 = this;
    this.Parser = parse5;
    function parse5(doc2) {
      return fromMarkdown(doc2, Object.assign({}, self2.data("settings"), options, {
        extensions: self2.data("micromarkExtensions") || [],
        mdastExtensions: self2.data("fromMarkdownExtensions") || []
      }));
    }
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/node_modules/zwitch/index.js
var require_zwitch = __commonJS((exports, module) => {
  module.exports = factory;
  var noop = Function.prototype;
  var own = {}.hasOwnProperty;
  function factory(key, options) {
    var settings = options || {};
    function one(value) {
      var fn = one.invalid;
      var handlers = one.handlers;
      if (value && own.call(value, key)) {
        fn = own.call(handlers, value[key]) ? handlers[value[key]] : one.unknown;
      }
      return (fn || noop).apply(this, arguments);
    }
    one.handlers = settings.handlers || {};
    one.invalid = settings.invalid;
    one.unknown = settings.unknown;
    return one;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
var require_blockquote = __commonJS((exports, module) => {
  module.exports = blockquote;
  var flow = require_container_flow();
  var indentLines = require_indent_lines();
  function blockquote(node, _, context) {
    var exit = context.enter("blockquote");
    var value = indentLines(flow(node, context), map);
    exit();
    return value;
  }
  function map(line, index, blank) {
    return ">" + (blank ? "" : " ") + line;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
var require_pattern_in_scope = __commonJS((exports, module) => {
  module.exports = patternInScope;
  function patternInScope(stack, pattern) {
    return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct);
  }
  function listInScope(stack, list, none) {
    var index;
    if (!list) {
      return none;
    }
    if (typeof list === "string") {
      list = [list];
    }
    index = -1;
    while (++index < list.length) {
      if (stack.indexOf(list[index]) !== -1) {
        return true;
      }
    }
    return false;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/break.js
var require_break = __commonJS((exports, module) => {
  module.exports = hardBreak;
  var patternInScope = require_pattern_in_scope();
  function hardBreak(node, _, context, safe) {
    var index = -1;
    while (++index < context.unsafe.length) {
      if (context.unsafe[index].character === `
` && patternInScope(context.stack, context.unsafe[index])) {
        return /[ \t]/.test(safe.before) ? "" : " ";
      }
    }
    return "\\\n";
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/node_modules/longest-streak/index.js
var require_longest_streak = __commonJS((exports, module) => {
  module.exports = longestStreak;
  function longestStreak(value, character) {
    var count = 0;
    var maximum = 0;
    var expected;
    var index;
    if (typeof character !== "string" || character.length !== 1) {
      throw new Error("Expected character");
    }
    value = String(value);
    index = value.indexOf(character);
    expected = index;
    while (index !== -1) {
      count++;
      if (index === expected) {
        if (count > maximum) {
          maximum = count;
        }
      } else {
        count = 1;
      }
      expected = index + 1;
      index = value.indexOf(character, expected);
    }
    return maximum;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
var require_format_code_as_indented = __commonJS((exports, module) => {
  module.exports = formatCodeAsIndented;
  function formatCodeAsIndented(node, context) {
    return !context.options.fences && node.value && !node.lang && /[^ \r\n]/.test(node.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node.value);
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/check-fence.js
var require_check_fence = __commonJS((exports, module) => {
  module.exports = checkFence;
  function checkFence(context) {
    var marker = context.options.fence || "`";
    if (marker !== "`" && marker !== "~") {
      throw new Error("Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`");
    }
    return marker;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/safe.js
var require_safe = __commonJS((exports, module) => {
  module.exports = safe;
  var patternCompile = require_pattern_compile();
  var patternInScope = require_pattern_in_scope();
  function safe(context, input, config2) {
    var value = (config2.before || "") + (input || "") + (config2.after || "");
    var positions = [];
    var result = [];
    var infos = {};
    var index = -1;
    var before;
    var after;
    var position;
    var pattern;
    var expression;
    var match;
    var start;
    var end;
    while (++index < context.unsafe.length) {
      pattern = context.unsafe[index];
      if (!patternInScope(context.stack, pattern)) {
        continue;
      }
      expression = patternCompile(pattern);
      while (match = expression.exec(value)) {
        before = "before" in pattern || pattern.atBreak;
        after = "after" in pattern;
        position = match.index + (before ? match[1].length : 0);
        if (positions.indexOf(position) === -1) {
          positions.push(position);
          infos[position] = { before, after };
        } else {
          if (infos[position].before && !before) {
            infos[position].before = false;
          }
          if (infos[position].after && !after) {
            infos[position].after = false;
          }
        }
      }
    }
    positions.sort(numerical);
    start = config2.before ? config2.before.length : 0;
    end = value.length - (config2.after ? config2.after.length : 0);
    index = -1;
    while (++index < positions.length) {
      position = positions[index];
      if (position < start || position >= end) {
        continue;
      }
      if (position + 1 < end && positions[index + 1] === position + 1 && infos[position].after && !infos[position + 1].before && !infos[position + 1].after) {
        continue;
      }
      if (start !== position) {
        result.push(escapeBackslashes(value.slice(start, position), "\\"));
      }
      start = position;
      if (/[!-/:-@[-`{-~]/.test(value.charAt(position)) && (!config2.encode || config2.encode.indexOf(value.charAt(position)) === -1)) {
        result.push("\\");
      } else {
        result.push("&#x" + value.charCodeAt(position).toString(16).toUpperCase() + ";");
        start++;
      }
    }
    result.push(escapeBackslashes(value.slice(start, end), config2.after));
    return result.join("");
  }
  function numerical(a, b) {
    return a - b;
  }
  function escapeBackslashes(value, after) {
    var expression = /\\(?=[!-/:-@[-`{-~])/g;
    var positions = [];
    var results = [];
    var index = -1;
    var start = 0;
    var whole = value + after;
    var match;
    while (match = expression.exec(whole)) {
      positions.push(match.index);
    }
    while (++index < positions.length) {
      if (start !== positions[index]) {
        results.push(value.slice(start, positions[index]));
      }
      results.push("\\");
      start = positions[index];
    }
    results.push(value.slice(start));
    return results.join("");
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/code.js
var require_code = __commonJS((exports, module) => {
  module.exports = code;
  var repeat = require_repeat_string();
  var streak = require_longest_streak();
  var formatCodeAsIndented = require_format_code_as_indented();
  var checkFence = require_check_fence();
  var indentLines = require_indent_lines();
  var safe = require_safe();
  function code(node, _, context) {
    var marker = checkFence(context);
    var raw = node.value || "";
    var suffix = marker === "`" ? "GraveAccent" : "Tilde";
    var value;
    var sequence;
    var exit;
    var subexit;
    if (formatCodeAsIndented(node, context)) {
      exit = context.enter("codeIndented");
      value = indentLines(raw, map);
    } else {
      sequence = repeat(marker, Math.max(streak(raw, marker) + 1, 3));
      exit = context.enter("codeFenced");
      value = sequence;
      if (node.lang) {
        subexit = context.enter("codeFencedLang" + suffix);
        value += safe(context, node.lang, {
          before: "`",
          after: " ",
          encode: ["`"]
        });
        subexit();
      }
      if (node.lang && node.meta) {
        subexit = context.enter("codeFencedMeta" + suffix);
        value += " " + safe(context, node.meta, {
          before: " ",
          after: `
`,
          encode: ["`"]
        });
        subexit();
      }
      value += `
`;
      if (raw) {
        value += raw + `
`;
      }
      value += sequence;
    }
    exit();
    return value;
  }
  function map(line, _, blank) {
    return (blank ? "" : "    ") + line;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/association.js
var require_association = __commonJS((exports, module) => {
  module.exports = association;
  var decode2 = require_decode_entity();
  var characterEscape = /\\([!-/:-@[-`{-~])/g;
  var characterReference = /&(#(\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
  function association(node) {
    if (node.label || !node.identifier) {
      return node.label || "";
    }
    return node.identifier.replace(characterEscape, "$1").replace(characterReference, decodeIfPossible);
  }
  function decodeIfPossible($0, $1) {
    return decode2($1) || $0;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/check-quote.js
var require_check_quote = __commonJS((exports, module) => {
  module.exports = checkQuote;
  function checkQuote(context) {
    var marker = context.options.quote || '"';
    if (marker !== '"' && marker !== "'") {
      throw new Error("Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`");
    }
    return marker;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/definition.js
var require_definition2 = __commonJS((exports, module) => {
  module.exports = definition;
  var association = require_association();
  var checkQuote = require_check_quote();
  var safe = require_safe();
  function definition(node, _, context) {
    var marker = checkQuote(context);
    var suffix = marker === '"' ? "Quote" : "Apostrophe";
    var exit = context.enter("definition");
    var subexit = context.enter("label");
    var value = "[" + safe(context, association(node), { before: "[", after: "]" }) + "]: ";
    subexit();
    if (!node.url || /[ \t\r\n]/.test(node.url)) {
      subexit = context.enter("destinationLiteral");
      value += "<" + safe(context, node.url, { before: "<", after: ">" }) + ">";
    } else {
      subexit = context.enter("destinationRaw");
      value += safe(context, node.url, { before: " ", after: " " });
    }
    subexit();
    if (node.title) {
      subexit = context.enter("title" + suffix);
      value += " " + marker + safe(context, node.title, { before: marker, after: marker }) + marker;
      subexit();
    }
    exit();
    return value;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
var require_check_emphasis = __commonJS((exports, module) => {
  module.exports = checkEmphasis;
  function checkEmphasis(context) {
    var marker = context.options.emphasis || "*";
    if (marker !== "*" && marker !== "_") {
      throw new Error("Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`");
    }
    return marker;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
var require_emphasis = __commonJS((exports, module) => {
  module.exports = emphasis;
  emphasis.peek = emphasisPeek;
  var checkEmphasis = require_check_emphasis();
  var phrasing = require_container_phrasing();
  function emphasis(node, _, context) {
    var marker = checkEmphasis(context);
    var exit = context.enter("emphasis");
    var value = phrasing(node, context, { before: marker, after: marker });
    exit();
    return marker + value + marker;
  }
  function emphasisPeek(node, _, context) {
    return context.options.emphasis || "*";
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/node_modules/mdast-util-to-string/index.js
var require_mdast_util_to_string2 = __commonJS((exports, module) => {
  module.exports = toString;
  function toString(node) {
    return node && (node.value || node.alt || node.title || ("children" in node) && all(node.children) || ("length" in node) && all(node)) || "";
  }
  function all(values) {
    var result = [];
    var index = -1;
    while (++index < values.length) {
      result[index] = toString(values[index]);
    }
    return result.join("");
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
var require_format_heading_as_setext = __commonJS((exports, module) => {
  module.exports = formatHeadingAsSetext;
  var toString = require_mdast_util_to_string2();
  function formatHeadingAsSetext(node, context) {
    return context.options.setext && (!node.depth || node.depth < 3) && toString(node);
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/heading.js
var require_heading = __commonJS((exports, module) => {
  module.exports = heading;
  var repeat = require_repeat_string();
  var formatHeadingAsSetext = require_format_heading_as_setext();
  var phrasing = require_container_phrasing();
  function heading(node, _, context) {
    var rank = Math.max(Math.min(6, node.depth || 1), 1);
    var exit;
    var subexit;
    var value;
    var sequence;
    if (formatHeadingAsSetext(node, context)) {
      exit = context.enter("headingSetext");
      subexit = context.enter("phrasing");
      value = phrasing(node, context, { before: `
`, after: `
` });
      subexit();
      exit();
      return value + `
` + repeat(rank === 1 ? "=" : "-", value.length - (Math.max(value.lastIndexOf("\r"), value.lastIndexOf(`
`)) + 1));
    }
    sequence = repeat("#", rank);
    exit = context.enter("headingAtx");
    subexit = context.enter("phrasing");
    value = phrasing(node, context, { before: "# ", after: `
` });
    value = value ? sequence + " " + value : sequence;
    if (context.options.closeAtx) {
      value += " " + sequence;
    }
    subexit();
    exit();
    return value;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/html.js
var require_html = __commonJS((exports, module) => {
  module.exports = html;
  html.peek = htmlPeek;
  function html(node) {
    return node.value || "";
  }
  function htmlPeek() {
    return "<";
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/image.js
var require_image = __commonJS((exports, module) => {
  module.exports = image;
  image.peek = imagePeek;
  var checkQuote = require_check_quote();
  var safe = require_safe();
  function image(node, _, context) {
    var quote = checkQuote(context);
    var suffix = quote === '"' ? "Quote" : "Apostrophe";
    var exit = context.enter("image");
    var subexit = context.enter("label");
    var value = "![" + safe(context, node.alt, { before: "[", after: "]" }) + "](";
    subexit();
    if (!node.url && node.title || /[ \t\r\n]/.test(node.url)) {
      subexit = context.enter("destinationLiteral");
      value += "<" + safe(context, node.url, { before: "<", after: ">" }) + ">";
    } else {
      subexit = context.enter("destinationRaw");
      value += safe(context, node.url, {
        before: "(",
        after: node.title ? " " : ")"
      });
    }
    subexit();
    if (node.title) {
      subexit = context.enter("title" + suffix);
      value += " " + quote + safe(context, node.title, { before: quote, after: quote }) + quote;
      subexit();
    }
    value += ")";
    exit();
    return value;
  }
  function imagePeek() {
    return "!";
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
var require_image_reference = __commonJS((exports, module) => {
  module.exports = imageReference;
  imageReference.peek = imageReferencePeek;
  var association = require_association();
  var safe = require_safe();
  function imageReference(node, _, context) {
    var type = node.referenceType;
    var exit = context.enter("imageReference");
    var subexit = context.enter("label");
    var alt = safe(context, node.alt, { before: "[", after: "]" });
    var value = "![" + alt + "]";
    var reference;
    var stack;
    subexit();
    stack = context.stack;
    context.stack = [];
    subexit = context.enter("reference");
    reference = safe(context, association(node), { before: "[", after: "]" });
    subexit();
    context.stack = stack;
    exit();
    if (type === "full" || !alt || alt !== reference) {
      value += "[" + reference + "]";
    } else if (type !== "shortcut") {
      value += "[]";
    }
    return value;
  }
  function imageReferencePeek() {
    return "!";
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
var require_format_link_as_autolink = __commonJS((exports, module) => {
  module.exports = formatLinkAsAutolink;
  var toString = require_mdast_util_to_string2();
  function formatLinkAsAutolink(node, context) {
    var raw = toString(node);
    return !context.options.resourceLink && node.url && !node.title && node.children && node.children.length === 1 && node.children[0].type === "text" && (raw === node.url || "mailto:" + raw === node.url) && /^[a-z][a-z+.-]+:/i.test(node.url) && !/[\0- <>\u007F]/.test(node.url);
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/link.js
var require_link = __commonJS((exports, module) => {
  module.exports = link;
  link.peek = linkPeek;
  var checkQuote = require_check_quote();
  var formatLinkAsAutolink = require_format_link_as_autolink();
  var phrasing = require_container_phrasing();
  var safe = require_safe();
  function link(node, _, context) {
    var quote = checkQuote(context);
    var suffix = quote === '"' ? "Quote" : "Apostrophe";
    var exit;
    var subexit;
    var value;
    var stack;
    if (formatLinkAsAutolink(node, context)) {
      stack = context.stack;
      context.stack = [];
      exit = context.enter("autolink");
      value = "<" + phrasing(node, context, { before: "<", after: ">" }) + ">";
      exit();
      context.stack = stack;
      return value;
    }
    exit = context.enter("link");
    subexit = context.enter("label");
    value = "[" + phrasing(node, context, { before: "[", after: "]" }) + "](";
    subexit();
    if (!node.url && node.title || /[ \t\r\n]/.test(node.url)) {
      subexit = context.enter("destinationLiteral");
      value += "<" + safe(context, node.url, { before: "<", after: ">" }) + ">";
    } else {
      subexit = context.enter("destinationRaw");
      value += safe(context, node.url, {
        before: "(",
        after: node.title ? " " : ")"
      });
    }
    subexit();
    if (node.title) {
      subexit = context.enter("title" + suffix);
      value += " " + quote + safe(context, node.title, { before: quote, after: quote }) + quote;
      subexit();
    }
    value += ")";
    exit();
    return value;
  }
  function linkPeek(node, _, context) {
    return formatLinkAsAutolink(node, context) ? "<" : "[";
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
var require_link_reference = __commonJS((exports, module) => {
  module.exports = linkReference;
  linkReference.peek = linkReferencePeek;
  var association = require_association();
  var phrasing = require_container_phrasing();
  var safe = require_safe();
  function linkReference(node, _, context) {
    var type = node.referenceType;
    var exit = context.enter("linkReference");
    var subexit = context.enter("label");
    var text = phrasing(node, context, { before: "[", after: "]" });
    var value = "[" + text + "]";
    var reference;
    var stack;
    subexit();
    stack = context.stack;
    context.stack = [];
    subexit = context.enter("reference");
    reference = safe(context, association(node), { before: "[", after: "]" });
    subexit();
    context.stack = stack;
    exit();
    if (type === "full" || !text || text !== reference) {
      value += "[" + reference + "]";
    } else if (type !== "shortcut") {
      value += "[]";
    }
    return value;
  }
  function linkReferencePeek() {
    return "[";
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/list.js
var require_list2 = __commonJS((exports, module) => {
  module.exports = list;
  var flow = require_container_flow();
  function list(node, _, context) {
    var exit = context.enter("list");
    var value = flow(node, context);
    exit();
    return value;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
var require_paragraph = __commonJS((exports, module) => {
  module.exports = paragraph;
  var phrasing = require_container_phrasing();
  function paragraph(node, _, context) {
    var exit = context.enter("paragraph");
    var subexit = context.enter("phrasing");
    var value = phrasing(node, context, { before: `
`, after: `
` });
    subexit();
    exit();
    return value;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/root.js
var require_root = __commonJS((exports, module) => {
  module.exports = root;
  var flow = require_container_flow();
  function root(node, _, context) {
    return flow(node, context);
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/check-strong.js
var require_check_strong = __commonJS((exports, module) => {
  module.exports = checkStrong;
  function checkStrong(context) {
    var marker = context.options.strong || "*";
    if (marker !== "*" && marker !== "_") {
      throw new Error("Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`");
    }
    return marker;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/strong.js
var require_strong = __commonJS((exports, module) => {
  module.exports = strong;
  strong.peek = strongPeek;
  var checkStrong = require_check_strong();
  var phrasing = require_container_phrasing();
  function strong(node, _, context) {
    var marker = checkStrong(context);
    var exit = context.enter("strong");
    var value = phrasing(node, context, { before: marker, after: marker });
    exit();
    return marker + marker + value + marker + marker;
  }
  function strongPeek(node, _, context) {
    return context.options.strong || "*";
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/text.js
var require_text2 = __commonJS((exports, module) => {
  module.exports = text;
  var safe = require_safe();
  function text(node, parent, context, safeOptions) {
    return safe(context, node.value, safeOptions);
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/check-rule-repeat.js
var require_check_rule_repeat = __commonJS((exports, module) => {
  module.exports = checkRule;
  function checkRule(context) {
    var repetition = context.options.ruleRepetition || 3;
    if (repetition < 3) {
      throw new Error("Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more");
    }
    return repetition;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/util/check-rule.js
var require_check_rule = __commonJS((exports, module) => {
  module.exports = checkRule;
  function checkRule(context) {
    var marker = context.options.rule || "*";
    if (marker !== "*" && marker !== "-" && marker !== "_") {
      throw new Error("Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`");
    }
    return marker;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
var require_thematic_break2 = __commonJS((exports, module) => {
  module.exports = thematicBreak;
  var repeat = require_repeat_string();
  var checkRepeat = require_check_rule_repeat();
  var checkRule = require_check_rule();
  function thematicBreak(node, parent, context) {
    var value = repeat(checkRule(context) + (context.options.ruleSpaces ? " " : ""), checkRepeat(context));
    return context.options.ruleSpaces ? value.slice(0, -1) : value;
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/handle/index.js
var require_handle = __commonJS((exports) => {
  exports.blockquote = require_blockquote();
  exports.break = require_break();
  exports.code = require_code();
  exports.definition = require_definition2();
  exports.emphasis = require_emphasis();
  exports.hardBreak = require_break();
  exports.heading = require_heading();
  exports.html = require_html();
  exports.image = require_image();
  exports.imageReference = require_image_reference();
  exports.inlineCode = require_inline_code();
  exports.link = require_link();
  exports.linkReference = require_link_reference();
  exports.list = require_list2();
  exports.listItem = require_list_item();
  exports.paragraph = require_paragraph();
  exports.root = require_root();
  exports.strong = require_strong();
  exports.text = require_text2();
  exports.thematicBreak = require_thematic_break2();
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/join.js
var require_join = __commonJS((exports, module) => {
  module.exports = [joinDefaults];
  var formatCodeAsIndented = require_format_code_as_indented();
  var formatHeadingAsSetext = require_format_heading_as_setext();
  function joinDefaults(left, right, parent, context) {
    if (right.type === "list" && right.type === left.type && Boolean(left.ordered) === Boolean(right.ordered) || right.type === "code" && formatCodeAsIndented(right, context) && (left.type === "list" || left.type === right.type && formatCodeAsIndented(left, context))) {
      return false;
    }
    if (typeof parent.spread === "boolean") {
      if (left.type === "paragraph" && (left.type === right.type || right.type === "definition" || right.type === "heading" && formatHeadingAsSetext(right, context))) {
        return;
      }
      return parent.spread ? 1 : 0;
    }
  }
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/unsafe.js
var require_unsafe = __commonJS((exports, module) => {
  module.exports = [
    {
      character: "\t",
      inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
    },
    {
      character: "\r",
      inConstruct: [
        "codeFencedLangGraveAccent",
        "codeFencedLangTilde",
        "codeFencedMetaGraveAccent",
        "codeFencedMetaTilde",
        "destinationLiteral",
        "headingAtx"
      ]
    },
    {
      character: `
`,
      inConstruct: [
        "codeFencedLangGraveAccent",
        "codeFencedLangTilde",
        "codeFencedMetaGraveAccent",
        "codeFencedMetaTilde",
        "destinationLiteral",
        "headingAtx"
      ]
    },
    {
      character: " ",
      inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
    },
    { character: "!", after: "\\[", inConstruct: "phrasing" },
    { character: '"', inConstruct: "titleQuote" },
    { atBreak: true, character: "#" },
    { character: "#", inConstruct: "headingAtx", after: `(?:[\r
]|$)` },
    { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
    { character: "'", inConstruct: "titleApostrophe" },
    { character: "(", inConstruct: "destinationRaw" },
    { before: "\\]", character: "(", inConstruct: "phrasing" },
    { atBreak: true, before: "\\d+", character: ")" },
    { character: ")", inConstruct: "destinationRaw" },
    { atBreak: true, character: "*" },
    { character: "*", inConstruct: "phrasing" },
    { atBreak: true, character: "+" },
    { atBreak: true, character: "-" },
    { atBreak: true, before: "\\d+", character: ".", after: `(?:[ 	\r
]|$)` },
    { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
    { character: "<", after: "[!/?A-Za-z]", inConstruct: "phrasing" },
    { character: "<", inConstruct: "destinationLiteral" },
    { atBreak: true, character: "=" },
    { atBreak: true, character: ">" },
    { character: ">", inConstruct: "destinationLiteral" },
    { atBreak: true, character: "[" },
    { character: "[", inConstruct: ["phrasing", "label", "reference"] },
    { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
    {
      character: "]",
      inConstruct: ["label", "reference"]
    },
    { atBreak: true, character: "_" },
    { before: "[^A-Za-z]", character: "_", inConstruct: "phrasing" },
    { character: "_", after: "[^A-Za-z]", inConstruct: "phrasing" },
    { atBreak: true, character: "`" },
    {
      character: "`",
      inConstruct: [
        "codeFencedLangGraveAccent",
        "codeFencedMetaGraveAccent",
        "phrasing"
      ]
    },
    { atBreak: true, character: "~" }
  ];
});

// node_modules/telegramify-markdown/node_modules/mdast-util-to-markdown/lib/index.js
var require_lib = __commonJS((exports, module) => {
  module.exports = toMarkdown;
  var zwitch = require_zwitch();
  var configure = require_configure();
  var defaultHandlers = require_handle();
  var defaultJoin = require_join();
  var defaultUnsafe = require_unsafe();
  function toMarkdown(tree, options) {
    var settings = options || {};
    var context = {
      enter,
      stack: [],
      unsafe: [],
      join: [],
      handlers: {},
      options: {}
    };
    var result;
    configure(context, {
      unsafe: defaultUnsafe,
      join: defaultJoin,
      handlers: defaultHandlers
    });
    configure(context, settings);
    if (context.options.tightDefinitions) {
      context.join = [joinDefinition].concat(context.join);
    }
    context.handle = zwitch("type", {
      invalid,
      unknown,
      handlers: context.handlers
    });
    result = context.handle(tree, null, context, { before: `
`, after: `
` });
    if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {
      result += `
`;
    }
    return result;
    function enter(name) {
      context.stack.push(name);
      return exit;
      function exit() {
        context.stack.pop();
      }
    }
  }
  function invalid(value) {
    throw new Error("Cannot handle value `" + value + "`, expected node");
  }
  function unknown(node) {
    throw new Error("Cannot handle unknown node `" + node.type + "`");
  }
  function joinDefinition(left, right) {
    if (left.type === "definition" && left.type === right.type) {
      return 0;
    }
  }
});

// node_modules/telegramify-markdown/node_modules/remark-stringify/index.js
var require_remark_stringify = __commonJS((exports, module) => {
  module.exports = stringify2;
  var toMarkdown = require_lib();
  function stringify2(options) {
    var self2 = this;
    this.Compiler = compile;
    function compile(tree) {
      return toMarkdown(tree, Object.assign({}, self2.data("settings"), options, {
        extensions: self2.data("toMarkdownExtensions") || []
      }));
    }
  }
});

// node_modules/telegramify-markdown/node_modules/unist-util-visit/node_modules/unist-util-is/convert.js
var require_convert2 = __commonJS((exports, module) => {
  module.exports = convert;
  function convert(test) {
    if (test == null) {
      return ok;
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    if (typeof test === "object") {
      return "length" in test ? anyFactory(test) : allFactory(test);
    }
    if (typeof test === "function") {
      return test;
    }
    throw new Error("Expected function, string, or object as test");
  }
  function allFactory(test) {
    return all;
    function all(node) {
      var key;
      for (key in test) {
        if (node[key] !== test[key])
          return false;
      }
      return true;
    }
  }
  function anyFactory(tests) {
    var checks2 = [];
    var index = -1;
    while (++index < tests.length) {
      checks2[index] = convert(tests[index]);
    }
    return any;
    function any() {
      var index2 = -1;
      while (++index2 < checks2.length) {
        if (checks2[index2].apply(this, arguments)) {
          return true;
        }
      }
      return false;
    }
  }
  function typeFactory(test) {
    return type;
    function type(node) {
      return Boolean(node && node.type === test);
    }
  }
  function ok() {
    return true;
  }
});

// node_modules/telegramify-markdown/node_modules/unist-util-visit/node_modules/unist-util-visit-parents/color.js
var require_color2 = __commonJS((exports, module) => {
  module.exports = color2;
  function color2(d) {
    return "\x1B[33m" + d + "\x1B[39m";
  }
});

// node_modules/telegramify-markdown/node_modules/unist-util-visit/node_modules/unist-util-visit-parents/index.js
var require_unist_util_visit_parents2 = __commonJS((exports, module) => {
  module.exports = visitParents;
  var convert = require_convert2();
  var color2 = require_color2();
  var CONTINUE = true;
  var SKIP = "skip";
  var EXIT = false;
  visitParents.CONTINUE = CONTINUE;
  visitParents.SKIP = SKIP;
  visitParents.EXIT = EXIT;
  function visitParents(tree, test, visitor, reverse) {
    var step;
    var is;
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    is = convert(test);
    step = reverse ? -1 : 1;
    factory(tree, null, [])();
    function factory(node, index, parents) {
      var value = typeof node === "object" && node !== null ? node : {};
      var name;
      if (typeof value.type === "string") {
        name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : undefined;
        visit.displayName = "node (" + color2(value.type + (name ? "<" + name + ">" : "")) + ")";
      }
      return visit;
      function visit() {
        var grandparents = parents.concat(node);
        var result = [];
        var subresult;
        var offset;
        if (!test || is(node, index, parents[parents.length - 1] || null)) {
          result = toResult(visitor(node, parents));
          if (result[0] === EXIT) {
            return result;
          }
        }
        if (node.children && result[0] !== SKIP) {
          offset = (reverse ? node.children.length : -1) + step;
          while (offset > -1 && offset < node.children.length) {
            subresult = factory(node.children[offset], offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
        return result;
      }
    }
  }
  function toResult(value) {
    if (value !== null && typeof value === "object" && "length" in value) {
      return value;
    }
    if (typeof value === "number") {
      return [CONTINUE, value];
    }
    return [value];
  }
});

// node_modules/telegramify-markdown/node_modules/unist-util-visit/index.js
var require_unist_util_visit = __commonJS((exports, module) => {
  module.exports = visit;
  var visitParents = require_unist_util_visit_parents2();
  var CONTINUE = visitParents.CONTINUE;
  var SKIP = visitParents.SKIP;
  var EXIT = visitParents.EXIT;
  visit.CONTINUE = CONTINUE;
  visit.SKIP = SKIP;
  visit.EXIT = EXIT;
  function visit(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    visitParents(tree, test, overload, reverse);
    function overload(node, parents) {
      var parent = parents[parents.length - 1];
      var index = parent ? parent.children.indexOf(node) : null;
      return visitor(node, index, parent);
    }
  }
});

// node_modules/html-comment-regex/index.js
var require_html_comment_regex = __commonJS((exports, module) => {
  module.exports = /<!--([\s\S]*?)-->/g;
});

// node_modules/telegramify-markdown/node_modules/remark-remove-comments/transformer.js
var require_transformer = __commonJS((exports, module) => {
  var visit = require_unist_util_visit();
  var htmlCommentRegex = require_html_comment_regex();
  var removeComments = (tree, file) => {
    const handler = (node, index, parent) => {
      const isComment = node.value.match(htmlCommentRegex);
      if (isComment) {
        parent.children.splice(index, 1);
        return [visit.SKIP, index];
      }
    };
    visit(tree, "html", handler);
    visit(tree, "jsx", handler);
  };
  module.exports = removeComments;
});

// node_modules/telegramify-markdown/node_modules/remark-remove-comments/index.js
var require_remark_remove_comments = __commonJS((exports, module) => {
  var transformer = require_transformer();
  function attacher() {
    return transformer;
  }
  module.exports = attacher;
});

// node_modules/telegramify-markdown/node_modules/unified/node_modules/bail/index.js
var require_bail = __commonJS((exports, module) => {
  module.exports = bail;
  function bail(err) {
    if (err) {
      throw err;
    }
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS((exports, module) => {
  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  module.exports = function isBuffer(obj) {
    return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  };
});

// node_modules/extend/index.js
var require_extend = __commonJS((exports, module) => {
  var hasOwn = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var defineProperty = Object.defineProperty;
  var gOPD = Object.getOwnPropertyDescriptor;
  var isArray = function isArray(arr2) {
    if (typeof Array.isArray === "function") {
      return Array.isArray(arr2);
    }
    return toStr.call(arr2) === "[object Array]";
  };
  var isPlainObject2 = function isPlainObject(obj) {
    if (!obj || toStr.call(obj) !== "[object Object]") {
      return false;
    }
    var hasOwnConstructor = hasOwn.call(obj, "constructor");
    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
      return false;
    }
    var key;
    for (key in obj) {}
    return typeof key === "undefined" || hasOwn.call(obj, key);
  };
  var setProperty = function setProperty(target, options) {
    if (defineProperty && options.name === "__proto__") {
      defineProperty(target, options.name, {
        enumerable: true,
        configurable: true,
        value: options.newValue,
        writable: true
      });
    } else {
      target[options.name] = options.newValue;
    }
  };
  var getProperty = function getProperty(obj, name) {
    if (name === "__proto__") {
      if (!hasOwn.call(obj, name)) {
        return;
      } else if (gOPD) {
        return gOPD(obj, name).value;
      }
    }
    return obj[name];
  };
  module.exports = function extend() {
    var options, name, src, copy, copyIsArray, clone2;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (target == null || typeof target !== "object" && typeof target !== "function") {
      target = {};
    }
    for (;i < length; ++i) {
      options = arguments[i];
      if (options != null) {
        for (name in options) {
          src = getProperty(target, name);
          copy = getProperty(options, name);
          if (target !== copy) {
            if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone2 = src && isArray(src) ? src : [];
              } else {
                clone2 = src && isPlainObject2(src) ? src : {};
              }
              setProperty(target, { name, newValue: extend(deep, clone2, copy) });
            } else if (typeof copy !== "undefined") {
              setProperty(target, { name, newValue: copy });
            }
          }
        }
      }
    }
    return target;
  };
});

// node_modules/telegramify-markdown/node_modules/unified/node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS((exports, module) => {
  module.exports = (value) => {
    if (Object.prototype.toString.call(value) !== "[object Object]") {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.prototype;
  };
});

// node_modules/telegramify-markdown/node_modules/unified/node_modules/trough/wrap.js
var require_wrap = __commonJS((exports, module) => {
  var slice = [].slice;
  module.exports = wrap2;
  function wrap2(fn, callback) {
    var invoked;
    return wrapped;
    function wrapped() {
      var params = slice.call(arguments, 0);
      var callback2 = fn.length > params.length;
      var result;
      if (callback2) {
        params.push(done);
      }
      try {
        result = fn.apply(null, params);
      } catch (error46) {
        if (callback2 && invoked) {
          throw error46;
        }
        return done(error46);
      }
      if (!callback2) {
        if (result && typeof result.then === "function") {
          result.then(then, done);
        } else if (result instanceof Error) {
          done(result);
        } else {
          then(result);
        }
      }
    }
    function done() {
      if (!invoked) {
        invoked = true;
        callback.apply(null, arguments);
      }
    }
    function then(value) {
      done(null, value);
    }
  }
});

// node_modules/telegramify-markdown/node_modules/unified/node_modules/trough/index.js
var require_trough = __commonJS((exports, module) => {
  var wrap2 = require_wrap();
  module.exports = trough;
  trough.wrap = wrap2;
  var slice = [].slice;
  function trough() {
    var fns = [];
    var middleware = {};
    middleware.run = run;
    middleware.use = use;
    return middleware;
    function run() {
      var index = -1;
      var input = slice.call(arguments, 0, -1);
      var done = arguments[arguments.length - 1];
      if (typeof done !== "function") {
        throw new Error("Expected function as last argument, not " + done);
      }
      next.apply(null, [null].concat(input));
      function next(err) {
        var fn = fns[++index];
        var params = slice.call(arguments, 0);
        var values = params.slice(1);
        var length = input.length;
        var pos = -1;
        if (err) {
          done(err);
          return;
        }
        while (++pos < length) {
          if (values[pos] === null || values[pos] === undefined) {
            values[pos] = input[pos];
          }
        }
        input = values;
        if (fn) {
          wrap2(fn, next).apply(null, input);
        } else {
          done.apply(null, [null].concat(input));
        }
      }
    }
    function use(fn) {
      if (typeof fn !== "function") {
        throw new Error("Expected `fn` to be a function, not " + fn);
      }
      fns.push(fn);
      return middleware;
    }
  }
});

// node_modules/telegramify-markdown/node_modules/unified/node_modules/vfile/node_modules/unist-util-stringify-position/index.js
var require_unist_util_stringify_position2 = __commonJS((exports, module) => {
  var own = {}.hasOwnProperty;
  module.exports = stringify2;
  function stringify2(value) {
    if (!value || typeof value !== "object") {
      return "";
    }
    if (own.call(value, "position") || own.call(value, "type")) {
      return position(value.position);
    }
    if (own.call(value, "start") || own.call(value, "end")) {
      return position(value);
    }
    if (own.call(value, "line") || own.call(value, "column")) {
      return point(value);
    }
    return "";
  }
  function point(point2) {
    if (!point2 || typeof point2 !== "object") {
      point2 = {};
    }
    return index(point2.line) + ":" + index(point2.column);
  }
  function position(pos) {
    if (!pos || typeof pos !== "object") {
      pos = {};
    }
    return point(pos.start) + "-" + point(pos.end);
  }
  function index(value) {
    return value && typeof value === "number" ? value : 1;
  }
});

// node_modules/telegramify-markdown/node_modules/unified/node_modules/vfile/node_modules/vfile-message/index.js
var require_vfile_message = __commonJS((exports, module) => {
  var stringify2 = require_unist_util_stringify_position2();
  module.exports = VMessage;
  function VMessagePrototype() {}
  VMessagePrototype.prototype = Error.prototype;
  VMessage.prototype = new VMessagePrototype;
  var proto = VMessage.prototype;
  proto.file = "";
  proto.name = "";
  proto.reason = "";
  proto.message = "";
  proto.stack = "";
  proto.fatal = null;
  proto.column = null;
  proto.line = null;
  function VMessage(reason, position, origin) {
    var parts;
    var range;
    var location2;
    if (typeof position === "string") {
      origin = position;
      position = null;
    }
    parts = parseOrigin(origin);
    range = stringify2(position) || "1:1";
    location2 = {
      start: { line: null, column: null },
      end: { line: null, column: null }
    };
    if (position && position.position) {
      position = position.position;
    }
    if (position) {
      if (position.start) {
        location2 = position;
        position = position.start;
      } else {
        location2.start = position;
      }
    }
    if (reason.stack) {
      this.stack = reason.stack;
      reason = reason.message;
    }
    this.message = reason;
    this.name = range;
    this.reason = reason;
    this.line = position ? position.line : null;
    this.column = position ? position.column : null;
    this.location = location2;
    this.source = parts[0];
    this.ruleId = parts[1];
  }
  function parseOrigin(origin) {
    var result = [null, null];
    var index;
    if (typeof origin === "string") {
      index = origin.indexOf(":");
      if (index === -1) {
        result[1] = origin;
      } else {
        result[0] = origin.slice(0, index);
        result[1] = origin.slice(index + 1);
      }
    }
    return result;
  }
});

// node_modules/telegramify-markdown/node_modules/unified/node_modules/vfile/lib/minproc.js
var require_minproc = __commonJS((exports, module) => {
  module.exports = process;
});

// node_modules/telegramify-markdown/node_modules/unified/node_modules/vfile/lib/core.js
var require_core = __commonJS((exports, module) => {
  var p = __require("path");
  var proc = require_minproc();
  var buffer = require_is_buffer();
  module.exports = VFile;
  var own = {}.hasOwnProperty;
  var order = ["history", "path", "basename", "stem", "extname", "dirname"];
  VFile.prototype.toString = toString;
  Object.defineProperty(VFile.prototype, "path", { get: getPath, set: setPath });
  Object.defineProperty(VFile.prototype, "dirname", {
    get: getDirname,
    set: setDirname
  });
  Object.defineProperty(VFile.prototype, "basename", {
    get: getBasename,
    set: setBasename
  });
  Object.defineProperty(VFile.prototype, "extname", {
    get: getExtname,
    set: setExtname
  });
  Object.defineProperty(VFile.prototype, "stem", { get: getStem, set: setStem });
  function VFile(options) {
    var prop;
    var index;
    if (!options) {
      options = {};
    } else if (typeof options === "string" || buffer(options)) {
      options = { contents: options };
    } else if ("message" in options && "messages" in options) {
      return options;
    }
    if (!(this instanceof VFile)) {
      return new VFile(options);
    }
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = proc.cwd();
    index = -1;
    while (++index < order.length) {
      prop = order[index];
      if (own.call(options, prop)) {
        this[prop] = options[prop];
      }
    }
    for (prop in options) {
      if (order.indexOf(prop) < 0) {
        this[prop] = options[prop];
      }
    }
  }
  function getPath() {
    return this.history[this.history.length - 1];
  }
  function setPath(path) {
    assertNonEmpty(path, "path");
    if (this.path !== path) {
      this.history.push(path);
    }
  }
  function getDirname() {
    return typeof this.path === "string" ? p.dirname(this.path) : undefined;
  }
  function setDirname(dirname) {
    assertPath(this.path, "dirname");
    this.path = p.join(dirname || "", this.basename);
  }
  function getBasename() {
    return typeof this.path === "string" ? p.basename(this.path) : undefined;
  }
  function setBasename(basename) {
    assertNonEmpty(basename, "basename");
    assertPart(basename, "basename");
    this.path = p.join(this.dirname || "", basename);
  }
  function getExtname() {
    return typeof this.path === "string" ? p.extname(this.path) : undefined;
  }
  function setExtname(extname) {
    assertPart(extname, "extname");
    assertPath(this.path, "extname");
    if (extname) {
      if (extname.charCodeAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname.indexOf(".", 1) > -1) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = p.join(this.dirname, this.stem + (extname || ""));
  }
  function getStem() {
    return typeof this.path === "string" ? p.basename(this.path, this.extname) : undefined;
  }
  function setStem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = p.join(this.dirname || "", stem + (this.extname || ""));
  }
  function toString(encoding) {
    return (this.contents || "").toString(encoding);
  }
  function assertPart(part, name) {
    if (part && part.indexOf(p.sep) > -1) {
      throw new Error("`" + name + "` cannot be a path: did not expect `" + p.sep + "`");
    }
  }
  function assertNonEmpty(part, name) {
    if (!part) {
      throw new Error("`" + name + "` cannot be empty");
    }
  }
  function assertPath(path, name) {
    if (!path) {
      throw new Error("Setting `" + name + "` requires `path` to be set too");
    }
  }
});

// node_modules/telegramify-markdown/node_modules/unified/node_modules/vfile/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var VMessage = require_vfile_message();
  var VFile = require_core();
  module.exports = VFile;
  VFile.prototype.message = message;
  VFile.prototype.info = info;
  VFile.prototype.fail = fail;
  function message(reason, position, origin) {
    var message2 = new VMessage(reason, position, origin);
    if (this.path) {
      message2.name = this.path + ":" + message2.name;
      message2.file = this.path;
    }
    message2.fatal = false;
    this.messages.push(message2);
    return message2;
  }
  function fail() {
    var message2 = this.message.apply(this, arguments);
    message2.fatal = true;
    throw message2;
  }
  function info() {
    var message2 = this.message.apply(this, arguments);
    message2.fatal = null;
    return message2;
  }
});

// node_modules/telegramify-markdown/node_modules/unified/index.js
var require_unified = __commonJS((exports, module) => {
  var bail = require_bail();
  var buffer = require_is_buffer();
  var extend2 = require_extend();
  var plain = require_is_plain_obj();
  var trough = require_trough();
  var vfile = require_lib2();
  module.exports = unified().freeze();
  var slice = [].slice;
  var own = {}.hasOwnProperty;
  var pipeline = trough().use(pipelineParse).use(pipelineRun).use(pipelineStringify);
  function pipelineParse(p, ctx) {
    ctx.tree = p.parse(ctx.file);
  }
  function pipelineRun(p, ctx, next) {
    p.run(ctx.tree, ctx.file, done);
    function done(error46, tree, file) {
      if (error46) {
        next(error46);
      } else {
        ctx.tree = tree;
        ctx.file = file;
        next();
      }
    }
  }
  function pipelineStringify(p, ctx) {
    var result = p.stringify(ctx.tree, ctx.file);
    if (result === undefined || result === null) {} else if (typeof result === "string" || buffer(result)) {
      if ("value" in ctx.file) {
        ctx.file.value = result;
      }
      ctx.file.contents = result;
    } else {
      ctx.file.result = result;
    }
  }
  function unified() {
    var attachers = [];
    var transformers = trough();
    var namespace = {};
    var freezeIndex = -1;
    var frozen;
    processor.data = data;
    processor.freeze = freeze;
    processor.attachers = attachers;
    processor.use = use;
    processor.parse = parse4;
    processor.stringify = stringify2;
    processor.run = run;
    processor.runSync = runSync;
    processor.process = process2;
    processor.processSync = processSync;
    return processor;
    function processor() {
      var destination = unified();
      var index = -1;
      while (++index < attachers.length) {
        destination.use.apply(null, attachers[index]);
      }
      destination.data(extend2(true, {}, namespace));
      return destination;
    }
    function freeze() {
      var values;
      var transformer;
      if (frozen) {
        return processor;
      }
      while (++freezeIndex < attachers.length) {
        values = attachers[freezeIndex];
        if (values[1] === false) {
          continue;
        }
        if (values[1] === true) {
          values[1] = undefined;
        }
        transformer = values[0].apply(processor, values.slice(1));
        if (typeof transformer === "function") {
          transformers.use(transformer);
        }
      }
      frozen = true;
      freezeIndex = Infinity;
      return processor;
    }
    function data(key, value) {
      if (typeof key === "string") {
        if (arguments.length === 2) {
          assertUnfrozen("data", frozen);
          namespace[key] = value;
          return processor;
        }
        return own.call(namespace, key) && namespace[key] || null;
      }
      if (key) {
        assertUnfrozen("data", frozen);
        namespace = key;
        return processor;
      }
      return namespace;
    }
    function use(value) {
      var settings;
      assertUnfrozen("use", frozen);
      if (value === null || value === undefined) {} else if (typeof value === "function") {
        addPlugin.apply(null, arguments);
      } else if (typeof value === "object") {
        if ("length" in value) {
          addList(value);
        } else {
          addPreset(value);
        }
      } else {
        throw new Error("Expected usable value, not `" + value + "`");
      }
      if (settings) {
        namespace.settings = extend2(namespace.settings || {}, settings);
      }
      return processor;
      function addPreset(result) {
        addList(result.plugins);
        if (result.settings) {
          settings = extend2(settings || {}, result.settings);
        }
      }
      function add(value2) {
        if (typeof value2 === "function") {
          addPlugin(value2);
        } else if (typeof value2 === "object") {
          if ("length" in value2) {
            addPlugin.apply(null, value2);
          } else {
            addPreset(value2);
          }
        } else {
          throw new Error("Expected usable value, not `" + value2 + "`");
        }
      }
      function addList(plugins) {
        var index = -1;
        if (plugins === null || plugins === undefined) {} else if (typeof plugins === "object" && "length" in plugins) {
          while (++index < plugins.length) {
            add(plugins[index]);
          }
        } else {
          throw new Error("Expected a list of plugins, not `" + plugins + "`");
        }
      }
      function addPlugin(plugin, value2) {
        var entry = find(plugin);
        if (entry) {
          if (plain(entry[1]) && plain(value2)) {
            value2 = extend2(true, entry[1], value2);
          }
          entry[1] = value2;
        } else {
          attachers.push(slice.call(arguments));
        }
      }
    }
    function find(plugin) {
      var index = -1;
      while (++index < attachers.length) {
        if (attachers[index][0] === plugin) {
          return attachers[index];
        }
      }
    }
    function parse4(doc2) {
      var file = vfile(doc2);
      var Parser;
      freeze();
      Parser = processor.Parser;
      assertParser("parse", Parser);
      if (newable(Parser, "parse")) {
        return new Parser(String(file), file).parse();
      }
      return Parser(String(file), file);
    }
    function run(node, file, cb) {
      assertNode(node);
      freeze();
      if (!cb && typeof file === "function") {
        cb = file;
        file = null;
      }
      if (!cb) {
        return new Promise(executor);
      }
      executor(null, cb);
      function executor(resolve, reject) {
        transformers.run(node, vfile(file), done);
        function done(error46, tree, file2) {
          tree = tree || node;
          if (error46) {
            reject(error46);
          } else if (resolve) {
            resolve(tree);
          } else {
            cb(null, tree, file2);
          }
        }
      }
    }
    function runSync(node, file) {
      var result;
      var complete;
      run(node, file, done);
      assertDone("runSync", "run", complete);
      return result;
      function done(error46, tree) {
        complete = true;
        result = tree;
        bail(error46);
      }
    }
    function stringify2(node, doc2) {
      var file = vfile(doc2);
      var Compiler;
      freeze();
      Compiler = processor.Compiler;
      assertCompiler("stringify", Compiler);
      assertNode(node);
      if (newable(Compiler, "compile")) {
        return new Compiler(node, file).compile();
      }
      return Compiler(node, file);
    }
    function process2(doc2, cb) {
      freeze();
      assertParser("process", processor.Parser);
      assertCompiler("process", processor.Compiler);
      if (!cb) {
        return new Promise(executor);
      }
      executor(null, cb);
      function executor(resolve, reject) {
        var file = vfile(doc2);
        pipeline.run(processor, { file }, done);
        function done(error46) {
          if (error46) {
            reject(error46);
          } else if (resolve) {
            resolve(file);
          } else {
            cb(null, file);
          }
        }
      }
    }
    function processSync(doc2) {
      var file;
      var complete;
      freeze();
      assertParser("processSync", processor.Parser);
      assertCompiler("processSync", processor.Compiler);
      file = vfile(doc2);
      process2(file, done);
      assertDone("processSync", "process", complete);
      return file;
      function done(error46) {
        complete = true;
        bail(error46);
      }
    }
  }
  function newable(value, name) {
    return typeof value === "function" && value.prototype && (keys(value.prototype) || (name in value.prototype));
  }
  function keys(value) {
    var key;
    for (key in value) {
      return true;
    }
    return false;
  }
  function assertParser(name, Parser) {
    if (typeof Parser !== "function") {
      throw new Error("Cannot `" + name + "` without `Parser`");
    }
  }
  function assertCompiler(name, Compiler) {
    if (typeof Compiler !== "function") {
      throw new Error("Cannot `" + name + "` without `Compiler`");
    }
  }
  function assertUnfrozen(name, frozen) {
    if (frozen) {
      throw new Error("Cannot invoke `" + name + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.");
    }
  }
  function assertNode(node) {
    if (!node || typeof node.type !== "string") {
      throw new Error("Expected node, got `" + node + "`");
    }
  }
  function assertDone(name, asyncName, complete) {
    if (!complete) {
      throw new Error("`" + name + "` finished async. Use `" + asyncName + "` instead");
    }
  }
});

// node_modules/telegramify-markdown/node_modules/unist-util-remove/node_modules/unist-util-is/convert.js
var require_convert3 = __commonJS((exports, module) => {
  module.exports = convert;
  function convert(test) {
    if (test == null) {
      return ok;
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    if (typeof test === "object") {
      return "length" in test ? anyFactory(test) : allFactory(test);
    }
    if (typeof test === "function") {
      return test;
    }
    throw new Error("Expected function, string, or object as test");
  }
  function allFactory(test) {
    return all;
    function all(node) {
      var key;
      for (key in test) {
        if (node[key] !== test[key])
          return false;
      }
      return true;
    }
  }
  function anyFactory(tests) {
    var checks2 = [];
    var index = -1;
    while (++index < tests.length) {
      checks2[index] = convert(tests[index]);
    }
    return any;
    function any() {
      var index2 = -1;
      while (++index2 < checks2.length) {
        if (checks2[index2].apply(this, arguments)) {
          return true;
        }
      }
      return false;
    }
  }
  function typeFactory(test) {
    return type;
    function type(node) {
      return Boolean(node && node.type === test);
    }
  }
  function ok() {
    return true;
  }
});

// node_modules/telegramify-markdown/node_modules/unist-util-remove/index.js
var require_unist_util_remove = __commonJS((exports, module) => {
  var convert = require_convert3();
  module.exports = remove;
  function remove(tree, options, test) {
    var is = convert(test || options);
    var cascade = options.cascade == null ? true : options.cascade;
    return preorder(tree, null, null);
    function preorder(node, index, parent) {
      var children = node.children;
      var childIndex = -1;
      var position = 0;
      if (is(node, index, parent)) {
        return null;
      }
      if (children && children.length) {
        while (++childIndex < children.length) {
          if (preorder(children[childIndex], childIndex, node)) {
            children[position++] = children[childIndex];
          }
        }
        if (cascade && !position) {
          return null;
        }
        children.length = position;
      }
      return node;
    }
  }
});

// node_modules/telegramify-markdown/lib/definitions.js
var require_definitions = __commonJS((exports, module) => {
  var remove = require_unist_util_remove();
  var visit = require_unist_util_visit();
  var collectDefinitions = (definitions) => (tree) => {
    visit(tree, "definition", (node) => {
      definitions[node.identifier] = {
        title: node.title,
        url: node.url
      };
    });
  };
  var removeDefinitions = () => (tree) => {
    remove(tree, { cascade: true }, "definition");
  };
  module.exports = {
    collectDefinitions,
    removeDefinitions
  };
});

// node_modules/telegramify-markdown/node_modules/mdast-util-gfm-table/index.js
var require_mdast_util_gfm_table = __commonJS((exports) => {
  exports.fromMarkdown = require_from_markdown3();
  exports.toMarkdown = require_to_markdown3();
});

// node_modules/telegramify-markdown/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  var { URL: URL2 } = __require("url");
  function wrap2(string2, ...wrappers) {
    return [
      ...wrappers,
      string2,
      ...wrappers.reverse()
    ].join("");
  }
  function isURL(string2) {
    try {
      return Boolean(new URL2(string2));
    } catch (error46) {
      return false;
    }
  }
  function escapeSymbols(text, textType = "text") {
    if (!text) {
      return text;
    }
    switch (textType) {
      case "code":
        return text.replace(/\\/g, "\\\\").replace(/`/g, "\\`");
      case "link":
        return text.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
      default:
        return text.replace(/_/g, "\\_").replace(/\*/g, "\\*").replace(/\[/g, "\\[").replace(/]/g, "\\]").replace(/\(/g, "\\(").replace(/\)/g, "\\)").replace(/~/g, "\\~").replace(/`/g, "\\`").replace(/>/g, "\\>").replace(/#/g, "\\#").replace(/\+/g, "\\+").replace(/-/g, "\\-").replace(/=/g, "\\=").replace(/\|/g, "\\|").replace(/{/g, "\\{").replace(/}/g, "\\}").replace(/\./g, "\\.").replace(/!/g, "\\!");
    }
  }
  function processUnsupportedTags(content, strategy) {
    switch (strategy) {
      case "escape":
        return escapeSymbols(content);
      case "remove":
        return "";
      case "keep":
      default:
        return content;
    }
  }
  module.exports = {
    wrap: wrap2,
    isURL,
    escapeSymbols,
    processUnsupportedTags
  };
});

// node_modules/telegramify-markdown/lib/telegramify.js
var require_telegramify = __commonJS((exports, module) => {
  var defaultHandlers = require_handle();
  var phrasing = require_container_phrasing();
  var { toMarkdown: gfmTableToMarkdown } = require_mdast_util_gfm_table();
  var { wrap: wrap2, isURL, escapeSymbols, processUnsupportedTags } = require_utils();
  var createHandlers = (definitions, unsupportedTagsStrategy) => ({
    heading: (node, _parent, context) => {
      const marker = "*";
      const exit = context.enter("heading");
      const value = phrasing(node, context, { before: marker, after: marker });
      exit();
      return wrap2(value, marker);
    },
    strong: (node, _parent, context) => {
      const marker = "*";
      const exit = context.enter("strong");
      const value = phrasing(node, context, { before: marker, after: marker });
      exit();
      return wrap2(value, marker);
    },
    delete(node, _parent, context) {
      const marker = "~";
      const exit = context.enter("delete");
      const value = phrasing(node, context, { before: marker, after: marker });
      exit();
      return wrap2(value, marker);
    },
    emphasis: (node, _parent, context) => {
      const marker = "_";
      const exit = context.enter("emphasis");
      const value = phrasing(node, context, { before: marker, after: marker });
      exit();
      return wrap2(value, marker);
    },
    list: (...args) => defaultHandlers.list(...args).replace(/^(\d+)./gm, "$1\\."),
    listItem: (...args) => defaultHandlers.listItem(...args).replace(/^\*/, "\u2022"),
    code(node, _parent, context) {
      const exit = context.enter("code");
      const content = node.value.replace(/^#![a-z]+\n/, "");
      exit();
      return wrap2(escapeSymbols(content, "code"), "```", `
`);
    },
    link: (node, _parent, context) => {
      const exit = context.enter("link");
      const text = phrasing(node, context, { before: "|", after: ">" }) || escapeSymbols(node.title);
      const isUrlEncoded = decodeURI(node.url) !== node.url;
      const url = isUrlEncoded ? node.url : encodeURI(node.url);
      exit();
      if (!isURL(url))
        return escapeSymbols(text) || escapeSymbols(url);
      return text ? `[${text}](${escapeSymbols(url, "link")})` : `[${escapeSymbols(url)}](${escapeSymbols(url, "link")})`;
    },
    linkReference: (node, _parent, context) => {
      const exit = context.enter("linkReference");
      const definition = definitions[node.identifier];
      const text = phrasing(node, context, { before: "|", after: ">" }) || (definition ? definition.title : null);
      exit();
      if (!definition || !isURL(definition.url))
        return escapeSymbols(text);
      return text ? `[${text}](${escapeSymbols(definition.url, "link")})` : `[${escapeSymbols(definition.url)}](${escapeSymbols(definition.url, "link")})`;
    },
    image: (node, _parent, context) => {
      const exit = context.enter("image");
      const text = node.alt || node.title;
      const url = node.url;
      exit();
      if (!isURL(url))
        return escapeSymbols(text) || escapeSymbols(url);
      return text ? `[${escapeSymbols(text)}](${escapeSymbols(url, "link")})` : `[${escapeSymbols(url)}](${escapeSymbols(url, "link")})`;
    },
    imageReference: (node, _parent, context) => {
      const exit = context.enter("imageReference");
      const definition = definitions[node.identifier];
      const text = node.alt || (definition ? definition.title : null);
      exit();
      if (!definition || !isURL(definition.url))
        return escapeSymbols(text);
      return text ? `[${escapeSymbols(text)}](${escapeSymbols(definition.url, "link")})` : `[${escapeSymbols(definition.url)}](${escapeSymbols(definition.url, "link")})`;
    },
    text: (node, _parent, context) => {
      const exit = context.enter("text");
      const text = node.value;
      exit();
      return escapeSymbols(text);
    },
    blockquote: (node, _parent, context) => processUnsupportedTags(defaultHandlers.blockquote(node, _parent, context), unsupportedTagsStrategy),
    html: (node, _parent, context) => processUnsupportedTags(defaultHandlers.html(node, _parent, context), unsupportedTagsStrategy),
    table: (node, _parent, context) => processUnsupportedTags(gfmTableToMarkdown().handlers.table(node, _parent, context), unsupportedTagsStrategy)
  });
  var createOptions = (definitions, unsupportedTagsStrategy) => ({
    bullet: "*",
    tightDefinitions: true,
    handlers: createHandlers(definitions, unsupportedTagsStrategy)
  });
  module.exports = createOptions;
});

// node_modules/telegramify-markdown/lib/convert.js
var require_convert4 = __commonJS((exports, module) => {
  var gfm = require_remark_gfm();
  var parse4 = require_remark_parse();
  var stringify2 = require_remark_stringify();
  var removeComments = require_remark_remove_comments();
  var unified = require_unified();
  var { collectDefinitions, removeDefinitions } = require_definitions();
  var createTelegramifyOptions = require_telegramify();
  module.exports = (markdown, unsupportedTagsStrategy) => {
    const definitions = {};
    const telegramifyOptions = createTelegramifyOptions(definitions, unsupportedTagsStrategy);
    return unified().use(parse4).use(gfm).use(removeComments).use(collectDefinitions, definitions).use(removeDefinitions).use(stringify2, telegramifyOptions).processSync(markdown).toString().replace(/<!---->\n/gi, "");
  };
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse4(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse4(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend2;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error46) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error46) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error46) {}
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error46) {
      return "[UnexpectedJSONParseError]: " + error46.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var os = __require("os");
  var tty = __require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version3 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version3 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util3 = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util3.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error46) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util3.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util3.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util3.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/telegraf/lib/core/helpers/util.js
var require_util = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.indexed = exports.zip = exports.fmtCaption = exports.env = undefined;
  exports.env = process.env;
  function fmtCaption(extra) {
    if (!extra)
      return;
    const caption = extra.caption;
    if (!caption || typeof caption === "string")
      return extra;
    const { text, entities } = caption;
    return {
      ...extra,
      caption: text,
      ...entities && {
        caption_entities: entities,
        parse_mode: undefined
      }
    };
  }
  exports.fmtCaption = fmtCaption;
  function* zip(xs, ys) {
    const x = xs[Symbol.iterator]();
    const y = ys[Symbol.iterator]();
    let x1 = x.next();
    let y1 = y.next();
    while (!x1.done) {
      yield x1.value;
      if (!y1.done)
        yield y1.value;
      x1 = x.next();
      y1 = y.next();
    }
    while (!y1.done) {
      yield y1.value;
      y1 = y.next();
    }
  }
  exports.zip = zip;
  function indexed(target, indexer) {
    return new Proxy(target, {
      get: function(target2, prop, receiver) {
        if ((typeof prop === "string" || typeof prop === "number") && !isNaN(+prop))
          return indexer.call(target2, +prop);
        return Reflect.get(target2, prop, receiver);
      }
    });
  }
  exports.indexed = indexed;
});

// node_modules/telegraf/lib/reactions.js
var require_reactions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageReactions = exports.ReactionList = exports.Digit = undefined;
  var util_1 = require_util();
  exports.Digit = new Set(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]);
  var inspectReaction = (reaction) => {
    if (reaction.type === "custom_emoji")
      return `Custom(${reaction.custom_emoji_id})`;
    else
      return reaction.emoji;
  };

  class ReactionList {
    constructor(list) {
      this.list = list;
    }
    static fromArray(list = []) {
      return (0, util_1.indexed)(new ReactionList(list), function(index) {
        return this.list[index];
      });
    }
    static has(reactions, reaction) {
      if (typeof reaction === "string")
        if (exports.Digit.has(reaction[0]))
          return reactions.some((r) => r.custom_emoji_id === reaction);
        else
          return reactions.some((r) => r.emoji === reaction);
      return reactions.some((r) => {
        if (r.type === "custom_emoji")
          return r.custom_emoji_id === reaction.custom_emoji_id;
        else if (r.type === "emoji")
          return r.emoji === reaction.emoji;
      });
    }
    toArray() {
      return [...this.list];
    }
    filter(filterFn) {
      return ReactionList.fromArray(this.list.filter(filterFn));
    }
    has(reaction) {
      return ReactionList.has(this.list, reaction);
    }
    get count() {
      return this.list.length;
    }
    [Symbol.iterator]() {
      return this.list[Symbol.iterator]();
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      const flattened = this.list.map(inspectReaction).join(", ");
      return ["ReactionList {", flattened, "}"].join(" ");
    }
  }
  exports.ReactionList = ReactionList;

  class MessageReactions extends ReactionList {
    constructor(ctx) {
      var _a2, _b;
      super((_b = (_a2 = ctx.update.message_reaction) === null || _a2 === undefined ? undefined : _a2.new_reaction) !== null && _b !== undefined ? _b : []);
      this.ctx = ctx;
    }
    static from(ctx) {
      return (0, util_1.indexed)(new MessageReactions(ctx), function(index) {
        return this.list[index];
      });
    }
    get old() {
      var _a2;
      return ReactionList.fromArray((_a2 = this.ctx.update.message_reaction) === null || _a2 === undefined ? undefined : _a2.old_reaction);
    }
    get new() {
      var _a2;
      return ReactionList.fromArray((_a2 = this.ctx.update.message_reaction) === null || _a2 === undefined ? undefined : _a2.new_reaction);
    }
    get added() {
      return this.new.filter((reaction) => !this.old.has(reaction));
    }
    get removed() {
      return this.old.filter((reaction) => !this.new.has(reaction));
    }
    get kept() {
      return this.new.filter((reaction) => this.old.has(reaction));
    }
  }
  exports.MessageReactions = MessageReactions;
});

// node_modules/telegraf/lib/context.js
var require_context = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Context = undefined;
  var debug_1 = __importDefault(require_src());
  var reactions_1 = require_reactions();
  var debug = (0, debug_1.default)("telegraf:context");

  class Context {
    constructor(update, telegram, botInfo) {
      this.update = update;
      this.telegram = telegram;
      this.botInfo = botInfo;
      this.state = {};
    }
    get updateType() {
      for (const key in this.update) {
        if (typeof this.update[key] === "object")
          return key;
      }
      throw new Error(`Cannot determine \`updateType\` of ${JSON.stringify(this.update)}`);
    }
    get me() {
      var _a2;
      return (_a2 = this.botInfo) === null || _a2 === undefined ? undefined : _a2.username;
    }
    get tg() {
      return this.telegram;
    }
    get message() {
      return this.update.message;
    }
    get editedMessage() {
      return this.update.edited_message;
    }
    get inlineQuery() {
      return this.update.inline_query;
    }
    get shippingQuery() {
      return this.update.shipping_query;
    }
    get preCheckoutQuery() {
      return this.update.pre_checkout_query;
    }
    get chosenInlineResult() {
      return this.update.chosen_inline_result;
    }
    get channelPost() {
      return this.update.channel_post;
    }
    get editedChannelPost() {
      return this.update.edited_channel_post;
    }
    get messageReaction() {
      return this.update.message_reaction;
    }
    get messageReactionCount() {
      return this.update.message_reaction_count;
    }
    get callbackQuery() {
      return this.update.callback_query;
    }
    get poll() {
      return this.update.poll;
    }
    get pollAnswer() {
      return this.update.poll_answer;
    }
    get myChatMember() {
      return this.update.my_chat_member;
    }
    get chatMember() {
      return this.update.chat_member;
    }
    get chatJoinRequest() {
      return this.update.chat_join_request;
    }
    get chatBoost() {
      return this.update.chat_boost;
    }
    get removedChatBoost() {
      return this.update.removed_chat_boost;
    }
    get msg() {
      return getMessageFromAnySource(this);
    }
    get msgId() {
      return getMsgIdFromAnySource(this);
    }
    get chat() {
      var _a2, _b, _c, _d, _e, _f, _g;
      return (_g = (_f = (_e = (_d = (_c = (_b = (_a2 = this.msg) !== null && _a2 !== undefined ? _a2 : this.messageReaction) !== null && _b !== undefined ? _b : this.messageReactionCount) !== null && _c !== undefined ? _c : this.chatJoinRequest) !== null && _d !== undefined ? _d : this.chatMember) !== null && _e !== undefined ? _e : this.myChatMember) !== null && _f !== undefined ? _f : this.removedChatBoost) === null || _g === undefined ? undefined : _g.chat;
    }
    get senderChat() {
      const msg = this.msg;
      return (msg === null || msg === undefined ? undefined : msg.has("sender_chat")) && msg.sender_chat;
    }
    get from() {
      return getUserFromAnySource(this);
    }
    get inlineMessageId() {
      var _a2, _b;
      return (_b = (_a2 = this.callbackQuery) !== null && _a2 !== undefined ? _a2 : this.chosenInlineResult) === null || _b === undefined ? undefined : _b.inline_message_id;
    }
    get passportData() {
      var _a2;
      if (this.message == null)
        return;
      if (!("passport_data" in this.message))
        return;
      return (_a2 = this.message) === null || _a2 === undefined ? undefined : _a2.passport_data;
    }
    get webAppData() {
      if (!(this.message && ("web_app_data" in this.message)))
        return;
      const { data, button_text } = this.message.web_app_data;
      return {
        data: {
          json() {
            return JSON.parse(data);
          },
          text() {
            return data;
          }
        },
        button_text
      };
    }
    get webhookReply() {
      return this.telegram.webhookReply;
    }
    set webhookReply(enable) {
      this.telegram.webhookReply = enable;
    }
    get reactions() {
      return reactions_1.MessageReactions.from(this);
    }
    assert(value, method) {
      if (value === undefined) {
        throw new TypeError(`Telegraf: "${method}" isn't available for "${this.updateType}"`);
      }
    }
    has(filters) {
      if (!Array.isArray(filters))
        filters = [filters];
      for (const filter of filters)
        if (typeof filter !== "string" ? filter(this.update) : (filter in this.update))
          return true;
      return false;
    }
    get text() {
      return getTextAndEntitiesFromAnySource(this)[0];
    }
    entities(...types2) {
      const [text = "", entities = []] = getTextAndEntitiesFromAnySource(this);
      return (types2.length ? entities.filter((entity) => types2.includes(entity.type)) : entities).map((entity) => ({
        ...entity,
        fragment: text.slice(entity.offset, entity.offset + entity.length)
      }));
    }
    answerInlineQuery(...args) {
      this.assert(this.inlineQuery, "answerInlineQuery");
      return this.telegram.answerInlineQuery(this.inlineQuery.id, ...args);
    }
    answerCbQuery(...args) {
      this.assert(this.callbackQuery, "answerCbQuery");
      return this.telegram.answerCbQuery(this.callbackQuery.id, ...args);
    }
    answerGameQuery(...args) {
      this.assert(this.callbackQuery, "answerGameQuery");
      return this.telegram.answerGameQuery(this.callbackQuery.id, ...args);
    }
    getUserChatBoosts() {
      this.assert(this.chat, "getUserChatBoosts");
      this.assert(this.from, "getUserChatBoosts");
      return this.telegram.getUserChatBoosts(this.chat.id, this.from.id);
    }
    answerShippingQuery(...args) {
      this.assert(this.shippingQuery, "answerShippingQuery");
      return this.telegram.answerShippingQuery(this.shippingQuery.id, ...args);
    }
    answerPreCheckoutQuery(...args) {
      this.assert(this.preCheckoutQuery, "answerPreCheckoutQuery");
      return this.telegram.answerPreCheckoutQuery(this.preCheckoutQuery.id, ...args);
    }
    editMessageText(text, extra) {
      var _a2, _b;
      this.assert((_a2 = this.msgId) !== null && _a2 !== undefined ? _a2 : this.inlineMessageId, "editMessageText");
      return this.telegram.editMessageText((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, text, extra);
    }
    editMessageCaption(caption, extra) {
      var _a2, _b;
      this.assert((_a2 = this.msgId) !== null && _a2 !== undefined ? _a2 : this.inlineMessageId, "editMessageCaption");
      return this.telegram.editMessageCaption((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, caption, extra);
    }
    editMessageMedia(media, extra) {
      var _a2, _b;
      this.assert((_a2 = this.msgId) !== null && _a2 !== undefined ? _a2 : this.inlineMessageId, "editMessageMedia");
      return this.telegram.editMessageMedia((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, media, extra);
    }
    editMessageReplyMarkup(markup) {
      var _a2, _b;
      this.assert((_a2 = this.msgId) !== null && _a2 !== undefined ? _a2 : this.inlineMessageId, "editMessageReplyMarkup");
      return this.telegram.editMessageReplyMarkup((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, markup);
    }
    editMessageLiveLocation(latitude, longitude, extra) {
      var _a2, _b;
      this.assert((_a2 = this.msgId) !== null && _a2 !== undefined ? _a2 : this.inlineMessageId, "editMessageLiveLocation");
      return this.telegram.editMessageLiveLocation((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, latitude, longitude, extra);
    }
    stopMessageLiveLocation(markup) {
      var _a2, _b;
      this.assert((_a2 = this.msgId) !== null && _a2 !== undefined ? _a2 : this.inlineMessageId, "stopMessageLiveLocation");
      return this.telegram.stopMessageLiveLocation((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, markup);
    }
    sendMessage(text, extra) {
      this.assert(this.chat, "sendMessage");
      return this.telegram.sendMessage(this.chat.id, text, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    reply(...args) {
      return this.sendMessage(...args);
    }
    getChat(...args) {
      this.assert(this.chat, "getChat");
      return this.telegram.getChat(this.chat.id, ...args);
    }
    exportChatInviteLink(...args) {
      this.assert(this.chat, "exportChatInviteLink");
      return this.telegram.exportChatInviteLink(this.chat.id, ...args);
    }
    createChatInviteLink(...args) {
      this.assert(this.chat, "createChatInviteLink");
      return this.telegram.createChatInviteLink(this.chat.id, ...args);
    }
    editChatInviteLink(...args) {
      this.assert(this.chat, "editChatInviteLink");
      return this.telegram.editChatInviteLink(this.chat.id, ...args);
    }
    revokeChatInviteLink(...args) {
      this.assert(this.chat, "revokeChatInviteLink");
      return this.telegram.revokeChatInviteLink(this.chat.id, ...args);
    }
    banChatMember(...args) {
      this.assert(this.chat, "banChatMember");
      return this.telegram.banChatMember(this.chat.id, ...args);
    }
    get kickChatMember() {
      return this.banChatMember;
    }
    unbanChatMember(...args) {
      this.assert(this.chat, "unbanChatMember");
      return this.telegram.unbanChatMember(this.chat.id, ...args);
    }
    restrictChatMember(...args) {
      this.assert(this.chat, "restrictChatMember");
      return this.telegram.restrictChatMember(this.chat.id, ...args);
    }
    promoteChatMember(...args) {
      this.assert(this.chat, "promoteChatMember");
      return this.telegram.promoteChatMember(this.chat.id, ...args);
    }
    setChatAdministratorCustomTitle(...args) {
      this.assert(this.chat, "setChatAdministratorCustomTitle");
      return this.telegram.setChatAdministratorCustomTitle(this.chat.id, ...args);
    }
    setChatPhoto(...args) {
      this.assert(this.chat, "setChatPhoto");
      return this.telegram.setChatPhoto(this.chat.id, ...args);
    }
    deleteChatPhoto(...args) {
      this.assert(this.chat, "deleteChatPhoto");
      return this.telegram.deleteChatPhoto(this.chat.id, ...args);
    }
    setChatTitle(...args) {
      this.assert(this.chat, "setChatTitle");
      return this.telegram.setChatTitle(this.chat.id, ...args);
    }
    setChatDescription(...args) {
      this.assert(this.chat, "setChatDescription");
      return this.telegram.setChatDescription(this.chat.id, ...args);
    }
    pinChatMessage(...args) {
      this.assert(this.chat, "pinChatMessage");
      return this.telegram.pinChatMessage(this.chat.id, ...args);
    }
    unpinChatMessage(...args) {
      this.assert(this.chat, "unpinChatMessage");
      return this.telegram.unpinChatMessage(this.chat.id, ...args);
    }
    unpinAllChatMessages(...args) {
      this.assert(this.chat, "unpinAllChatMessages");
      return this.telegram.unpinAllChatMessages(this.chat.id, ...args);
    }
    leaveChat(...args) {
      this.assert(this.chat, "leaveChat");
      return this.telegram.leaveChat(this.chat.id, ...args);
    }
    setChatPermissions(...args) {
      this.assert(this.chat, "setChatPermissions");
      return this.telegram.setChatPermissions(this.chat.id, ...args);
    }
    getChatAdministrators(...args) {
      this.assert(this.chat, "getChatAdministrators");
      return this.telegram.getChatAdministrators(this.chat.id, ...args);
    }
    getChatMember(...args) {
      this.assert(this.chat, "getChatMember");
      return this.telegram.getChatMember(this.chat.id, ...args);
    }
    getChatMembersCount(...args) {
      this.assert(this.chat, "getChatMembersCount");
      return this.telegram.getChatMembersCount(this.chat.id, ...args);
    }
    setPassportDataErrors(errors3) {
      this.assert(this.from, "setPassportDataErrors");
      return this.telegram.setPassportDataErrors(this.from.id, errors3);
    }
    sendPhoto(photo, extra) {
      this.assert(this.chat, "sendPhoto");
      return this.telegram.sendPhoto(this.chat.id, photo, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithPhoto(...args) {
      return this.sendPhoto(...args);
    }
    sendMediaGroup(media, extra) {
      this.assert(this.chat, "sendMediaGroup");
      return this.telegram.sendMediaGroup(this.chat.id, media, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithMediaGroup(...args) {
      return this.sendMediaGroup(...args);
    }
    sendAudio(audio, extra) {
      this.assert(this.chat, "sendAudio");
      return this.telegram.sendAudio(this.chat.id, audio, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithAudio(...args) {
      return this.sendAudio(...args);
    }
    sendDice(extra) {
      this.assert(this.chat, "sendDice");
      return this.telegram.sendDice(this.chat.id, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithDice(...args) {
      return this.sendDice(...args);
    }
    sendDocument(document2, extra) {
      this.assert(this.chat, "sendDocument");
      return this.telegram.sendDocument(this.chat.id, document2, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithDocument(...args) {
      return this.sendDocument(...args);
    }
    sendSticker(sticker, extra) {
      this.assert(this.chat, "sendSticker");
      return this.telegram.sendSticker(this.chat.id, sticker, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithSticker(...args) {
      return this.sendSticker(...args);
    }
    sendVideo(video, extra) {
      this.assert(this.chat, "sendVideo");
      return this.telegram.sendVideo(this.chat.id, video, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithVideo(...args) {
      return this.sendVideo(...args);
    }
    sendAnimation(animation, extra) {
      this.assert(this.chat, "sendAnimation");
      return this.telegram.sendAnimation(this.chat.id, animation, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithAnimation(...args) {
      return this.sendAnimation(...args);
    }
    sendVideoNote(videoNote, extra) {
      this.assert(this.chat, "sendVideoNote");
      return this.telegram.sendVideoNote(this.chat.id, videoNote, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithVideoNote(...args) {
      return this.sendVideoNote(...args);
    }
    sendInvoice(invoice, extra) {
      this.assert(this.chat, "sendInvoice");
      return this.telegram.sendInvoice(this.chat.id, invoice, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithInvoice(...args) {
      return this.sendInvoice(...args);
    }
    sendGame(game, extra) {
      this.assert(this.chat, "sendGame");
      return this.telegram.sendGame(this.chat.id, game, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithGame(...args) {
      return this.sendGame(...args);
    }
    sendVoice(voice, extra) {
      this.assert(this.chat, "sendVoice");
      return this.telegram.sendVoice(this.chat.id, voice, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithVoice(...args) {
      return this.sendVoice(...args);
    }
    sendPoll(poll, options, extra) {
      this.assert(this.chat, "sendPoll");
      return this.telegram.sendPoll(this.chat.id, poll, options, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithPoll(...args) {
      return this.sendPoll(...args);
    }
    sendQuiz(quiz, options, extra) {
      this.assert(this.chat, "sendQuiz");
      return this.telegram.sendQuiz(this.chat.id, quiz, options, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithQuiz(...args) {
      return this.sendQuiz(...args);
    }
    stopPoll(...args) {
      this.assert(this.chat, "stopPoll");
      return this.telegram.stopPoll(this.chat.id, ...args);
    }
    sendChatAction(action, extra) {
      this.assert(this.chat, "sendChatAction");
      return this.telegram.sendChatAction(this.chat.id, action, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    async persistentChatAction(action, callback, { intervalDuration, ...extra } = {}) {
      await this.sendChatAction(action, { ...extra });
      const timer = setInterval(() => this.sendChatAction(action, { ...extra }).catch((err) => {
        debug("Ignored error while persisting sendChatAction:", err);
      }), intervalDuration !== null && intervalDuration !== undefined ? intervalDuration : 4000);
      try {
        await callback();
      } finally {
        clearInterval(timer);
      }
    }
    replyWithChatAction(...args) {
      return this.sendChatAction(...args);
    }
    react(reaction, is_big) {
      this.assert(this.chat, "setMessageReaction");
      this.assert(this.msgId, "setMessageReaction");
      const emojis = reaction ? Array.isArray(reaction) ? reaction : [reaction] : undefined;
      const reactions = emojis === null || emojis === undefined ? undefined : emojis.map((emoji2) => typeof emoji2 === "string" ? reactions_1.Digit.has(emoji2[0]) ? { type: "custom_emoji", custom_emoji_id: emoji2 } : { type: "emoji", emoji: emoji2 } : emoji2);
      return this.telegram.setMessageReaction(this.chat.id, this.msgId, reactions, is_big);
    }
    sendLocation(latitude, longitude, extra) {
      this.assert(this.chat, "sendLocation");
      return this.telegram.sendLocation(this.chat.id, latitude, longitude, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithLocation(...args) {
      return this.sendLocation(...args);
    }
    sendVenue(latitude, longitude, title, address, extra) {
      this.assert(this.chat, "sendVenue");
      return this.telegram.sendVenue(this.chat.id, latitude, longitude, title, address, { message_thread_id: getThreadId(this), ...extra });
    }
    replyWithVenue(...args) {
      return this.sendVenue(...args);
    }
    sendContact(phoneNumber, firstName, extra) {
      this.assert(this.chat, "sendContact");
      return this.telegram.sendContact(this.chat.id, phoneNumber, firstName, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithContact(...args) {
      return this.sendContact(...args);
    }
    getStickerSet(setName) {
      return this.telegram.getStickerSet(setName);
    }
    setChatStickerSet(setName) {
      this.assert(this.chat, "setChatStickerSet");
      return this.telegram.setChatStickerSet(this.chat.id, setName);
    }
    deleteChatStickerSet() {
      this.assert(this.chat, "deleteChatStickerSet");
      return this.telegram.deleteChatStickerSet(this.chat.id);
    }
    createForumTopic(...args) {
      this.assert(this.chat, "createForumTopic");
      return this.telegram.createForumTopic(this.chat.id, ...args);
    }
    editForumTopic(extra) {
      var _a2;
      this.assert(this.chat, "editForumTopic");
      this.assert((_a2 = this.message) === null || _a2 === undefined ? undefined : _a2.message_thread_id, "editForumTopic");
      return this.telegram.editForumTopic(this.chat.id, this.message.message_thread_id, extra);
    }
    closeForumTopic() {
      var _a2;
      this.assert(this.chat, "closeForumTopic");
      this.assert((_a2 = this.message) === null || _a2 === undefined ? undefined : _a2.message_thread_id, "closeForumTopic");
      return this.telegram.closeForumTopic(this.chat.id, this.message.message_thread_id);
    }
    reopenForumTopic() {
      var _a2;
      this.assert(this.chat, "reopenForumTopic");
      this.assert((_a2 = this.message) === null || _a2 === undefined ? undefined : _a2.message_thread_id, "reopenForumTopic");
      return this.telegram.reopenForumTopic(this.chat.id, this.message.message_thread_id);
    }
    deleteForumTopic() {
      var _a2;
      this.assert(this.chat, "deleteForumTopic");
      this.assert((_a2 = this.message) === null || _a2 === undefined ? undefined : _a2.message_thread_id, "deleteForumTopic");
      return this.telegram.deleteForumTopic(this.chat.id, this.message.message_thread_id);
    }
    unpinAllForumTopicMessages() {
      var _a2;
      this.assert(this.chat, "unpinAllForumTopicMessages");
      this.assert((_a2 = this.message) === null || _a2 === undefined ? undefined : _a2.message_thread_id, "unpinAllForumTopicMessages");
      return this.telegram.unpinAllForumTopicMessages(this.chat.id, this.message.message_thread_id);
    }
    editGeneralForumTopic(name) {
      this.assert(this.chat, "editGeneralForumTopic");
      return this.telegram.editGeneralForumTopic(this.chat.id, name);
    }
    closeGeneralForumTopic() {
      this.assert(this.chat, "closeGeneralForumTopic");
      return this.telegram.closeGeneralForumTopic(this.chat.id);
    }
    reopenGeneralForumTopic() {
      this.assert(this.chat, "reopenGeneralForumTopic");
      return this.telegram.reopenGeneralForumTopic(this.chat.id);
    }
    hideGeneralForumTopic() {
      this.assert(this.chat, "hideGeneralForumTopic");
      return this.telegram.hideGeneralForumTopic(this.chat.id);
    }
    unhideGeneralForumTopic() {
      this.assert(this.chat, "unhideGeneralForumTopic");
      return this.telegram.unhideGeneralForumTopic(this.chat.id);
    }
    unpinAllGeneralForumTopicMessages() {
      this.assert(this.chat, "unpinAllGeneralForumTopicMessages");
      return this.telegram.unpinAllGeneralForumTopicMessages(this.chat.id);
    }
    setStickerPositionInSet(sticker, position) {
      return this.telegram.setStickerPositionInSet(sticker, position);
    }
    setStickerSetThumb(...args) {
      return this.telegram.setStickerSetThumbnail(...args);
    }
    setStickerSetThumbnail(...args) {
      return this.telegram.setStickerSetThumbnail(...args);
    }
    setStickerMaskPosition(...args) {
      return this.telegram.setStickerMaskPosition(...args);
    }
    setStickerKeywords(...args) {
      return this.telegram.setStickerKeywords(...args);
    }
    setStickerEmojiList(...args) {
      return this.telegram.setStickerEmojiList(...args);
    }
    deleteStickerSet(...args) {
      return this.telegram.deleteStickerSet(...args);
    }
    setStickerSetTitle(...args) {
      return this.telegram.setStickerSetTitle(...args);
    }
    setCustomEmojiStickerSetThumbnail(...args) {
      return this.telegram.setCustomEmojiStickerSetThumbnail(...args);
    }
    deleteStickerFromSet(sticker) {
      return this.telegram.deleteStickerFromSet(sticker);
    }
    uploadStickerFile(...args) {
      this.assert(this.from, "uploadStickerFile");
      return this.telegram.uploadStickerFile(this.from.id, ...args);
    }
    createNewStickerSet(...args) {
      this.assert(this.from, "createNewStickerSet");
      return this.telegram.createNewStickerSet(this.from.id, ...args);
    }
    addStickerToSet(...args) {
      this.assert(this.from, "addStickerToSet");
      return this.telegram.addStickerToSet(this.from.id, ...args);
    }
    getMyCommands() {
      return this.telegram.getMyCommands();
    }
    setMyCommands(commands) {
      return this.telegram.setMyCommands(commands);
    }
    replyWithMarkdown(markdown, extra) {
      return this.reply(markdown, { parse_mode: "Markdown", ...extra });
    }
    replyWithMarkdownV2(markdown, extra) {
      return this.reply(markdown, { parse_mode: "MarkdownV2", ...extra });
    }
    replyWithHTML(html, extra) {
      return this.reply(html, { parse_mode: "HTML", ...extra });
    }
    deleteMessage(messageId) {
      this.assert(this.chat, "deleteMessage");
      if (typeof messageId !== "undefined")
        return this.telegram.deleteMessage(this.chat.id, messageId);
      this.assert(this.msgId, "deleteMessage");
      return this.telegram.deleteMessage(this.chat.id, this.msgId);
    }
    deleteMessages(messageIds) {
      this.assert(this.chat, "deleteMessages");
      return this.telegram.deleteMessages(this.chat.id, messageIds);
    }
    forwardMessage(chatId, extra) {
      this.assert(this.chat, "forwardMessage");
      this.assert(this.msgId, "forwardMessage");
      return this.telegram.forwardMessage(chatId, this.chat.id, this.msgId, extra);
    }
    forwardMessages(chatId, messageIds, extra) {
      this.assert(this.chat, "forwardMessages");
      return this.telegram.forwardMessages(chatId, this.chat.id, messageIds, extra);
    }
    copyMessage(chatId, extra) {
      this.assert(this.chat, "copyMessage");
      this.assert(this.msgId, "copyMessage");
      return this.telegram.copyMessage(chatId, this.chat.id, this.msgId, extra);
    }
    copyMessages(chatId, messageIds, extra) {
      var _a2;
      this.assert(this.chat, "copyMessages");
      return this.telegram.copyMessages(chatId, (_a2 = this.chat) === null || _a2 === undefined ? undefined : _a2.id, messageIds, extra);
    }
    approveChatJoinRequest(userId) {
      this.assert(this.chat, "approveChatJoinRequest");
      return this.telegram.approveChatJoinRequest(this.chat.id, userId);
    }
    declineChatJoinRequest(userId) {
      this.assert(this.chat, "declineChatJoinRequest");
      return this.telegram.declineChatJoinRequest(this.chat.id, userId);
    }
    banChatSenderChat(senderChatId) {
      this.assert(this.chat, "banChatSenderChat");
      return this.telegram.banChatSenderChat(this.chat.id, senderChatId);
    }
    unbanChatSenderChat(senderChatId) {
      this.assert(this.chat, "unbanChatSenderChat");
      return this.telegram.unbanChatSenderChat(this.chat.id, senderChatId);
    }
    setChatMenuButton(menuButton) {
      this.assert(this.chat, "setChatMenuButton");
      return this.telegram.setChatMenuButton({ chatId: this.chat.id, menuButton });
    }
    getChatMenuButton() {
      this.assert(this.chat, "getChatMenuButton");
      return this.telegram.getChatMenuButton({ chatId: this.chat.id });
    }
    setMyDefaultAdministratorRights(extra) {
      return this.telegram.setMyDefaultAdministratorRights(extra);
    }
    getMyDefaultAdministratorRights(extra) {
      return this.telegram.getMyDefaultAdministratorRights(extra);
    }
  }
  exports.Context = Context;
  exports.default = Context;
  var Msg = {
    isAccessible() {
      return "date" in this && this.date !== 0;
    },
    has(...keys) {
      return keys.some((key) => this[key] != null);
    }
  };
  function getMessageFromAnySource(ctx) {
    var _a2, _b, _c, _d, _e;
    const msg = (_e = (_d = (_b = (_a2 = ctx.message) !== null && _a2 !== undefined ? _a2 : ctx.editedMessage) !== null && _b !== undefined ? _b : (_c = ctx.callbackQuery) === null || _c === undefined ? undefined : _c.message) !== null && _d !== undefined ? _d : ctx.channelPost) !== null && _e !== undefined ? _e : ctx.editedChannelPost;
    if (msg)
      return Object.assign(Object.create(Msg), msg);
  }
  function getUserFromAnySource(ctx) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    if (ctx.callbackQuery)
      return ctx.callbackQuery.from;
    const msg = ctx.msg;
    if (msg === null || msg === undefined ? undefined : msg.has("from"))
      return msg.from;
    return (_h = (_g = (_f = (_e = (_d = (_c = (_b = (_a2 = ctx.inlineQuery) !== null && _a2 !== undefined ? _a2 : ctx.shippingQuery) !== null && _b !== undefined ? _b : ctx.preCheckoutQuery) !== null && _c !== undefined ? _c : ctx.chosenInlineResult) !== null && _d !== undefined ? _d : ctx.chatMember) !== null && _e !== undefined ? _e : ctx.myChatMember) !== null && _f !== undefined ? _f : ctx.chatJoinRequest) === null || _g === undefined ? undefined : _g.from) !== null && _h !== undefined ? _h : (_m = (_k = (_j = ctx.messageReaction) !== null && _j !== undefined ? _j : ctx.pollAnswer) !== null && _k !== undefined ? _k : (_l = ctx.chatBoost) === null || _l === undefined ? undefined : _l.boost.source) === null || _m === undefined ? undefined : _m.user;
  }
  function getMsgIdFromAnySource(ctx) {
    var _a2, _b;
    const msg = getMessageFromAnySource(ctx);
    return (_b = (_a2 = msg !== null && msg !== undefined ? msg : ctx.messageReaction) !== null && _a2 !== undefined ? _a2 : ctx.messageReactionCount) === null || _b === undefined ? undefined : _b.message_id;
  }
  function getTextAndEntitiesFromAnySource(ctx) {
    const msg = ctx.msg;
    let text, entities;
    if (msg) {
      if ("text" in msg)
        text = msg.text, entities = msg.entities;
      else if ("caption" in msg)
        text = msg.caption, entities = msg.caption_entities;
      else if ("game" in msg)
        text = msg.game.text, entities = msg.game.text_entities;
    } else if (ctx.poll)
      text = ctx.poll.explanation, entities = ctx.poll.explanation_entities;
    return [text, entities];
  }
  var getThreadId = (ctx) => {
    const msg = ctx.msg;
    return (msg === null || msg === undefined ? undefined : msg.isAccessible()) ? msg.is_topic_message ? msg.message_thread_id : undefined : undefined;
  };
});

// node_modules/telegraf/lib/filters.js
var require_filters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.allOf = exports.anyOf = exports.callbackQuery = exports.editedChannelPost = exports.channelPost = exports.editedMessage = exports.message = undefined;
  var message = (...keys) => (update) => {
    if (!("message" in update))
      return false;
    for (const key of keys) {
      if (!(key in update.message))
        return false;
    }
    return true;
  };
  exports.message = message;
  var editedMessage = (...keys) => (update) => {
    if (!("edited_message" in update))
      return false;
    for (const key of keys) {
      if (!(key in update.edited_message))
        return false;
    }
    return true;
  };
  exports.editedMessage = editedMessage;
  var channelPost = (...keys) => (update) => {
    if (!("channel_post" in update))
      return false;
    for (const key of keys) {
      if (!(key in update.channel_post))
        return false;
    }
    return true;
  };
  exports.channelPost = channelPost;
  var editedChannelPost = (...keys) => (update) => {
    if (!("edited_channel_post" in update))
      return false;
    for (const key of keys) {
      if (!(key in update.edited_channel_post))
        return false;
    }
    return true;
  };
  exports.editedChannelPost = editedChannelPost;
  var callbackQuery = (...keys) => (update) => {
    if (!("callback_query" in update))
      return false;
    for (const key of keys) {
      if (!(key in update.callback_query))
        return false;
    }
    return true;
  };
  exports.callbackQuery = callbackQuery;
  var anyOf = (...filters) => (update) => {
    for (const filter of filters)
      if (filter(update))
        return true;
    return false;
  };
  exports.anyOf = anyOf;
  var allOf = (...filters) => (update) => {
    for (const filter of filters)
      if (!filter(update))
        return false;
    return true;
  };
  exports.allOf = allOf;
});

// node_modules/telegraf/lib/core/helpers/args.js
var require_args = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.argsParser = undefined;
  var SINGLE_QUOTE = "'";
  var DOUBLE_QUOTE = '"';
  function argsParser(str, entities = [], entityOffset = 0) {
    const mentions = {};
    for (const entity of entities)
      if (entity.type === "text_mention" || entity.type === "text_link")
        mentions[entity.offset - entityOffset] = entity.length;
    const args = [];
    let done = 0;
    let inside = undefined;
    let buf = "";
    function flush(to) {
      if (done !== to)
        args.push(buf + str.slice(done, to)), inside = undefined;
      buf = "";
      done = to + 1;
    }
    for (let i = 0;i < str.length; i++) {
      const char = str[i];
      const mention = mentions[i];
      if (mention) {
        flush(i);
        done--;
        i += mention;
        flush(i);
      } else if (char === SINGLE_QUOTE || char === DOUBLE_QUOTE)
        if (inside)
          if (inside === char)
            flush(i);
          else
            continue;
        else
          flush(i), inside = char;
      else if (char === " ")
        if (inside)
          continue;
        else
          flush(i);
      else if (char === `
`)
        flush(i);
      else if (char === "\\")
        buf += str.slice(done, i), done = ++i;
      else
        continue;
    }
    if (done < str.length)
      flush(str.length);
    return args;
  }
  exports.argsParser = argsParser;
});

// node_modules/telegraf/lib/composer.js
var require_composer = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Composer = undefined;
  var context_1 = __importDefault(require_context());
  var filters_1 = require_filters();
  var args_1 = require_args();
  function always(x) {
    return () => x;
  }
  var anoop = always(Promise.resolve());

  class Composer {
    constructor(...fns) {
      this.handler = Composer.compose(fns);
    }
    use(...fns) {
      this.handler = Composer.compose([this.handler, ...fns]);
      return this;
    }
    guard(guardFn, ...fns) {
      return this.use(Composer.guard(guardFn, ...fns));
    }
    on(filters, ...fns) {
      return this.use(Composer.on(filters, ...fns));
    }
    hears(triggers, ...fns) {
      return this.use(Composer.hears(triggers, ...fns));
    }
    command(command, ...fns) {
      return this.use(Composer.command(command, ...fns));
    }
    action(triggers, ...fns) {
      return this.use(Composer.action(triggers, ...fns));
    }
    inlineQuery(triggers, ...fns) {
      return this.use(Composer.inlineQuery(triggers, ...fns));
    }
    gameQuery(...fns) {
      return this.use(Composer.gameQuery(...fns));
    }
    reaction(reaction, ...fns) {
      return this.use(Composer.reaction(reaction, ...fns));
    }
    drop(predicate) {
      return this.use(Composer.drop(predicate));
    }
    filter(predicate) {
      return this.use(Composer.filter(predicate));
    }
    entity(predicate, ...fns) {
      return this.use(Composer.entity(predicate, ...fns));
    }
    email(email2, ...fns) {
      return this.use(Composer.email(email2, ...fns));
    }
    url(url, ...fns) {
      return this.use(Composer.url(url, ...fns));
    }
    textLink(link, ...fns) {
      return this.use(Composer.textLink(link, ...fns));
    }
    textMention(mention, ...fns) {
      return this.use(Composer.textMention(mention, ...fns));
    }
    mention(mention, ...fns) {
      return this.use(Composer.mention(mention, ...fns));
    }
    phone(number2, ...fns) {
      return this.use(Composer.phone(number2, ...fns));
    }
    hashtag(hashtag, ...fns) {
      return this.use(Composer.hashtag(hashtag, ...fns));
    }
    cashtag(cashtag, ...fns) {
      return this.use(Composer.cashtag(cashtag, ...fns));
    }
    spoiler(text, ...fns) {
      return this.use(Composer.spoiler(text, ...fns));
    }
    start(...fns) {
      const handler = Composer.compose(fns);
      return this.command("start", (ctx, next) => handler(Object.assign(ctx, { startPayload: ctx.payload }), next));
    }
    help(...fns) {
      return this.command("help", ...fns);
    }
    settings(...fns) {
      return this.command("settings", ...fns);
    }
    middleware() {
      return this.handler;
    }
    static reply(...args) {
      return (ctx) => ctx.reply(...args);
    }
    static catch(errorHandler, ...fns) {
      const handler = Composer.compose(fns);
      return (ctx, next) => Promise.resolve(handler(ctx, next)).catch((err) => errorHandler(err, ctx));
    }
    static fork(middleware) {
      const handler = Composer.unwrap(middleware);
      return async (ctx, next) => {
        await Promise.all([handler(ctx, anoop), next()]);
      };
    }
    static tap(middleware) {
      const handler = Composer.unwrap(middleware);
      return (ctx, next) => Promise.resolve(handler(ctx, anoop)).then(() => next());
    }
    static passThru() {
      return (ctx, next) => next();
    }
    static lazy(factoryFn) {
      if (typeof factoryFn !== "function") {
        throw new Error("Argument must be a function");
      }
      return (ctx, next) => Promise.resolve(factoryFn(ctx)).then((middleware) => Composer.unwrap(middleware)(ctx, next));
    }
    static log(logFn = console.log) {
      return (ctx, next) => {
        logFn(JSON.stringify(ctx.update, null, 2));
        return next();
      };
    }
    static branch(predicate, trueMiddleware, falseMiddleware) {
      if (typeof predicate !== "function") {
        return Composer.unwrap(predicate ? trueMiddleware : falseMiddleware);
      }
      return Composer.lazy((ctx) => Promise.resolve(predicate(ctx)).then((value) => value ? trueMiddleware : falseMiddleware));
    }
    static optional(predicate, ...fns) {
      return Composer.branch(predicate, Composer.compose(fns), Composer.passThru());
    }
    static filter(predicate) {
      return Composer.branch(predicate, Composer.passThru(), anoop);
    }
    static drop(predicate) {
      return Composer.branch(predicate, anoop, Composer.passThru());
    }
    static dispatch(routeFn, handlers) {
      return Composer.lazy((ctx) => Promise.resolve(routeFn(ctx)).then((value) => handlers[value]));
    }
    static guard(guardFn, ...fns) {
      return Composer.optional((ctx) => guardFn(ctx.update), ...fns);
    }
    static on(updateType, ...fns) {
      const filters = Array.isArray(updateType) ? updateType : [updateType];
      const predicate = (update) => {
        for (const filter of filters) {
          if (typeof filter !== "string" ? filter(update) : (filter in update) || ("message" in update) && (filter in update.message)) {
            return true;
          }
        }
        return false;
      };
      return Composer.optional((ctx) => predicate(ctx.update), ...fns);
    }
    static entity(predicate, ...fns) {
      if (typeof predicate !== "function") {
        const entityTypes = normaliseTextArguments(predicate);
        return Composer.entity(({ type }) => entityTypes.includes(type), ...fns);
      }
      return Composer.optional((ctx) => {
        var _a2;
        const msg = (_a2 = ctx.message) !== null && _a2 !== undefined ? _a2 : ctx.channelPost;
        if (msg === undefined) {
          return false;
        }
        const text = getText(msg);
        const entities = getEntities(msg);
        if (text === undefined)
          return false;
        return entities.some((entity) => predicate(entity, text.substring(entity.offset, entity.offset + entity.length), ctx));
      }, ...fns);
    }
    static entityText(entityType, predicate, ...fns) {
      if (fns.length === 0) {
        return Array.isArray(predicate) ? Composer.entity(entityType, ...predicate) : Composer.entity(entityType, predicate);
      }
      const triggers = normaliseTriggers(predicate);
      return Composer.entity(({ type }, value, ctx) => {
        if (type !== entityType) {
          return false;
        }
        for (const trigger of triggers) {
          if (ctx.match = trigger(value, ctx)) {
            return true;
          }
        }
        return false;
      }, ...fns);
    }
    static email(email2, ...fns) {
      return Composer.entityText("email", email2, ...fns);
    }
    static phone(number2, ...fns) {
      return Composer.entityText("phone_number", number2, ...fns);
    }
    static url(url, ...fns) {
      return Composer.entityText("url", url, ...fns);
    }
    static textLink(link, ...fns) {
      return Composer.entityText("text_link", link, ...fns);
    }
    static textMention(mention, ...fns) {
      return Composer.entityText("text_mention", mention, ...fns);
    }
    static mention(mention, ...fns) {
      return Composer.entityText("mention", normaliseTextArguments(mention, "@"), ...fns);
    }
    static hashtag(hashtag, ...fns) {
      return Composer.entityText("hashtag", normaliseTextArguments(hashtag, "#"), ...fns);
    }
    static cashtag(cashtag, ...fns) {
      return Composer.entityText("cashtag", normaliseTextArguments(cashtag, "$"), ...fns);
    }
    static spoiler(text, ...fns) {
      return Composer.entityText("spoiler", text, ...fns);
    }
    static match(triggers, ...fns) {
      const handler = Composer.compose(fns);
      return (ctx, next) => {
        var _a2, _b, _c, _d;
        const text = (_c = (_b = (_a2 = getText(ctx.message)) !== null && _a2 !== undefined ? _a2 : getText(ctx.channelPost)) !== null && _b !== undefined ? _b : getText(ctx.callbackQuery)) !== null && _c !== undefined ? _c : (_d = ctx.inlineQuery) === null || _d === undefined ? undefined : _d.query;
        if (text === undefined)
          return next();
        for (const trigger of triggers) {
          const match = trigger(text, ctx);
          if (match)
            return handler(Object.assign(ctx, { match }), next);
        }
        return next();
      };
    }
    static hears(triggers, ...fns) {
      return Composer.on("text", Composer.match(normaliseTriggers(triggers), ...fns));
    }
    static command(command, ...fns) {
      if (fns.length === 0)
        return Composer.entity("bot_command", command);
      const triggers = normaliseTriggers(command);
      const filter = (0, filters_1.message)("text");
      const handler = Composer.compose(fns);
      return Composer.on(filter, (ctx, next) => {
        const { entities } = ctx.message;
        const cmdEntity = entities === null || entities === undefined ? undefined : entities[0];
        if ((cmdEntity === null || cmdEntity === undefined ? undefined : cmdEntity.type) !== "bot_command")
          return next();
        if (cmdEntity.offset > 0)
          return next();
        const len = cmdEntity.length;
        const text = ctx.message.text;
        const [cmdPart, to] = text.slice(0, len).split("@");
        if (!cmdPart)
          return next();
        if (to && to.toLowerCase() !== ctx.me.toLowerCase())
          return next();
        const command2 = cmdPart.slice(1);
        for (const trigger of triggers) {
          const match = trigger(command2, ctx);
          if (match) {
            const payloadOffset = len + 1;
            const payload = text.slice(payloadOffset);
            const c = Object.assign(ctx, { match, command: command2, payload, args: [] });
            let _args = undefined;
            Object.defineProperty(c, "args", {
              enumerable: true,
              configurable: true,
              get() {
                if (_args != null)
                  return _args;
                return _args = (0, args_1.argsParser)(payload, entities, payloadOffset);
              },
              set(args) {
                _args = args;
              }
            });
            return handler(c, next);
          }
        }
        return next();
      });
    }
    static action(triggers, ...fns) {
      return Composer.on("callback_query", Composer.match(normaliseTriggers(triggers), ...fns));
    }
    static inlineQuery(triggers, ...fns) {
      return Composer.on("inline_query", Composer.match(normaliseTriggers(triggers), ...fns));
    }
    static reaction(reaction, ...fns) {
      const reactions = Array.isArray(reaction) ? reaction : [reaction];
      const handler = Composer.compose(fns);
      return Composer.on("message_reaction", (ctx, next) => {
        const match = reactions.find((r) => typeof r === "string" && r.startsWith("-") ? ctx.reactions.removed.has(r.slice(1)) : ctx.reactions.added.has(r));
        if (match)
          return handler(Object.assign(ctx, { match }), next);
        return next();
      });
    }
    static acl(userId, ...fns) {
      if (typeof userId === "function") {
        return Composer.optional(userId, ...fns);
      }
      const allowed = Array.isArray(userId) ? userId : [userId];
      return Composer.optional((ctx) => !ctx.from || allowed.includes(ctx.from.id), ...fns);
    }
    static memberStatus(status, ...fns) {
      const statuses = Array.isArray(status) ? status : [status];
      return Composer.optional(async (ctx) => {
        if (ctx.message === undefined)
          return false;
        const member = await ctx.getChatMember(ctx.message.from.id);
        return statuses.includes(member.status);
      }, ...fns);
    }
    static admin(...fns) {
      return Composer.memberStatus(["administrator", "creator"], ...fns);
    }
    static creator(...fns) {
      return Composer.memberStatus("creator", ...fns);
    }
    static chatType(type, ...fns) {
      const types2 = Array.isArray(type) ? type : [type];
      return Composer.optional((ctx) => {
        const chat = ctx.chat;
        return chat !== undefined && types2.includes(chat.type);
      }, ...fns);
    }
    static privateChat(...fns) {
      return Composer.chatType("private", ...fns);
    }
    static groupChat(...fns) {
      return Composer.chatType(["group", "supergroup"], ...fns);
    }
    static gameQuery(...fns) {
      return Composer.guard((0, filters_1.callbackQuery)("game_short_name"), ...fns);
    }
    static unwrap(handler) {
      if (!handler) {
        throw new Error("Handler is undefined");
      }
      return "middleware" in handler ? handler.middleware() : handler;
    }
    static compose(middlewares) {
      if (!Array.isArray(middlewares)) {
        throw new Error("Middlewares must be an array");
      }
      if (middlewares.length === 0) {
        return Composer.passThru();
      }
      if (middlewares.length === 1) {
        return Composer.unwrap(middlewares[0]);
      }
      return (ctx, next) => {
        let index = -1;
        return execute(0, ctx);
        async function execute(i, context) {
          var _a2;
          if (!(context instanceof context_1.default)) {
            throw new Error("next(ctx) called with invalid context");
          }
          if (i <= index) {
            throw new Error("next() called multiple times");
          }
          index = i;
          const handler = Composer.unwrap((_a2 = middlewares[i]) !== null && _a2 !== undefined ? _a2 : next);
          await handler(context, async (ctx2 = context) => {
            await execute(i + 1, ctx2);
          });
        }
      };
    }
  }
  exports.Composer = Composer;
  Composer.mount = Composer.on;
  function escapeRegExp(s) {
    return s.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
  }
  function normaliseTriggers(triggers) {
    if (!Array.isArray(triggers))
      triggers = [triggers];
    return triggers.map((trigger) => {
      if (!trigger)
        throw new Error("Invalid trigger");
      if (typeof trigger === "function")
        return trigger;
      if (trigger instanceof RegExp)
        return (value = "") => {
          trigger.lastIndex = 0;
          return trigger.exec(value);
        };
      const regex2 = new RegExp(`^${escapeRegExp(trigger)}$`);
      return (value) => regex2.exec(value);
    });
  }
  function getEntities(msg) {
    var _a2, _b;
    if (msg == null)
      return [];
    if ("caption_entities" in msg)
      return (_a2 = msg.caption_entities) !== null && _a2 !== undefined ? _a2 : [];
    if ("entities" in msg)
      return (_b = msg.entities) !== null && _b !== undefined ? _b : [];
    return [];
  }
  function getText(msg) {
    if (msg == null)
      return;
    if ("caption" in msg)
      return msg.caption;
    if ("text" in msg)
      return msg.text;
    if ("data" in msg)
      return msg.data;
    if ("game_short_name" in msg)
      return msg.game_short_name;
    return;
  }
  function normaliseTextArguments(argument, prefix = "") {
    const args = Array.isArray(argument) ? argument : [argument];
    return args.filter(Boolean).map((arg) => prefix && typeof arg === "string" && !arg.startsWith(prefix) ? `${prefix}${arg}` : arg);
  }
  exports.default = Composer;
});

// node_modules/telegraf/lib/core/helpers/compact.js
var require_compact = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compactOptions = undefined;
  function compactOptions(options) {
    if (!options) {
      return options;
    }
    const compacted = {};
    for (const key in options)
      if (Object.prototype.hasOwnProperty.call(options, key) && options[key] !== undefined)
        compacted[key] = options[key];
    return compacted;
  }
  exports.compactOptions = compactOptions;
});

// node_modules/telegraf/lib/core/network/webhook.js
var require_webhook = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var debug_1 = __importDefault(require_src());
  var debug = (0, debug_1.default)("telegraf:webhook");
  function generateWebhook(filter, updateHandler) {
    return async (req, res, next = () => {
      res.statusCode = 403;
      debug("Replying with status code", res.statusCode);
      res.end();
    }) => {
      debug("Incoming request", req.method, req.url);
      if (!filter(req)) {
        debug("Webhook filter failed", req.method, req.url);
        return next();
      }
      let update;
      try {
        if (req.body != null) {
          let body = req.body;
          if (body instanceof Buffer)
            body = String(req.body);
          if (typeof body === "string")
            body = JSON.parse(body);
          update = body;
        } else {
          let body = "";
          for await (const chunk of req)
            body += String(chunk);
          update = JSON.parse(body);
        }
      } catch (error46) {
        res.writeHead(415).end();
        debug("Failed to parse request body:", error46);
        return;
      }
      return await updateHandler(update, res);
    };
  }
  exports.default = generateWebhook;
});

// node_modules/telegraf/lib/core/network/error.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TelegramError = undefined;

  class TelegramError extends Error {
    constructor(response, on = {}) {
      super(`${response.error_code}: ${response.description}`);
      this.response = response;
      this.on = on;
    }
    get code() {
      return this.response.error_code;
    }
    get description() {
      return this.response.description;
    }
    get parameters() {
      return this.response.parameters;
    }
  }
  exports.TelegramError = TelegramError;
  exports.default = TelegramError;
});

// node_modules/telegraf/lib/core/network/polling.js
var require_polling = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Polling = undefined;
  var abort_controller_1 = __importDefault(__require("abort-controller"));
  var debug_1 = __importDefault(require_src());
  var util_1 = __require("util");
  var error_1 = require_error();
  var debug = (0, debug_1.default)("telegraf:polling");
  var wait = (0, util_1.promisify)(setTimeout);
  function always(x) {
    return () => x;
  }
  var noop = always(Promise.resolve());

  class Polling {
    constructor(telegram, allowedUpdates) {
      this.telegram = telegram;
      this.allowedUpdates = allowedUpdates;
      this.abortController = new abort_controller_1.default;
      this.skipOffsetSync = false;
      this.offset = 0;
    }
    async* [Symbol.asyncIterator]() {
      var _a2, _b;
      debug("Starting long polling");
      do {
        try {
          const updates = await this.telegram.callApi("getUpdates", {
            timeout: 50,
            offset: this.offset,
            allowed_updates: this.allowedUpdates
          }, this.abortController);
          const last = updates[updates.length - 1];
          if (last !== undefined) {
            this.offset = last.update_id + 1;
          }
          yield updates;
        } catch (error46) {
          const err = error46;
          if (err.name === "AbortError")
            return;
          if (err.name === "FetchError" || err instanceof error_1.TelegramError && err.code === 429 || err instanceof error_1.TelegramError && err.code >= 500) {
            const retryAfter = (_b = (_a2 = err.parameters) === null || _a2 === undefined ? undefined : _a2.retry_after) !== null && _b !== undefined ? _b : 5;
            debug("Failed to fetch updates, retrying after %ds.", retryAfter, err);
            await wait(retryAfter * 1000);
            continue;
          }
          if (err instanceof error_1.TelegramError && (err.code === 401 || err.code === 409)) {
            this.skipOffsetSync = true;
            throw err;
          }
          throw err;
        }
      } while (!this.abortController.signal.aborted);
    }
    async syncUpdateOffset() {
      if (this.skipOffsetSync)
        return;
      debug("Syncing update offset...");
      await this.telegram.callApi("getUpdates", { offset: this.offset, limit: 1 });
    }
    async loop(handleUpdate) {
      if (this.abortController.signal.aborted)
        throw new Error("Polling instances must not be reused!");
      try {
        for await (const updates of this)
          await Promise.all(updates.map(handleUpdate));
      } finally {
        debug("Long polling stopped");
        this.stop();
        await this.syncUpdateOffset().catch(noop);
      }
    }
    stop() {
      this.abortController.abort();
    }
  }
  exports.Polling = Polling;
});

// node_modules/p-timeout/index.js
var require_p_timeout2 = __commonJS((exports, module) => {
  class TimeoutError extends Error {
    constructor(message) {
      super(message);
      this.name = "TimeoutError";
    }
  }
  var pTimeout = (promise, milliseconds, fallback, options) => {
    let timer;
    const cancelablePromise = new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || milliseconds < 0) {
        throw new TypeError("Expected `milliseconds` to be a positive number");
      }
      if (milliseconds === Infinity) {
        resolve(promise);
        return;
      }
      options = {
        customTimers: { setTimeout, clearTimeout },
        ...options
      };
      timer = options.customTimers.setTimeout.call(undefined, () => {
        if (typeof fallback === "function") {
          try {
            resolve(fallback());
          } catch (error46) {
            reject(error46);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      (async () => {
        try {
          resolve(await promise);
        } catch (error46) {
          reject(error46);
        } finally {
          options.customTimers.clearTimeout.call(undefined, timer);
        }
      })();
    });
    cancelablePromise.clear = () => {
      clearTimeout(timer);
      timer = undefined;
    };
    return cancelablePromise;
  };
  module.exports = pTimeout;
  module.exports.default = pTimeout;
  module.exports.TimeoutError = TimeoutError;
});

// node_modules/telegraf/lib/core/helpers/check.js
var require_check = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.is2D = exports.hasPropType = exports.hasProp = undefined;
  function hasProp(obj, prop) {
    return obj !== undefined && prop in obj;
  }
  exports.hasProp = hasProp;
  function hasPropType(obj, prop, type) {
    return hasProp(obj, prop) && type === typeof obj[prop];
  }
  exports.hasPropType = hasPropType;
  function is2D(arr2) {
    return Array.isArray(arr2[0]);
  }
  exports.is2D = is2D;
});

// node_modules/sandwich-stream/dist/sandwich-stream.js
var require_sandwich_stream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var stream = __require("stream");
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  function __rest(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
      for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++)
        if (e.indexOf(p[i]) < 0)
          t[p[i]] = s[p[i]];
    }
    return t;
  }

  class SandwichStream extends stream.Readable {
    constructor(_a2) {
      var { head, tail, separator } = _a2, remaining = __rest(_a2, ["head", "tail", "separator"]);
      super(remaining);
      this.streamsActive = false;
      this.streams = [];
      this.newStreams = [];
      this.currentStream = null;
      this.head = head !== null && head !== undefined ? head : null;
      this.tail = tail !== null && tail !== undefined ? tail : null;
      this.separator = separator !== null && separator !== undefined ? separator : null;
    }
    add(newStream) {
      if (this.streamsActive === false) {
        this.streams.push(newStream);
        newStream.on("error", this.subStreamOnError.bind(this));
      } else {
        this.newStreams.push(newStream);
      }
      return this;
    }
    _read() {
      if (this.streamsActive === false) {
        this.streamsActive = true;
        this.pushHead();
        this.streamNextStream();
      }
    }
    subStreamOnError(err) {
      this.emit("error", err);
    }
    streamNextStream() {
      if (this.nextStream() === true) {
        this.bindCurrentStreamEvents();
      } else {
        this.pushTail();
        this.push(null);
      }
    }
    nextStream() {
      const tmp = this.streams.shift();
      this.currentStream = tmp !== undefined ? tmp : null;
      return this.currentStream !== null;
    }
    bindCurrentStreamEvents() {
      this.currentStream.on("readable", this.currentStreamOnReadable.bind(this));
      this.currentStream.on("end", this.currentStreamOnEnd.bind(this));
    }
    currentStreamOnReadable() {
      const tmp = this.currentStream.read();
      const data = tmp !== undefined && tmp !== null ? tmp : "";
      this.push(data);
    }
    currentStreamOnEnd() {
      this.pushSeparator();
      this.streams.concat(this.newStreams);
      this.newStreams = [];
      this.streamNextStream();
    }
    pushHead() {
      if (this.head !== null) {
        this.push(this.head);
      }
    }
    pushSeparator() {
      if (0 < this.streams.length && this.separator !== null) {
        this.push(this.separator);
      }
    }
    pushTail() {
      if (this.tail !== null) {
        this.push(this.tail);
      }
    }
  }
  exports.SandwichStream = SandwichStream;
  exports.default = SandwichStream;
});

// node_modules/telegraf/lib/core/network/multipart-stream.js
var require_multipart_stream = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var stream = __importStar(__require("stream"));
  var check_1 = require_check();
  var sandwich_stream_1 = __importDefault(require_sandwich_stream());
  var CRNL = `\r
`;

  class MultipartStream extends sandwich_stream_1.default {
    constructor(boundary) {
      super({
        head: `--${boundary}${CRNL}`,
        tail: `${CRNL}--${boundary}--`,
        separator: `${CRNL}--${boundary}${CRNL}`
      });
    }
    addPart(part) {
      const partStream = new stream.PassThrough;
      for (const [key, header] of Object.entries(part.headers)) {
        partStream.write(`${key}:${header}${CRNL}`);
      }
      partStream.write(CRNL);
      if (MultipartStream.isStream(part.body)) {
        part.body.pipe(partStream);
      } else {
        partStream.end(part.body);
      }
      this.add(partStream);
    }
    static isStream(stream2) {
      return typeof stream2 === "object" && stream2 !== null && (0, check_1.hasPropType)(stream2, "pipe", "function");
    }
  }
  exports.default = MultipartStream;
});

// node_modules/telegraf/lib/core/network/client.js
var require_client = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto2 = __importStar(__require("crypto"));
  var fs = __importStar(__require("fs"));
  var promises_1 = __require("fs/promises");
  var https = __importStar(__require("https"));
  var path = __importStar(__require("path"));
  var node_fetch_1 = __importDefault(__require("node-fetch"));
  var check_1 = require_check();
  var compact_1 = require_compact();
  var multipart_stream_1 = __importDefault(require_multipart_stream());
  var error_1 = __importDefault(require_error());
  var url_1 = __require("url");
  var debug = require_src()("telegraf:client");
  var { isStream } = multipart_stream_1.default;
  var WEBHOOK_REPLY_METHOD_ALLOWLIST = new Set([
    "answerCallbackQuery",
    "answerInlineQuery",
    "deleteMessage",
    "leaveChat",
    "sendChatAction"
  ]);
  var DEFAULT_EXTENSIONS = {
    audio: "mp3",
    photo: "jpg",
    sticker: "webp",
    video: "mp4",
    animation: "mp4",
    video_note: "mp4",
    voice: "ogg"
  };
  var DEFAULT_OPTIONS = {
    apiRoot: "https://api.telegram.org",
    apiMode: "bot",
    webhookReply: true,
    agent: new https.Agent({
      keepAlive: true,
      keepAliveMsecs: 1e4
    }),
    attachmentAgent: undefined,
    testEnv: false
  };
  function includesMedia(payload) {
    return Object.entries(payload).some(([key, value]) => {
      if (key === "link_preview_options")
        return false;
      if (Array.isArray(value)) {
        return value.some(({ media }) => media && typeof media === "object" && (media.source || media.url));
      }
      return value && typeof value === "object" && ((0, check_1.hasProp)(value, "source") && value.source || (0, check_1.hasProp)(value, "url") && value.url || (0, check_1.hasPropType)(value, "media", "object") && ((0, check_1.hasProp)(value.media, "source") && value.media.source || (0, check_1.hasProp)(value.media, "url") && value.media.url));
    });
  }
  function replacer(_, value) {
    if (value == null)
      return;
    return value;
  }
  function buildJSONConfig(payload) {
    return Promise.resolve({
      method: "POST",
      compress: true,
      headers: { "content-type": "application/json", connection: "keep-alive" },
      body: JSON.stringify(payload, replacer)
    });
  }
  var FORM_DATA_JSON_FIELDS = [
    "results",
    "reply_markup",
    "mask_position",
    "shipping_options",
    "errors"
  ];
  async function buildFormDataConfig(payload, agent) {
    for (const field of FORM_DATA_JSON_FIELDS) {
      if ((0, check_1.hasProp)(payload, field) && typeof payload[field] !== "string") {
        payload[field] = JSON.stringify(payload[field]);
      }
    }
    const boundary = crypto2.randomBytes(32).toString("hex");
    const formData = new multipart_stream_1.default(boundary);
    await Promise.all(Object.keys(payload).map((key) => attachFormValue(formData, key, payload[key], agent)));
    return {
      method: "POST",
      compress: true,
      headers: {
        "content-type": `multipart/form-data; boundary=${boundary}`,
        connection: "keep-alive"
      },
      body: formData
    };
  }
  async function attachFormValue(form, id, value, agent) {
    if (value == null) {
      return;
    }
    if (typeof value === "string" || typeof value === "boolean" || typeof value === "number") {
      form.addPart({
        headers: { "content-disposition": `form-data; name="${id}"` },
        body: `${value}`
      });
      return;
    }
    if (id === "thumb" || id === "thumbnail") {
      const attachmentId = crypto2.randomBytes(16).toString("hex");
      await attachFormMedia(form, value, attachmentId, agent);
      return form.addPart({
        headers: { "content-disposition": `form-data; name="${id}"` },
        body: `attach://${attachmentId}`
      });
    }
    if (Array.isArray(value)) {
      const items = await Promise.all(value.map(async (item) => {
        var _a2;
        if (typeof item.media !== "object") {
          return await Promise.resolve(item);
        }
        const attachmentId = crypto2.randomBytes(16).toString("hex");
        await attachFormMedia(form, item.media, attachmentId, agent);
        const thumb = (_a2 = item.thumb) !== null && _a2 !== undefined ? _a2 : item.thumbnail;
        if (typeof thumb === "object") {
          const thumbAttachmentId = crypto2.randomBytes(16).toString("hex");
          await attachFormMedia(form, thumb, thumbAttachmentId, agent);
          return {
            ...item,
            media: `attach://${attachmentId}`,
            thumbnail: `attach://${thumbAttachmentId}`
          };
        }
        return { ...item, media: `attach://${attachmentId}` };
      }));
      return form.addPart({
        headers: { "content-disposition": `form-data; name="${id}"` },
        body: JSON.stringify(items)
      });
    }
    if (value && typeof value === "object" && (0, check_1.hasProp)(value, "media") && (0, check_1.hasProp)(value, "type") && typeof value.media !== "undefined" && typeof value.type !== "undefined") {
      const attachmentId = crypto2.randomBytes(16).toString("hex");
      await attachFormMedia(form, value.media, attachmentId, agent);
      return form.addPart({
        headers: { "content-disposition": `form-data; name="${id}"` },
        body: JSON.stringify({
          ...value,
          media: `attach://${attachmentId}`
        })
      });
    }
    return await attachFormMedia(form, value, id, agent);
  }
  async function attachFormMedia(form, media, id, agent) {
    var _a2, _b, _c;
    let fileName = (_a2 = media.filename) !== null && _a2 !== undefined ? _a2 : `${id}.${(_b = DEFAULT_EXTENSIONS[id]) !== null && _b !== undefined ? _b : "dat"}`;
    if ("url" in media && media.url !== undefined) {
      const timeout = 500000;
      const res = await (0, node_fetch_1.default)(media.url, { agent, timeout });
      return form.addPart({
        headers: {
          "content-disposition": `form-data; name="${id}"; filename="${fileName}"`
        },
        body: res.body
      });
    }
    if ("source" in media && media.source) {
      let mediaSource = media.source;
      if (typeof media.source === "string") {
        const source = await (0, promises_1.realpath)(media.source);
        if ((await (0, promises_1.stat)(source)).isFile()) {
          fileName = (_c = media.filename) !== null && _c !== undefined ? _c : path.basename(media.source);
          mediaSource = await fs.createReadStream(media.source);
        } else {
          throw new TypeError(`Unable to upload '${media.source}', not a file`);
        }
      }
      if (isStream(mediaSource) || Buffer.isBuffer(mediaSource)) {
        form.addPart({
          headers: {
            "content-disposition": `form-data; name="${id}"; filename="${fileName}"`
          },
          body: mediaSource
        });
      }
    }
  }
  async function answerToWebhook(response, payload, options) {
    if (!includesMedia(payload)) {
      if (!response.headersSent) {
        response.setHeader("content-type", "application/json");
      }
      response.end(JSON.stringify(payload), "utf-8");
      return true;
    }
    const { headers, body } = await buildFormDataConfig(payload, options.attachmentAgent);
    if (!response.headersSent) {
      for (const [key, value] of Object.entries(headers)) {
        response.setHeader(key, value);
      }
    }
    await new Promise((resolve) => {
      response.on("finish", resolve);
      body.pipe(response);
    });
    return true;
  }
  function redactToken(error46) {
    error46.message = error46.message.replace(/\/(bot|user)(\d+):[^/]+\//, "/$1$2:[REDACTED]/");
    throw error46;
  }

  class ApiClient {
    constructor(token, options, response) {
      this.token = token;
      this.response = response;
      this.options = {
        ...DEFAULT_OPTIONS,
        ...(0, compact_1.compactOptions)(options)
      };
      if (this.options.apiRoot.startsWith("http://")) {
        this.options.agent = undefined;
      }
    }
    set webhookReply(enable) {
      this.options.webhookReply = enable;
    }
    get webhookReply() {
      return this.options.webhookReply;
    }
    async callApi(method, payload, { signal } = {}) {
      const { token, options, response } = this;
      if (options.webhookReply && (response === null || response === undefined ? undefined : response.writableEnded) === false && WEBHOOK_REPLY_METHOD_ALLOWLIST.has(method)) {
        debug("Call via webhook", method, payload);
        return await answerToWebhook(response, { method, ...payload }, options);
      }
      if (!token) {
        throw new error_1.default({
          error_code: 401,
          description: "Bot Token is required"
        });
      }
      debug("HTTP call", method, payload);
      const config2 = includesMedia(payload) ? await buildFormDataConfig({ method, ...payload }, options.attachmentAgent) : await buildJSONConfig(payload);
      const apiUrl = new url_1.URL(`./${options.apiMode}${token}${options.testEnv ? "/test" : ""}/${method}`, options.apiRoot);
      config2.agent = options.agent;
      config2.signal = signal;
      config2.timeout = 500000;
      const res = await (0, node_fetch_1.default)(apiUrl, config2).catch(redactToken);
      if (res.status >= 500) {
        const errorPayload = {
          error_code: res.status,
          description: res.statusText
        };
        throw new error_1.default(errorPayload, { method, payload });
      }
      const data = await res.json();
      if (!data.ok) {
        debug("API call failed", data);
        throw new error_1.default(data, { method, payload });
      }
      return data.result;
    }
  }
  exports.default = ApiClient;
});

// node_modules/telegraf/lib/core/helpers/formatting.js
var require_formatting = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.linkOrMention = exports.createFmt = exports.join = exports.FmtString = undefined;
  var util_1 = require_util();

  class FmtString {
    constructor(text, entities) {
      this.text = text;
      if (entities) {
        this.entities = entities;
        this.parse_mode = undefined;
      }
    }
    static normalise(content) {
      if (content instanceof FmtString)
        return content;
      return new FmtString(String(content));
    }
  }
  exports.FmtString = FmtString;
  var isArray = Array.isArray;
  var _add = (base, next) => {
    var _a2;
    const len = base.text.length;
    if (next instanceof FmtString) {
      base.text = `${base.text}${next.text}`;
      for (let i = 0;i < (((_a2 = next.entities) === null || _a2 === undefined ? undefined : _a2.length) || 0); i++) {
        const entity = next.entities[i];
        base.entities.push({ ...entity, offset: entity.offset + len });
      }
    } else
      base.text = `${base.text}${next}`;
  };
  var join = (fragments, separator) => {
    const result = new FmtString("");
    result.entities = [];
    const iter = fragments[Symbol.iterator]();
    let curr = iter.next();
    while (!curr.done) {
      _add(result, curr.value);
      curr = iter.next();
      if (separator && !curr.done)
        _add(result, separator);
    }
    if (result.entities.length)
      result.parse_mode = undefined;
    else
      delete result.entities;
    return result;
  };
  exports.join = join;
  function createFmt(kind, opts) {
    return function fmt(parts, ...items) {
      var _a2;
      parts = isArray(parts) ? parts : [parts];
      const result = (0, exports.join)((0, util_1.zip)(parts, items));
      if (kind) {
        (_a2 = result.entities) !== null && _a2 !== undefined || (result.entities = []);
        result.entities.unshift({
          type: kind,
          offset: 0,
          length: result.text.length,
          ...opts
        });
        result.parse_mode = undefined;
      }
      return result;
    };
  }
  exports.createFmt = createFmt;
  var linkOrMention = (content, data) => {
    const { text, entities = [] } = FmtString.normalise(content);
    entities.unshift(Object.assign(data, { offset: 0, length: text.length }));
    return new FmtString(text, entities);
  };
  exports.linkOrMention = linkOrMention;
});

// node_modules/telegraf/lib/format.js
var require_format = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mention = exports.link = exports.pre = exports.code = exports.quote = exports.underline = exports.strikethrough = exports.spoiler = exports.italic = exports.bold = exports.fmt = exports.join = exports.FmtString = undefined;
  var formatting_1 = require_formatting();
  Object.defineProperty(exports, "FmtString", { enumerable: true, get: function() {
    return formatting_1.FmtString;
  } });
  exports.join = formatting_1.join;
  exports.fmt = (0, formatting_1.createFmt)();
  exports.bold = (0, formatting_1.createFmt)("bold");
  exports.italic = (0, formatting_1.createFmt)("italic");
  exports.spoiler = (0, formatting_1.createFmt)("spoiler");
  exports.strikethrough = (0, formatting_1.createFmt)("strikethrough");
  exports.underline = (0, formatting_1.createFmt)("underline");
  exports.quote = (0, formatting_1.createFmt)("blockquote");
  exports.code = (0, formatting_1.createFmt)("code");
  var pre = (language) => (0, formatting_1.createFmt)("pre", { language });
  exports.pre = pre;
  var link = (content, url) => (0, formatting_1.linkOrMention)(content, { type: "text_link", url });
  exports.link = link;
  var mention = (name, user) => typeof user === "number" ? (0, exports.link)(name, "tg://user?id=" + user) : (0, formatting_1.linkOrMention)(name, {
    type: "text_mention",
    user
  });
  exports.mention = mention;
});

// node_modules/telegraf/lib/telegram.js
var require_telegram = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Telegram = undefined;
  var client_1 = __importDefault(require_client());
  var path_1 = __require("path");
  var url_1 = __require("url");
  var format_1 = require_format();
  var util_1 = require_util();

  class Telegram extends client_1.default {
    getMe() {
      return this.callApi("getMe", {});
    }
    getFile(fileId) {
      return this.callApi("getFile", { file_id: fileId });
    }
    async getFileLink(fileId) {
      if (typeof fileId === "string") {
        fileId = await this.getFile(fileId);
      } else if (fileId.file_path === undefined) {
        fileId = await this.getFile(fileId.file_id);
      }
      if (fileId.file_path !== undefined && (0, path_1.isAbsolute)(fileId.file_path)) {
        const url = new url_1.URL(this.options.apiRoot);
        url.port = "";
        url.pathname = fileId.file_path;
        url.protocol = "file:";
        return url;
      }
      return new url_1.URL(`./file/${this.options.apiMode}${this.token}${this.options.testEnv ? "/test" : ""}/${fileId.file_path}`, this.options.apiRoot);
    }
    getUpdates(timeout, limit, offset, allowedUpdates) {
      return this.callApi("getUpdates", {
        allowed_updates: allowedUpdates,
        limit,
        offset,
        timeout
      });
    }
    getWebhookInfo() {
      return this.callApi("getWebhookInfo", {});
    }
    getGameHighScores(userId, inlineMessageId, chatId, messageId) {
      return this.callApi("getGameHighScores", {
        user_id: userId,
        inline_message_id: inlineMessageId,
        chat_id: chatId,
        message_id: messageId
      });
    }
    setGameScore(userId, score, inlineMessageId, chatId, messageId, editMessage = true, force = false) {
      return this.callApi("setGameScore", {
        force,
        score,
        user_id: userId,
        inline_message_id: inlineMessageId,
        chat_id: chatId,
        message_id: messageId,
        disable_edit_message: !editMessage
      });
    }
    setWebhook(url, extra) {
      return this.callApi("setWebhook", {
        url,
        ...extra
      });
    }
    deleteWebhook(extra) {
      return this.callApi("deleteWebhook", {
        ...extra
      });
    }
    sendMessage(chatId, text, extra) {
      const t = format_1.FmtString.normalise(text);
      return this.callApi("sendMessage", { chat_id: chatId, ...extra, ...t });
    }
    forwardMessage(chatId, fromChatId, messageId, extra) {
      return this.callApi("forwardMessage", {
        chat_id: chatId,
        from_chat_id: fromChatId,
        message_id: messageId,
        ...extra
      });
    }
    forwardMessages(chatId, fromChatId, messageIds, extra) {
      return this.callApi("forwardMessages", {
        chat_id: chatId,
        from_chat_id: fromChatId,
        message_ids: messageIds,
        ...extra
      });
    }
    sendChatAction(chat_id, action, extra) {
      return this.callApi("sendChatAction", { chat_id, action, ...extra });
    }
    setMessageReaction(chat_id, message_id, reaction, is_big) {
      return this.callApi("setMessageReaction", {
        chat_id,
        message_id,
        reaction,
        is_big
      });
    }
    getUserProfilePhotos(userId, offset, limit) {
      return this.callApi("getUserProfilePhotos", {
        user_id: userId,
        offset,
        limit
      });
    }
    sendLocation(chatId, latitude, longitude, extra) {
      return this.callApi("sendLocation", {
        chat_id: chatId,
        latitude,
        longitude,
        ...extra
      });
    }
    sendVenue(chatId, latitude, longitude, title, address, extra) {
      return this.callApi("sendVenue", {
        latitude,
        longitude,
        title,
        address,
        chat_id: chatId,
        ...extra
      });
    }
    sendInvoice(chatId, invoice, extra) {
      return this.callApi("sendInvoice", {
        chat_id: chatId,
        ...invoice,
        ...extra
      });
    }
    sendContact(chatId, phoneNumber, firstName, extra) {
      return this.callApi("sendContact", {
        chat_id: chatId,
        phone_number: phoneNumber,
        first_name: firstName,
        ...extra
      });
    }
    sendPhoto(chatId, photo, extra) {
      return this.callApi("sendPhoto", {
        chat_id: chatId,
        photo,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendDice(chatId, extra) {
      return this.callApi("sendDice", { chat_id: chatId, ...extra });
    }
    sendDocument(chatId, document2, extra) {
      return this.callApi("sendDocument", {
        chat_id: chatId,
        document: document2,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendAudio(chatId, audio, extra) {
      return this.callApi("sendAudio", {
        chat_id: chatId,
        audio,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendSticker(chatId, sticker, extra) {
      return this.callApi("sendSticker", { chat_id: chatId, sticker, ...extra });
    }
    sendVideo(chatId, video, extra) {
      return this.callApi("sendVideo", {
        chat_id: chatId,
        video,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendAnimation(chatId, animation, extra) {
      return this.callApi("sendAnimation", {
        chat_id: chatId,
        animation,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendVideoNote(chatId, videoNote, extra) {
      return this.callApi("sendVideoNote", {
        chat_id: chatId,
        video_note: videoNote,
        ...extra
      });
    }
    sendVoice(chatId, voice, extra) {
      return this.callApi("sendVoice", {
        chat_id: chatId,
        voice,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendGame(chatId, gameName, extra) {
      return this.callApi("sendGame", {
        chat_id: chatId,
        game_short_name: gameName,
        ...extra
      });
    }
    sendMediaGroup(chatId, media, extra) {
      return this.callApi("sendMediaGroup", { chat_id: chatId, media, ...extra });
    }
    sendPoll(chatId, question, options, extra) {
      return this.callApi("sendPoll", {
        chat_id: chatId,
        type: "regular",
        question,
        options,
        ...extra
      });
    }
    sendQuiz(chatId, question, options, extra) {
      return this.callApi("sendPoll", {
        chat_id: chatId,
        type: "quiz",
        question,
        options,
        ...extra
      });
    }
    stopPoll(chatId, messageId, extra) {
      return this.callApi("stopPoll", {
        chat_id: chatId,
        message_id: messageId,
        ...extra
      });
    }
    getChat(chatId) {
      return this.callApi("getChat", { chat_id: chatId });
    }
    getChatAdministrators(chatId) {
      return this.callApi("getChatAdministrators", { chat_id: chatId });
    }
    getChatMember(chatId, userId) {
      return this.callApi("getChatMember", { chat_id: chatId, user_id: userId });
    }
    getChatMembersCount(chatId) {
      return this.callApi("getChatMembersCount", { chat_id: chatId });
    }
    answerInlineQuery(inlineQueryId, results, extra) {
      return this.callApi("answerInlineQuery", {
        inline_query_id: inlineQueryId,
        results,
        ...extra
      });
    }
    setChatPermissions(chatId, permissions, extra) {
      return this.callApi("setChatPermissions", {
        chat_id: chatId,
        permissions,
        ...extra
      });
    }
    banChatMember(chatId, userId, untilDate, extra) {
      return this.callApi("banChatMember", {
        chat_id: chatId,
        user_id: userId,
        until_date: untilDate,
        ...extra
      });
    }
    get kickChatMember() {
      return this.banChatMember;
    }
    promoteChatMember(chatId, userId, extra) {
      return this.callApi("promoteChatMember", {
        chat_id: chatId,
        user_id: userId,
        ...extra
      });
    }
    restrictChatMember(chatId, userId, extra) {
      return this.callApi("restrictChatMember", {
        chat_id: chatId,
        user_id: userId,
        ...extra
      });
    }
    setChatAdministratorCustomTitle(chatId, userId, title) {
      return this.callApi("setChatAdministratorCustomTitle", {
        chat_id: chatId,
        user_id: userId,
        custom_title: title
      });
    }
    exportChatInviteLink(chatId) {
      return this.callApi("exportChatInviteLink", { chat_id: chatId });
    }
    createChatInviteLink(chatId, extra) {
      return this.callApi("createChatInviteLink", {
        chat_id: chatId,
        ...extra
      });
    }
    createInvoiceLink(invoice) {
      return this.callApi("createInvoiceLink", {
        ...invoice
      });
    }
    editChatInviteLink(chatId, inviteLink, extra) {
      return this.callApi("editChatInviteLink", {
        chat_id: chatId,
        invite_link: inviteLink,
        ...extra
      });
    }
    revokeChatInviteLink(chatId, inviteLink) {
      return this.callApi("revokeChatInviteLink", {
        chat_id: chatId,
        invite_link: inviteLink
      });
    }
    setChatPhoto(chatId, photo) {
      return this.callApi("setChatPhoto", { chat_id: chatId, photo });
    }
    deleteChatPhoto(chatId) {
      return this.callApi("deleteChatPhoto", { chat_id: chatId });
    }
    setChatTitle(chatId, title) {
      return this.callApi("setChatTitle", { chat_id: chatId, title });
    }
    setChatDescription(chatId, description) {
      return this.callApi("setChatDescription", { chat_id: chatId, description });
    }
    pinChatMessage(chatId, messageId, extra) {
      return this.callApi("pinChatMessage", {
        chat_id: chatId,
        message_id: messageId,
        ...extra
      });
    }
    unpinChatMessage(chatId, messageId) {
      return this.callApi("unpinChatMessage", {
        chat_id: chatId,
        message_id: messageId
      });
    }
    unpinAllChatMessages(chatId) {
      return this.callApi("unpinAllChatMessages", { chat_id: chatId });
    }
    leaveChat(chatId) {
      return this.callApi("leaveChat", { chat_id: chatId });
    }
    unbanChatMember(chatId, userId, extra) {
      return this.callApi("unbanChatMember", {
        chat_id: chatId,
        user_id: userId,
        ...extra
      });
    }
    answerCbQuery(callbackQueryId, text, extra) {
      return this.callApi("answerCallbackQuery", {
        text,
        callback_query_id: callbackQueryId,
        ...extra
      });
    }
    answerGameQuery(callbackQueryId, url) {
      return this.callApi("answerCallbackQuery", {
        url,
        callback_query_id: callbackQueryId
      });
    }
    getUserChatBoosts(chat_id, user_id) {
      return this.callApi("getUserChatBoosts", {
        chat_id,
        user_id
      });
    }
    answerShippingQuery(shippingQueryId, ok, shippingOptions, errorMessage) {
      return this.callApi("answerShippingQuery", {
        ok,
        shipping_query_id: shippingQueryId,
        shipping_options: shippingOptions,
        error_message: errorMessage
      });
    }
    answerPreCheckoutQuery(preCheckoutQueryId, ok, errorMessage) {
      return this.callApi("answerPreCheckoutQuery", {
        ok,
        pre_checkout_query_id: preCheckoutQueryId,
        error_message: errorMessage
      });
    }
    answerWebAppQuery(webAppQueryId, result) {
      return this.callApi("answerWebAppQuery", {
        web_app_query_id: webAppQueryId,
        result
      });
    }
    editMessageText(chatId, messageId, inlineMessageId, text, extra) {
      const t = format_1.FmtString.normalise(text);
      return this.callApi("editMessageText", {
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        ...extra,
        ...t
      });
    }
    editMessageCaption(chatId, messageId, inlineMessageId, caption, extra) {
      return this.callApi("editMessageCaption", {
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        ...extra,
        ...(0, util_1.fmtCaption)({ caption })
      });
    }
    editMessageMedia(chatId, messageId, inlineMessageId, media, extra) {
      return this.callApi("editMessageMedia", {
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        media: (0, util_1.fmtCaption)(media),
        ...extra
      });
    }
    editMessageReplyMarkup(chatId, messageId, inlineMessageId, markup) {
      return this.callApi("editMessageReplyMarkup", {
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        reply_markup: markup
      });
    }
    editMessageLiveLocation(chatId, messageId, inlineMessageId, latitude, longitude, extra) {
      return this.callApi("editMessageLiveLocation", {
        latitude,
        longitude,
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        ...extra
      });
    }
    stopMessageLiveLocation(chatId, messageId, inlineMessageId, markup) {
      return this.callApi("stopMessageLiveLocation", {
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        reply_markup: markup
      });
    }
    deleteMessage(chatId, messageId) {
      return this.callApi("deleteMessage", {
        chat_id: chatId,
        message_id: messageId
      });
    }
    deleteMessages(chatId, messageIds) {
      return this.callApi("deleteMessages", {
        chat_id: chatId,
        message_ids: messageIds
      });
    }
    setChatStickerSet(chatId, setName) {
      return this.callApi("setChatStickerSet", {
        chat_id: chatId,
        sticker_set_name: setName
      });
    }
    deleteChatStickerSet(chatId) {
      return this.callApi("deleteChatStickerSet", { chat_id: chatId });
    }
    getForumTopicIconStickers() {
      return this.callApi("getForumTopicIconStickers", {});
    }
    createForumTopic(chat_id, name, extra) {
      return this.callApi("createForumTopic", {
        chat_id,
        name,
        ...extra
      });
    }
    editForumTopic(chat_id, message_thread_id, extra) {
      return this.callApi("editForumTopic", {
        chat_id,
        message_thread_id,
        ...extra
      });
    }
    closeForumTopic(chat_id, message_thread_id) {
      return this.callApi("closeForumTopic", {
        chat_id,
        message_thread_id
      });
    }
    reopenForumTopic(chat_id, message_thread_id) {
      return this.callApi("reopenForumTopic", {
        chat_id,
        message_thread_id
      });
    }
    deleteForumTopic(chat_id, message_thread_id) {
      return this.callApi("deleteForumTopic", {
        chat_id,
        message_thread_id
      });
    }
    unpinAllForumTopicMessages(chat_id, message_thread_id) {
      return this.callApi("unpinAllForumTopicMessages", {
        chat_id,
        message_thread_id
      });
    }
    editGeneralForumTopic(chat_id, name) {
      return this.callApi("editGeneralForumTopic", { chat_id, name });
    }
    closeGeneralForumTopic(chat_id) {
      return this.callApi("closeGeneralForumTopic", { chat_id });
    }
    reopenGeneralForumTopic(chat_id) {
      return this.callApi("reopenGeneralForumTopic", { chat_id });
    }
    hideGeneralForumTopic(chat_id) {
      return this.callApi("hideGeneralForumTopic", { chat_id });
    }
    unhideGeneralForumTopic(chat_id) {
      return this.callApi("unhideGeneralForumTopic", { chat_id });
    }
    unpinAllGeneralForumTopicMessages(chat_id) {
      return this.callApi("unpinAllGeneralForumTopicMessages", { chat_id });
    }
    getStickerSet(name) {
      return this.callApi("getStickerSet", { name });
    }
    uploadStickerFile(ownerId, sticker, sticker_format) {
      return this.callApi("uploadStickerFile", {
        user_id: ownerId,
        sticker_format,
        sticker
      });
    }
    createNewStickerSet(ownerId, name, title, stickerData) {
      return this.callApi("createNewStickerSet", {
        name,
        title,
        user_id: ownerId,
        ...stickerData
      });
    }
    addStickerToSet(ownerId, name, stickerData) {
      return this.callApi("addStickerToSet", {
        name,
        user_id: ownerId,
        ...stickerData
      });
    }
    setStickerPositionInSet(sticker, position) {
      return this.callApi("setStickerPositionInSet", {
        sticker,
        position
      });
    }
    get setStickerSetThumb() {
      return this.setStickerSetThumbnail;
    }
    setStickerSetThumbnail(name, userId, thumbnail) {
      return this.callApi("setStickerSetThumbnail", {
        name,
        user_id: userId,
        thumbnail
      });
    }
    setStickerMaskPosition(sticker, mask_position) {
      return this.callApi("setStickerMaskPosition", { sticker, mask_position });
    }
    setStickerKeywords(sticker, keywords) {
      return this.callApi("setStickerKeywords", { sticker, keywords });
    }
    setStickerEmojiList(sticker, emoji_list) {
      return this.callApi("setStickerEmojiList", { sticker, emoji_list });
    }
    deleteStickerSet(name) {
      return this.callApi("deleteStickerSet", { name });
    }
    setStickerSetTitle(name, title) {
      return this.callApi("setStickerSetTitle", { name, title });
    }
    setCustomEmojiStickerSetThumbnail(name, custom_emoji_id) {
      return this.callApi("setCustomEmojiStickerSetThumbnail", {
        name,
        custom_emoji_id
      });
    }
    deleteStickerFromSet(sticker) {
      return this.callApi("deleteStickerFromSet", { sticker });
    }
    getCustomEmojiStickers(custom_emoji_ids) {
      return this.callApi("getCustomEmojiStickers", { custom_emoji_ids });
    }
    setMyCommands(commands, extra) {
      return this.callApi("setMyCommands", { commands, ...extra });
    }
    deleteMyCommands(extra = {}) {
      return this.callApi("deleteMyCommands", extra);
    }
    getMyCommands(extra = {}) {
      return this.callApi("getMyCommands", extra);
    }
    setMyDescription(description, language_code) {
      return this.callApi("setMyDescription", { description, language_code });
    }
    setMyName(name, language_code) {
      return this.callApi("setMyName", { name, language_code });
    }
    getMyName(language_code) {
      return this.callApi("getMyName", { language_code });
    }
    getMyDescription(language_code) {
      return this.callApi("getMyDescription", { language_code });
    }
    setMyShortDescription(short_description, language_code) {
      return this.callApi("setMyShortDescription", {
        short_description,
        language_code
      });
    }
    getMyShortDescription(language_code) {
      return this.callApi("getMyShortDescription", { language_code });
    }
    setPassportDataErrors(userId, errors3) {
      return this.callApi("setPassportDataErrors", {
        user_id: userId,
        errors: errors3
      });
    }
    sendCopy(chatId, message, extra) {
      return this.copyMessage(chatId, message.chat.id, message.message_id, extra);
    }
    copyMessage(chatId, fromChatId, messageId, extra) {
      return this.callApi("copyMessage", {
        chat_id: chatId,
        from_chat_id: fromChatId,
        message_id: messageId,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    copyMessages(chatId, fromChatId, messageIds, extra) {
      return this.callApi("copyMessages", {
        chat_id: chatId,
        from_chat_id: fromChatId,
        message_ids: messageIds,
        ...extra
      });
    }
    approveChatJoinRequest(chatId, userId) {
      return this.callApi("approveChatJoinRequest", {
        chat_id: chatId,
        user_id: userId
      });
    }
    declineChatJoinRequest(chatId, userId) {
      return this.callApi("declineChatJoinRequest", {
        chat_id: chatId,
        user_id: userId
      });
    }
    banChatSenderChat(chatId, senderChatId, extra) {
      return this.callApi("banChatSenderChat", {
        chat_id: chatId,
        sender_chat_id: senderChatId,
        ...extra
      });
    }
    unbanChatSenderChat(chatId, senderChatId) {
      return this.callApi("unbanChatSenderChat", {
        chat_id: chatId,
        sender_chat_id: senderChatId
      });
    }
    setChatMenuButton({ chatId, menuButton } = {}) {
      return this.callApi("setChatMenuButton", {
        chat_id: chatId,
        menu_button: menuButton
      });
    }
    getChatMenuButton({ chatId } = {}) {
      return this.callApi("getChatMenuButton", {
        chat_id: chatId
      });
    }
    setMyDefaultAdministratorRights({ rights, forChannels } = {}) {
      return this.callApi("setMyDefaultAdministratorRights", {
        rights,
        for_channels: forChannels
      });
    }
    getMyDefaultAdministratorRights({ forChannels } = {}) {
      return this.callApi("getMyDefaultAdministratorRights", {
        for_channels: forChannels
      });
    }
    logOut() {
      return this.callApi("logOut", {});
    }
    close() {
      return this.callApi("close", {});
    }
  }
  exports.Telegram = Telegram;
  exports.default = Telegram;
});

// node_modules/buffer-fill/index.js
var require_buffer_fill = __commonJS((exports, module) => {
  var hasFullSupport = function() {
    try {
      if (!Buffer.isEncoding("latin1")) {
        return false;
      }
      var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4);
      buf.fill("ab", "ucs2");
      return buf.toString("hex") === "61006200";
    } catch (_) {
      return false;
    }
  }();
  function isSingleByte(val) {
    return val.length === 1 && val.charCodeAt(0) < 256;
  }
  function fillWithNumber(buffer, val, start, end) {
    if (start < 0 || end > buffer.length) {
      throw new RangeError("Out of range index");
    }
    start = start >>> 0;
    end = end === undefined ? buffer.length : end >>> 0;
    if (end > start) {
      buffer.fill(val, start, end);
    }
    return buffer;
  }
  function fillWithBuffer(buffer, val, start, end) {
    if (start < 0 || end > buffer.length) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return buffer;
    }
    start = start >>> 0;
    end = end === undefined ? buffer.length : end >>> 0;
    var pos = start;
    var len = val.length;
    while (pos <= end - len) {
      val.copy(buffer, pos);
      pos += len;
    }
    if (pos !== end) {
      val.copy(buffer, pos, 0, end - pos);
    }
    return buffer;
  }
  function fill(buffer, val, start, end, encoding) {
    if (hasFullSupport) {
      return buffer.fill(val, start, end, encoding);
    }
    if (typeof val === "number") {
      return fillWithNumber(buffer, val, start, end);
    }
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = buffer.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = buffer.length;
      }
      if (encoding !== undefined && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (encoding === "latin1") {
        encoding = "binary";
      }
      if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val === "") {
        return fillWithNumber(buffer, 0, start, end);
      }
      if (isSingleByte(val)) {
        return fillWithNumber(buffer, val.charCodeAt(0), start, end);
      }
      val = new Buffer(val, encoding);
    }
    if (Buffer.isBuffer(val)) {
      return fillWithBuffer(buffer, val, start, end);
    }
    return fillWithNumber(buffer, 0, start, end);
  }
  module.exports = fill;
});

// node_modules/buffer-alloc-unsafe/index.js
var require_buffer_alloc_unsafe = __commonJS((exports, module) => {
  function allocUnsafe(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    }
    if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
    if (Buffer.allocUnsafe) {
      return Buffer.allocUnsafe(size);
    } else {
      return new Buffer(size);
    }
  }
  module.exports = allocUnsafe;
});

// node_modules/buffer-alloc/index.js
var require_buffer_alloc = __commonJS((exports, module) => {
  var bufferFill = require_buffer_fill();
  var allocUnsafe = require_buffer_alloc_unsafe();
  module.exports = function alloc(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    }
    if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
    if (Buffer.alloc) {
      return Buffer.alloc(size, fill, encoding);
    }
    var buffer = allocUnsafe(size);
    if (size === 0) {
      return buffer;
    }
    if (fill === undefined) {
      return bufferFill(buffer, 0);
    }
    if (typeof encoding !== "string") {
      encoding = undefined;
    }
    return bufferFill(buffer, fill, encoding);
  };
});

// node_modules/safe-compare/index.js
var require_safe_compare = __commonJS((exports, module) => {
  var crypto2 = __require("crypto");
  var bufferAlloc = require_buffer_alloc();
  var safeCompare = function safeCompare(a, b) {
    var strA = String(a);
    var strB = String(b);
    var lenA = strA.length;
    var result = 0;
    if (lenA !== strB.length) {
      strB = strA;
      result = 1;
    }
    for (var i = 0;i < lenA; i++) {
      result |= strA.charCodeAt(i) ^ strB.charCodeAt(i);
    }
    return result === 0;
  };
  var nativeTimingSafeEqual = function nativeTimingSafeEqual(a, b) {
    var strA = String(a);
    var strB = String(b);
    var aLen = Buffer.byteLength(strA);
    var bLen = Buffer.byteLength(strB);
    var bufA = bufferAlloc(aLen, 0, "utf8");
    bufA.write(strA);
    var bufB = bufferAlloc(aLen, 0, "utf8");
    bufB.write(strB);
    return crypto2.timingSafeEqual(bufA, bufB) && aLen === bLen;
  };
  module.exports = typeof crypto2.timingSafeEqual !== "undefined" ? nativeTimingSafeEqual : safeCompare;
});

// node_modules/telegraf/lib/telegraf.js
var require_telegraf = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Telegraf = undefined;
  var crypto2 = __importStar(__require("crypto"));
  var http = __importStar(__require("http"));
  var https = __importStar(__require("https"));
  var composer_1 = require_composer();
  var compact_1 = require_compact();
  var context_1 = __importDefault(require_context());
  var debug_1 = __importDefault(require_src());
  var webhook_1 = __importDefault(require_webhook());
  var polling_1 = require_polling();
  var p_timeout_1 = __importDefault(require_p_timeout2());
  var telegram_1 = __importDefault(require_telegram());
  var url_1 = __require("url");
  var safeCompare = require_safe_compare();
  var debug = (0, debug_1.default)("telegraf:main");
  var DEFAULT_OPTIONS = {
    telegram: {},
    handlerTimeout: 90000,
    contextType: context_1.default
  };
  function always(x) {
    return () => x;
  }
  var anoop = always(Promise.resolve());
  var TOKEN_HEADER = "x-telegram-bot-api-secret-token";

  class Telegraf extends composer_1.Composer {
    constructor(token, options) {
      super();
      this.context = {};
      this.webhookFilter = function(req) {
        const debug2 = (0, debug_1.default)("telegraf:webhook");
        if (req.method === "POST") {
          if (safeCompare(this.path, req.url)) {
            if (!this.secretToken)
              return true;
            else {
              const token2 = req.headers[TOKEN_HEADER];
              if (safeCompare(this.secretToken, token2))
                return true;
              else
                debug2("Secret token does not match:", token2, this.secretToken);
            }
          } else
            debug2("Path does not match:", req.url, this.path);
        } else
          debug2("Unexpected request method, not POST. Received:", req.method);
        return false;
      };
      this.handleError = (err, ctx) => {
        process.exitCode = 1;
        console.error("Unhandled error while processing", ctx.update);
        throw err;
      };
      this.options = {
        ...DEFAULT_OPTIONS,
        ...(0, compact_1.compactOptions)(options)
      };
      this.telegram = new telegram_1.default(token, this.options.telegram);
      debug("Created a `Telegraf` instance");
    }
    get token() {
      return this.telegram.token;
    }
    set webhookReply(webhookReply) {
      this.telegram.webhookReply = webhookReply;
    }
    get webhookReply() {
      return this.telegram.webhookReply;
    }
    catch(handler) {
      this.handleError = handler;
      return this;
    }
    webhookCallback(path = "/", opts = {}) {
      const { secretToken } = opts;
      return (0, webhook_1.default)(this.webhookFilter.bind({ hookPath: path, path, secretToken }), (update, res) => this.handleUpdate(update, res));
    }
    getDomainOpts(opts) {
      var _a2;
      const protocol = opts.domain.startsWith("https://") || opts.domain.startsWith("http://");
      if (protocol)
        debug("Unexpected protocol in domain, telegraf will use https:", opts.domain);
      const domain2 = protocol ? new url_1.URL(opts.domain).host : opts.domain;
      const path = (_a2 = opts.path) !== null && _a2 !== undefined ? _a2 : `/telegraf/${this.secretPathComponent()}`;
      const url = `https://${domain2}${path}`;
      return { domain: domain2, path, url };
    }
    async createWebhook(opts) {
      const { domain: domain2, path, ...extra } = opts;
      const domainOpts = this.getDomainOpts({ domain: domain2, path });
      await this.telegram.setWebhook(domainOpts.url, extra);
      debug(`Webhook set to ${domainOpts.url}`);
      return this.webhookCallback(domainOpts.path, {
        secretToken: extra.secret_token
      });
    }
    startPolling(allowedUpdates = []) {
      this.polling = new polling_1.Polling(this.telegram, allowedUpdates);
      return this.polling.loop(async (update) => {
        await this.handleUpdate(update);
      });
    }
    startWebhook(path, tlsOptions, port, host, cb, secretToken) {
      const webhookCb = this.webhookCallback(path, { secretToken });
      const callback = typeof cb === "function" ? (req, res) => webhookCb(req, res, () => cb(req, res)) : webhookCb;
      this.webhookServer = tlsOptions != null ? https.createServer(tlsOptions, callback) : http.createServer(callback);
      this.webhookServer.listen(port, host, () => {
        debug("Webhook listening on port: %s", port);
      });
      return this;
    }
    secretPathComponent() {
      return crypto2.createHash("sha3-256").update(this.token).update(process.version).digest("hex");
    }
    async launch(config2 = {}, onLaunch) {
      var _a2, _b;
      const [cfg, onMe] = typeof config2 === "function" ? [{}, config2] : [config2, onLaunch];
      const drop_pending_updates = cfg.dropPendingUpdates;
      const allowed_updates = cfg.allowedUpdates;
      const webhook = cfg.webhook;
      debug("Connecting to Telegram");
      (_a2 = this.botInfo) !== null && _a2 !== undefined || (this.botInfo = await this.telegram.getMe());
      onMe === null || onMe === undefined || onMe();
      debug(`Launching @${this.botInfo.username}`);
      if (webhook === undefined) {
        await this.telegram.deleteWebhook({ drop_pending_updates });
        debug("Bot started with long polling");
        await this.startPolling(allowed_updates);
        return;
      }
      const domainOpts = this.getDomainOpts({
        domain: webhook.domain,
        path: (_b = webhook.path) !== null && _b !== undefined ? _b : webhook.hookPath
      });
      const { tlsOptions, port, host, cb, secretToken } = webhook;
      this.startWebhook(domainOpts.path, tlsOptions, port, host, cb, secretToken);
      await this.telegram.setWebhook(domainOpts.url, {
        drop_pending_updates,
        allowed_updates,
        ip_address: webhook.ipAddress,
        max_connections: webhook.maxConnections,
        secret_token: webhook.secretToken,
        certificate: webhook.certificate
      });
      debug(`Bot started with webhook @ ${domainOpts.url}`);
    }
    stop(reason = "unspecified") {
      var _a2, _b;
      debug("Stopping bot... Reason:", reason);
      if (this.polling === undefined && this.webhookServer === undefined) {
        throw new Error("Bot is not running!");
      }
      (_a2 = this.webhookServer) === null || _a2 === undefined || _a2.close();
      (_b = this.polling) === null || _b === undefined || _b.stop();
    }
    async handleUpdate(update, webhookResponse) {
      var _a2, _b;
      (_a2 = this.botInfo) !== null && _a2 !== undefined || (this.botInfo = (debug("Update %d is waiting for `botInfo` to be initialized", update.update_id), await ((_b = this.botInfoCall) !== null && _b !== undefined ? _b : this.botInfoCall = this.telegram.getMe())));
      debug("Processing update", update.update_id);
      const tg = new telegram_1.default(this.token, this.telegram.options, webhookResponse);
      const TelegrafContext = this.options.contextType;
      const ctx = new TelegrafContext(update, tg, this.botInfo);
      Object.assign(ctx, this.context);
      try {
        await (0, p_timeout_1.default)(Promise.resolve(this.middleware()(ctx, anoop)), this.options.handlerTimeout);
      } catch (err) {
        return await this.handleError(err, ctx);
      } finally {
        if ((webhookResponse === null || webhookResponse === undefined ? undefined : webhookResponse.writableEnded) === false) {
          webhookResponse.end();
        }
        debug("Finished processing update", update.update_id);
      }
    }
  }
  exports.Telegraf = Telegraf;
});

// node_modules/telegraf/lib/router.js
var require_router = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Router = undefined;
  var composer_1 = __importDefault(require_composer());

  class Router {
    constructor(routeFn, handlers = new Map) {
      this.routeFn = routeFn;
      this.handlers = handlers;
      this.otherwiseHandler = composer_1.default.passThru();
      if (typeof routeFn !== "function") {
        throw new Error("Missing routing function");
      }
    }
    on(route, ...fns) {
      if (fns.length === 0) {
        throw new TypeError("At least one handler must be provided");
      }
      this.handlers.set(route, composer_1.default.compose(fns));
      return this;
    }
    otherwise(...fns) {
      if (fns.length === 0) {
        throw new TypeError("At least one otherwise handler must be provided");
      }
      this.otherwiseHandler = composer_1.default.compose(fns);
      return this;
    }
    middleware() {
      return composer_1.default.lazy((ctx) => {
        var _a2;
        const result = this.routeFn(ctx);
        if (result == null) {
          return this.otherwiseHandler;
        }
        Object.assign(ctx, result.context);
        Object.assign(ctx.state, result.state);
        return (_a2 = this.handlers.get(result.route)) !== null && _a2 !== undefined ? _a2 : this.otherwiseHandler;
      });
    }
  }
  exports.Router = Router;
});

// node_modules/telegraf/lib/button.js
var require_button = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.webApp = exports.login = exports.pay = exports.game = exports.switchToCurrentChat = exports.switchToChat = exports.callback = exports.url = exports.channelRequest = exports.groupRequest = exports.botRequest = exports.userRequest = exports.pollRequest = exports.locationRequest = exports.contactRequest = exports.text = undefined;
  function text(text2, hide = false) {
    return { text: text2, hide };
  }
  exports.text = text;
  function contactRequest(text2, hide = false) {
    return { text: text2, request_contact: true, hide };
  }
  exports.contactRequest = contactRequest;
  function locationRequest(text2, hide = false) {
    return { text: text2, request_location: true, hide };
  }
  exports.locationRequest = locationRequest;
  function pollRequest(text2, type, hide = false) {
    return { text: text2, request_poll: { type }, hide };
  }
  exports.pollRequest = pollRequest;
  function userRequest(text2, request_id, extra, hide = false) {
    return {
      text: text2,
      request_users: { request_id, ...extra },
      hide
    };
  }
  exports.userRequest = userRequest;
  function botRequest(text2, request_id, extra, hide = false) {
    return {
      text: text2,
      request_users: { request_id, user_is_bot: true, ...extra },
      hide
    };
  }
  exports.botRequest = botRequest;
  function groupRequest(text2, request_id, extra, hide = false) {
    return {
      text: text2,
      request_chat: { request_id, chat_is_channel: false, ...extra },
      hide
    };
  }
  exports.groupRequest = groupRequest;
  function channelRequest(text2, request_id, extra, hide = false) {
    return {
      text: text2,
      request_chat: { request_id, chat_is_channel: true, ...extra },
      hide
    };
  }
  exports.channelRequest = channelRequest;
  function url(text2, url2, hide = false) {
    return { text: text2, url: url2, hide };
  }
  exports.url = url;
  function callback(text2, data, hide = false) {
    return { text: text2, callback_data: data, hide };
  }
  exports.callback = callback;
  function switchToChat(text2, value, hide = false) {
    return { text: text2, switch_inline_query: value, hide };
  }
  exports.switchToChat = switchToChat;
  function switchToCurrentChat(text2, value, hide = false) {
    return { text: text2, switch_inline_query_current_chat: value, hide };
  }
  exports.switchToCurrentChat = switchToCurrentChat;
  function game(text2, hide = false) {
    return { text: text2, callback_game: {}, hide };
  }
  exports.game = game;
  function pay(text2, hide = false) {
    return { text: text2, pay: true, hide };
  }
  exports.pay = pay;
  function login(text2, url2, opts = {}, hide = false) {
    return {
      text: text2,
      login_url: { ...opts, url: url2 },
      hide
    };
  }
  exports.login = login;
  function webApp(text2, url2, hide = false) {
    return {
      text: text2,
      web_app: { url: url2 },
      hide
    };
  }
  exports.webApp = webApp;
});

// node_modules/telegraf/lib/markup.js
var require_markup = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.inlineKeyboard = exports.keyboard = exports.forceReply = exports.removeKeyboard = exports.button = exports.Markup = undefined;
  var check_1 = require_check();

  class Markup {
    constructor(reply_markup) {
      this.reply_markup = reply_markup;
    }
    selective(value = true) {
      return new Markup({ ...this.reply_markup, selective: value });
    }
    placeholder(placeholder) {
      return new Markup({
        ...this.reply_markup,
        input_field_placeholder: placeholder
      });
    }
    resize(value = true) {
      return new Markup({
        ...this.reply_markup,
        resize_keyboard: value
      });
    }
    oneTime(value = true) {
      return new Markup({
        ...this.reply_markup,
        one_time_keyboard: value
      });
    }
    persistent(value = true) {
      return new Markup({
        ...this.reply_markup,
        is_persistent: value
      });
    }
  }
  exports.Markup = Markup;
  exports.button = __importStar(require_button());
  function removeKeyboard() {
    return new Markup({ remove_keyboard: true });
  }
  exports.removeKeyboard = removeKeyboard;
  function forceReply() {
    return new Markup({ force_reply: true });
  }
  exports.forceReply = forceReply;
  function keyboard(buttons, options) {
    const keyboard2 = buildKeyboard(buttons, {
      columns: 1,
      ...options
    });
    return new Markup({ keyboard: keyboard2 });
  }
  exports.keyboard = keyboard;
  function inlineKeyboard(buttons, options) {
    const inlineKeyboard2 = buildKeyboard(buttons, {
      columns: buttons.length,
      ...options
    });
    return new Markup({ inline_keyboard: inlineKeyboard2 });
  }
  exports.inlineKeyboard = inlineKeyboard;
  function buildKeyboard(buttons, options) {
    const result = [];
    if (!Array.isArray(buttons)) {
      return result;
    }
    if ((0, check_1.is2D)(buttons)) {
      return buttons.map((row) => row.filter((button) => !button.hide));
    }
    const wrapFn = options.wrap !== undefined ? options.wrap : (_btn, _index, currentRow2) => currentRow2.length >= options.columns;
    let currentRow = [];
    let index = 0;
    for (const btn of buttons.filter((button) => !button.hide)) {
      if (wrapFn(btn, index, currentRow) && currentRow.length > 0) {
        result.push(currentRow);
        currentRow = [];
      }
      currentRow.push(btn);
      index++;
    }
    if (currentRow.length > 0) {
      result.push(currentRow);
    }
    return result;
  }
});

// node_modules/telegraf/lib/telegram-types.js
var require_telegram_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Markup = undefined;
  var markup_1 = require_markup();
  Object.defineProperty(exports, "Markup", { enumerable: true, get: function() {
    return markup_1.Markup;
  } });
});

// node_modules/telegraf/lib/input.js
var require_input = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromFileId = exports.fromURL = exports.fromURLStream = exports.fromReadableStream = exports.fromBuffer = exports.fromLocalFile = undefined;
  var fromLocalFile = (path, filename) => ({ source: path, filename });
  exports.fromLocalFile = fromLocalFile;
  var fromBuffer = (buffer, filename) => ({ source: buffer, filename });
  exports.fromBuffer = fromBuffer;
  var fromReadableStream = (stream, filename) => ({ source: stream, filename });
  exports.fromReadableStream = fromReadableStream;
  var fromURLStream = (url, filename) => ({ url: url.toString(), filename });
  exports.fromURLStream = fromURLStream;
  var fromURL = (url) => url.toString();
  exports.fromURL = fromURL;
  var fromFileId = (fileId) => fileId;
  exports.fromFileId = fromFileId;
});

// node_modules/telegraf/lib/core/helpers/deunionize.js
var require_deunionize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deunionize = undefined;
  function deunionize(t) {
    return t;
  }
  exports.deunionize = deunionize;
});

// node_modules/telegraf/lib/session.js
var require_session = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isSessionContext = exports.MemorySessionStore = exports.session = undefined;
  var debug_1 = __importDefault(require_src());
  var debug = (0, debug_1.default)("telegraf:session");
  function session(options) {
    var _a2, _b, _c;
    const prop = (_a2 = options === null || options === undefined ? undefined : options.property) !== null && _a2 !== undefined ? _a2 : "session";
    const getSessionKey = (_b = options === null || options === undefined ? undefined : options.getSessionKey) !== null && _b !== undefined ? _b : defaultGetSessionKey;
    const store = (_c = options === null || options === undefined ? undefined : options.store) !== null && _c !== undefined ? _c : new MemorySessionStore;
    const cache2 = new Map;
    const concurrents = new Map;
    return async (ctx, next) => {
      var _a3;
      const updId = ctx.update.update_id;
      let released = false;
      function releaseChecks() {
        if (released && process.env.EXPERIMENTAL_SESSION_CHECKS)
          throw new Error("Session was accessed or assigned to after the middleware chain exhausted. This is a bug in your code. You're probably accessing session asynchronously and missing awaits.");
      }
      const key = await getSessionKey(ctx);
      if (!key) {
        ctx[prop] = undefined;
        return await next();
      }
      let cached2 = cache2.get(key);
      if (cached2) {
        debug(`(${updId}) found cached session, reusing from cache`);
        ++cached2.counter;
      } else {
        debug(`(${updId}) did not find cached session`);
        let promise = concurrents.get(key);
        if (promise)
          debug(`(${updId}) found a concurrent request, reusing promise`);
        else {
          debug(`(${updId}) fetching from upstream store`);
          promise = store.get(key);
        }
        concurrents.set(key, promise);
        const upstream = await promise;
        concurrents.delete(key);
        debug(`(${updId}) updating cache`);
        const c2 = cache2.get(key);
        if (c2) {
          c2.counter++;
          cached2 = c2;
        } else {
          cached2 = { ref: upstream !== null && upstream !== undefined ? upstream : (_a3 = options === null || options === undefined ? undefined : options.defaultSession) === null || _a3 === undefined ? undefined : _a3.call(options, ctx), counter: 1 };
          cache2.set(key, cached2);
        }
      }
      const c = cached2;
      let touched = false;
      Object.defineProperty(ctx, prop, {
        get() {
          releaseChecks();
          touched = true;
          return c.ref;
        },
        set(value) {
          releaseChecks();
          touched = true;
          c.ref = value;
        }
      });
      try {
        await next();
        released = true;
      } finally {
        if (--c.counter === 0) {
          debug(`(${updId}) refcounter reached 0, removing cached`);
          cache2.delete(key);
        }
        debug(`(${updId}) middlewares completed, checking session`);
        if (touched)
          if (c.ref == null) {
            debug(`(${updId}) ctx.${prop} missing, removing from store`);
            await store.delete(key);
          } else {
            debug(`(${updId}) ctx.${prop} found, updating store`);
            await store.set(key, c.ref);
          }
      }
    };
  }
  exports.session = session;
  function defaultGetSessionKey(ctx) {
    var _a2, _b;
    const fromId = (_a2 = ctx.from) === null || _a2 === undefined ? undefined : _a2.id;
    const chatId = (_b = ctx.chat) === null || _b === undefined ? undefined : _b.id;
    if (fromId == null || chatId == null)
      return;
    return `${fromId}:${chatId}`;
  }

  class MemorySessionStore {
    constructor(ttl = Infinity) {
      this.ttl = ttl;
      this.store = new Map;
    }
    get(name) {
      const entry = this.store.get(name);
      if (entry == null) {
        return;
      } else if (entry.expires < Date.now()) {
        this.delete(name);
        return;
      }
      return entry.session;
    }
    set(name, value) {
      const now = Date.now();
      this.store.set(name, { session: value, expires: now + this.ttl });
    }
    delete(name) {
      this.store.delete(name);
    }
  }
  exports.MemorySessionStore = MemorySessionStore;
  function isSessionContext(ctx) {
    return "session" in ctx;
  }
  exports.isSessionContext = isSessionContext;
});

// node_modules/telegraf/lib/scenes/context.js
var require_context2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var composer_1 = __importDefault(require_composer());
  var debug_1 = __importDefault(require_src());
  var debug = (0, debug_1.default)("telegraf:scenes:context");
  var noop = () => Promise.resolve();
  var now = () => Math.floor(Date.now() / 1000);

  class SceneContextScene {
    constructor(ctx, scenes, options) {
      this.ctx = ctx;
      this.scenes = scenes;
      this.leaving = false;
      const fallbackSessionDefault = {};
      this.options = { defaultSession: fallbackSessionDefault, ...options };
    }
    get session() {
      var _a2, _b;
      const defaultSession = Object.assign({}, this.options.defaultSession);
      let session = (_b = (_a2 = this.ctx.session) === null || _a2 === undefined ? undefined : _a2.__scenes) !== null && _b !== undefined ? _b : defaultSession;
      if (session.expires !== undefined && session.expires < now()) {
        session = defaultSession;
      }
      if (this.ctx.session === undefined) {
        this.ctx.session = { __scenes: session };
      } else {
        this.ctx.session.__scenes = session;
      }
      return session;
    }
    get state() {
      var _a2;
      var _b;
      return (_a2 = (_b = this.session).state) !== null && _a2 !== undefined ? _a2 : _b.state = {};
    }
    set state(value) {
      this.session.state = { ...value };
    }
    get current() {
      var _a2;
      const sceneId = (_a2 = this.session.current) !== null && _a2 !== undefined ? _a2 : this.options.default;
      return sceneId === undefined || !this.scenes.has(sceneId) ? undefined : this.scenes.get(sceneId);
    }
    reset() {
      if (this.ctx.session !== undefined)
        this.ctx.session.__scenes = Object.assign({}, this.options.defaultSession);
    }
    async enter(sceneId, initialState = {}, silent = false) {
      var _a2, _b;
      if (!this.scenes.has(sceneId)) {
        throw new Error(`Can't find scene: ${sceneId}`);
      }
      if (!silent) {
        await this.leave();
      }
      debug("Entering scene", sceneId, initialState, silent);
      this.session.current = sceneId;
      this.state = initialState;
      const ttl = (_b = (_a2 = this.current) === null || _a2 === undefined ? undefined : _a2.ttl) !== null && _b !== undefined ? _b : this.options.ttl;
      if (ttl !== undefined) {
        this.session.expires = now() + ttl;
      }
      if (this.current === undefined || silent) {
        return;
      }
      const handler = "enterMiddleware" in this.current && typeof this.current.enterMiddleware === "function" ? this.current.enterMiddleware() : this.current.middleware();
      return await handler(this.ctx, noop);
    }
    reenter() {
      return this.session.current === undefined ? undefined : this.enter(this.session.current, this.state);
    }
    async leave() {
      if (this.leaving)
        return;
      debug("Leaving scene");
      try {
        this.leaving = true;
        if (this.current === undefined) {
          return;
        }
        const handler = "leaveMiddleware" in this.current && typeof this.current.leaveMiddleware === "function" ? this.current.leaveMiddleware() : composer_1.default.passThru();
        await handler(this.ctx, noop);
        return this.reset();
      } finally {
        this.leaving = false;
      }
    }
  }
  exports.default = SceneContextScene;
});

// node_modules/telegraf/lib/scenes/stage.js
var require_stage = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Stage = undefined;
  var session_1 = require_session();
  var context_1 = __importDefault(require_context2());
  var composer_1 = require_composer();

  class Stage extends composer_1.Composer {
    constructor(scenes = [], options) {
      super();
      this.options = { ...options };
      this.scenes = new Map;
      scenes.forEach((scene) => this.register(scene));
    }
    register(...scenes) {
      scenes.forEach((scene) => {
        if ((scene === null || scene === undefined ? undefined : scene.id) == null || typeof scene.middleware !== "function") {
          throw new Error("telegraf: Unsupported scene");
        }
        this.scenes.set(scene.id, scene);
      });
      return this;
    }
    middleware() {
      const handler = composer_1.Composer.compose([
        (ctx, next) => {
          const scenes = this.scenes;
          const scene = new context_1.default(ctx, scenes, this.options);
          ctx.scene = scene;
          return next();
        },
        super.middleware(),
        composer_1.Composer.lazy((ctx) => {
          var _a2;
          return (_a2 = ctx.scene.current) !== null && _a2 !== undefined ? _a2 : composer_1.Composer.passThru();
        })
      ]);
      return composer_1.Composer.optional(session_1.isSessionContext, handler);
    }
    static enter(...args) {
      return (ctx) => ctx.scene.enter(...args);
    }
    static reenter(...args) {
      return (ctx) => ctx.scene.reenter(...args);
    }
    static leave(...args) {
      return (ctx) => ctx.scene.leave(...args);
    }
  }
  exports.Stage = Stage;
});

// node_modules/telegraf/lib/scenes/base.js
var require_base = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaseScene = undefined;
  var composer_1 = __importDefault(require_composer());
  var { compose } = composer_1.default;

  class BaseScene extends composer_1.default {
    constructor(id, options) {
      const opts = {
        handlers: [],
        enterHandlers: [],
        leaveHandlers: [],
        ...options
      };
      super(...opts.handlers);
      this.id = id;
      this.ttl = opts.ttl;
      this.enterHandler = compose(opts.enterHandlers);
      this.leaveHandler = compose(opts.leaveHandlers);
    }
    enter(...fns) {
      this.enterHandler = compose([this.enterHandler, ...fns]);
      return this;
    }
    leave(...fns) {
      this.leaveHandler = compose([this.leaveHandler, ...fns]);
      return this;
    }
    enterMiddleware() {
      return this.enterHandler;
    }
    leaveMiddleware() {
      return this.leaveHandler;
    }
  }
  exports.BaseScene = BaseScene;
  exports.default = BaseScene;
});

// node_modules/telegraf/lib/scenes/wizard/context.js
var require_context3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class WizardContextWizard {
    constructor(ctx, steps) {
      var _a2;
      this.ctx = ctx;
      this.steps = steps;
      this.state = ctx.scene.state;
      this.cursor = (_a2 = ctx.scene.session.cursor) !== null && _a2 !== undefined ? _a2 : 0;
    }
    get step() {
      return this.steps[this.cursor];
    }
    get cursor() {
      return this.ctx.scene.session.cursor;
    }
    set cursor(cursor) {
      this.ctx.scene.session.cursor = cursor;
    }
    selectStep(index) {
      this.cursor = index;
      return this;
    }
    next() {
      return this.selectStep(this.cursor + 1);
    }
    back() {
      return this.selectStep(this.cursor - 1);
    }
  }
  exports.default = WizardContextWizard;
});

// node_modules/telegraf/lib/scenes/wizard/index.js
var require_wizard = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WizardScene = undefined;
  var base_1 = __importDefault(require_base());
  var context_1 = __importDefault(require_context3());
  var composer_1 = __importDefault(require_composer());

  class WizardScene extends base_1.default {
    constructor(id, options, ...steps) {
      let opts;
      let s;
      if (typeof options === "function" || "middleware" in options) {
        opts = undefined;
        s = [options, ...steps];
      } else {
        opts = options;
        s = steps;
      }
      super(id, opts);
      this.steps = s;
    }
    middleware() {
      return composer_1.default.compose([
        (ctx, next) => {
          ctx.wizard = new context_1.default(ctx, this.steps);
          return next();
        },
        super.middleware(),
        (ctx, next) => {
          if (ctx.wizard.step === undefined) {
            ctx.wizard.selectStep(0);
            return ctx.scene.leave();
          }
          return composer_1.default.unwrap(ctx.wizard.step)(ctx, next);
        }
      ]);
    }
    enterMiddleware() {
      return composer_1.default.compose([this.enterHandler, this.middleware()]);
    }
  }
  exports.WizardScene = WizardScene;
});

// node_modules/telegraf/lib/scenes/index.js
var require_scenes = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WizardContextWizard = exports.WizardScene = exports.BaseScene = exports.SceneContextScene = exports.Stage = undefined;
  var stage_1 = require_stage();
  Object.defineProperty(exports, "Stage", { enumerable: true, get: function() {
    return stage_1.Stage;
  } });
  var context_1 = require_context2();
  Object.defineProperty(exports, "SceneContextScene", { enumerable: true, get: function() {
    return __importDefault(context_1).default;
  } });
  var base_1 = require_base();
  Object.defineProperty(exports, "BaseScene", { enumerable: true, get: function() {
    return base_1.BaseScene;
  } });
  var wizard_1 = require_wizard();
  Object.defineProperty(exports, "WizardScene", { enumerable: true, get: function() {
    return wizard_1.WizardScene;
  } });
  var context_2 = require_context3();
  Object.defineProperty(exports, "WizardContextWizard", { enumerable: true, get: function() {
    return __importDefault(context_2).default;
  } });
});

// node_modules/telegraf/lib/scenes.js
var require_scenes2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_scenes(), exports);
});

// node_modules/telegraf/lib/index.js
var require_lib3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Scenes = exports.MemorySessionStore = exports.session = exports.deunionize = exports.Format = exports.Input = exports.Markup = exports.Types = exports.Telegram = exports.TelegramError = exports.Router = exports.Composer = exports.Context = exports.Telegraf = undefined;
  var telegraf_1 = require_telegraf();
  Object.defineProperty(exports, "Telegraf", { enumerable: true, get: function() {
    return telegraf_1.Telegraf;
  } });
  var context_1 = require_context();
  Object.defineProperty(exports, "Context", { enumerable: true, get: function() {
    return context_1.Context;
  } });
  var composer_1 = require_composer();
  Object.defineProperty(exports, "Composer", { enumerable: true, get: function() {
    return composer_1.Composer;
  } });
  var router_1 = require_router();
  Object.defineProperty(exports, "Router", { enumerable: true, get: function() {
    return router_1.Router;
  } });
  var error_1 = require_error();
  Object.defineProperty(exports, "TelegramError", { enumerable: true, get: function() {
    return error_1.TelegramError;
  } });
  var telegram_1 = require_telegram();
  Object.defineProperty(exports, "Telegram", { enumerable: true, get: function() {
    return telegram_1.Telegram;
  } });
  exports.Types = __importStar(require_telegram_types());
  exports.Markup = __importStar(require_markup());
  exports.Input = __importStar(require_input());
  exports.Format = __importStar(require_format());
  var deunionize_1 = require_deunionize();
  Object.defineProperty(exports, "deunionize", { enumerable: true, get: function() {
    return deunionize_1.deunionize;
  } });
  var session_1 = require_session();
  Object.defineProperty(exports, "session", { enumerable: true, get: function() {
    return session_1.session;
  } });
  Object.defineProperty(exports, "MemorySessionStore", { enumerable: true, get: function() {
    return session_1.MemorySessionStore;
  } });
  exports.Scenes = __importStar(require_scenes2());
});

// node_modules/zod/v4/mini/parse.js
var init_parse2 = __esm(() => {
  init_core2();
});

// node_modules/zod/v4/mini/schemas.js
var init_schemas2 = () => {};

// node_modules/zod/v4/mini/checks.js
var init_checks2 = () => {};

// node_modules/zod/v4/mini/iso.js
var init_iso = () => {};

// node_modules/zod/v4/mini/coerce.js
var init_coerce = () => {};

// node_modules/zod/v4/mini/external.js
var init_external2 = __esm(() => {
  init_core2();
  init_parse2();
  init_schemas2();
  init_checks2();
  init_locales();
  init_iso();
  init_coerce();
});

// node_modules/zod/v4/mini/index.js
var init_mini = __esm(() => {
  init_external2();
});

// node_modules/zod/v4-mini/index.js
var init_v4_mini = __esm(() => {
  init_mini();
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-compat.js
function isZ4Schema(s) {
  const schema = s;
  return !!schema._zod;
}
function safeParse2(schema, data) {
  if (isZ4Schema(schema)) {
    const result2 = safeParse(schema, data);
    return result2;
  }
  const v3Schema = schema;
  const result = v3Schema.safeParse(data);
  return result;
}
function getObjectShape(schema) {
  var _a2, _b;
  if (!schema)
    return;
  let rawShape;
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    rawShape = (_b = (_a2 = v4Schema._zod) === null || _a2 === undefined ? undefined : _a2.def) === null || _b === undefined ? undefined : _b.shape;
  } else {
    const v3Schema = schema;
    rawShape = v3Schema.shape;
  }
  if (!rawShape)
    return;
  if (typeof rawShape === "function") {
    try {
      return rawShape();
    } catch (_c) {
      return;
    }
  }
  return rawShape;
}
function getLiteralValue(schema) {
  var _a2;
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    const def2 = (_a2 = v4Schema._zod) === null || _a2 === undefined ? undefined : _a2.def;
    if (def2) {
      if (def2.value !== undefined)
        return def2.value;
      if (Array.isArray(def2.values) && def2.values.length > 0) {
        return def2.values[0];
      }
    }
  }
  const v3Schema = schema;
  const def = v3Schema._def;
  if (def) {
    if (def.value !== undefined)
      return def.value;
    if (Array.isArray(def.values) && def.values.length > 0) {
      return def.values[0];
    }
  }
  const directValue = schema.value;
  if (directValue !== undefined)
    return directValue;
  return;
}
var init_zod_compat = __esm(() => {
  init_v4_mini();
});

// node_modules/zod/v4/classic/checks.js
var init_checks3 = __esm(() => {
  init_core2();
});

// node_modules/zod/v4/classic/iso.js
var exports_iso2 = {};
__export(exports_iso2, {
  time: () => time3,
  duration: () => duration2,
  datetime: () => datetime2,
  date: () => date3,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
function date3(params) {
  return _isoDate(ZodISODate, params);
}
function time3(params) {
  return _isoTime(ZodISOTime, params);
}
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}
var ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration;
var init_iso2 = __esm(() => {
  init_core2();
  init_schemas3();
  ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
    $ZodISODateTime.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
    $ZodISODate.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
    $ZodISOTime.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
    $ZodISODuration.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
});

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
}, ZodError3, ZodRealError;
var init_errors3 = __esm(() => {
  init_core2();
  init_core2();
  init_util();
  ZodError3 = $constructor("ZodError", initializer2);
  ZodRealError = $constructor("ZodError", initializer2, {
    Parent: Error
  });
});

// node_modules/zod/v4/classic/parse.js
var parse5, parseAsync2, safeParse3, safeParseAsync2, encode2, decode2, encodeAsync2, decodeAsync2, safeEncode2, safeDecode2, safeEncodeAsync2, safeDecodeAsync2;
var init_parse3 = __esm(() => {
  init_core2();
  init_errors3();
  parse5 = /* @__PURE__ */ _parse(ZodRealError);
  parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
  safeParse3 = /* @__PURE__ */ _safeParse(ZodRealError);
  safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
  encode2 = /* @__PURE__ */ _encode(ZodRealError);
  decode2 = /* @__PURE__ */ _decode(ZodRealError);
  encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
  decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
  safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
  safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
  safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
  safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);
});

// node_modules/zod/v4/classic/schemas.js
function string2(params) {
  return _string(ZodString2, params);
}
function email2(params) {
  return _email(ZodEmail, params);
}
function guid2(params) {
  return _guid(ZodGUID, params);
}
function uuid3(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: exports_regexes.domain,
    ...exports_util.normalizeParams(params)
  });
}
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
function ulid2(params) {
  return _ulid(ZodULID, params);
}
function xid2(params) {
  return _xid(ZodXID, params);
}
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
function mac2(params) {
  return _mac(ZodMAC, params);
}
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
function base643(params) {
  return _base64(ZodBase64, params);
}
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
function e1642(params) {
  return _e164(ZodE164, params);
}
function jwt(params) {
  return _jwt(ZodJWT, params);
}
function stringFormat(format2, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format2, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", exports_regexes.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", exports_regexes.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format2 = `${alg}_${enc}`;
  const regex2 = exports_regexes[format2];
  if (!regex2)
    throw new Error(`Unrecognized hash format: ${format2}`);
  return _stringFormat(ZodCustomStringFormat, format2, regex2, params);
}
function number2(params) {
  return _number(ZodNumber2, params);
}
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
function boolean2(params) {
  return _boolean(ZodBoolean2, params);
}
function bigint2(params) {
  return _bigint(ZodBigInt2, params);
}
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
function symbol(params) {
  return _symbol(ZodSymbol2, params);
}
function _undefined3(params) {
  return _undefined2(ZodUndefined2, params);
}
function _null3(params) {
  return _null2(ZodNull2, params);
}
function any() {
  return _any(ZodAny2);
}
function unknown() {
  return _unknown(ZodUnknown2);
}
function never(params) {
  return _never(ZodNever2, params);
}
function _void2(params) {
  return _void(ZodVoid2, params);
}
function date4(params) {
  return _date(ZodDate2, params);
}
function array(element, params) {
  return _array(ZodArray2, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
function object2(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...exports_util.normalizeParams(params)
  };
  return new ZodObject2(def);
}
function strictObject(shape, params) {
  return new ZodObject2({
    type: "object",
    shape,
    catchall: never(),
    ...exports_util.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject2({
    type: "object",
    shape,
    catchall: unknown(),
    ...exports_util.normalizeParams(params)
  });
}
function union(options, params) {
  return new ZodUnion2({
    type: "union",
    options,
    ...exports_util.normalizeParams(params)
  });
}
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion2({
    type: "union",
    options,
    discriminator,
    ...exports_util.normalizeParams(params)
  });
}
function intersection(left, right) {
  return new ZodIntersection2({
    type: "intersection",
    left,
    right
  });
}
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple2({
    type: "tuple",
    items,
    rest,
    ...exports_util.normalizeParams(params)
  });
}
function record(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = undefined;
  return new ZodRecord2({
    type: "record",
    keyType: k,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function map(keyType, valueType, params) {
  return new ZodMap2({
    type: "map",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function set(valueType, params) {
  return new ZodSet2({
    type: "set",
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum2({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum2({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
function literal(value, params) {
  return new ZodLiteral2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util.normalizeParams(params)
  });
}
function file(params) {
  return _file(ZodFile, params);
}
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
function optional(innerType) {
  return new ZodOptional2({
    type: "optional",
    innerType
  });
}
function nullable(innerType) {
  return new ZodNullable2({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
function _default2(innerType, defaultValue) {
  return new ZodDefault2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);
    }
  });
}
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);
    }
  });
}
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...exports_util.normalizeParams(params)
  });
}
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
function _catch2(innerType, catchValue) {
  return new ZodCatch2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function nan(params) {
  return _nan(ZodNaN2, params);
}
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
  });
}
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
function readonly(innerType) {
  return new ZodReadonly2({
    type: "readonly",
    innerType
  });
}
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...exports_util.normalizeParams(params)
  });
}
function lazy(getter) {
  return new ZodLazy2({
    type: "lazy",
    getter
  });
}
function promise(innerType) {
  return new ZodPromise2({
    type: "promise",
    innerType
  });
}
function _function(params) {
  return new ZodFunction2({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
function custom2(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...exports_util.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
var ZodType2, _ZodString, ZodString2, ZodStringFormat, ZodEmail, ZodGUID, ZodUUID, ZodURL, ZodEmoji, ZodNanoID, ZodCUID, ZodCUID2, ZodULID, ZodXID, ZodKSUID, ZodIPv4, ZodMAC, ZodIPv6, ZodCIDRv4, ZodCIDRv6, ZodBase64, ZodBase64URL, ZodE164, ZodJWT, ZodCustomStringFormat, ZodNumber2, ZodNumberFormat, ZodBoolean2, ZodBigInt2, ZodBigIntFormat, ZodSymbol2, ZodUndefined2, ZodNull2, ZodAny2, ZodUnknown2, ZodNever2, ZodVoid2, ZodDate2, ZodArray2, ZodObject2, ZodUnion2, ZodDiscriminatedUnion2, ZodIntersection2, ZodTuple2, ZodRecord2, ZodMap2, ZodSet2, ZodEnum2, ZodLiteral2, ZodFile, ZodTransform, ZodOptional2, ZodNullable2, ZodDefault2, ZodPrefault, ZodNonOptional, ZodSuccess, ZodCatch2, ZodNaN2, ZodPipe, ZodCodec, ZodReadonly2, ZodTemplateLiteral, ZodLazy2, ZodPromise2, ZodFunction2, ZodCustom, describe2, meta2, stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean2,
  String: ZodString2
}, ...args);
var init_schemas3 = __esm(() => {
  init_core2();
  init_core2();
  init_checks3();
  init_iso2();
  init_parse3();
  ZodType2 = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
    $ZodType.init(inst, def);
    inst.def = def;
    inst.type = def.type;
    Object.defineProperty(inst, "_def", { value: def });
    inst.check = (...checks3) => {
      return inst.clone(exports_util.mergeDefs(def, {
        checks: [
          ...def.checks ?? [],
          ...checks3.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }));
    };
    inst.clone = (def2, params) => clone(inst, def2, params);
    inst.brand = () => inst;
    inst.register = (reg, meta2) => {
      reg.add(inst, meta2);
      return inst;
    };
    inst.parse = (data, params) => parse5(inst, data, params, { callee: inst.parse });
    inst.safeParse = (data, params) => safeParse3(inst, data, params);
    inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
    inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
    inst.spa = inst.safeParseAsync;
    inst.encode = (data, params) => encode2(inst, data, params);
    inst.decode = (data, params) => decode2(inst, data, params);
    inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
    inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
    inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
    inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
    inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
    inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
    inst.refine = (check, params) => inst.check(refine(check, params));
    inst.superRefine = (refinement) => inst.check(superRefine(refinement));
    inst.overwrite = (fn) => inst.check(_overwrite(fn));
    inst.optional = () => optional(inst);
    inst.nullable = () => nullable(inst);
    inst.nullish = () => optional(nullable(inst));
    inst.nonoptional = (params) => nonoptional(inst, params);
    inst.array = () => array(inst);
    inst.or = (arg) => union([inst, arg]);
    inst.and = (arg) => intersection(inst, arg);
    inst.transform = (tx) => pipe(inst, transform(tx));
    inst.default = (def2) => _default2(inst, def2);
    inst.prefault = (def2) => prefault(inst, def2);
    inst.catch = (params) => _catch2(inst, params);
    inst.pipe = (target) => pipe(inst, target);
    inst.readonly = () => readonly(inst);
    inst.describe = (description) => {
      const cl = inst.clone();
      globalRegistry.add(cl, { description });
      return cl;
    };
    Object.defineProperty(inst, "description", {
      get() {
        return globalRegistry.get(inst)?.description;
      },
      configurable: true
    });
    inst.meta = (...args) => {
      if (args.length === 0) {
        return globalRegistry.get(inst);
      }
      const cl = inst.clone();
      globalRegistry.add(cl, args[0]);
      return cl;
    };
    inst.isOptional = () => inst.safeParse(undefined).success;
    inst.isNullable = () => inst.safeParse(null).success;
    return inst;
  });
  _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
    $ZodString.init(inst, def);
    ZodType2.init(inst, def);
    const bag = inst._zod.bag;
    inst.format = bag.format ?? null;
    inst.minLength = bag.minimum ?? null;
    inst.maxLength = bag.maximum ?? null;
    inst.regex = (...args) => inst.check(_regex(...args));
    inst.includes = (...args) => inst.check(_includes(...args));
    inst.startsWith = (...args) => inst.check(_startsWith(...args));
    inst.endsWith = (...args) => inst.check(_endsWith(...args));
    inst.min = (...args) => inst.check(_minLength(...args));
    inst.max = (...args) => inst.check(_maxLength(...args));
    inst.length = (...args) => inst.check(_length(...args));
    inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
    inst.lowercase = (params) => inst.check(_lowercase(params));
    inst.uppercase = (params) => inst.check(_uppercase(params));
    inst.trim = () => inst.check(_trim());
    inst.normalize = (...args) => inst.check(_normalize(...args));
    inst.toLowerCase = () => inst.check(_toLowerCase());
    inst.toUpperCase = () => inst.check(_toUpperCase());
    inst.slugify = () => inst.check(_slugify());
  });
  ZodString2 = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
    $ZodString.init(inst, def);
    _ZodString.init(inst, def);
    inst.email = (params) => inst.check(_email(ZodEmail, params));
    inst.url = (params) => inst.check(_url(ZodURL, params));
    inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
    inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
    inst.guid = (params) => inst.check(_guid(ZodGUID, params));
    inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
    inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
    inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
    inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
    inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
    inst.guid = (params) => inst.check(_guid(ZodGUID, params));
    inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
    inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
    inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
    inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
    inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
    inst.xid = (params) => inst.check(_xid(ZodXID, params));
    inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
    inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
    inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
    inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
    inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
    inst.e164 = (params) => inst.check(_e164(ZodE164, params));
    inst.datetime = (params) => inst.check(datetime2(params));
    inst.date = (params) => inst.check(date3(params));
    inst.time = (params) => inst.check(time3(params));
    inst.duration = (params) => inst.check(duration2(params));
  });
  ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    _ZodString.init(inst, def);
  });
  ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
    $ZodEmail.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
    $ZodGUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
    $ZodUUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
    $ZodURL.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
    $ZodEmoji.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
    $ZodNanoID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
    $ZodCUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
    $ZodCUID2.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
    $ZodULID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
    $ZodXID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
    $ZodKSUID.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
    $ZodIPv4.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
    $ZodMAC.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
    $ZodIPv6.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
    $ZodCIDRv4.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
    $ZodCIDRv6.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
    $ZodBase64.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
    $ZodBase64URL.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
    $ZodE164.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
    $ZodJWT.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
    $ZodCustomStringFormat.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
  ZodNumber2 = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
    $ZodNumber.init(inst, def);
    ZodType2.init(inst, def);
    inst.gt = (value, params) => inst.check(_gt(value, params));
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.lt = (value, params) => inst.check(_lt(value, params));
    inst.lte = (value, params) => inst.check(_lte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    inst.int = (params) => inst.check(int(params));
    inst.safe = (params) => inst.check(int(params));
    inst.positive = (params) => inst.check(_gt(0, params));
    inst.nonnegative = (params) => inst.check(_gte(0, params));
    inst.negative = (params) => inst.check(_lt(0, params));
    inst.nonpositive = (params) => inst.check(_lte(0, params));
    inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
    inst.step = (value, params) => inst.check(_multipleOf(value, params));
    inst.finite = () => inst;
    const bag = inst._zod.bag;
    inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
    inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
    inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
    inst.isFinite = true;
    inst.format = bag.format ?? null;
  });
  ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
    $ZodNumberFormat.init(inst, def);
    ZodNumber2.init(inst, def);
  });
  ZodBoolean2 = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
    $ZodBoolean.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodBigInt2 = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
    $ZodBigInt.init(inst, def);
    ZodType2.init(inst, def);
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.gt = (value, params) => inst.check(_gt(value, params));
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.lt = (value, params) => inst.check(_lt(value, params));
    inst.lte = (value, params) => inst.check(_lte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    inst.positive = (params) => inst.check(_gt(BigInt(0), params));
    inst.negative = (params) => inst.check(_lt(BigInt(0), params));
    inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
    inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
    inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
    const bag = inst._zod.bag;
    inst.minValue = bag.minimum ?? null;
    inst.maxValue = bag.maximum ?? null;
    inst.format = bag.format ?? null;
  });
  ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
    $ZodBigIntFormat.init(inst, def);
    ZodBigInt2.init(inst, def);
  });
  ZodSymbol2 = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
    $ZodSymbol.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodUndefined2 = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
    $ZodUndefined.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodNull2 = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
    $ZodNull.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodAny2 = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
    $ZodAny.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodUnknown2 = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
    $ZodUnknown.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodNever2 = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
    $ZodNever.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodVoid2 = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
    $ZodVoid.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodDate2 = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
    $ZodDate.init(inst, def);
    ZodType2.init(inst, def);
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    const c = inst._zod.bag;
    inst.minDate = c.minimum ? new Date(c.minimum) : null;
    inst.maxDate = c.maximum ? new Date(c.maximum) : null;
  });
  ZodArray2 = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
    $ZodArray.init(inst, def);
    ZodType2.init(inst, def);
    inst.element = def.element;
    inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
    inst.nonempty = (params) => inst.check(_minLength(1, params));
    inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
    inst.length = (len, params) => inst.check(_length(len, params));
    inst.unwrap = () => inst.element;
  });
  ZodObject2 = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
    $ZodObjectJIT.init(inst, def);
    ZodType2.init(inst, def);
    exports_util.defineLazy(inst, "shape", () => {
      return def.shape;
    });
    inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
    inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
    inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
    inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
    inst.extend = (incoming) => {
      return exports_util.extend(inst, incoming);
    };
    inst.safeExtend = (incoming) => {
      return exports_util.safeExtend(inst, incoming);
    };
    inst.merge = (other) => exports_util.merge(inst, other);
    inst.pick = (mask) => exports_util.pick(inst, mask);
    inst.omit = (mask) => exports_util.omit(inst, mask);
    inst.partial = (...args) => exports_util.partial(ZodOptional2, inst, args[0]);
    inst.required = (...args) => exports_util.required(ZodNonOptional, inst, args[0]);
  });
  ZodUnion2 = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
    $ZodUnion.init(inst, def);
    ZodType2.init(inst, def);
    inst.options = def.options;
  });
  ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
    ZodUnion2.init(inst, def);
    $ZodDiscriminatedUnion.init(inst, def);
  });
  ZodIntersection2 = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
    $ZodIntersection.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodTuple2 = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
    $ZodTuple.init(inst, def);
    ZodType2.init(inst, def);
    inst.rest = (rest) => inst.clone({
      ...inst._zod.def,
      rest
    });
  });
  ZodRecord2 = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
    $ZodRecord.init(inst, def);
    ZodType2.init(inst, def);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
  });
  ZodMap2 = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
    $ZodMap.init(inst, def);
    ZodType2.init(inst, def);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
  });
  ZodSet2 = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
    $ZodSet.init(inst, def);
    ZodType2.init(inst, def);
    inst.min = (...args) => inst.check(_minSize(...args));
    inst.nonempty = (params) => inst.check(_minSize(1, params));
    inst.max = (...args) => inst.check(_maxSize(...args));
    inst.size = (...args) => inst.check(_size(...args));
  });
  ZodEnum2 = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
    $ZodEnum.init(inst, def);
    ZodType2.init(inst, def);
    inst.enum = def.entries;
    inst.options = Object.values(def.entries);
    const keys = new Set(Object.keys(def.entries));
    inst.extract = (values, params) => {
      const newEntries = {};
      for (const value of values) {
        if (keys.has(value)) {
          newEntries[value] = def.entries[value];
        } else
          throw new Error(`Key ${value} not found in enum`);
      }
      return new ZodEnum2({
        ...def,
        checks: [],
        ...exports_util.normalizeParams(params),
        entries: newEntries
      });
    };
    inst.exclude = (values, params) => {
      const newEntries = { ...def.entries };
      for (const value of values) {
        if (keys.has(value)) {
          delete newEntries[value];
        } else
          throw new Error(`Key ${value} not found in enum`);
      }
      return new ZodEnum2({
        ...def,
        checks: [],
        ...exports_util.normalizeParams(params),
        entries: newEntries
      });
    };
  });
  ZodLiteral2 = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
    $ZodLiteral.init(inst, def);
    ZodType2.init(inst, def);
    inst.values = new Set(def.values);
    Object.defineProperty(inst, "value", {
      get() {
        if (def.values.length > 1) {
          throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
        }
        return def.values[0];
      }
    });
  });
  ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
    $ZodFile.init(inst, def);
    ZodType2.init(inst, def);
    inst.min = (size, params) => inst.check(_minSize(size, params));
    inst.max = (size, params) => inst.check(_maxSize(size, params));
    inst.mime = (types2, params) => inst.check(_mime(Array.isArray(types2) ? types2 : [types2], params));
  });
  ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
    $ZodTransform.init(inst, def);
    ZodType2.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (_ctx.direction === "backward") {
        throw new $ZodEncodeError(inst.constructor.name);
      }
      payload.addIssue = (issue2) => {
        if (typeof issue2 === "string") {
          payload.issues.push(exports_util.issue(issue2, payload.value, def));
        } else {
          const _issue = issue2;
          if (_issue.fatal)
            _issue.continue = false;
          _issue.code ?? (_issue.code = "custom");
          _issue.input ?? (_issue.input = payload.value);
          _issue.inst ?? (_issue.inst = inst);
          payload.issues.push(exports_util.issue(_issue));
        }
      };
      const output = def.transform(payload.value, payload);
      if (output instanceof Promise) {
        return output.then((output2) => {
          payload.value = output2;
          return payload;
        });
      }
      payload.value = output;
      return payload;
    };
  });
  ZodOptional2 = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
    $ZodOptional.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodNullable2 = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
    $ZodNullable.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodDefault2 = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
    $ZodDefault.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeDefault = inst.unwrap;
  });
  ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
    $ZodPrefault.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
    $ZodNonOptional.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
    $ZodSuccess.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodCatch2 = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
    $ZodCatch.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeCatch = inst.unwrap;
  });
  ZodNaN2 = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
    $ZodNaN.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
    $ZodPipe.init(inst, def);
    ZodType2.init(inst, def);
    inst.in = def.in;
    inst.out = def.out;
  });
  ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
    ZodPipe.init(inst, def);
    $ZodCodec.init(inst, def);
  });
  ZodReadonly2 = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
    $ZodReadonly.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
    $ZodTemplateLiteral.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodLazy2 = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
    $ZodLazy.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.getter();
  });
  ZodPromise2 = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
    $ZodPromise.init(inst, def);
    ZodType2.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
  ZodFunction2 = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
    $ZodFunction.init(inst, def);
    ZodType2.init(inst, def);
  });
  ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
    $ZodCustom.init(inst, def);
    ZodType2.init(inst, def);
  });
  describe2 = describe;
  meta2 = meta;
});

// node_modules/zod/v4/classic/compat.js
function setErrorMap2(map2) {
  config({
    customError: map2
  });
}
function getErrorMap2() {
  return config().customError;
}
var ZodIssueCode2, ZodFirstPartyTypeKind2;
var init_compat = __esm(() => {
  init_core2();
  ZodIssueCode2 = {
    invalid_type: "invalid_type",
    too_big: "too_big",
    too_small: "too_small",
    invalid_format: "invalid_format",
    not_multiple_of: "not_multiple_of",
    unrecognized_keys: "unrecognized_keys",
    invalid_union: "invalid_union",
    invalid_key: "invalid_key",
    invalid_element: "invalid_element",
    invalid_value: "invalid_value",
    custom: "custom"
  };
  (function(ZodFirstPartyTypeKind3) {})(ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {}));
});

// node_modules/zod/v4/classic/coerce.js
var exports_coerce2 = {};
__export(exports_coerce2, {
  string: () => string3,
  number: () => number3,
  date: () => date5,
  boolean: () => boolean3,
  bigint: () => bigint3
});
function string3(params) {
  return _coercedString(ZodString2, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber2, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean2, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt2, params);
}
function date5(params) {
  return _coercedDate(ZodDate2, params);
}
var init_coerce2 = __esm(() => {
  init_core2();
  init_schemas3();
});

// node_modules/zod/v4/classic/external.js
var exports_external2 = {};
__export(exports_external2, {
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid3,
  util: () => exports_util,
  url: () => url,
  uppercase: () => _uppercase,
  unknown: () => unknown,
  union: () => union,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  trim: () => _trim,
  treeifyError: () => treeifyError,
  transform: () => transform,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  toJSONSchema: () => toJSONSchema,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  startsWith: () => _startsWith,
  slugify: () => _slugify,
  size: () => _size,
  setErrorMap: () => setErrorMap2,
  set: () => set,
  safeParseAsync: () => safeParseAsync2,
  safeParse: () => safeParse3,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeEncode: () => safeEncode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeDecode: () => safeDecode2,
  registry: () => registry,
  regexes: () => exports_regexes,
  regex: () => _regex,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  property: () => _property,
  promise: () => promise,
  prettifyError: () => prettifyError,
  preprocess: () => preprocess,
  prefault: () => prefault,
  positive: () => _positive,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  parseAsync: () => parseAsync2,
  parse: () => parse5,
  overwrite: () => _overwrite,
  optional: () => optional,
  object: () => object2,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonoptional: () => nonoptional,
  nonnegative: () => _nonnegative,
  never: () => never,
  negative: () => _negative,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  meta: () => meta2,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  map: () => map,
  mac: () => mac2,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  looseObject: () => looseObject,
  locales: () => exports_locales,
  literal: () => literal,
  length: () => _length,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json,
  iso: () => exports_iso2,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  includes: () => _includes,
  httpUrl: () => httpUrl,
  hostname: () => hostname2,
  hex: () => hex2,
  hash: () => hash,
  guid: () => guid2,
  gte: () => _gte,
  gt: () => _gt,
  globalRegistry: () => globalRegistry,
  getErrorMap: () => getErrorMap2,
  function: () => _function,
  formatError: () => formatError,
  float64: () => float64,
  float32: () => float32,
  flattenError: () => flattenError,
  file: () => file,
  enum: () => _enum2,
  endsWith: () => _endsWith,
  encodeAsync: () => encodeAsync2,
  encode: () => encode2,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  describe: () => describe2,
  decodeAsync: () => decodeAsync2,
  decode: () => decode2,
  date: () => date4,
  custom: () => custom2,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  core: () => exports_core2,
  config: () => config,
  coerce: () => exports_coerce2,
  codec: () => codec,
  clone: () => clone,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check,
  catch: () => _catch2,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url2,
  base64: () => base643,
  array: () => array,
  any: () => any,
  _function: () => _function,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid2,
  ZodUnknown: () => ZodUnknown2,
  ZodUnion: () => ZodUnion2,
  ZodUndefined: () => ZodUndefined2,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType2,
  ZodTuple: () => ZodTuple2,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol2,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString2,
  ZodSet: () => ZodSet2,
  ZodRecord: () => ZodRecord2,
  ZodRealError: () => ZodRealError,
  ZodReadonly: () => ZodReadonly2,
  ZodPromise: () => ZodPromise2,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional2,
  ZodObject: () => ZodObject2,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber2,
  ZodNullable: () => ZodNullable2,
  ZodNull: () => ZodNull2,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever2,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN2,
  ZodMap: () => ZodMap2,
  ZodMAC: () => ZodMAC,
  ZodLiteral: () => ZodLiteral2,
  ZodLazy: () => ZodLazy2,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIssueCode: () => ZodIssueCode2,
  ZodIntersection: () => ZodIntersection2,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFunction: () => ZodFunction2,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind2,
  ZodFile: () => ZodFile,
  ZodError: () => ZodError3,
  ZodEnum: () => ZodEnum2,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodDefault: () => ZodDefault2,
  ZodDate: () => ZodDate2,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCodec: () => ZodCodec,
  ZodCatch: () => ZodCatch2,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean2,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt2,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray2,
  ZodAny: () => ZodAny2,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  $output: () => $output,
  $input: () => $input,
  $brand: () => $brand
});
var init_external3 = __esm(() => {
  init_core2();
  init_schemas3();
  init_checks3();
  init_errors3();
  init_parse3();
  init_compat();
  init_core2();
  init_en();
  init_core2();
  init_locales();
  init_iso2();
  init_iso2();
  init_coerce2();
  config(en_default());
});

// node_modules/zod/v4/classic/index.js
var init_classic = __esm(() => {
  init_external3();
  init_external3();
});

// node_modules/zod/v4/index.js
var init_v4 = __esm(() => {
  init_classic();
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
var exports_types = {};
__export(exports_types, {
  isJSONRPCResponse: () => isJSONRPCResponse,
  isJSONRPCRequest: () => isJSONRPCRequest,
  isJSONRPCNotification: () => isJSONRPCNotification,
  isJSONRPCError: () => isJSONRPCError,
  isInitializedNotification: () => isInitializedNotification,
  isInitializeRequest: () => isInitializeRequest,
  assertCompleteRequestResourceTemplate: () => assertCompleteRequestResourceTemplate,
  assertCompleteRequestPrompt: () => assertCompleteRequestPrompt,
  UrlElicitationRequiredError: () => UrlElicitationRequiredError,
  UntitledSingleSelectEnumSchemaSchema: () => UntitledSingleSelectEnumSchemaSchema,
  UntitledMultiSelectEnumSchemaSchema: () => UntitledMultiSelectEnumSchemaSchema,
  UnsubscribeRequestSchema: () => UnsubscribeRequestSchema,
  UnsubscribeRequestParamsSchema: () => UnsubscribeRequestParamsSchema,
  ToolUseContentSchema: () => ToolUseContentSchema,
  ToolSchema: () => ToolSchema,
  ToolResultContentSchema: () => ToolResultContentSchema,
  ToolListChangedNotificationSchema: () => ToolListChangedNotificationSchema,
  ToolExecutionSchema: () => ToolExecutionSchema,
  ToolChoiceSchema: () => ToolChoiceSchema,
  ToolAnnotationsSchema: () => ToolAnnotationsSchema,
  TitledSingleSelectEnumSchemaSchema: () => TitledSingleSelectEnumSchemaSchema,
  TitledMultiSelectEnumSchemaSchema: () => TitledMultiSelectEnumSchemaSchema,
  TextResourceContentsSchema: () => TextResourceContentsSchema,
  TextContentSchema: () => TextContentSchema,
  TaskStatusNotificationSchema: () => TaskStatusNotificationSchema,
  TaskStatusNotificationParamsSchema: () => TaskStatusNotificationParamsSchema,
  TaskSchema: () => TaskSchema,
  TaskCreationParamsSchema: () => TaskCreationParamsSchema,
  SubscribeRequestSchema: () => SubscribeRequestSchema,
  SubscribeRequestParamsSchema: () => SubscribeRequestParamsSchema,
  StringSchemaSchema: () => StringSchemaSchema,
  SingleSelectEnumSchemaSchema: () => SingleSelectEnumSchemaSchema,
  SetLevelRequestSchema: () => SetLevelRequestSchema,
  SetLevelRequestParamsSchema: () => SetLevelRequestParamsSchema,
  ServerTasksCapabilitySchema: () => ServerTasksCapabilitySchema,
  ServerResultSchema: () => ServerResultSchema,
  ServerRequestSchema: () => ServerRequestSchema,
  ServerNotificationSchema: () => ServerNotificationSchema,
  ServerCapabilitiesSchema: () => ServerCapabilitiesSchema,
  SamplingMessageSchema: () => SamplingMessageSchema,
  SamplingMessageContentBlockSchema: () => SamplingMessageContentBlockSchema,
  SamplingContentSchema: () => SamplingContentSchema,
  SUPPORTED_PROTOCOL_VERSIONS: () => SUPPORTED_PROTOCOL_VERSIONS,
  RootsListChangedNotificationSchema: () => RootsListChangedNotificationSchema,
  RootSchema: () => RootSchema,
  ResultSchema: () => ResultSchema,
  ResourceUpdatedNotificationSchema: () => ResourceUpdatedNotificationSchema,
  ResourceUpdatedNotificationParamsSchema: () => ResourceUpdatedNotificationParamsSchema,
  ResourceTemplateSchema: () => ResourceTemplateSchema,
  ResourceTemplateReferenceSchema: () => ResourceTemplateReferenceSchema,
  ResourceSchema: () => ResourceSchema,
  ResourceRequestParamsSchema: () => ResourceRequestParamsSchema,
  ResourceReferenceSchema: () => ResourceReferenceSchema,
  ResourceListChangedNotificationSchema: () => ResourceListChangedNotificationSchema,
  ResourceLinkSchema: () => ResourceLinkSchema,
  ResourceContentsSchema: () => ResourceContentsSchema,
  RequestSchema: () => RequestSchema,
  RequestIdSchema: () => RequestIdSchema,
  RelatedTaskMetadataSchema: () => RelatedTaskMetadataSchema,
  ReadResourceResultSchema: () => ReadResourceResultSchema,
  ReadResourceRequestSchema: () => ReadResourceRequestSchema,
  ReadResourceRequestParamsSchema: () => ReadResourceRequestParamsSchema,
  RELATED_TASK_META_KEY: () => RELATED_TASK_META_KEY,
  PromptSchema: () => PromptSchema,
  PromptReferenceSchema: () => PromptReferenceSchema,
  PromptMessageSchema: () => PromptMessageSchema,
  PromptListChangedNotificationSchema: () => PromptListChangedNotificationSchema,
  PromptArgumentSchema: () => PromptArgumentSchema,
  ProgressTokenSchema: () => ProgressTokenSchema,
  ProgressSchema: () => ProgressSchema,
  ProgressNotificationSchema: () => ProgressNotificationSchema,
  ProgressNotificationParamsSchema: () => ProgressNotificationParamsSchema,
  PrimitiveSchemaDefinitionSchema: () => PrimitiveSchemaDefinitionSchema,
  PingRequestSchema: () => PingRequestSchema,
  PaginatedResultSchema: () => PaginatedResultSchema,
  PaginatedRequestSchema: () => PaginatedRequestSchema,
  PaginatedRequestParamsSchema: () => PaginatedRequestParamsSchema,
  NumberSchemaSchema: () => NumberSchemaSchema,
  NotificationSchema: () => NotificationSchema,
  MultiSelectEnumSchemaSchema: () => MultiSelectEnumSchemaSchema,
  ModelPreferencesSchema: () => ModelPreferencesSchema,
  ModelHintSchema: () => ModelHintSchema,
  McpError: () => McpError,
  LoggingMessageNotificationSchema: () => LoggingMessageNotificationSchema,
  LoggingMessageNotificationParamsSchema: () => LoggingMessageNotificationParamsSchema,
  LoggingLevelSchema: () => LoggingLevelSchema,
  ListToolsResultSchema: () => ListToolsResultSchema,
  ListToolsRequestSchema: () => ListToolsRequestSchema,
  ListTasksResultSchema: () => ListTasksResultSchema,
  ListTasksRequestSchema: () => ListTasksRequestSchema,
  ListRootsResultSchema: () => ListRootsResultSchema,
  ListRootsRequestSchema: () => ListRootsRequestSchema,
  ListResourcesResultSchema: () => ListResourcesResultSchema,
  ListResourcesRequestSchema: () => ListResourcesRequestSchema,
  ListResourceTemplatesResultSchema: () => ListResourceTemplatesResultSchema,
  ListResourceTemplatesRequestSchema: () => ListResourceTemplatesRequestSchema,
  ListPromptsResultSchema: () => ListPromptsResultSchema,
  ListPromptsRequestSchema: () => ListPromptsRequestSchema,
  LegacyTitledEnumSchemaSchema: () => LegacyTitledEnumSchemaSchema,
  LATEST_PROTOCOL_VERSION: () => LATEST_PROTOCOL_VERSION,
  JSONRPC_VERSION: () => JSONRPC_VERSION,
  JSONRPCResponseSchema: () => JSONRPCResponseSchema,
  JSONRPCRequestSchema: () => JSONRPCRequestSchema,
  JSONRPCNotificationSchema: () => JSONRPCNotificationSchema,
  JSONRPCMessageSchema: () => JSONRPCMessageSchema,
  JSONRPCErrorSchema: () => JSONRPCErrorSchema,
  InitializedNotificationSchema: () => InitializedNotificationSchema,
  InitializeResultSchema: () => InitializeResultSchema,
  InitializeRequestSchema: () => InitializeRequestSchema,
  InitializeRequestParamsSchema: () => InitializeRequestParamsSchema,
  ImplementationSchema: () => ImplementationSchema,
  ImageContentSchema: () => ImageContentSchema,
  IconsSchema: () => IconsSchema,
  IconSchema: () => IconSchema,
  GetTaskResultSchema: () => GetTaskResultSchema,
  GetTaskRequestSchema: () => GetTaskRequestSchema,
  GetTaskPayloadRequestSchema: () => GetTaskPayloadRequestSchema,
  GetPromptResultSchema: () => GetPromptResultSchema,
  GetPromptRequestSchema: () => GetPromptRequestSchema,
  GetPromptRequestParamsSchema: () => GetPromptRequestParamsSchema,
  ErrorCode: () => ErrorCode,
  EnumSchemaSchema: () => EnumSchemaSchema,
  EmptyResultSchema: () => EmptyResultSchema,
  EmbeddedResourceSchema: () => EmbeddedResourceSchema,
  ElicitationCompleteNotificationSchema: () => ElicitationCompleteNotificationSchema,
  ElicitationCompleteNotificationParamsSchema: () => ElicitationCompleteNotificationParamsSchema,
  ElicitResultSchema: () => ElicitResultSchema,
  ElicitRequestURLParamsSchema: () => ElicitRequestURLParamsSchema,
  ElicitRequestSchema: () => ElicitRequestSchema,
  ElicitRequestParamsSchema: () => ElicitRequestParamsSchema,
  ElicitRequestFormParamsSchema: () => ElicitRequestFormParamsSchema,
  DEFAULT_NEGOTIATED_PROTOCOL_VERSION: () => DEFAULT_NEGOTIATED_PROTOCOL_VERSION,
  CursorSchema: () => CursorSchema,
  CreateTaskResultSchema: () => CreateTaskResultSchema,
  CreateMessageResultWithToolsSchema: () => CreateMessageResultWithToolsSchema,
  CreateMessageResultSchema: () => CreateMessageResultSchema,
  CreateMessageRequestSchema: () => CreateMessageRequestSchema,
  CreateMessageRequestParamsSchema: () => CreateMessageRequestParamsSchema,
  ContentBlockSchema: () => ContentBlockSchema,
  CompleteResultSchema: () => CompleteResultSchema,
  CompleteRequestSchema: () => CompleteRequestSchema,
  CompleteRequestParamsSchema: () => CompleteRequestParamsSchema,
  CompatibilityCallToolResultSchema: () => CompatibilityCallToolResultSchema,
  ClientTasksCapabilitySchema: () => ClientTasksCapabilitySchema,
  ClientResultSchema: () => ClientResultSchema,
  ClientRequestSchema: () => ClientRequestSchema,
  ClientNotificationSchema: () => ClientNotificationSchema,
  ClientCapabilitiesSchema: () => ClientCapabilitiesSchema,
  CancelledNotificationSchema: () => CancelledNotificationSchema,
  CancelledNotificationParamsSchema: () => CancelledNotificationParamsSchema,
  CancelTaskResultSchema: () => CancelTaskResultSchema,
  CancelTaskRequestSchema: () => CancelTaskRequestSchema,
  CallToolResultSchema: () => CallToolResultSchema,
  CallToolRequestSchema: () => CallToolRequestSchema,
  CallToolRequestParamsSchema: () => CallToolRequestParamsSchema,
  BooleanSchemaSchema: () => BooleanSchemaSchema,
  BlobResourceContentsSchema: () => BlobResourceContentsSchema,
  BaseMetadataSchema: () => BaseMetadataSchema,
  AudioContentSchema: () => AudioContentSchema,
  AnnotationsSchema: () => AnnotationsSchema
});
function assertCompleteRequestPrompt(request) {
  if (request.params.ref.type !== "ref/prompt") {
    throw new TypeError(`Expected CompleteRequestPrompt, but got ${request.params.ref.type}`);
  }
}
function assertCompleteRequestResourceTemplate(request) {
  if (request.params.ref.type !== "ref/resource") {
    throw new TypeError(`Expected CompleteRequestResourceTemplate, but got ${request.params.ref.type}`);
  }
}
var LATEST_PROTOCOL_VERSION = "2025-11-25", DEFAULT_NEGOTIATED_PROTOCOL_VERSION = "2025-03-26", SUPPORTED_PROTOCOL_VERSIONS, RELATED_TASK_META_KEY = "io.modelcontextprotocol/related-task", JSONRPC_VERSION = "2.0", AssertObjectSchema, ProgressTokenSchema, CursorSchema, TaskCreationParamsSchema, RelatedTaskMetadataSchema, RequestMetaSchema, BaseRequestParamsSchema, RequestSchema, NotificationsParamsSchema, NotificationSchema, ResultSchema, RequestIdSchema, JSONRPCRequestSchema, isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success, JSONRPCNotificationSchema, isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success, JSONRPCResponseSchema, isJSONRPCResponse = (value) => JSONRPCResponseSchema.safeParse(value).success, ErrorCode, JSONRPCErrorSchema, isJSONRPCError = (value) => JSONRPCErrorSchema.safeParse(value).success, JSONRPCMessageSchema, EmptyResultSchema, CancelledNotificationParamsSchema, CancelledNotificationSchema, IconSchema, IconsSchema, BaseMetadataSchema, ImplementationSchema, FormElicitationCapabilitySchema, ElicitationCapabilitySchema, ClientTasksCapabilitySchema, ServerTasksCapabilitySchema, ClientCapabilitiesSchema, InitializeRequestParamsSchema, InitializeRequestSchema, isInitializeRequest = (value) => InitializeRequestSchema.safeParse(value).success, ServerCapabilitiesSchema, InitializeResultSchema, InitializedNotificationSchema, isInitializedNotification = (value) => InitializedNotificationSchema.safeParse(value).success, PingRequestSchema, ProgressSchema, ProgressNotificationParamsSchema, ProgressNotificationSchema, PaginatedRequestParamsSchema, PaginatedRequestSchema, PaginatedResultSchema, TaskSchema, CreateTaskResultSchema, TaskStatusNotificationParamsSchema, TaskStatusNotificationSchema, GetTaskRequestSchema, GetTaskResultSchema, GetTaskPayloadRequestSchema, ListTasksRequestSchema, ListTasksResultSchema, CancelTaskRequestSchema, CancelTaskResultSchema, ResourceContentsSchema, TextResourceContentsSchema, Base64Schema, BlobResourceContentsSchema, AnnotationsSchema, ResourceSchema, ResourceTemplateSchema, ListResourcesRequestSchema, ListResourcesResultSchema, ListResourceTemplatesRequestSchema, ListResourceTemplatesResultSchema, ResourceRequestParamsSchema, ReadResourceRequestParamsSchema, ReadResourceRequestSchema, ReadResourceResultSchema, ResourceListChangedNotificationSchema, SubscribeRequestParamsSchema, SubscribeRequestSchema, UnsubscribeRequestParamsSchema, UnsubscribeRequestSchema, ResourceUpdatedNotificationParamsSchema, ResourceUpdatedNotificationSchema, PromptArgumentSchema, PromptSchema, ListPromptsRequestSchema, ListPromptsResultSchema, GetPromptRequestParamsSchema, GetPromptRequestSchema, TextContentSchema, ImageContentSchema, AudioContentSchema, ToolUseContentSchema, EmbeddedResourceSchema, ResourceLinkSchema, ContentBlockSchema, PromptMessageSchema, GetPromptResultSchema, PromptListChangedNotificationSchema, ToolAnnotationsSchema, ToolExecutionSchema, ToolSchema, ListToolsRequestSchema, ListToolsResultSchema, CallToolResultSchema, CompatibilityCallToolResultSchema, CallToolRequestParamsSchema, CallToolRequestSchema, ToolListChangedNotificationSchema, LoggingLevelSchema, SetLevelRequestParamsSchema, SetLevelRequestSchema, LoggingMessageNotificationParamsSchema, LoggingMessageNotificationSchema, ModelHintSchema, ModelPreferencesSchema, ToolChoiceSchema, ToolResultContentSchema, SamplingContentSchema, SamplingMessageContentBlockSchema, SamplingMessageSchema, CreateMessageRequestParamsSchema, CreateMessageRequestSchema, CreateMessageResultSchema, CreateMessageResultWithToolsSchema, BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema, UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema, LegacyTitledEnumSchemaSchema, SingleSelectEnumSchemaSchema, UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema, MultiSelectEnumSchemaSchema, EnumSchemaSchema, PrimitiveSchemaDefinitionSchema, ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema, ElicitRequestParamsSchema, ElicitRequestSchema, ElicitationCompleteNotificationParamsSchema, ElicitationCompleteNotificationSchema, ElicitResultSchema, ResourceTemplateReferenceSchema, ResourceReferenceSchema, PromptReferenceSchema, CompleteRequestParamsSchema, CompleteRequestSchema, CompleteResultSchema, RootSchema, ListRootsRequestSchema, ListRootsResultSchema, RootsListChangedNotificationSchema, ClientRequestSchema, ClientNotificationSchema, ClientResultSchema, ServerRequestSchema, ServerNotificationSchema, ServerResultSchema, McpError, UrlElicitationRequiredError;
var init_types2 = __esm(() => {
  init_v4();
  SUPPORTED_PROTOCOL_VERSIONS = [LATEST_PROTOCOL_VERSION, "2025-06-18", "2025-03-26", "2024-11-05", "2024-10-07"];
  AssertObjectSchema = custom2((v) => v !== null && (typeof v === "object" || typeof v === "function"));
  ProgressTokenSchema = union([string2(), number2().int()]);
  CursorSchema = string2();
  TaskCreationParamsSchema = looseObject({
    ttl: union([number2(), _null3()]).optional(),
    pollInterval: number2().optional()
  });
  RelatedTaskMetadataSchema = looseObject({
    taskId: string2()
  });
  RequestMetaSchema = looseObject({
    progressToken: ProgressTokenSchema.optional(),
    [RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()
  });
  BaseRequestParamsSchema = looseObject({
    task: TaskCreationParamsSchema.optional(),
    _meta: RequestMetaSchema.optional()
  });
  RequestSchema = object2({
    method: string2(),
    params: BaseRequestParamsSchema.optional()
  });
  NotificationsParamsSchema = looseObject({
    _meta: object2({
      [RELATED_TASK_META_KEY]: optional(RelatedTaskMetadataSchema)
    }).passthrough().optional()
  });
  NotificationSchema = object2({
    method: string2(),
    params: NotificationsParamsSchema.optional()
  });
  ResultSchema = looseObject({
    _meta: looseObject({
      [RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()
    }).optional()
  });
  RequestIdSchema = union([string2(), number2().int()]);
  JSONRPCRequestSchema = object2({
    jsonrpc: literal(JSONRPC_VERSION),
    id: RequestIdSchema,
    ...RequestSchema.shape
  }).strict();
  JSONRPCNotificationSchema = object2({
    jsonrpc: literal(JSONRPC_VERSION),
    ...NotificationSchema.shape
  }).strict();
  JSONRPCResponseSchema = object2({
    jsonrpc: literal(JSONRPC_VERSION),
    id: RequestIdSchema,
    result: ResultSchema
  }).strict();
  (function(ErrorCode2) {
    ErrorCode2[ErrorCode2["ConnectionClosed"] = -32000] = "ConnectionClosed";
    ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";
    ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";
    ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
    ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
    ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
    ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";
    ErrorCode2[ErrorCode2["UrlElicitationRequired"] = -32042] = "UrlElicitationRequired";
  })(ErrorCode || (ErrorCode = {}));
  JSONRPCErrorSchema = object2({
    jsonrpc: literal(JSONRPC_VERSION),
    id: RequestIdSchema,
    error: object2({
      code: number2().int(),
      message: string2(),
      data: optional(unknown())
    })
  }).strict();
  JSONRPCMessageSchema = union([JSONRPCRequestSchema, JSONRPCNotificationSchema, JSONRPCResponseSchema, JSONRPCErrorSchema]);
  EmptyResultSchema = ResultSchema.strict();
  CancelledNotificationParamsSchema = NotificationsParamsSchema.extend({
    requestId: RequestIdSchema,
    reason: string2().optional()
  });
  CancelledNotificationSchema = NotificationSchema.extend({
    method: literal("notifications/cancelled"),
    params: CancelledNotificationParamsSchema
  });
  IconSchema = object2({
    src: string2(),
    mimeType: string2().optional(),
    sizes: array(string2()).optional()
  });
  IconsSchema = object2({
    icons: array(IconSchema).optional()
  });
  BaseMetadataSchema = object2({
    name: string2(),
    title: string2().optional()
  });
  ImplementationSchema = BaseMetadataSchema.extend({
    ...BaseMetadataSchema.shape,
    ...IconsSchema.shape,
    version: string2(),
    websiteUrl: string2().optional()
  });
  FormElicitationCapabilitySchema = intersection(object2({
    applyDefaults: boolean2().optional()
  }), record(string2(), unknown()));
  ElicitationCapabilitySchema = preprocess((value) => {
    if (value && typeof value === "object" && !Array.isArray(value)) {
      if (Object.keys(value).length === 0) {
        return { form: {} };
      }
    }
    return value;
  }, intersection(object2({
    form: FormElicitationCapabilitySchema.optional(),
    url: AssertObjectSchema.optional()
  }), record(string2(), unknown()).optional()));
  ClientTasksCapabilitySchema = object2({
    list: optional(object2({}).passthrough()),
    cancel: optional(object2({}).passthrough()),
    requests: optional(object2({
      sampling: optional(object2({
        createMessage: optional(object2({}).passthrough())
      }).passthrough()),
      elicitation: optional(object2({
        create: optional(object2({}).passthrough())
      }).passthrough())
    }).passthrough())
  }).passthrough();
  ServerTasksCapabilitySchema = object2({
    list: optional(object2({}).passthrough()),
    cancel: optional(object2({}).passthrough()),
    requests: optional(object2({
      tools: optional(object2({
        call: optional(object2({}).passthrough())
      }).passthrough())
    }).passthrough())
  }).passthrough();
  ClientCapabilitiesSchema = object2({
    experimental: record(string2(), AssertObjectSchema).optional(),
    sampling: object2({
      context: AssertObjectSchema.optional(),
      tools: AssertObjectSchema.optional()
    }).optional(),
    elicitation: ElicitationCapabilitySchema.optional(),
    roots: object2({
      listChanged: boolean2().optional()
    }).optional(),
    tasks: optional(ClientTasksCapabilitySchema)
  });
  InitializeRequestParamsSchema = BaseRequestParamsSchema.extend({
    protocolVersion: string2(),
    capabilities: ClientCapabilitiesSchema,
    clientInfo: ImplementationSchema
  });
  InitializeRequestSchema = RequestSchema.extend({
    method: literal("initialize"),
    params: InitializeRequestParamsSchema
  });
  ServerCapabilitiesSchema = object2({
    experimental: record(string2(), AssertObjectSchema).optional(),
    logging: AssertObjectSchema.optional(),
    completions: AssertObjectSchema.optional(),
    prompts: optional(object2({
      listChanged: optional(boolean2())
    })),
    resources: object2({
      subscribe: boolean2().optional(),
      listChanged: boolean2().optional()
    }).optional(),
    tools: object2({
      listChanged: boolean2().optional()
    }).optional(),
    tasks: optional(ServerTasksCapabilitySchema)
  }).passthrough();
  InitializeResultSchema = ResultSchema.extend({
    protocolVersion: string2(),
    capabilities: ServerCapabilitiesSchema,
    serverInfo: ImplementationSchema,
    instructions: string2().optional()
  });
  InitializedNotificationSchema = NotificationSchema.extend({
    method: literal("notifications/initialized")
  });
  PingRequestSchema = RequestSchema.extend({
    method: literal("ping")
  });
  ProgressSchema = object2({
    progress: number2(),
    total: optional(number2()),
    message: optional(string2())
  });
  ProgressNotificationParamsSchema = object2({
    ...NotificationsParamsSchema.shape,
    ...ProgressSchema.shape,
    progressToken: ProgressTokenSchema
  });
  ProgressNotificationSchema = NotificationSchema.extend({
    method: literal("notifications/progress"),
    params: ProgressNotificationParamsSchema
  });
  PaginatedRequestParamsSchema = BaseRequestParamsSchema.extend({
    cursor: CursorSchema.optional()
  });
  PaginatedRequestSchema = RequestSchema.extend({
    params: PaginatedRequestParamsSchema.optional()
  });
  PaginatedResultSchema = ResultSchema.extend({
    nextCursor: optional(CursorSchema)
  });
  TaskSchema = object2({
    taskId: string2(),
    status: _enum2(["working", "input_required", "completed", "failed", "cancelled"]),
    ttl: union([number2(), _null3()]),
    createdAt: string2(),
    lastUpdatedAt: string2(),
    pollInterval: optional(number2()),
    statusMessage: optional(string2())
  });
  CreateTaskResultSchema = ResultSchema.extend({
    task: TaskSchema
  });
  TaskStatusNotificationParamsSchema = NotificationsParamsSchema.merge(TaskSchema);
  TaskStatusNotificationSchema = NotificationSchema.extend({
    method: literal("notifications/tasks/status"),
    params: TaskStatusNotificationParamsSchema
  });
  GetTaskRequestSchema = RequestSchema.extend({
    method: literal("tasks/get"),
    params: BaseRequestParamsSchema.extend({
      taskId: string2()
    })
  });
  GetTaskResultSchema = ResultSchema.merge(TaskSchema);
  GetTaskPayloadRequestSchema = RequestSchema.extend({
    method: literal("tasks/result"),
    params: BaseRequestParamsSchema.extend({
      taskId: string2()
    })
  });
  ListTasksRequestSchema = PaginatedRequestSchema.extend({
    method: literal("tasks/list")
  });
  ListTasksResultSchema = PaginatedResultSchema.extend({
    tasks: array(TaskSchema)
  });
  CancelTaskRequestSchema = RequestSchema.extend({
    method: literal("tasks/cancel"),
    params: BaseRequestParamsSchema.extend({
      taskId: string2()
    })
  });
  CancelTaskResultSchema = ResultSchema.merge(TaskSchema);
  ResourceContentsSchema = object2({
    uri: string2(),
    mimeType: optional(string2()),
    _meta: record(string2(), unknown()).optional()
  });
  TextResourceContentsSchema = ResourceContentsSchema.extend({
    text: string2()
  });
  Base64Schema = string2().refine((val) => {
    try {
      atob(val);
      return true;
    } catch (_a2) {
      return false;
    }
  }, { message: "Invalid Base64 string" });
  BlobResourceContentsSchema = ResourceContentsSchema.extend({
    blob: Base64Schema
  });
  AnnotationsSchema = object2({
    audience: array(_enum2(["user", "assistant"])).optional(),
    priority: number2().min(0).max(1).optional(),
    lastModified: exports_iso2.datetime({ offset: true }).optional()
  });
  ResourceSchema = object2({
    ...BaseMetadataSchema.shape,
    ...IconsSchema.shape,
    uri: string2(),
    description: optional(string2()),
    mimeType: optional(string2()),
    annotations: AnnotationsSchema.optional(),
    _meta: optional(looseObject({}))
  });
  ResourceTemplateSchema = object2({
    ...BaseMetadataSchema.shape,
    ...IconsSchema.shape,
    uriTemplate: string2(),
    description: optional(string2()),
    mimeType: optional(string2()),
    annotations: AnnotationsSchema.optional(),
    _meta: optional(looseObject({}))
  });
  ListResourcesRequestSchema = PaginatedRequestSchema.extend({
    method: literal("resources/list")
  });
  ListResourcesResultSchema = PaginatedResultSchema.extend({
    resources: array(ResourceSchema)
  });
  ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
    method: literal("resources/templates/list")
  });
  ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
    resourceTemplates: array(ResourceTemplateSchema)
  });
  ResourceRequestParamsSchema = BaseRequestParamsSchema.extend({
    uri: string2()
  });
  ReadResourceRequestParamsSchema = ResourceRequestParamsSchema;
  ReadResourceRequestSchema = RequestSchema.extend({
    method: literal("resources/read"),
    params: ReadResourceRequestParamsSchema
  });
  ReadResourceResultSchema = ResultSchema.extend({
    contents: array(union([TextResourceContentsSchema, BlobResourceContentsSchema]))
  });
  ResourceListChangedNotificationSchema = NotificationSchema.extend({
    method: literal("notifications/resources/list_changed")
  });
  SubscribeRequestParamsSchema = ResourceRequestParamsSchema;
  SubscribeRequestSchema = RequestSchema.extend({
    method: literal("resources/subscribe"),
    params: SubscribeRequestParamsSchema
  });
  UnsubscribeRequestParamsSchema = ResourceRequestParamsSchema;
  UnsubscribeRequestSchema = RequestSchema.extend({
    method: literal("resources/unsubscribe"),
    params: UnsubscribeRequestParamsSchema
  });
  ResourceUpdatedNotificationParamsSchema = NotificationsParamsSchema.extend({
    uri: string2()
  });
  ResourceUpdatedNotificationSchema = NotificationSchema.extend({
    method: literal("notifications/resources/updated"),
    params: ResourceUpdatedNotificationParamsSchema
  });
  PromptArgumentSchema = object2({
    name: string2(),
    description: optional(string2()),
    required: optional(boolean2())
  });
  PromptSchema = object2({
    ...BaseMetadataSchema.shape,
    ...IconsSchema.shape,
    description: optional(string2()),
    arguments: optional(array(PromptArgumentSchema)),
    _meta: optional(looseObject({}))
  });
  ListPromptsRequestSchema = PaginatedRequestSchema.extend({
    method: literal("prompts/list")
  });
  ListPromptsResultSchema = PaginatedResultSchema.extend({
    prompts: array(PromptSchema)
  });
  GetPromptRequestParamsSchema = BaseRequestParamsSchema.extend({
    name: string2(),
    arguments: record(string2(), string2()).optional()
  });
  GetPromptRequestSchema = RequestSchema.extend({
    method: literal("prompts/get"),
    params: GetPromptRequestParamsSchema
  });
  TextContentSchema = object2({
    type: literal("text"),
    text: string2(),
    annotations: AnnotationsSchema.optional(),
    _meta: record(string2(), unknown()).optional()
  });
  ImageContentSchema = object2({
    type: literal("image"),
    data: Base64Schema,
    mimeType: string2(),
    annotations: AnnotationsSchema.optional(),
    _meta: record(string2(), unknown()).optional()
  });
  AudioContentSchema = object2({
    type: literal("audio"),
    data: Base64Schema,
    mimeType: string2(),
    annotations: AnnotationsSchema.optional(),
    _meta: record(string2(), unknown()).optional()
  });
  ToolUseContentSchema = object2({
    type: literal("tool_use"),
    name: string2(),
    id: string2(),
    input: object2({}).passthrough(),
    _meta: optional(object2({}).passthrough())
  }).passthrough();
  EmbeddedResourceSchema = object2({
    type: literal("resource"),
    resource: union([TextResourceContentsSchema, BlobResourceContentsSchema]),
    annotations: AnnotationsSchema.optional(),
    _meta: record(string2(), unknown()).optional()
  });
  ResourceLinkSchema = ResourceSchema.extend({
    type: literal("resource_link")
  });
  ContentBlockSchema = union([
    TextContentSchema,
    ImageContentSchema,
    AudioContentSchema,
    ResourceLinkSchema,
    EmbeddedResourceSchema
  ]);
  PromptMessageSchema = object2({
    role: _enum2(["user", "assistant"]),
    content: ContentBlockSchema
  });
  GetPromptResultSchema = ResultSchema.extend({
    description: optional(string2()),
    messages: array(PromptMessageSchema)
  });
  PromptListChangedNotificationSchema = NotificationSchema.extend({
    method: literal("notifications/prompts/list_changed")
  });
  ToolAnnotationsSchema = object2({
    title: string2().optional(),
    readOnlyHint: boolean2().optional(),
    destructiveHint: boolean2().optional(),
    idempotentHint: boolean2().optional(),
    openWorldHint: boolean2().optional()
  });
  ToolExecutionSchema = object2({
    taskSupport: _enum2(["required", "optional", "forbidden"]).optional()
  });
  ToolSchema = object2({
    ...BaseMetadataSchema.shape,
    ...IconsSchema.shape,
    description: string2().optional(),
    inputSchema: object2({
      type: literal("object"),
      properties: record(string2(), AssertObjectSchema).optional(),
      required: array(string2()).optional()
    }).catchall(unknown()),
    outputSchema: object2({
      type: literal("object"),
      properties: record(string2(), AssertObjectSchema).optional(),
      required: array(string2()).optional()
    }).catchall(unknown()).optional(),
    annotations: optional(ToolAnnotationsSchema),
    execution: optional(ToolExecutionSchema),
    _meta: record(string2(), unknown()).optional()
  });
  ListToolsRequestSchema = PaginatedRequestSchema.extend({
    method: literal("tools/list")
  });
  ListToolsResultSchema = PaginatedResultSchema.extend({
    tools: array(ToolSchema)
  });
  CallToolResultSchema = ResultSchema.extend({
    content: array(ContentBlockSchema).default([]),
    structuredContent: record(string2(), unknown()).optional(),
    isError: optional(boolean2())
  });
  CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({
    toolResult: unknown()
  }));
  CallToolRequestParamsSchema = BaseRequestParamsSchema.extend({
    name: string2(),
    arguments: optional(record(string2(), unknown()))
  });
  CallToolRequestSchema = RequestSchema.extend({
    method: literal("tools/call"),
    params: CallToolRequestParamsSchema
  });
  ToolListChangedNotificationSchema = NotificationSchema.extend({
    method: literal("notifications/tools/list_changed")
  });
  LoggingLevelSchema = _enum2(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]);
  SetLevelRequestParamsSchema = BaseRequestParamsSchema.extend({
    level: LoggingLevelSchema
  });
  SetLevelRequestSchema = RequestSchema.extend({
    method: literal("logging/setLevel"),
    params: SetLevelRequestParamsSchema
  });
  LoggingMessageNotificationParamsSchema = NotificationsParamsSchema.extend({
    level: LoggingLevelSchema,
    logger: string2().optional(),
    data: unknown()
  });
  LoggingMessageNotificationSchema = NotificationSchema.extend({
    method: literal("notifications/message"),
    params: LoggingMessageNotificationParamsSchema
  });
  ModelHintSchema = object2({
    name: string2().optional()
  });
  ModelPreferencesSchema = object2({
    hints: optional(array(ModelHintSchema)),
    costPriority: optional(number2().min(0).max(1)),
    speedPriority: optional(number2().min(0).max(1)),
    intelligencePriority: optional(number2().min(0).max(1))
  });
  ToolChoiceSchema = object2({
    mode: optional(_enum2(["auto", "required", "none"]))
  });
  ToolResultContentSchema = object2({
    type: literal("tool_result"),
    toolUseId: string2().describe("The unique identifier for the corresponding tool call."),
    content: array(ContentBlockSchema).default([]),
    structuredContent: object2({}).passthrough().optional(),
    isError: optional(boolean2()),
    _meta: optional(object2({}).passthrough())
  }).passthrough();
  SamplingContentSchema = discriminatedUnion("type", [TextContentSchema, ImageContentSchema, AudioContentSchema]);
  SamplingMessageContentBlockSchema = discriminatedUnion("type", [
    TextContentSchema,
    ImageContentSchema,
    AudioContentSchema,
    ToolUseContentSchema,
    ToolResultContentSchema
  ]);
  SamplingMessageSchema = object2({
    role: _enum2(["user", "assistant"]),
    content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)]),
    _meta: optional(object2({}).passthrough())
  }).passthrough();
  CreateMessageRequestParamsSchema = BaseRequestParamsSchema.extend({
    messages: array(SamplingMessageSchema),
    modelPreferences: ModelPreferencesSchema.optional(),
    systemPrompt: string2().optional(),
    includeContext: _enum2(["none", "thisServer", "allServers"]).optional(),
    temperature: number2().optional(),
    maxTokens: number2().int(),
    stopSequences: array(string2()).optional(),
    metadata: AssertObjectSchema.optional(),
    tools: optional(array(ToolSchema)),
    toolChoice: optional(ToolChoiceSchema)
  });
  CreateMessageRequestSchema = RequestSchema.extend({
    method: literal("sampling/createMessage"),
    params: CreateMessageRequestParamsSchema
  });
  CreateMessageResultSchema = ResultSchema.extend({
    model: string2(),
    stopReason: optional(_enum2(["endTurn", "stopSequence", "maxTokens"]).or(string2())),
    role: _enum2(["user", "assistant"]),
    content: SamplingContentSchema
  });
  CreateMessageResultWithToolsSchema = ResultSchema.extend({
    model: string2(),
    stopReason: optional(_enum2(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(string2())),
    role: _enum2(["user", "assistant"]),
    content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)])
  });
  BooleanSchemaSchema = object2({
    type: literal("boolean"),
    title: string2().optional(),
    description: string2().optional(),
    default: boolean2().optional()
  });
  StringSchemaSchema = object2({
    type: literal("string"),
    title: string2().optional(),
    description: string2().optional(),
    minLength: number2().optional(),
    maxLength: number2().optional(),
    format: _enum2(["email", "uri", "date", "date-time"]).optional(),
    default: string2().optional()
  });
  NumberSchemaSchema = object2({
    type: _enum2(["number", "integer"]),
    title: string2().optional(),
    description: string2().optional(),
    minimum: number2().optional(),
    maximum: number2().optional(),
    default: number2().optional()
  });
  UntitledSingleSelectEnumSchemaSchema = object2({
    type: literal("string"),
    title: string2().optional(),
    description: string2().optional(),
    enum: array(string2()),
    default: string2().optional()
  });
  TitledSingleSelectEnumSchemaSchema = object2({
    type: literal("string"),
    title: string2().optional(),
    description: string2().optional(),
    oneOf: array(object2({
      const: string2(),
      title: string2()
    })),
    default: string2().optional()
  });
  LegacyTitledEnumSchemaSchema = object2({
    type: literal("string"),
    title: string2().optional(),
    description: string2().optional(),
    enum: array(string2()),
    enumNames: array(string2()).optional(),
    default: string2().optional()
  });
  SingleSelectEnumSchemaSchema = union([UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema]);
  UntitledMultiSelectEnumSchemaSchema = object2({
    type: literal("array"),
    title: string2().optional(),
    description: string2().optional(),
    minItems: number2().optional(),
    maxItems: number2().optional(),
    items: object2({
      type: literal("string"),
      enum: array(string2())
    }),
    default: array(string2()).optional()
  });
  TitledMultiSelectEnumSchemaSchema = object2({
    type: literal("array"),
    title: string2().optional(),
    description: string2().optional(),
    minItems: number2().optional(),
    maxItems: number2().optional(),
    items: object2({
      anyOf: array(object2({
        const: string2(),
        title: string2()
      }))
    }),
    default: array(string2()).optional()
  });
  MultiSelectEnumSchemaSchema = union([UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema]);
  EnumSchemaSchema = union([LegacyTitledEnumSchemaSchema, SingleSelectEnumSchemaSchema, MultiSelectEnumSchemaSchema]);
  PrimitiveSchemaDefinitionSchema = union([EnumSchemaSchema, BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema]);
  ElicitRequestFormParamsSchema = BaseRequestParamsSchema.extend({
    mode: literal("form").optional(),
    message: string2(),
    requestedSchema: object2({
      type: literal("object"),
      properties: record(string2(), PrimitiveSchemaDefinitionSchema),
      required: array(string2()).optional()
    })
  });
  ElicitRequestURLParamsSchema = BaseRequestParamsSchema.extend({
    mode: literal("url"),
    message: string2(),
    elicitationId: string2(),
    url: string2().url()
  });
  ElicitRequestParamsSchema = union([ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema]);
  ElicitRequestSchema = RequestSchema.extend({
    method: literal("elicitation/create"),
    params: ElicitRequestParamsSchema
  });
  ElicitationCompleteNotificationParamsSchema = NotificationsParamsSchema.extend({
    elicitationId: string2()
  });
  ElicitationCompleteNotificationSchema = NotificationSchema.extend({
    method: literal("notifications/elicitation/complete"),
    params: ElicitationCompleteNotificationParamsSchema
  });
  ElicitResultSchema = ResultSchema.extend({
    action: _enum2(["accept", "decline", "cancel"]),
    content: preprocess((val) => val === null ? undefined : val, record(string2(), union([string2(), number2(), boolean2(), array(string2())])).optional())
  });
  ResourceTemplateReferenceSchema = object2({
    type: literal("ref/resource"),
    uri: string2()
  });
  ResourceReferenceSchema = ResourceTemplateReferenceSchema;
  PromptReferenceSchema = object2({
    type: literal("ref/prompt"),
    name: string2()
  });
  CompleteRequestParamsSchema = BaseRequestParamsSchema.extend({
    ref: union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
    argument: object2({
      name: string2(),
      value: string2()
    }),
    context: object2({
      arguments: record(string2(), string2()).optional()
    }).optional()
  });
  CompleteRequestSchema = RequestSchema.extend({
    method: literal("completion/complete"),
    params: CompleteRequestParamsSchema
  });
  CompleteResultSchema = ResultSchema.extend({
    completion: looseObject({
      values: array(string2()).max(100),
      total: optional(number2().int()),
      hasMore: optional(boolean2())
    })
  });
  RootSchema = object2({
    uri: string2().startsWith("file://"),
    name: string2().optional(),
    _meta: record(string2(), unknown()).optional()
  });
  ListRootsRequestSchema = RequestSchema.extend({
    method: literal("roots/list")
  });
  ListRootsResultSchema = ResultSchema.extend({
    roots: array(RootSchema)
  });
  RootsListChangedNotificationSchema = NotificationSchema.extend({
    method: literal("notifications/roots/list_changed")
  });
  ClientRequestSchema = union([
    PingRequestSchema,
    InitializeRequestSchema,
    CompleteRequestSchema,
    SetLevelRequestSchema,
    GetPromptRequestSchema,
    ListPromptsRequestSchema,
    ListResourcesRequestSchema,
    ListResourceTemplatesRequestSchema,
    ReadResourceRequestSchema,
    SubscribeRequestSchema,
    UnsubscribeRequestSchema,
    CallToolRequestSchema,
    ListToolsRequestSchema,
    GetTaskRequestSchema,
    GetTaskPayloadRequestSchema,
    ListTasksRequestSchema
  ]);
  ClientNotificationSchema = union([
    CancelledNotificationSchema,
    ProgressNotificationSchema,
    InitializedNotificationSchema,
    RootsListChangedNotificationSchema,
    TaskStatusNotificationSchema
  ]);
  ClientResultSchema = union([
    EmptyResultSchema,
    CreateMessageResultSchema,
    CreateMessageResultWithToolsSchema,
    ElicitResultSchema,
    ListRootsResultSchema,
    GetTaskResultSchema,
    ListTasksResultSchema,
    CreateTaskResultSchema
  ]);
  ServerRequestSchema = union([
    PingRequestSchema,
    CreateMessageRequestSchema,
    ElicitRequestSchema,
    ListRootsRequestSchema,
    GetTaskRequestSchema,
    GetTaskPayloadRequestSchema,
    ListTasksRequestSchema
  ]);
  ServerNotificationSchema = union([
    CancelledNotificationSchema,
    ProgressNotificationSchema,
    LoggingMessageNotificationSchema,
    ResourceUpdatedNotificationSchema,
    ResourceListChangedNotificationSchema,
    ToolListChangedNotificationSchema,
    PromptListChangedNotificationSchema,
    TaskStatusNotificationSchema,
    ElicitationCompleteNotificationSchema
  ]);
  ServerResultSchema = union([
    EmptyResultSchema,
    InitializeResultSchema,
    CompleteResultSchema,
    GetPromptResultSchema,
    ListPromptsResultSchema,
    ListResourcesResultSchema,
    ListResourceTemplatesResultSchema,
    ReadResourceResultSchema,
    CallToolResultSchema,
    ListToolsResultSchema,
    GetTaskResultSchema,
    ListTasksResultSchema,
    CreateTaskResultSchema
  ]);
  McpError = class McpError extends Error {
    constructor(code, message, data) {
      super(`MCP error ${code}: ${message}`);
      this.code = code;
      this.data = data;
      this.name = "McpError";
    }
    static fromError(code, message, data) {
      if (code === ErrorCode.UrlElicitationRequired && data) {
        const errorData = data;
        if (errorData.elicitations) {
          return new UrlElicitationRequiredError(errorData.elicitations, message);
        }
      }
      return new McpError(code, message, data);
    }
  };
  UrlElicitationRequiredError = class UrlElicitationRequiredError extends McpError {
    constructor(elicitations, message = `URL elicitation${elicitations.length > 1 ? "s" : ""} required`) {
      super(ErrorCode.UrlElicitationRequired, message, {
        elicitations
      });
    }
    get elicitations() {
      var _a2, _b;
      return (_b = (_a2 = this.data) === null || _a2 === undefined ? undefined : _a2.elicitations) !== null && _b !== undefined ? _b : [];
    }
  };
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/interfaces.js
function isTerminal(status) {
  return status === "completed" || status === "failed" || status === "cancelled";
}

// node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride2;
var init_Options = __esm(() => {
  ignoreOverride2 = Symbol("Let zodToJsonSchema decide on which parser to use");
});

// node_modules/zod-to-json-schema/dist/esm/Refs.js
var init_Refs = __esm(() => {
  init_Options();
});
// node_modules/zod-to-json-schema/dist/esm/parsers/any.js
var init_any = () => {};

// node_modules/zod-to-json-schema/dist/esm/parsers/array.js
var init_array = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
var init_bigint = () => {};
// node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
var init_branded = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
var init_catch = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/date.js
var init_date = () => {};

// node_modules/zod-to-json-schema/dist/esm/parsers/default.js
var init_default = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
var init_effects = __esm(() => {
  init_parseDef();
  init_any();
});
// node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
var init_intersection = __esm(() => {
  init_parseDef();
});
// node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var ALPHA_NUMERIC2;
var init_string = __esm(() => {
  ALPHA_NUMERIC2 = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
});

// node_modules/zod-to-json-schema/dist/esm/parsers/record.js
var init_record = __esm(() => {
  init_parseDef();
  init_string();
  init_branded();
  init_any();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/map.js
var init_map = __esm(() => {
  init_parseDef();
  init_record();
  init_any();
});
// node_modules/zod-to-json-schema/dist/esm/parsers/never.js
var init_never = __esm(() => {
  init_any();
});
// node_modules/zod-to-json-schema/dist/esm/parsers/union.js
var init_union = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
var init_nullable = __esm(() => {
  init_parseDef();
  init_union();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/number.js
var init_number = () => {};

// node_modules/zod-to-json-schema/dist/esm/parsers/object.js
var init_object = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
var init_optional = __esm(() => {
  init_parseDef();
  init_any();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
var init_pipeline = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
var init_promise = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/set.js
var init_set = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
var init_tuple = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
var init_undefined = __esm(() => {
  init_any();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
var init_unknown = __esm(() => {
  init_any();
});

// node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
var init_readonly = __esm(() => {
  init_parseDef();
});

// node_modules/zod-to-json-schema/dist/esm/selectParser.js
var init_selectParser = __esm(() => {
  init_any();
  init_array();
  init_bigint();
  init_branded();
  init_catch();
  init_date();
  init_default();
  init_effects();
  init_intersection();
  init_map();
  init_never();
  init_nullable();
  init_number();
  init_object();
  init_optional();
  init_pipeline();
  init_promise();
  init_record();
  init_set();
  init_string();
  init_tuple();
  init_undefined();
  init_union();
  init_unknown();
  init_readonly();
});

// node_modules/zod-to-json-schema/dist/esm/parseDef.js
var init_parseDef = __esm(() => {
  init_Options();
  init_selectParser();
  init_any();
});

// node_modules/zod-to-json-schema/dist/esm/parseTypes.js
var init_parseTypes = () => {};

// node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
var init_zodToJsonSchema = __esm(() => {
  init_parseDef();
  init_Refs();
  init_any();
});

// node_modules/zod-to-json-schema/dist/esm/index.js
var init_esm = __esm(() => {
  init_Options();
  init_Refs();
  init_parseDef();
  init_parseTypes();
  init_any();
  init_array();
  init_bigint();
  init_branded();
  init_catch();
  init_date();
  init_default();
  init_effects();
  init_intersection();
  init_map();
  init_never();
  init_nullable();
  init_number();
  init_object();
  init_optional();
  init_pipeline();
  init_promise();
  init_readonly();
  init_record();
  init_set();
  init_string();
  init_tuple();
  init_undefined();
  init_union();
  init_unknown();
  init_selectParser();
  init_zodToJsonSchema();
  init_zodToJsonSchema();
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-json-schema-compat.js
function getMethodLiteral(schema) {
  const shape = getObjectShape(schema);
  const methodSchema = shape === null || shape === undefined ? undefined : shape.method;
  if (!methodSchema) {
    throw new Error("Schema is missing a method literal");
  }
  const value = getLiteralValue(methodSchema);
  if (typeof value !== "string") {
    throw new Error("Schema method literal must be a string");
  }
  return value;
}
function parseWithCompat(schema, data) {
  const result = safeParse2(schema, data);
  if (!result.success) {
    throw result.error;
  }
  return result.data;
}
var init_zod_json_schema_compat = __esm(() => {
  init_zod_compat();
  init_esm();
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
class Protocol {
  constructor(_options) {
    this._options = _options;
    this._requestMessageId = 0;
    this._requestHandlers = new Map;
    this._requestHandlerAbortControllers = new Map;
    this._notificationHandlers = new Map;
    this._responseHandlers = new Map;
    this._progressHandlers = new Map;
    this._timeoutInfo = new Map;
    this._pendingDebouncedNotifications = new Set;
    this._taskProgressTokens = new Map;
    this._requestResolvers = new Map;
    this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
      this._oncancel(notification);
    });
    this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
      this._onprogress(notification);
    });
    this.setRequestHandler(PingRequestSchema, (_request) => ({}));
    this._taskStore = _options === null || _options === undefined ? undefined : _options.taskStore;
    this._taskMessageQueue = _options === null || _options === undefined ? undefined : _options.taskMessageQueue;
    if (this._taskStore) {
      this.setRequestHandler(GetTaskRequestSchema, async (request, extra) => {
        const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        }
        return {
          ...task
        };
      });
      this.setRequestHandler(GetTaskPayloadRequestSchema, async (request, extra) => {
        const handleTaskResult = async () => {
          var _a2;
          const taskId = request.params.taskId;
          if (this._taskMessageQueue) {
            let queuedMessage;
            while (queuedMessage = await this._taskMessageQueue.dequeue(taskId, extra.sessionId)) {
              if (queuedMessage.type === "response" || queuedMessage.type === "error") {
                const message = queuedMessage.message;
                const requestId = message.id;
                const resolver = this._requestResolvers.get(requestId);
                if (resolver) {
                  this._requestResolvers.delete(requestId);
                  if (queuedMessage.type === "response") {
                    resolver(message);
                  } else {
                    const errorMessage = message;
                    const error46 = new McpError(errorMessage.error.code, errorMessage.error.message, errorMessage.error.data);
                    resolver(error46);
                  }
                } else {
                  const messageType = queuedMessage.type === "response" ? "Response" : "Error";
                  this._onerror(new Error(`${messageType} handler missing for request ${requestId}`));
                }
                continue;
              }
              await ((_a2 = this._transport) === null || _a2 === undefined ? undefined : _a2.send(queuedMessage.message, { relatedRequestId: extra.requestId }));
            }
          }
          const task = await this._taskStore.getTask(taskId, extra.sessionId);
          if (!task) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found: ${taskId}`);
          }
          if (!isTerminal(task.status)) {
            await this._waitForTaskUpdate(taskId, extra.signal);
            return await handleTaskResult();
          }
          if (isTerminal(task.status)) {
            const result = await this._taskStore.getTaskResult(taskId, extra.sessionId);
            this._clearTaskQueue(taskId);
            return {
              ...result,
              _meta: {
                ...result._meta,
                [RELATED_TASK_META_KEY]: {
                  taskId
                }
              }
            };
          }
          return await handleTaskResult();
        };
        return await handleTaskResult();
      });
      this.setRequestHandler(ListTasksRequestSchema, async (request, extra) => {
        var _a2;
        try {
          const { tasks, nextCursor } = await this._taskStore.listTasks((_a2 = request.params) === null || _a2 === undefined ? undefined : _a2.cursor, extra.sessionId);
          return {
            tasks,
            nextCursor,
            _meta: {}
          };
        } catch (error46) {
          throw new McpError(ErrorCode.InvalidParams, `Failed to list tasks: ${error46 instanceof Error ? error46.message : String(error46)}`);
        }
      });
      this.setRequestHandler(CancelTaskRequestSchema, async (request, extra) => {
        try {
          const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
          if (!task) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found: ${request.params.taskId}`);
          }
          if (isTerminal(task.status)) {
            throw new McpError(ErrorCode.InvalidParams, `Cannot cancel task in terminal status: ${task.status}`);
          }
          await this._taskStore.updateTaskStatus(request.params.taskId, "cancelled", "Client cancelled task execution.", extra.sessionId);
          this._clearTaskQueue(request.params.taskId);
          const cancelledTask = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
          if (!cancelledTask) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found after cancellation: ${request.params.taskId}`);
          }
          return {
            _meta: {},
            ...cancelledTask
          };
        } catch (error46) {
          if (error46 instanceof McpError) {
            throw error46;
          }
          throw new McpError(ErrorCode.InvalidRequest, `Failed to cancel task: ${error46 instanceof Error ? error46.message : String(error46)}`);
        }
      });
    }
  }
  async _oncancel(notification) {
    const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
    controller === null || controller === undefined || controller.abort(notification.params.reason);
  }
  _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
    this._timeoutInfo.set(messageId, {
      timeoutId: setTimeout(onTimeout, timeout),
      startTime: Date.now(),
      timeout,
      maxTotalTimeout,
      resetTimeoutOnProgress,
      onTimeout
    });
  }
  _resetTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (!info)
      return false;
    const totalElapsed = Date.now() - info.startTime;
    if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
      this._timeoutInfo.delete(messageId);
      throw McpError.fromError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
        maxTotalTimeout: info.maxTotalTimeout,
        totalElapsed
      });
    }
    clearTimeout(info.timeoutId);
    info.timeoutId = setTimeout(info.onTimeout, info.timeout);
    return true;
  }
  _cleanupTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (info) {
      clearTimeout(info.timeoutId);
      this._timeoutInfo.delete(messageId);
    }
  }
  async connect(transport) {
    var _a2, _b, _c;
    this._transport = transport;
    const _onclose = (_a2 = this.transport) === null || _a2 === undefined ? undefined : _a2.onclose;
    this._transport.onclose = () => {
      _onclose === null || _onclose === undefined || _onclose();
      this._onclose();
    };
    const _onerror = (_b = this.transport) === null || _b === undefined ? undefined : _b.onerror;
    this._transport.onerror = (error46) => {
      _onerror === null || _onerror === undefined || _onerror(error46);
      this._onerror(error46);
    };
    const _onmessage = (_c = this._transport) === null || _c === undefined ? undefined : _c.onmessage;
    this._transport.onmessage = (message, extra) => {
      _onmessage === null || _onmessage === undefined || _onmessage(message, extra);
      if (isJSONRPCResponse(message) || isJSONRPCError(message)) {
        this._onresponse(message);
      } else if (isJSONRPCRequest(message)) {
        this._onrequest(message, extra);
      } else if (isJSONRPCNotification(message)) {
        this._onnotification(message);
      } else {
        this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
      }
    };
    await this._transport.start();
  }
  _onclose() {
    var _a2;
    const responseHandlers = this._responseHandlers;
    this._responseHandlers = new Map;
    this._progressHandlers.clear();
    this._taskProgressTokens.clear();
    this._pendingDebouncedNotifications.clear();
    const error46 = McpError.fromError(ErrorCode.ConnectionClosed, "Connection closed");
    this._transport = undefined;
    (_a2 = this.onclose) === null || _a2 === undefined || _a2.call(this);
    for (const handler of responseHandlers.values()) {
      handler(error46);
    }
  }
  _onerror(error46) {
    var _a2;
    (_a2 = this.onerror) === null || _a2 === undefined || _a2.call(this, error46);
  }
  _onnotification(notification) {
    var _a2;
    const handler = (_a2 = this._notificationHandlers.get(notification.method)) !== null && _a2 !== undefined ? _a2 : this.fallbackNotificationHandler;
    if (handler === undefined) {
      return;
    }
    Promise.resolve().then(() => handler(notification)).catch((error46) => this._onerror(new Error(`Uncaught error in notification handler: ${error46}`)));
  }
  _onrequest(request, extra) {
    var _a2, _b, _c, _d, _e, _f;
    const handler = (_a2 = this._requestHandlers.get(request.method)) !== null && _a2 !== undefined ? _a2 : this.fallbackRequestHandler;
    const capturedTransport = this._transport;
    const relatedTaskId = (_d = (_c = (_b = request.params) === null || _b === undefined ? undefined : _b._meta) === null || _c === undefined ? undefined : _c[RELATED_TASK_META_KEY]) === null || _d === undefined ? undefined : _d.taskId;
    if (handler === undefined) {
      const errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: ErrorCode.MethodNotFound,
          message: "Method not found"
        }
      };
      if (relatedTaskId && this._taskMessageQueue) {
        this._enqueueTaskMessage(relatedTaskId, {
          type: "error",
          message: errorResponse,
          timestamp: Date.now()
        }, capturedTransport === null || capturedTransport === undefined ? undefined : capturedTransport.sessionId).catch((error46) => this._onerror(new Error(`Failed to enqueue error response: ${error46}`)));
      } else {
        capturedTransport === null || capturedTransport === undefined || capturedTransport.send(errorResponse).catch((error46) => this._onerror(new Error(`Failed to send an error response: ${error46}`)));
      }
      return;
    }
    const abortController = new AbortController;
    this._requestHandlerAbortControllers.set(request.id, abortController);
    const taskCreationParams = (_e = request.params) === null || _e === undefined ? undefined : _e.task;
    const taskStore = this._taskStore ? this.requestTaskStore(request, capturedTransport === null || capturedTransport === undefined ? undefined : capturedTransport.sessionId) : undefined;
    const fullExtra = {
      signal: abortController.signal,
      sessionId: capturedTransport === null || capturedTransport === undefined ? undefined : capturedTransport.sessionId,
      _meta: (_f = request.params) === null || _f === undefined ? undefined : _f._meta,
      sendNotification: async (notification) => {
        const notificationOptions = { relatedRequestId: request.id };
        if (relatedTaskId) {
          notificationOptions.relatedTask = { taskId: relatedTaskId };
        }
        await this.notification(notification, notificationOptions);
      },
      sendRequest: async (r, resultSchema, options) => {
        var _a3, _b2;
        const requestOptions = { ...options, relatedRequestId: request.id };
        if (relatedTaskId && !requestOptions.relatedTask) {
          requestOptions.relatedTask = { taskId: relatedTaskId };
        }
        const effectiveTaskId = (_b2 = (_a3 = requestOptions.relatedTask) === null || _a3 === undefined ? undefined : _a3.taskId) !== null && _b2 !== undefined ? _b2 : relatedTaskId;
        if (effectiveTaskId && taskStore) {
          await taskStore.updateTaskStatus(effectiveTaskId, "input_required");
        }
        return await this.request(r, resultSchema, requestOptions);
      },
      authInfo: extra === null || extra === undefined ? undefined : extra.authInfo,
      requestId: request.id,
      requestInfo: extra === null || extra === undefined ? undefined : extra.requestInfo,
      taskId: relatedTaskId,
      taskStore,
      taskRequestedTtl: taskCreationParams === null || taskCreationParams === undefined ? undefined : taskCreationParams.ttl,
      closeSSEStream: extra === null || extra === undefined ? undefined : extra.closeSSEStream,
      closeStandaloneSSEStream: extra === null || extra === undefined ? undefined : extra.closeStandaloneSSEStream
    };
    Promise.resolve().then(() => {
      if (taskCreationParams) {
        this.assertTaskHandlerCapability(request.method);
      }
    }).then(() => handler(request, fullExtra)).then(async (result) => {
      if (abortController.signal.aborted) {
        return;
      }
      const response = {
        result,
        jsonrpc: "2.0",
        id: request.id
      };
      if (relatedTaskId && this._taskMessageQueue) {
        await this._enqueueTaskMessage(relatedTaskId, {
          type: "response",
          message: response,
          timestamp: Date.now()
        }, capturedTransport === null || capturedTransport === undefined ? undefined : capturedTransport.sessionId);
      } else {
        await (capturedTransport === null || capturedTransport === undefined ? undefined : capturedTransport.send(response));
      }
    }, async (error46) => {
      var _a3;
      if (abortController.signal.aborted) {
        return;
      }
      const errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: Number.isSafeInteger(error46["code"]) ? error46["code"] : ErrorCode.InternalError,
          message: (_a3 = error46.message) !== null && _a3 !== undefined ? _a3 : "Internal error",
          ...error46["data"] !== undefined && { data: error46["data"] }
        }
      };
      if (relatedTaskId && this._taskMessageQueue) {
        await this._enqueueTaskMessage(relatedTaskId, {
          type: "error",
          message: errorResponse,
          timestamp: Date.now()
        }, capturedTransport === null || capturedTransport === undefined ? undefined : capturedTransport.sessionId);
      } else {
        await (capturedTransport === null || capturedTransport === undefined ? undefined : capturedTransport.send(errorResponse));
      }
    }).catch((error46) => this._onerror(new Error(`Failed to send response: ${error46}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(request.id);
    });
  }
  _onprogress(notification) {
    const { progressToken, ...params } = notification.params;
    const messageId = Number(progressToken);
    const handler = this._progressHandlers.get(messageId);
    if (!handler) {
      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
      return;
    }
    const responseHandler = this._responseHandlers.get(messageId);
    const timeoutInfo = this._timeoutInfo.get(messageId);
    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
      try {
        this._resetTimeout(messageId);
      } catch (error46) {
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        responseHandler(error46);
        return;
      }
    }
    handler(params);
  }
  _onresponse(response) {
    const messageId = Number(response.id);
    const resolver = this._requestResolvers.get(messageId);
    if (resolver) {
      this._requestResolvers.delete(messageId);
      if (isJSONRPCResponse(response)) {
        resolver(response);
      } else {
        const error46 = new McpError(response.error.code, response.error.message, response.error.data);
        resolver(error46);
      }
      return;
    }
    const handler = this._responseHandlers.get(messageId);
    if (handler === undefined) {
      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
      return;
    }
    this._responseHandlers.delete(messageId);
    this._cleanupTimeout(messageId);
    let isTaskResponse = false;
    if (isJSONRPCResponse(response) && response.result && typeof response.result === "object") {
      const result = response.result;
      if (result.task && typeof result.task === "object") {
        const task = result.task;
        if (typeof task.taskId === "string") {
          isTaskResponse = true;
          this._taskProgressTokens.set(task.taskId, messageId);
        }
      }
    }
    if (!isTaskResponse) {
      this._progressHandlers.delete(messageId);
    }
    if (isJSONRPCResponse(response)) {
      handler(response);
    } else {
      const error46 = McpError.fromError(response.error.code, response.error.message, response.error.data);
      handler(error46);
    }
  }
  get transport() {
    return this._transport;
  }
  async close() {
    var _a2;
    await ((_a2 = this._transport) === null || _a2 === undefined ? undefined : _a2.close());
  }
  async* requestStream(request, resultSchema, options) {
    var _a2, _b, _c, _d;
    const { task } = options !== null && options !== undefined ? options : {};
    if (!task) {
      try {
        const result = await this.request(request, resultSchema, options);
        yield { type: "result", result };
      } catch (error46) {
        yield {
          type: "error",
          error: error46 instanceof McpError ? error46 : new McpError(ErrorCode.InternalError, String(error46))
        };
      }
      return;
    }
    let taskId;
    try {
      const createResult = await this.request(request, CreateTaskResultSchema, options);
      if (createResult.task) {
        taskId = createResult.task.taskId;
        yield { type: "taskCreated", task: createResult.task };
      } else {
        throw new McpError(ErrorCode.InternalError, "Task creation did not return a task");
      }
      while (true) {
        const task2 = await this.getTask({ taskId }, options);
        yield { type: "taskStatus", task: task2 };
        if (isTerminal(task2.status)) {
          if (task2.status === "completed") {
            const result = await this.getTaskResult({ taskId }, resultSchema, options);
            yield { type: "result", result };
          } else if (task2.status === "failed") {
            yield {
              type: "error",
              error: new McpError(ErrorCode.InternalError, `Task ${taskId} failed`)
            };
          } else if (task2.status === "cancelled") {
            yield {
              type: "error",
              error: new McpError(ErrorCode.InternalError, `Task ${taskId} was cancelled`)
            };
          }
          return;
        }
        if (task2.status === "input_required") {
          const result = await this.getTaskResult({ taskId }, resultSchema, options);
          yield { type: "result", result };
          return;
        }
        const pollInterval = (_c = (_a2 = task2.pollInterval) !== null && _a2 !== undefined ? _a2 : (_b = this._options) === null || _b === undefined ? undefined : _b.defaultTaskPollInterval) !== null && _c !== undefined ? _c : 1000;
        await new Promise((resolve) => setTimeout(resolve, pollInterval));
        (_d = options === null || options === undefined ? undefined : options.signal) === null || _d === undefined || _d.throwIfAborted();
      }
    } catch (error46) {
      yield {
        type: "error",
        error: error46 instanceof McpError ? error46 : new McpError(ErrorCode.InternalError, String(error46))
      };
    }
  }
  request(request, resultSchema, options) {
    const { relatedRequestId, resumptionToken, onresumptiontoken, task, relatedTask } = options !== null && options !== undefined ? options : {};
    return new Promise((resolve, reject) => {
      var _a2, _b, _c, _d, _e, _f, _g;
      const earlyReject = (error46) => {
        reject(error46);
      };
      if (!this._transport) {
        earlyReject(new Error("Not connected"));
        return;
      }
      if (((_a2 = this._options) === null || _a2 === undefined ? undefined : _a2.enforceStrictCapabilities) === true) {
        try {
          this.assertCapabilityForMethod(request.method);
          if (task) {
            this.assertTaskCapability(request.method);
          }
        } catch (e) {
          earlyReject(e);
          return;
        }
      }
      (_b = options === null || options === undefined ? undefined : options.signal) === null || _b === undefined || _b.throwIfAborted();
      const messageId = this._requestMessageId++;
      const jsonrpcRequest = {
        ...request,
        jsonrpc: "2.0",
        id: messageId
      };
      if (options === null || options === undefined ? undefined : options.onprogress) {
        this._progressHandlers.set(messageId, options.onprogress);
        jsonrpcRequest.params = {
          ...request.params,
          _meta: {
            ...((_c = request.params) === null || _c === undefined ? undefined : _c._meta) || {},
            progressToken: messageId
          }
        };
      }
      if (task) {
        jsonrpcRequest.params = {
          ...jsonrpcRequest.params,
          task
        };
      }
      if (relatedTask) {
        jsonrpcRequest.params = {
          ...jsonrpcRequest.params,
          _meta: {
            ...((_d = jsonrpcRequest.params) === null || _d === undefined ? undefined : _d._meta) || {},
            [RELATED_TASK_META_KEY]: relatedTask
          }
        };
      }
      const cancel = (reason) => {
        var _a3;
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        (_a3 = this._transport) === null || _a3 === undefined || _a3.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: messageId,
            reason: String(reason)
          }
        }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error47) => this._onerror(new Error(`Failed to send cancellation: ${error47}`)));
        const error46 = reason instanceof McpError ? reason : new McpError(ErrorCode.RequestTimeout, String(reason));
        reject(error46);
      };
      this._responseHandlers.set(messageId, (response) => {
        var _a3;
        if ((_a3 = options === null || options === undefined ? undefined : options.signal) === null || _a3 === undefined ? undefined : _a3.aborted) {
          return;
        }
        if (response instanceof Error) {
          return reject(response);
        }
        try {
          const parseResult = safeParse2(resultSchema, response.result);
          if (!parseResult.success) {
            reject(parseResult.error);
          } else {
            resolve(parseResult.data);
          }
        } catch (error46) {
          reject(error46);
        }
      });
      (_e = options === null || options === undefined ? undefined : options.signal) === null || _e === undefined || _e.addEventListener("abort", () => {
        var _a3;
        cancel((_a3 = options === null || options === undefined ? undefined : options.signal) === null || _a3 === undefined ? undefined : _a3.reason);
      });
      const timeout = (_f = options === null || options === undefined ? undefined : options.timeout) !== null && _f !== undefined ? _f : DEFAULT_REQUEST_TIMEOUT_MSEC;
      const timeoutHandler = () => cancel(McpError.fromError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
      this._setupTimeout(messageId, timeout, options === null || options === undefined ? undefined : options.maxTotalTimeout, timeoutHandler, (_g = options === null || options === undefined ? undefined : options.resetTimeoutOnProgress) !== null && _g !== undefined ? _g : false);
      const relatedTaskId = relatedTask === null || relatedTask === undefined ? undefined : relatedTask.taskId;
      if (relatedTaskId) {
        const responseResolver = (response) => {
          const handler = this._responseHandlers.get(messageId);
          if (handler) {
            handler(response);
          } else {
            this._onerror(new Error(`Response handler missing for side-channeled request ${messageId}`));
          }
        };
        this._requestResolvers.set(messageId, responseResolver);
        this._enqueueTaskMessage(relatedTaskId, {
          type: "request",
          message: jsonrpcRequest,
          timestamp: Date.now()
        }).catch((error46) => {
          this._cleanupTimeout(messageId);
          reject(error46);
        });
      } else {
        this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error46) => {
          this._cleanupTimeout(messageId);
          reject(error46);
        });
      }
    });
  }
  async getTask(params, options) {
    return this.request({ method: "tasks/get", params }, GetTaskResultSchema, options);
  }
  async getTaskResult(params, resultSchema, options) {
    return this.request({ method: "tasks/result", params }, resultSchema, options);
  }
  async listTasks(params, options) {
    return this.request({ method: "tasks/list", params }, ListTasksResultSchema, options);
  }
  async cancelTask(params, options) {
    return this.request({ method: "tasks/cancel", params }, CancelTaskResultSchema, options);
  }
  async notification(notification, options) {
    var _a2, _b, _c, _d, _e;
    if (!this._transport) {
      throw new Error("Not connected");
    }
    this.assertNotificationCapability(notification.method);
    const relatedTaskId = (_a2 = options === null || options === undefined ? undefined : options.relatedTask) === null || _a2 === undefined ? undefined : _a2.taskId;
    if (relatedTaskId) {
      const jsonrpcNotification2 = {
        ...notification,
        jsonrpc: "2.0",
        params: {
          ...notification.params,
          _meta: {
            ...((_b = notification.params) === null || _b === undefined ? undefined : _b._meta) || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
      await this._enqueueTaskMessage(relatedTaskId, {
        type: "notification",
        message: jsonrpcNotification2,
        timestamp: Date.now()
      });
      return;
    }
    const debouncedMethods = (_d = (_c = this._options) === null || _c === undefined ? undefined : _c.debouncedNotificationMethods) !== null && _d !== undefined ? _d : [];
    const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !(options === null || options === undefined ? undefined : options.relatedRequestId) && !(options === null || options === undefined ? undefined : options.relatedTask);
    if (canDebounce) {
      if (this._pendingDebouncedNotifications.has(notification.method)) {
        return;
      }
      this._pendingDebouncedNotifications.add(notification.method);
      Promise.resolve().then(() => {
        var _a3, _b2;
        this._pendingDebouncedNotifications.delete(notification.method);
        if (!this._transport) {
          return;
        }
        let jsonrpcNotification2 = {
          ...notification,
          jsonrpc: "2.0"
        };
        if (options === null || options === undefined ? undefined : options.relatedTask) {
          jsonrpcNotification2 = {
            ...jsonrpcNotification2,
            params: {
              ...jsonrpcNotification2.params,
              _meta: {
                ...((_a3 = jsonrpcNotification2.params) === null || _a3 === undefined ? undefined : _a3._meta) || {},
                [RELATED_TASK_META_KEY]: options.relatedTask
              }
            }
          };
        }
        (_b2 = this._transport) === null || _b2 === undefined || _b2.send(jsonrpcNotification2, options).catch((error46) => this._onerror(error46));
      });
      return;
    }
    let jsonrpcNotification = {
      ...notification,
      jsonrpc: "2.0"
    };
    if (options === null || options === undefined ? undefined : options.relatedTask) {
      jsonrpcNotification = {
        ...jsonrpcNotification,
        params: {
          ...jsonrpcNotification.params,
          _meta: {
            ...((_e = jsonrpcNotification.params) === null || _e === undefined ? undefined : _e._meta) || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
    }
    await this._transport.send(jsonrpcNotification, options);
  }
  setRequestHandler(requestSchema, handler) {
    const method = getMethodLiteral(requestSchema);
    this.assertRequestHandlerCapability(method);
    this._requestHandlers.set(method, (request, extra) => {
      const parsed = parseWithCompat(requestSchema, request);
      return Promise.resolve(handler(parsed, extra));
    });
  }
  removeRequestHandler(method) {
    this._requestHandlers.delete(method);
  }
  assertCanSetRequestHandler(method) {
    if (this._requestHandlers.has(method)) {
      throw new Error(`A request handler for ${method} already exists, which would be overridden`);
    }
  }
  setNotificationHandler(notificationSchema, handler) {
    const method = getMethodLiteral(notificationSchema);
    this._notificationHandlers.set(method, (notification) => {
      const parsed = parseWithCompat(notificationSchema, notification);
      return Promise.resolve(handler(parsed));
    });
  }
  removeNotificationHandler(method) {
    this._notificationHandlers.delete(method);
  }
  _cleanupTaskProgressHandler(taskId) {
    const progressToken = this._taskProgressTokens.get(taskId);
    if (progressToken !== undefined) {
      this._progressHandlers.delete(progressToken);
      this._taskProgressTokens.delete(taskId);
    }
  }
  async _enqueueTaskMessage(taskId, message, sessionId) {
    var _a2;
    if (!this._taskStore || !this._taskMessageQueue) {
      throw new Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
    }
    const maxQueueSize = (_a2 = this._options) === null || _a2 === undefined ? undefined : _a2.maxTaskQueueSize;
    await this._taskMessageQueue.enqueue(taskId, message, sessionId, maxQueueSize);
  }
  async _clearTaskQueue(taskId, sessionId) {
    if (this._taskMessageQueue) {
      const messages = await this._taskMessageQueue.dequeueAll(taskId, sessionId);
      for (const message of messages) {
        if (message.type === "request" && isJSONRPCRequest(message.message)) {
          const requestId = message.message.id;
          const resolver = this._requestResolvers.get(requestId);
          if (resolver) {
            resolver(new McpError(ErrorCode.InternalError, "Task cancelled or completed"));
            this._requestResolvers.delete(requestId);
          } else {
            this._onerror(new Error(`Resolver missing for request ${requestId} during task ${taskId} cleanup`));
          }
        }
      }
    }
  }
  async _waitForTaskUpdate(taskId, signal) {
    var _a2, _b, _c;
    let interval = (_b = (_a2 = this._options) === null || _a2 === undefined ? undefined : _a2.defaultTaskPollInterval) !== null && _b !== undefined ? _b : 1000;
    try {
      const task = await ((_c = this._taskStore) === null || _c === undefined ? undefined : _c.getTask(taskId));
      if (task === null || task === undefined ? undefined : task.pollInterval) {
        interval = task.pollInterval;
      }
    } catch (_d) {}
    return new Promise((resolve, reject) => {
      if (signal.aborted) {
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
        return;
      }
      const timeoutId = setTimeout(resolve, interval);
      signal.addEventListener("abort", () => {
        clearTimeout(timeoutId);
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
      }, { once: true });
    });
  }
  requestTaskStore(request, sessionId) {
    const taskStore = this._taskStore;
    if (!taskStore) {
      throw new Error("No task store configured");
    }
    return {
      createTask: async (taskParams) => {
        if (!request) {
          throw new Error("No request provided");
        }
        return await taskStore.createTask(taskParams, request.id, {
          method: request.method,
          params: request.params
        }, sessionId);
      },
      getTask: async (taskId) => {
        const task = await taskStore.getTask(taskId, sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        }
        return task;
      },
      storeTaskResult: async (taskId, status, result) => {
        await taskStore.storeTaskResult(taskId, status, result, sessionId);
        const task = await taskStore.getTask(taskId, sessionId);
        if (task) {
          const notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: task
          });
          await this.notification(notification);
          if (isTerminal(task.status)) {
            this._cleanupTaskProgressHandler(taskId);
          }
        }
      },
      getTaskResult: (taskId) => {
        return taskStore.getTaskResult(taskId, sessionId);
      },
      updateTaskStatus: async (taskId, status, statusMessage) => {
        const task = await taskStore.getTask(taskId, sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, `Task "${taskId}" not found - it may have been cleaned up`);
        }
        if (isTerminal(task.status)) {
          throw new McpError(ErrorCode.InvalidParams, `Cannot update task "${taskId}" from terminal status "${task.status}" to "${status}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
        }
        await taskStore.updateTaskStatus(taskId, status, statusMessage, sessionId);
        const updatedTask = await taskStore.getTask(taskId, sessionId);
        if (updatedTask) {
          const notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: updatedTask
          });
          await this.notification(notification);
          if (isTerminal(updatedTask.status)) {
            this._cleanupTaskProgressHandler(taskId);
          }
        }
      },
      listTasks: (cursor) => {
        return taskStore.listTasks(cursor, sessionId);
      }
    };
  }
}
function isPlainObject2(value) {
  return value !== null && typeof value === "object" && !Array.isArray(value);
}
function mergeCapabilities(base, additional) {
  const result = { ...base };
  for (const key in additional) {
    const k = key;
    const addValue = additional[k];
    if (addValue === undefined)
      continue;
    const baseValue = result[k];
    if (isPlainObject2(baseValue) && isPlainObject2(addValue)) {
      result[k] = { ...baseValue, ...addValue };
    } else {
      result[k] = addValue;
    }
  }
  return result;
}
var DEFAULT_REQUEST_TIMEOUT_MSEC = 60000;
var init_protocol = __esm(() => {
  init_zod_compat();
  init_types2();
  init_zod_json_schema_compat();
});

// node_modules/isexe/windows.js
var require_windows = __commonJS((exports, module) => {
  module.exports = isexe;
  isexe.sync = sync;
  var fs = __require("fs");
  function checkPathExt(path, options) {
    var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0;i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat, path, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false;
    }
    return checkPathExt(path, options);
  }
  function isexe(path, options, cb) {
    fs.stat(path, function(er, stat) {
      cb(er, er ? false : checkStat(stat, path, options));
    });
  }
  function sync(path, options) {
    return checkStat(fs.statSync(path), path, options);
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS((exports, module) => {
  module.exports = isexe;
  isexe.sync = sync;
  var fs = __require("fs");
  function isexe(path, options, cb) {
    fs.stat(path, function(er, stat) {
      cb(er, er ? false : checkStat(stat, options));
    });
  }
  function sync(path, options) {
    return checkStat(fs.statSync(path), options);
  }
  function checkStat(stat, options) {
    return stat.isFile() && checkMode(stat, options);
  }
  function checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS((exports, module) => {
  var fs = __require("fs");
  var core2;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core2 = require_windows();
  } else {
    core2 = require_mode();
  }
  module.exports = isexe;
  isexe.sync = sync;
  function isexe(path, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve, reject) {
        isexe(path, options || {}, function(er, is) {
          if (er) {
            reject(er);
          } else {
            resolve(is);
          }
        });
      });
    }
    core2(path, options || {}, function(er, is) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is = false;
        }
      }
      cb(er, is);
    });
  }
  function sync(path, options) {
    try {
      return core2.sync(path, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS((exports, module) => {
  var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path = __require("path");
  var COLON = isWindows ? ";" : ":";
  var isexe = require_isexe();
  var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
  var getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON;
    const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
      ...isWindows ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || "").split(colon)
    ];
    const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows ? pathExtExe.split(colon) : [""];
    if (isWindows) {
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    return {
      pathEnv,
      pathExt,
      pathExtExe
    };
  };
  var which = (cmd, opt, cb) => {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    if (!opt)
      opt = {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    const step = (i) => new Promise((resolve, reject) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve(subStep(p, i, 0));
    });
    const subStep = (p, i, ii) => new Promise((resolve, reject) => {
      if (ii === pathExt.length)
        return resolve(step(i + 1));
      const ext = pathExt[ii];
      isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
        if (!er && is) {
          if (opt.all)
            found.push(p + ext);
          else
            return resolve(p + ext);
        }
        return resolve(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  };
  var whichSync = (cmd, opt) => {
    opt = opt || {};
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    for (let i = 0;i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0;j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          const is = isexe.sync(cur, { pathExt: pathExtExe });
          if (is) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {}
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  module.exports = which;
  which.sync = whichSync;
});

// node_modules/path-key/index.js
var require_path_key = __commonJS((exports, module) => {
  var pathKey = (options = {}) => {
    const environment = options.env || process.env;
    const platform = options.platform || process.platform;
    if (platform !== "win32") {
      return "PATH";
    }
    return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
  };
  module.exports = pathKey;
  module.exports.default = pathKey;
});

// node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS((exports, module) => {
  var path = __require("path");
  var which = require_which();
  var getPathKey = require_path_key();
  function resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;
    if (shouldSwitchCwd) {
      try {
        process.chdir(parsed.options.cwd);
      } catch (err) {}
    }
    let resolved;
    try {
      resolved = which.sync(parsed.command, {
        path: env[getPathKey({ env })],
        pathExt: withoutPathExt ? path.delimiter : undefined
      });
    } catch (e) {} finally {
      if (shouldSwitchCwd) {
        process.chdir(cwd);
      }
    }
    if (resolved) {
      resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
    }
    return resolved;
  }
  function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
  }
  module.exports = resolveCommand;
});

// node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS((exports, module) => {
  var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
  function escapeCommand(arg) {
    arg = arg.replace(metaCharsRegExp, "^$1");
    return arg;
  }
  function escapeArgument(arg, doubleEscapeMetaChars) {
    arg = `${arg}`;
    arg = arg.replace(/(?=(\\+?)?)\1"/g, "$1$1\\\"");
    arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1");
    arg = `"${arg}"`;
    arg = arg.replace(metaCharsRegExp, "^$1");
    if (doubleEscapeMetaChars) {
      arg = arg.replace(metaCharsRegExp, "^$1");
    }
    return arg;
  }
  exports.command = escapeCommand;
  exports.argument = escapeArgument;
});

// node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS((exports, module) => {
  module.exports = /^#!(.*)/;
});

// node_modules/shebang-command/index.js
var require_shebang_command = __commonJS((exports, module) => {
  var shebangRegex = require_shebang_regex();
  module.exports = (string6 = "") => {
    const match = string6.match(shebangRegex);
    if (!match) {
      return null;
    }
    const [path, argument] = match[0].replace(/#! ?/, "").split(" ");
    const binary = path.split("/").pop();
    if (binary === "env") {
      return argument;
    }
    return argument ? `${binary} ${argument}` : binary;
  };
});

// node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS((exports, module) => {
  var fs = __require("fs");
  var shebangCommand = require_shebang_command();
  function readShebang(command) {
    const size = 150;
    const buffer = Buffer.alloc(size);
    let fd;
    try {
      fd = fs.openSync(command, "r");
      fs.readSync(fd, buffer, 0, size, 0);
      fs.closeSync(fd);
    } catch (e) {}
    return shebangCommand(buffer.toString());
  }
  module.exports = readShebang;
});

// node_modules/cross-spawn/lib/parse.js
var require_parse4 = __commonJS((exports, module) => {
  var path = __require("path");
  var resolveCommand = require_resolveCommand();
  var escape2 = require_escape();
  var readShebang = require_readShebang();
  var isWin = process.platform === "win32";
  var isExecutableRegExp = /\.(?:com|exe)$/i;
  var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    if (shebang) {
      parsed.args.unshift(parsed.file);
      parsed.command = shebang;
      return resolveCommand(parsed);
    }
    return parsed.file;
  }
  function parseNonShell(parsed) {
    if (!isWin) {
      return parsed;
    }
    const commandFile = detectShebang(parsed);
    const needsShell = !isExecutableRegExp.test(commandFile);
    if (parsed.options.forceShell || needsShell) {
      const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
      parsed.command = path.normalize(parsed.command);
      parsed.command = escape2.command(parsed.command);
      parsed.args = parsed.args.map((arg) => escape2.argument(arg, needsDoubleEscapeMetaChars));
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
      parsed.command = process.env.comspec || "cmd.exe";
      parsed.options.windowsVerbatimArguments = true;
    }
    return parsed;
  }
  function parse7(command, args, options) {
    if (args && !Array.isArray(args)) {
      options = args;
      args = null;
    }
    args = args ? args.slice(0) : [];
    options = Object.assign({}, options);
    const parsed = {
      command,
      args,
      options,
      file: undefined,
      original: {
        command,
        args
      }
    };
    return options.shell ? parsed : parseNonShell(parsed);
  }
  module.exports = parse7;
});

// node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS((exports, module) => {
  var isWin = process.platform === "win32";
  function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${syscall} ${original.command}`,
      path: original.command,
      spawnargs: original.args
    });
  }
  function hookChildProcess(cp, parsed) {
    if (!isWin) {
      return;
    }
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
      if (name === "exit") {
        const err = verifyENOENT(arg1, parsed);
        if (err) {
          return originalEmit.call(cp, "error", err);
        }
      }
      return originalEmit.apply(cp, arguments);
    };
  }
  function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawn");
    }
    return null;
  }
  function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawnSync");
    }
    return null;
  }
  module.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
  };
});

// node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS((exports, module) => {
  var cp = __require("child_process");
  var parse7 = require_parse4();
  var enoent = require_enoent();
  function spawn(command, args, options) {
    const parsed = parse7(command, args, options);
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    enoent.hookChildProcess(spawned, parsed);
    return spawned;
  }
  function spawnSync(command, args, options) {
    const parsed = parse7(command, args, options);
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
    return result;
  }
  module.exports = spawn;
  module.exports.spawn = spawn;
  module.exports.sync = spawnSync;
  module.exports._parse = parse7;
  module.exports._enoent = enoent;
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/stdio.js
class ReadBuffer {
  append(chunk) {
    this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
  }
  readMessage() {
    if (!this._buffer) {
      return null;
    }
    const index = this._buffer.indexOf(`
`);
    if (index === -1) {
      return null;
    }
    const line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
    this._buffer = this._buffer.subarray(index + 1);
    return deserializeMessage(line);
  }
  clear() {
    this._buffer = undefined;
  }
}
function deserializeMessage(line) {
  return JSONRPCMessageSchema.parse(JSON.parse(line));
}
function serializeMessage(message) {
  return JSON.stringify(message) + `
`;
}
var init_stdio = __esm(() => {
  init_types2();
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/stdio.js
var exports_stdio = {};
__export(exports_stdio, {
  getDefaultEnvironment: () => getDefaultEnvironment,
  StdioClientTransport: () => StdioClientTransport,
  DEFAULT_INHERITED_ENV_VARS: () => DEFAULT_INHERITED_ENV_VARS
});
import process2 from "process";
import { PassThrough } from "stream";
function getDefaultEnvironment() {
  const env = {};
  for (const key of DEFAULT_INHERITED_ENV_VARS) {
    const value = process2.env[key];
    if (value === undefined) {
      continue;
    }
    if (value.startsWith("()")) {
      continue;
    }
    env[key] = value;
  }
  return env;
}

class StdioClientTransport {
  constructor(server) {
    this._readBuffer = new ReadBuffer;
    this._stderrStream = null;
    this._serverParams = server;
    if (server.stderr === "pipe" || server.stderr === "overlapped") {
      this._stderrStream = new PassThrough;
    }
  }
  async start() {
    if (this._process) {
      throw new Error("StdioClientTransport already started! If using Client class, note that connect() calls start() automatically.");
    }
    return new Promise((resolve, reject) => {
      var _a2, _b, _c, _d, _e;
      this._process = import_cross_spawn.default(this._serverParams.command, (_a2 = this._serverParams.args) !== null && _a2 !== undefined ? _a2 : [], {
        env: {
          ...getDefaultEnvironment(),
          ...this._serverParams.env
        },
        stdio: ["pipe", "pipe", (_b = this._serverParams.stderr) !== null && _b !== undefined ? _b : "inherit"],
        shell: false,
        windowsHide: process2.platform === "win32" && isElectron(),
        cwd: this._serverParams.cwd
      });
      this._process.on("error", (error47) => {
        var _a3;
        reject(error47);
        (_a3 = this.onerror) === null || _a3 === undefined || _a3.call(this, error47);
      });
      this._process.on("spawn", () => {
        resolve();
      });
      this._process.on("close", (_code) => {
        var _a3;
        this._process = undefined;
        (_a3 = this.onclose) === null || _a3 === undefined || _a3.call(this);
      });
      (_c = this._process.stdin) === null || _c === undefined || _c.on("error", (error47) => {
        var _a3;
        (_a3 = this.onerror) === null || _a3 === undefined || _a3.call(this, error47);
      });
      (_d = this._process.stdout) === null || _d === undefined || _d.on("data", (chunk) => {
        this._readBuffer.append(chunk);
        this.processReadBuffer();
      });
      (_e = this._process.stdout) === null || _e === undefined || _e.on("error", (error47) => {
        var _a3;
        (_a3 = this.onerror) === null || _a3 === undefined || _a3.call(this, error47);
      });
      if (this._stderrStream && this._process.stderr) {
        this._process.stderr.pipe(this._stderrStream);
      }
    });
  }
  get stderr() {
    var _a2, _b;
    if (this._stderrStream) {
      return this._stderrStream;
    }
    return (_b = (_a2 = this._process) === null || _a2 === undefined ? undefined : _a2.stderr) !== null && _b !== undefined ? _b : null;
  }
  get pid() {
    var _a2, _b;
    return (_b = (_a2 = this._process) === null || _a2 === undefined ? undefined : _a2.pid) !== null && _b !== undefined ? _b : null;
  }
  processReadBuffer() {
    var _a2, _b;
    while (true) {
      try {
        const message = this._readBuffer.readMessage();
        if (message === null) {
          break;
        }
        (_a2 = this.onmessage) === null || _a2 === undefined || _a2.call(this, message);
      } catch (error47) {
        (_b = this.onerror) === null || _b === undefined || _b.call(this, error47);
      }
    }
  }
  async close() {
    var _a2;
    if (this._process) {
      const processToClose = this._process;
      this._process = undefined;
      const closePromise = new Promise((resolve) => {
        processToClose.once("close", () => {
          resolve();
        });
      });
      try {
        (_a2 = processToClose.stdin) === null || _a2 === undefined || _a2.end();
      } catch (_b) {}
      await Promise.race([closePromise, new Promise((resolve) => setTimeout(resolve, 2000).unref())]);
      if (processToClose.exitCode === null) {
        try {
          processToClose.kill("SIGTERM");
        } catch (_c) {}
        await Promise.race([closePromise, new Promise((resolve) => setTimeout(resolve, 2000).unref())]);
      }
      if (processToClose.exitCode === null) {
        try {
          processToClose.kill("SIGKILL");
        } catch (_d) {}
      }
    }
    this._readBuffer.clear();
  }
  send(message) {
    return new Promise((resolve) => {
      var _a2;
      if (!((_a2 = this._process) === null || _a2 === undefined ? undefined : _a2.stdin)) {
        throw new Error("Not connected");
      }
      const json2 = serializeMessage(message);
      if (this._process.stdin.write(json2)) {
        resolve();
      } else {
        this._process.stdin.once("drain", resolve);
      }
    });
  }
}
function isElectron() {
  return "type" in process2;
}
var import_cross_spawn, DEFAULT_INHERITED_ENV_VARS;
var init_stdio2 = __esm(() => {
  import_cross_spawn = __toESM(require_cross_spawn(), 1);
  init_stdio();
  DEFAULT_INHERITED_ENV_VARS = process2.platform === "win32" ? [
    "APPDATA",
    "HOMEDRIVE",
    "HOMEPATH",
    "LOCALAPPDATA",
    "PATH",
    "PROCESSOR_ARCHITECTURE",
    "SYSTEMDRIVE",
    "SYSTEMROOT",
    "TEMP",
    "USERNAME",
    "USERPROFILE",
    "PROGRAMFILES"
  ] : ["HOME", "LOGNAME", "PATH", "SHELL", "TERM", "USER"];
});

// node_modules/ajv/dist/compile/codegen/code.js
var require_code2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = undefined;

  class _CodeOrName {
  }
  exports._CodeOrName = _CodeOrName;
  exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;

  class Name extends _CodeOrName {
    constructor(s) {
      super();
      if (!exports.IDENTIFIER.test(s))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports.Name = Name;

  class _Code extends _CodeOrName {
    constructor(code) {
      super();
      this._items = typeof code === "string" ? [code] : code;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a2;
      return (_a2 = this._str) !== null && _a2 !== undefined ? _a2 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
    }
    get names() {
      var _a2;
      return (_a2 = this._names) !== null && _a2 !== undefined ? _a2 : this._names = this._items.reduce((names, c) => {
        if (c instanceof Name)
          names[c.str] = (names[c.str] || 0) + 1;
        return names;
      }, {});
    }
  }
  exports._Code = _Code;
  exports.nil = new _Code("");
  function _(strs, ...args) {
    const code = [strs[0]];
    let i = 0;
    while (i < args.length) {
      addCodeArg(code, args[i]);
      code.push(strs[++i]);
    }
    return new _Code(code);
  }
  exports._ = _;
  var plus = new _Code("+");
  function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports.str = str;
  function addCodeArg(code, arg) {
    if (arg instanceof _Code)
      code.push(...arg._items);
    else if (arg instanceof Name)
      code.push(arg);
    else
      code.push(interpolate(arg));
  }
  exports.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res !== undefined) {
          expr.splice(i - 1, 3, res);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  }
  function mergeExprItems(a, b) {
    if (b === '""')
      return a;
    if (a === '""')
      return b;
    if (typeof a == "string") {
      if (b instanceof Name || a[a.length - 1] !== '"')
        return;
      if (typeof b != "string")
        return `${a.slice(0, -1)}${b}"`;
      if (b[0] === '"')
        return a.slice(0, -1) + b.slice(1);
      return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
      return `"${a}${b.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
  }
  exports.strConcat = strConcat;
  function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
  }
  function stringify2(x) {
    return new _Code(safeStringify(x));
  }
  exports.stringify = stringify2;
  function safeStringify(x) {
    return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
  }
  exports.getProperty = getProperty;
  function getEsmExportName(key) {
    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
      return new _Code(`${key}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
  }
  exports.getEsmExportName = getEsmExportName;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports.regexpCode = regexpCode;
});

// node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = undefined;
  var code_1 = require_code2();

  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
  exports.varKinds = {
    const: new code_1.Name("const"),
    let: new code_1.Name("let"),
    var: new code_1.Name("var")
  };

  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_1.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a2, _b;
      if (((_b = (_a2 = this._parent) === null || _a2 === undefined ? undefined : _a2._prefixes) === null || _b === undefined ? undefined : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports.Scope = Scope;

  class ValueScopeName extends code_1.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
    }
  }
  exports.ValueScopeName = ValueScopeName;
  var line = (0, code_1._)`\n`;

  class ValueScope extends Scope {
    constructor(opts) {
      super(opts);
      this._values = {};
      this._scope = opts.scope;
      this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a2;
      if (value.ref === undefined)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a2 = value.key) !== null && _a2 !== undefined ? _a2 : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = new Map;
      }
      vs.set(valueKey, name);
      const s = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s.length;
      s[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === undefined)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return (0, code_1._)`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === undefined)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code = code_1.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || new Map;
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c = valueCode(name);
          if (c) {
            const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
            code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
          } else if (c = getCode === null || getCode === undefined ? undefined : getCode(name)) {
            code = (0, code_1._)`${code}${c}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code;
    }
  }
  exports.ValueScope = ValueScope;
});

// node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = undefined;
  var code_1 = require_code2();
  var scope_1 = require_scope();
  var code_2 = require_code2();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = require_scope();
  Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports.operators = {
    GT: new code_1._Code(">"),
    GTE: new code_1._Code(">="),
    LT: new code_1._Code("<"),
    LTE: new code_1._Code("<="),
    EQ: new code_1._Code("==="),
    NEQ: new code_1._Code("!=="),
    NOT: new code_1._Code("!"),
    OR: new code_1._Code("||"),
    AND: new code_1._Code("&&"),
    ADD: new code_1._Code("+")
  };

  class Node {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }

  class Def extends Node {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names, constants) {
      if (!names[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names, constants);
      return this;
    }
    get names() {
      return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
    }
  }

  class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names, constants) {
      if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names, constants);
      return this;
    }
    get names() {
      const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
      return addExprNames(names, this.rhs);
    }
  }

  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }

  class Label extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }

  class Break extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }

  class Throw extends Node {
    constructor(error47) {
      super();
      this.error = error47;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }

  class AnyCode extends Node {
    constructor(code) {
      super();
      this.code = code;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : undefined;
    }
    optimizeNames(names, constants) {
      this.code = optimizeExpr(this.code, names, constants);
      return this;
    }
    get names() {
      return this.code instanceof code_1._CodeOrName ? this.code.names : {};
    }
  }

  class ParentNode extends Node {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts) {
      return this.nodes.reduce((code, n) => code + n.render(opts), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i, 1, ...n);
        else if (n)
          nodes[i] = n;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : undefined;
    }
    optimizeNames(names, constants) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i];
        if (n.optimizeNames(names, constants))
          continue;
        subtractNames(names, n.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : undefined;
    }
    get names() {
      return this.nodes.reduce((names, n) => addNames(names, n.names), {});
    }
  }

  class BlockNode extends ParentNode {
    render(opts) {
      return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
  }

  class Root extends ParentNode {
  }

  class Else extends BlockNode {
  }
  Else.kind = "else";

  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts) {
      let code = `if(${this.condition})` + super.render(opts);
      if (this.else)
        code += "else " + this.else.render(opts);
      return code;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return;
      return this;
    }
    optimizeNames(names, constants) {
      var _a2;
      this.else = (_a2 = this.else) === null || _a2 === undefined ? undefined : _a2.optimizeNames(names, constants);
      if (!(super.optimizeNames(names, constants) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names, constants);
      return this;
    }
    get names() {
      const names = super.names;
      addExprNames(names, this.condition);
      if (this.else)
        addNames(names, this.else.names);
      return names;
    }
  }
  If.kind = "if";

  class For extends BlockNode {
  }
  For.kind = "for";

  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts) {
      return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names, constants) {
      if (!super.optimizeNames(names, constants))
        return;
      this.iteration = optimizeExpr(this.iteration, names, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }

  class ForRange extends For {
    constructor(varKind, name, from, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to;
    }
    render(opts) {
      const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
    }
    get names() {
      const names = addExprNames(super.names, this.from);
      return addExprNames(names, this.to);
    }
  }

  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names, constants) {
      if (!super.optimizeNames(names, constants))
        return;
      this.iterable = optimizeExpr(this.iterable, names, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }

  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
  }
  Func.kind = "func";

  class Return extends ParentNode {
    render(opts) {
      return "return " + super.render(opts);
    }
  }
  Return.kind = "return";

  class Try extends BlockNode {
    render(opts) {
      let code = "try" + super.render(opts);
      if (this.catch)
        code += this.catch.render(opts);
      if (this.finally)
        code += this.finally.render(opts);
      return code;
    }
    optimizeNodes() {
      var _a2, _b;
      super.optimizeNodes();
      (_a2 = this.catch) === null || _a2 === undefined || _a2.optimizeNodes();
      (_b = this.finally) === null || _b === undefined || _b.optimizeNodes();
      return this;
    }
    optimizeNames(names, constants) {
      var _a2, _b;
      super.optimizeNames(names, constants);
      (_a2 = this.catch) === null || _a2 === undefined || _a2.optimizeNames(names, constants);
      (_b = this.finally) === null || _b === undefined || _b.optimizeNames(names, constants);
      return this;
    }
    get names() {
      const names = super.names;
      if (this.catch)
        addNames(names, this.catch.names);
      if (this.finally)
        addNames(names, this.finally.names);
      return names;
    }
  }

  class Catch extends BlockNode {
    constructor(error47) {
      super();
      this.error = error47;
    }
    render(opts) {
      return `catch(${this.error})` + super.render(opts);
    }
  }
  Catch.kind = "catch";

  class Finally extends BlockNode {
    render(opts) {
      return "finally" + super.render(opts);
    }
  }
  Finally.kind = "finally";

  class CodeGen {
    constructor(extScope, opts = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts, _n: opts.lines ? `
` : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root];
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(prefix) {
      return this._scope.name(prefix);
    }
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set);
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== undefined && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    }
    code(c) {
      if (typeof c == "function")
        c();
      else if (c !== code_1.nil)
        this._leafNode(new AnyCode(c));
      return this;
    }
    object(...keyValues) {
      const code = ["{"];
      for (const [key, value] of keyValues) {
        if (code.length > 1)
          code.push(",");
        code.push(key);
        if (key !== value || this.opts.es5) {
          code.push(":");
          (0, code_1.addCodeArg)(code, value);
        }
      }
      code.push("}");
      return new code_1._Code(code);
    }
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    else() {
      return this._elseNode(new Else);
    }
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr2 = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, (0, code_1._)`${arr2}.length`, (i) => {
          this.var(name, (0, code_1._)`${arr2}[${i}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    endFor() {
      return this._endBlockNode(For);
    }
    label(label) {
      return this._leafNode(new Label(label));
    }
    break(label) {
      return this._leafNode(new Break(label));
    }
    return(value) {
      const node = new Return;
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try;
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error47 = this.name("e");
        this._currNode = node.catch = new Catch(error47);
        catchCode(error47);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally;
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    throw(error47) {
      return this._leafNode(new Throw(error47));
    }
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === undefined)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== undefined && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    func(name, args = code_1.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node) {
      const ns = this._nodes;
      ns[ns.length - 1] = node;
    }
  }
  exports.CodeGen = CodeGen;
  function addNames(names, from) {
    for (const n in from)
      names[n] = (names[n] || 0) + (from[n] || 0);
    return names;
  }
  function addExprNames(names, from) {
    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
  }
  function optimizeExpr(expr, names, constants) {
    if (expr instanceof code_1.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_1._Code(expr._items.reduce((items, c) => {
      if (c instanceof code_1.Name)
        c = replaceName(c);
      if (c instanceof code_1._Code)
        items.push(...c._items);
      else
        items.push(c);
      return items;
    }, []));
    function replaceName(n) {
      const c = constants[n.str];
      if (c === undefined || names[n.str] !== 1)
        return n;
      delete names[n.str];
      return c;
    }
    function canOptimize(e) {
      return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined);
    }
  }
  function subtractNames(names, from) {
    for (const n in from)
      names[n] = (names[n] || 0) - (from[n] || 0);
  }
  function not(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
  }
  exports.not = not;
  var andCode = mappend(exports.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports.and = and;
  var orCode = mappend(exports.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports.or = or;
  function mappend(op) {
    return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
  }
  function par(x) {
    return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
  }
});

// node_modules/ajv/dist/compile/util.js
var require_util2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = undefined;
  var codegen_1 = require_codegen();
  var code_1 = require_code2();
  function toHash(arr2) {
    const hash2 = {};
    for (const item of arr2)
      hash2[item] = true;
    return hash2;
  }
  exports.toHash = toHash;
  function alwaysValidSchema(it, schema) {
    if (typeof schema == "boolean")
      return schema;
    if (Object.keys(schema).length === 0)
      return true;
    checkUnknownRules(it, schema);
    return !schemaHasRules(schema, it.self.RULES.all);
  }
  exports.alwaysValidSchema = alwaysValidSchema;
  function checkUnknownRules(it, schema = it.schema) {
    const { opts, self: self2 } = it;
    if (!opts.strictSchema)
      return;
    if (typeof schema === "boolean")
      return;
    const rules = self2.RULES.keywords;
    for (const key in schema) {
      if (!rules[key])
        checkStrictMode(it, `unknown keyword: "${key}"`);
    }
  }
  exports.checkUnknownRules = checkUnknownRules;
  function schemaHasRules(schema, rules) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (rules[key])
        return true;
    return false;
  }
  exports.schemaHasRules = schemaHasRules;
  function schemaHasRulesButRef(schema, RULES) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  }
  exports.schemaHasRulesButRef = schemaHasRulesButRef;
  function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
    if (!$data) {
      if (typeof schema == "number" || typeof schema == "boolean")
        return schema;
      if (typeof schema == "string")
        return (0, codegen_1._)`${schema}`;
    }
    return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
  }
  exports.schemaRefOrVal = schemaRefOrVal;
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  exports.unescapeFragment = unescapeFragment;
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  exports.escapeFragment = escapeFragment;
  function escapeJsonPointer(str) {
    if (typeof str == "number")
      return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  exports.escapeJsonPointer = escapeJsonPointer;
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  exports.unescapeJsonPointer = unescapeJsonPointer;
  function eachItem(xs, f) {
    if (Array.isArray(xs)) {
      for (const x of xs)
        f(x);
    } else {
      f(xs);
    }
  }
  exports.eachItem = eachItem;
  function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues3, resultToName }) {
    return (gen, from, to, toName) => {
      const res = to === undefined ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues3(from, to);
      return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
    };
  }
  exports.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
        gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
      }),
      mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
        if (from === true) {
          gen.assign(to, true);
        } else {
          gen.assign(to, (0, codegen_1._)`${to} || {}`);
          setEvaluated(gen, to, from);
        }
      }),
      mergeValues: (from, to) => from === true ? true : { ...from, ...to },
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
      mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
      mergeValues: (from, to) => from === true ? true : Math.max(from, to),
      resultToName: (gen, items) => gen.var("items", items)
    })
  };
  function evaluatedPropsToName(gen, ps) {
    if (ps === true)
      return gen.var("props", true);
    const props = gen.var("props", (0, codegen_1._)`{}`);
    if (ps !== undefined)
      setEvaluated(gen, props, ps);
    return props;
  }
  exports.evaluatedPropsToName = evaluatedPropsToName;
  function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
  }
  exports.setEvaluated = setEvaluated;
  var snippets = {};
  function useFunc(gen, f) {
    return gen.scopeValue("func", {
      ref: f,
      code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
    });
  }
  exports.useFunc = useFunc;
  var Type;
  (function(Type2) {
    Type2[Type2["Num"] = 0] = "Num";
    Type2[Type2["Str"] = 1] = "Str";
  })(Type || (exports.Type = Type = {}));
  function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_1.Name) {
      const isNumber = dataPropType === Type.Num;
      return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  }
  exports.getErrorPath = getErrorPath;
  function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it.self.logger.warn(msg);
  }
  exports.checkStrictMode = checkStrictMode;
});

// node_modules/ajv/dist/compile/names.js
var require_names = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var names = {
    data: new codegen_1.Name("data"),
    valCxt: new codegen_1.Name("valCxt"),
    instancePath: new codegen_1.Name("instancePath"),
    parentData: new codegen_1.Name("parentData"),
    parentDataProperty: new codegen_1.Name("parentDataProperty"),
    rootData: new codegen_1.Name("rootData"),
    dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
    vErrors: new codegen_1.Name("vErrors"),
    errors: new codegen_1.Name("errors"),
    this: new codegen_1.Name("this"),
    self: new codegen_1.Name("self"),
    scope: new codegen_1.Name("scope"),
    json: new codegen_1.Name("json"),
    jsonPos: new codegen_1.Name("jsonPos"),
    jsonLen: new codegen_1.Name("jsonLen"),
    jsonPart: new codegen_1.Name("jsonPart")
  };
  exports.default = names;
});

// node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  var names_1 = require_names();
  exports.keywordError = {
    message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
  };
  exports.keyword$DataError = {
    message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
  };
  function reportError(cxt, error47 = exports.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error47, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== undefined ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it, (0, codegen_1._)`[${errObj}]`);
    }
  }
  exports.reportError = reportError;
  function reportExtraError(cxt, error47 = exports.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error47, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it, names_1.default.vErrors);
    }
  }
  exports.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_1.default.errors, errsCount);
    gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
  }
  exports.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
    if (errsCount === undefined)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
      gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
      gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
      gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
      if (it.opts.verbose) {
        gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
        gen.assign((0, codegen_1._)`${err}.data`, data);
      }
    });
  }
  exports.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
    gen.code((0, codegen_1._)`${names_1.default.errors}++`);
  }
  function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
      gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  var E = {
    keyword: new codegen_1.Name("keyword"),
    schemaPath: new codegen_1.Name("schemaPath"),
    params: new codegen_1.Name("params"),
    propertyName: new codegen_1.Name("propertyName"),
    message: new codegen_1.Name("message"),
    schema: new codegen_1.Name("schema"),
    parentSchema: new codegen_1.Name("parentSchema")
  };
  function errorObjectCode(cxt, error47, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return (0, codegen_1._)`{}`;
    return errorObject(cxt, error47, errorPaths);
  }
  function errorObject(cxt, error47, errorPaths = {}) {
    const { gen, it } = cxt;
    const keyValues = [
      errorInstancePath(it, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error47, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
    if (schemaPath) {
      schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword, data, schemaValue, it } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
    if (opts.messages) {
      keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
      keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E.propertyName, propertyName]);
  }
});

// node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = undefined;
  var errors_1 = require_errors();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var boolError = {
    message: "boolean schema is false"
  };
  function topBoolOrEmptySchema(it) {
    const { gen, schema, validateName } = it;
    if (schema === false) {
      falseSchemaError(it, false);
    } else if (typeof schema == "object" && schema.$async === true) {
      gen.return(names_1.default.data);
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, null);
      gen.return(true);
    }
  }
  exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
  function boolOrEmptySchema(it, valid) {
    const { gen, schema } = it;
    if (schema === false) {
      gen.var(valid, false);
      falseSchemaError(it);
    } else {
      gen.var(valid, true);
    }
  }
  exports.boolOrEmptySchema = boolOrEmptySchema;
  function falseSchemaError(it, overrideAllErrors) {
    const { gen, data } = it;
    const cxt = {
      gen,
      keyword: "false schema",
      data,
      schema: false,
      schemaCode: false,
      schemaValue: false,
      params: {},
      it
    };
    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
  }
});

// node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRules = exports.isJSONType = undefined;
  var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
  var jsonTypes = new Set(_jsonTypes);
  function isJSONType(x) {
    return typeof x == "string" && jsonTypes.has(x);
  }
  exports.isJSONType = isJSONType;
  function getRules() {
    const groups = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...groups, integer: true, boolean: true, null: true },
      rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  exports.getRules = getRules;
});

// node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = undefined;
  function schemaHasRulesForType({ schema, self: self2 }, type) {
    const group = self2.RULES.types[type];
    return group && group !== true && shouldUseGroup(schema, group);
  }
  exports.schemaHasRulesForType = schemaHasRulesForType;
  function shouldUseGroup(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
  }
  exports.shouldUseGroup = shouldUseGroup;
  function shouldUseRule(schema, rule) {
    var _a2;
    return schema[rule.keyword] !== undefined || ((_a2 = rule.definition.implements) === null || _a2 === undefined ? undefined : _a2.some((kwd) => schema[kwd] !== undefined));
  }
  exports.shouldUseRule = shouldUseRule;
});

// node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = undefined;
  var rules_1 = require_rules();
  var applicability_1 = require_applicability();
  var errors_1 = require_errors();
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType || (exports.DataType = DataType = {}));
  function getSchemaTypes(schema) {
    const types2 = getJSONTypes(schema.type);
    const hasNull = types2.includes("null");
    if (hasNull) {
      if (schema.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types2.length && schema.nullable !== undefined) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema.nullable === true)
        types2.push("null");
    }
    return types2;
  }
  exports.getSchemaTypes = getSchemaTypes;
  function getJSONTypes(ts) {
    const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types2.every(rules_1.isJSONType))
      return types2;
    throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
  }
  exports.getJSONTypes = getJSONTypes;
  function coerceAndCheckDataType(it, types2) {
    const { gen, data, opts } = it;
    const coerceTo = coerceToTypes(types2, opts.coerceTypes);
    const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types2[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
      gen.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it, types2, coerceTo);
        else
          reportTypeError(it);
      });
    }
    return checkTypes;
  }
  exports.coerceAndCheckDataType = coerceAndCheckDataType;
  var COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(types2, coerceTypes) {
    return coerceTypes ? types2.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
  }
  function coerceData(it, types2, coerceTo) {
    const { gen, data, opts } = it;
    const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
    const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
    if (opts.coerceTypes === "array") {
      gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
    }
    gen.if((0, codegen_1._)`${coerced} !== undefined`);
    for (const t of coerceTo) {
      if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
        coerceSpecificType(t);
      }
    }
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
      gen.assign(data, coerced);
      assignParentData(it, coerced);
    });
    function coerceSpecificType(t) {
      switch (t) {
        case "string":
          gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
          return;
        case "number":
          gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
          return;
        case "integer":
          gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
          return;
        case "boolean":
          gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
          return;
        case "null":
          gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
          gen.assign(coerced, null);
          return;
        case "array":
          gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
      }
    }
  }
  function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
  }
  function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
    let cond;
    switch (dataType) {
      case "null":
        return (0, codegen_1._)`${data} ${EQ} null`;
      case "array":
        cond = (0, codegen_1._)`Array.isArray(${data})`;
        break;
      case "object":
        cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
        break;
      case "integer":
        cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
    }
    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
    function numCond(_cond = codegen_1.nil) {
      return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
    }
  }
  exports.checkDataType = checkDataType;
  function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types2 = (0, util_1.toHash)(dataTypes);
    if (types2.array && types2.object) {
      const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
      cond = types2.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
      delete types2.null;
      delete types2.array;
      delete types2.object;
    } else {
      cond = codegen_1.nil;
    }
    if (types2.number)
      delete types2.integer;
    for (const t in types2)
      cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
    return cond;
  }
  exports.checkDataTypes = checkDataTypes;
  var typeError = {
    message: ({ schema }) => `must be ${schema}`,
    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
  };
  function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    (0, errors_1.reportError)(cxt, typeError);
  }
  exports.reportTypeError = reportTypeError;
  function getTypeErrorContext(it) {
    const { gen, data, schema } = it;
    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
    return {
      gen,
      keyword: "type",
      data,
      schema: schema.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema,
      params: {},
      it
    };
  }
});

// node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assignDefaults = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  function assignDefaults(it, ty) {
    const { properties, items } = it.schema;
    if (ty === "object" && properties) {
      for (const key in properties) {
        assignDefault(it, key, properties[key].default);
      }
    } else if (ty === "array" && Array.isArray(items)) {
      items.forEach((sch, i) => assignDefault(it, i, sch.default));
    }
  }
  exports.assignDefaults = assignDefaults;
  function assignDefault(it, prop, defaultValue) {
    const { gen, compositeRule, data, opts } = it;
    if (defaultValue === undefined)
      return;
    const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
    if (compositeRule) {
      (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
      return;
    }
    let condition = (0, codegen_1._)`${childData} === undefined`;
    if (opts.useDefaults === "empty") {
      condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
    }
    gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
  }
});

// node_modules/ajv/dist/vocabularies/code.js
var require_code3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  var names_1 = require_names();
  var util_2 = require_util2();
  function checkReportMissingProp(cxt, prop) {
    const { gen, data, it } = cxt;
    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
      cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
      cxt.error();
    });
  }
  exports.checkReportMissingProp = checkReportMissingProp;
  function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
  }
  exports.checkMissingProp = checkMissingProp;
  function reportMissingProp(cxt, missing) {
    cxt.setParams({ missingProperty: missing }, true);
    cxt.error();
  }
  exports.reportMissingProp = reportMissingProp;
  function hasPropFunc(gen) {
    return gen.scopeValue("func", {
      ref: Object.prototype.hasOwnProperty,
      code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
    });
  }
  exports.hasPropFunc = hasPropFunc;
  function isOwnProperty(gen, data, property) {
    return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
  }
  exports.isOwnProperty = isOwnProperty;
  function propertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
    return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
  }
  exports.propertyInData = propertyInData;
  function noPropertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
  }
  exports.noPropertyInData = noPropertyInData;
  function allSchemaProperties(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
  }
  exports.allSchemaProperties = allSchemaProperties;
  function schemaProperties(it, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
  }
  exports.schemaProperties = schemaProperties;
  function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
    const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
    const valCxt = [
      [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
      [names_1.default.parentData, it.parentData],
      [names_1.default.parentDataProperty, it.parentDataProperty],
      [names_1.default.rootData, names_1.default.rootData]
    ];
    if (it.opts.dynamicRef)
      valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
    const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
    return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
  }
  exports.callValidateCode = callValidateCode;
  var newRegExp = (0, codegen_1._)`new RegExp`;
  function usePattern({ gen, it: { opts } }, pattern) {
    const u = opts.unicodeRegExp ? "u" : "";
    const { regExp } = opts.code;
    const rx = regExp(pattern, u);
    return gen.scopeValue("pattern", {
      key: rx.toString(),
      ref: rx,
      code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
    });
  }
  exports.usePattern = usePattern;
  function validateArray(cxt) {
    const { gen, data, keyword, it } = cxt;
    const valid = gen.name("valid");
    if (it.allErrors) {
      const validArr = gen.let("valid", true);
      validateItems(() => gen.assign(validArr, false));
      return validArr;
    }
    gen.var(valid, true);
    validateItems(() => gen.break());
    return valid;
    function validateItems(notValid) {
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword,
          dataProp: i,
          dataPropType: util_1.Type.Num
        }, valid);
        gen.if((0, codegen_1.not)(valid), notValid);
      });
    }
  }
  exports.validateArray = validateArray;
  function validateUnion(cxt) {
    const { gen, schema, keyword, it } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
    if (alwaysValid && !it.opts.unevaluated)
      return;
    const valid = gen.let("valid", false);
    const schValid = gen.name("_valid");
    gen.block(() => schema.forEach((_sch, i) => {
      const schCxt = cxt.subschema({
        keyword,
        schemaProp: i,
        compositeRule: true
      }, schValid);
      gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
      const merged = cxt.mergeValidEvaluated(schCxt, schValid);
      if (!merged)
        gen.if((0, codegen_1.not)(valid));
    }));
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
  }
  exports.validateUnion = validateUnion;
});

// node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = undefined;
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var code_1 = require_code3();
  var errors_1 = require_errors();
  function macroKeywordCode(cxt, def) {
    const { gen, keyword, schema, parentSchema, it } = cxt;
    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
    const schemaRef = useKeyword(gen, keyword, macroSchema);
    if (it.opts.validateSchema !== false)
      it.self.validateSchema(macroSchema, true);
    const valid = gen.name("valid");
    cxt.subschema({
      schema: macroSchema,
      schemaPath: codegen_1.nil,
      errSchemaPath: `${it.errSchemaPath}/${keyword}`,
      topSchemaRef: schemaRef,
      compositeRule: true
    }, valid);
    cxt.pass(valid, () => cxt.error(true));
  }
  exports.macroKeywordCode = macroKeywordCode;
  function funcKeywordCode(cxt, def) {
    var _a2;
    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
    checkAsyncKeyword(it, def);
    const validate4 = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
    const validateRef = useKeyword(gen, keyword, validate4);
    const valid = gen.let("valid");
    cxt.block$data(valid, validateKeyword);
    cxt.ok((_a2 = def.valid) !== null && _a2 !== undefined ? _a2 : valid);
    function validateKeyword() {
      if (def.errors === false) {
        assignValid();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => cxt.error());
      } else {
        const ruleErrs = def.async ? validateAsync() : validateSync();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => addErrs(cxt, ruleErrs));
      }
    }
    function validateAsync() {
      const ruleErrs = gen.let("ruleErrs", null);
      gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
      return ruleErrs;
    }
    function validateSync() {
      const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
      gen.assign(validateErrs, null);
      assignValid(codegen_1.nil);
      return validateErrs;
    }
    function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
      const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
      const passSchema = !(("compile" in def) && !$data || def.schema === false);
      gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
    }
    function reportErrs(errors4) {
      var _a3;
      gen.if((0, codegen_1.not)((_a3 = def.valid) !== null && _a3 !== undefined ? _a3 : valid), errors4);
    }
  }
  exports.funcKeywordCode = funcKeywordCode;
  function modifyData(cxt) {
    const { gen, data, it } = cxt;
    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
  }
  function addErrs(cxt, errs) {
    const { gen } = cxt;
    gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      (0, errors_1.extendErrors)(cxt);
    }, () => cxt.error());
  }
  function checkAsyncKeyword({ schemaEnv }, def) {
    if (def.async && !schemaEnv.$async)
      throw new Error("async keyword in sync schema");
  }
  function useKeyword(gen, keyword, result) {
    if (result === undefined)
      throw new Error(`keyword "${keyword}" failed to compile`);
    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
  }
  function validSchemaType(schema, schemaType, allowUndefined = false) {
    return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
  }
  exports.validSchemaType = validSchemaType;
  function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
      throw new Error("ajv implementation error");
    }
    const deps = def.dependencies;
    if (deps === null || deps === undefined ? undefined : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
      throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
    }
    if (def.validateSchema) {
      const valid = def.validateSchema(schema[keyword]);
      if (!valid) {
        const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
        if (opts.validateSchema === "log")
          self2.logger.error(msg);
        else
          throw new Error(msg);
      }
    }
  }
  exports.validateKeywordUsage = validateKeywordUsage;
});

// node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
    if (keyword !== undefined && schema !== undefined) {
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    }
    if (keyword !== undefined) {
      const sch = it.schema[keyword];
      return schemaProp === undefined ? {
        schema: sch,
        schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`
      } : {
        schema: sch[schemaProp],
        schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
        errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
      };
    }
    if (schema !== undefined) {
      if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      }
      return {
        schema,
        schemaPath,
        topSchemaRef,
        errSchemaPath
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  exports.getSubschema = getSubschema;
  function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
    if (data !== undefined && dataProp !== undefined) {
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    }
    const { gen } = it;
    if (dataProp !== undefined) {
      const { errorPath, dataPathArr, opts } = it;
      const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
      dataContextProps(nextData);
      subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
      subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
      subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
    }
    if (data !== undefined) {
      const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
      dataContextProps(nextData);
      if (propertyName !== undefined)
        subschema.propertyName = propertyName;
    }
    if (dataTypes)
      subschema.dataTypes = dataTypes;
    function dataContextProps(_nextData) {
      subschema.data = _nextData;
      subschema.dataLevel = it.dataLevel + 1;
      subschema.dataTypes = [];
      it.definedProperties = new Set;
      subschema.parentData = it.data;
      subschema.dataNames = [...it.dataNames, _nextData];
    }
  }
  exports.extendSubschemaData = extendSubschemaData;
  function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
    if (compositeRule !== undefined)
      subschema.compositeRule = compositeRule;
    if (createErrors !== undefined)
      subschema.createErrors = createErrors;
    if (allErrors !== undefined)
      subschema.allErrors = allErrors;
    subschema.jtdDiscriminator = jtdDiscriminator;
    subschema.jtdMetadata = jtdMetadata;
  }
  exports.extendSubschemaMode = extendSubschemaMode;
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports, module) => {
  module.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length;i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length;i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS((exports, module) => {
  var traverse = module.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {};
    var post = cb.post || function() {};
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true,
    if: true,
    then: true,
    else: true
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse.propsKeywords = {
    $defs: true,
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse.arrayKeywords) {
            for (var i = 0;i < sch.length; i++)
              _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          }
        } else if (key in traverse.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          }
        } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  }
  function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
});

// node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = undefined;
  var util_1 = require_util2();
  var equal = require_fast_deep_equal();
  var traverse = require_json_schema_traverse();
  var SIMPLE_INLINED = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function inlineRef(schema, limit = true) {
    if (typeof schema == "boolean")
      return true;
    if (limit === true)
      return !hasRef(schema);
    if (!limit)
      return false;
    return countKeys(schema) <= limit;
  }
  exports.inlineRef = inlineRef;
  var REF_KEYWORDS = new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function hasRef(schema) {
    for (const key in schema) {
      if (REF_KEYWORDS.has(key))
        return true;
      const sch = schema[key];
      if (Array.isArray(sch) && sch.some(hasRef))
        return true;
      if (typeof sch == "object" && hasRef(sch))
        return true;
    }
    return false;
  }
  function countKeys(schema) {
    let count = 0;
    for (const key in schema) {
      if (key === "$ref")
        return Infinity;
      count++;
      if (SIMPLE_INLINED.has(key))
        continue;
      if (typeof schema[key] == "object") {
        (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
      }
      if (count === Infinity)
        return Infinity;
    }
    return count;
  }
  function getFullPath(resolver, id = "", normalize) {
    if (normalize !== false)
      id = normalizeId(id);
    const p = resolver.parse(id);
    return _getFullPath(resolver, p);
  }
  exports.getFullPath = getFullPath;
  function _getFullPath(resolver, p) {
    const serialized = resolver.serialize(p);
    return serialized.split("#")[0] + "#";
  }
  exports._getFullPath = _getFullPath;
  var TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
  }
  exports.normalizeId = normalizeId;
  function resolveUrl(resolver, baseId, id) {
    id = normalizeId(id);
    return resolver.resolve(baseId, id);
  }
  exports.resolveUrl = resolveUrl;
  var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
  function getSchemaRefs(schema, baseId) {
    if (typeof schema == "boolean")
      return {};
    const { schemaId, uriResolver } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(uriResolver, schId, false);
    const localRefs = {};
    const schemaRefs = new Set;
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
      if (parentJsonPtr === undefined)
        return;
      const fullPath = pathPrefix + jsonPtr;
      let innerBaseId = baseIds[parentJsonPtr];
      if (typeof sch[schemaId] == "string")
        innerBaseId = addRef.call(this, sch[schemaId]);
      addAnchor.call(this, sch.$anchor);
      addAnchor.call(this, sch.$dynamicAnchor);
      baseIds[jsonPtr] = innerBaseId;
      function addRef(ref) {
        const _resolve = this.opts.uriResolver.resolve;
        ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
        if (schemaRefs.has(ref))
          throw ambiguos(ref);
        schemaRefs.add(ref);
        let schOrRef = this.refs[ref];
        if (typeof schOrRef == "string")
          schOrRef = this.refs[schOrRef];
        if (typeof schOrRef == "object") {
          checkAmbiguosRef(sch, schOrRef.schema, ref);
        } else if (ref !== normalizeId(fullPath)) {
          if (ref[0] === "#") {
            checkAmbiguosRef(sch, localRefs[ref], ref);
            localRefs[ref] = sch;
          } else {
            this.refs[ref] = fullPath;
          }
        }
        return ref;
      }
      function addAnchor(anchor) {
        if (typeof anchor == "string") {
          if (!ANCHOR.test(anchor))
            throw new Error(`invalid anchor "${anchor}"`);
          addRef.call(this, `#${anchor}`);
        }
      }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref) {
      if (sch2 !== undefined && !equal(sch1, sch2))
        throw ambiguos(ref);
    }
    function ambiguos(ref) {
      return new Error(`reference "${ref}" resolves to more than one schema`);
    }
  }
  exports.getSchemaRefs = getSchemaRefs;
});

// node_modules/ajv/dist/compile/validate/index.js
var require_validate2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getData = exports.KeywordCxt = exports.validateFunctionCode = undefined;
  var boolSchema_1 = require_boolSchema();
  var dataType_1 = require_dataType();
  var applicability_1 = require_applicability();
  var dataType_2 = require_dataType();
  var defaults_1 = require_defaults();
  var keyword_1 = require_keyword();
  var subschema_1 = require_subschema();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var resolve_1 = require_resolve();
  var util_1 = require_util2();
  var errors_1 = require_errors();
  function validateFunctionCode(it) {
    if (isSchemaObj(it)) {
      checkKeywords(it);
      if (schemaCxtHasRules(it)) {
        topSchemaObjCode(it);
        return;
      }
    }
    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
  }
  exports.validateFunctionCode = validateFunctionCode;
  function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
    if (opts.code.es5) {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
        gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
        destructureValCxtES5(gen, opts);
        gen.code(body);
      });
    } else {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
  }
  function destructureValCxt(opts) {
    return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
  }
  function destructureValCxtES5(gen, opts) {
    gen.if(names_1.default.valCxt, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
      gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
    }, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.rootData, names_1.default.data);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
    });
  }
  function topSchemaObjCode(it) {
    const { schema, opts, gen } = it;
    validateFunction(it, () => {
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      checkNoDefault(it);
      gen.let(names_1.default.vErrors, null);
      gen.let(names_1.default.errors, 0);
      if (opts.unevaluated)
        resetEvaluated(it);
      typeAndKeywords(it);
      returnResults(it);
    });
    return;
  }
  function resetEvaluated(it) {
    const { gen, validateName } = it;
    it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
    gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
    gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
  }
  function funcSourceUrl(schema, opts) {
    const schId = typeof schema == "object" && schema[opts.schemaId];
    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
  }
  function subschemaCode(it, valid) {
    if (isSchemaObj(it)) {
      checkKeywords(it);
      if (schemaCxtHasRules(it)) {
        subSchemaObjCode(it, valid);
        return;
      }
    }
    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
  }
  function schemaCxtHasRules({ schema, self: self2 }) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (self2.RULES.all[key])
        return true;
    return false;
  }
  function isSchemaObj(it) {
    return typeof it.schema != "boolean";
  }
  function subSchemaObjCode(it, valid) {
    const { schema, gen, opts } = it;
    if (opts.$comment && schema.$comment)
      commentKeyword(it);
    updateContext(it);
    checkAsyncSchema(it);
    const errsCount = gen.const("_errs", names_1.default.errors);
    typeAndKeywords(it, errsCount);
    gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
  }
  function checkKeywords(it) {
    (0, util_1.checkUnknownRules)(it);
    checkRefsAndKeywords(it);
  }
  function typeAndKeywords(it, errsCount) {
    if (it.opts.jtd)
      return schemaKeywords(it, [], false, errsCount);
    const types2 = (0, dataType_1.getSchemaTypes)(it.schema);
    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types2);
    schemaKeywords(it, types2, !checkedTypes, errsCount);
  }
  function checkRefsAndKeywords(it) {
    const { schema, errSchemaPath, opts, self: self2 } = it;
    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
      self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
  }
  function checkNoDefault(it) {
    const { schema, opts } = it;
    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
      (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
    }
  }
  function updateContext(it) {
    const schId = it.schema[it.opts.schemaId];
    if (schId)
      it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
  }
  function checkAsyncSchema(it) {
    if (it.schema.$async && !it.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
    const msg = schema.$comment;
    if (opts.$comment === true) {
      gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
    } else if (typeof opts.$comment == "function") {
      const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
      const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
      gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
    }
  }
  function returnResults(it) {
    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
    if (schemaEnv.$async) {
      gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
      if (opts.unevaluated)
        assignEvaluated(it);
      gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
    }
  }
  function assignEvaluated({ gen, evaluated, props, items }) {
    if (props instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.props`, props);
    if (items instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.items`, items);
  }
  function schemaKeywords(it, types2, typeErrors, errsCount) {
    const { gen, schema, data, allErrors, opts, self: self2 } = it;
    const { RULES } = self2;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
      gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
      return;
    }
    if (!opts.jtd)
      checkStrictTypes(it, types2);
    gen.block(() => {
      for (const group of RULES.rules)
        groupKeywords(group);
      groupKeywords(RULES.post);
    });
    function groupKeywords(group) {
      if (!(0, applicability_1.shouldUseGroup)(schema, group))
        return;
      if (group.type) {
        gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
        iterateKeywords(it, group);
        if (types2.length === 1 && types2[0] === group.type && typeErrors) {
          gen.else();
          (0, dataType_2.reportTypeError)(it);
        }
        gen.endIf();
      } else {
        iterateKeywords(it, group);
      }
      if (!allErrors)
        gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
    }
  }
  function iterateKeywords(it, group) {
    const { gen, schema, opts: { useDefaults } } = it;
    if (useDefaults)
      (0, defaults_1.assignDefaults)(it, group.type);
    gen.block(() => {
      for (const rule of group.rules) {
        if ((0, applicability_1.shouldUseRule)(schema, rule)) {
          keywordCode(it, rule.keyword, rule.definition, group.type);
        }
      }
    });
  }
  function checkStrictTypes(it, types2) {
    if (it.schemaEnv.meta || !it.opts.strictTypes)
      return;
    checkContextTypes(it, types2);
    if (!it.opts.allowUnionTypes)
      checkMultipleTypes(it, types2);
    checkKeywordTypes(it, it.dataTypes);
  }
  function checkContextTypes(it, types2) {
    if (!types2.length)
      return;
    if (!it.dataTypes.length) {
      it.dataTypes = types2;
      return;
    }
    types2.forEach((t) => {
      if (!includesType(it.dataTypes, t)) {
        strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
      }
    });
    narrowSchemaTypes(it, types2);
  }
  function checkMultipleTypes(it, ts) {
    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
      strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    }
  }
  function checkKeywordTypes(it, ts) {
    const rules = it.self.RULES.all;
    for (const keyword in rules) {
      const rule = rules[keyword];
      if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
        const { type } = rule.definition;
        if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
          strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
        }
      }
    }
  }
  function hasApplicableType(schTs, kwdT) {
    return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
  }
  function includesType(ts, t) {
    return ts.includes(t) || t === "integer" && ts.includes("number");
  }
  function narrowSchemaTypes(it, withTypes) {
    const ts = [];
    for (const t of it.dataTypes) {
      if (includesType(withTypes, t))
        ts.push(t);
      else if (withTypes.includes("integer") && t === "number")
        ts.push("integer");
    }
    it.dataTypes = ts;
  }
  function strictTypesError(it, msg) {
    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
    msg += ` at "${schemaPath}" (strictTypes)`;
    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
  }

  class KeywordCxt {
    constructor(it, def, keyword) {
      (0, keyword_1.validateKeywordUsage)(it, def, keyword);
      this.gen = it.gen;
      this.allErrors = it.allErrors;
      this.keyword = keyword;
      this.data = it.data;
      this.schema = it.schema[keyword];
      this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
      this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
      this.schemaType = def.schemaType;
      this.parentSchema = it.schema;
      this.params = {};
      this.it = it;
      this.def = def;
      if (this.$data) {
        this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
      } else {
        this.schemaCode = this.schemaValue;
        if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
          throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
        }
      }
      if ("code" in def ? def.trackErrors : def.errors !== false) {
        this.errsCount = it.gen.const("_errs", names_1.default.errors);
      }
    }
    result(condition, successAction, failAction) {
      this.failResult((0, codegen_1.not)(condition), successAction, failAction);
    }
    failResult(condition, successAction, failAction) {
      this.gen.if(condition);
      if (failAction)
        failAction();
      else
        this.error();
      if (successAction) {
        this.gen.else();
        successAction();
        if (this.allErrors)
          this.gen.endIf();
      } else {
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
    }
    pass(condition, failAction) {
      this.failResult((0, codegen_1.not)(condition), undefined, failAction);
    }
    fail(condition) {
      if (condition === undefined) {
        this.error();
        if (!this.allErrors)
          this.gen.if(false);
        return;
      }
      this.gen.if(condition);
      this.error();
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
    fail$data(condition) {
      if (!this.$data)
        return this.fail(condition);
      const { schemaCode } = this;
      this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
    }
    error(append, errorParams, errorPaths) {
      if (errorParams) {
        this.setParams(errorParams);
        this._error(append, errorPaths);
        this.setParams({});
        return;
      }
      this._error(append, errorPaths);
    }
    _error(append, errorPaths) {
      (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
    }
    $dataError() {
      (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
    }
    reset() {
      if (this.errsCount === undefined)
        throw new Error('add "trackErrors" to keyword definition');
      (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(cond) {
      if (!this.allErrors)
        this.gen.if(cond);
    }
    setParams(obj, assign) {
      if (assign)
        Object.assign(this.params, obj);
      else
        this.params = obj;
    }
    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
      this.gen.block(() => {
        this.check$data(valid, $dataValid);
        codeBlock();
      });
    }
    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
      if (!this.$data)
        return;
      const { gen, schemaCode, schemaType, def } = this;
      gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
      if (valid !== codegen_1.nil)
        gen.assign(valid, true);
      if (schemaType.length || def.validateSchema) {
        gen.elseIf(this.invalid$data());
        this.$dataError();
        if (valid !== codegen_1.nil)
          gen.assign(valid, false);
      }
      gen.else();
    }
    invalid$data() {
      const { gen, schemaCode, schemaType, def, it } = this;
      return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
      function wrong$DataType() {
        if (schemaType.length) {
          if (!(schemaCode instanceof codegen_1.Name))
            throw new Error("ajv implementation error");
          const st = Array.isArray(schemaType) ? schemaType : [schemaType];
          return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
        }
        return codegen_1.nil;
      }
      function invalid$DataSchema() {
        if (def.validateSchema) {
          const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
          return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
        }
        return codegen_1.nil;
      }
    }
    subschema(appl, valid) {
      const subschema = (0, subschema_1.getSubschema)(this.it, appl);
      (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
      (0, subschema_1.extendSubschemaMode)(subschema, appl);
      const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
      subschemaCode(nextContext, valid);
      return nextContext;
    }
    mergeEvaluated(schemaCxt, toName) {
      const { it, gen } = this;
      if (!it.opts.unevaluated)
        return;
      if (it.props !== true && schemaCxt.props !== undefined) {
        it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
      }
      if (it.items !== true && schemaCxt.items !== undefined) {
        it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
      }
    }
    mergeValidEvaluated(schemaCxt, valid) {
      const { it, gen } = this;
      if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
        gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
        return true;
      }
    }
  }
  exports.KeywordCxt = KeywordCxt;
  function keywordCode(it, keyword, def, ruleType) {
    const cxt = new KeywordCxt(it, def, keyword);
    if ("code" in def) {
      def.code(cxt, ruleType);
    } else if (cxt.$data && def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    } else if ("macro" in def) {
      (0, keyword_1.macroKeywordCode)(cxt, def);
    } else if (def.compile || def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    }
  }
  var JSON_POINTER2 = /^\/(?:[^~]|~0|~1)*$/;
  var RELATIVE_JSON_POINTER2 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function getData($data, { dataLevel, dataNames, dataPathArr }) {
    let jsonPointer;
    let data;
    if ($data === "")
      return names_1.default.rootData;
    if ($data[0] === "/") {
      if (!JSON_POINTER2.test($data))
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      jsonPointer = $data;
      data = names_1.default.rootData;
    } else {
      const matches = RELATIVE_JSON_POINTER2.exec($data);
      if (!matches)
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      const up = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer === "#") {
        if (up >= dataLevel)
          throw new Error(errorMsg("property/index", up));
        return dataPathArr[dataLevel - up];
      }
      if (up > dataLevel)
        throw new Error(errorMsg("data", up));
      data = dataNames[dataLevel - up];
      if (!jsonPointer)
        return data;
    }
    let expr = data;
    const segments = jsonPointer.split("/");
    for (const segment of segments) {
      if (segment) {
        data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
        expr = (0, codegen_1._)`${expr} && ${data}`;
      }
    }
    return expr;
    function errorMsg(pointerType, up) {
      return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
    }
  }
  exports.getData = getData;
});

// node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class ValidationError extends Error {
    constructor(errors4) {
      super("validation failed");
      this.errors = errors4;
      this.ajv = this.validation = true;
    }
  }
  exports.default = ValidationError;
});

// node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var resolve_1 = require_resolve();

  class MissingRefError extends Error {
    constructor(resolver, baseId, ref, msg) {
      super(msg || `can't resolve reference ${ref} from id ${baseId}`);
      this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
      this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
    }
  }
  exports.default = MissingRefError;
});

// node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = undefined;
  var codegen_1 = require_codegen();
  var validation_error_1 = require_validation_error();
  var names_1 = require_names();
  var resolve_1 = require_resolve();
  var util_1 = require_util2();
  var validate_1 = require_validate2();

  class SchemaEnv {
    constructor(env) {
      var _a2;
      this.refs = {};
      this.dynamicAnchors = {};
      let schema;
      if (typeof env.schema == "object")
        schema = env.schema;
      this.schema = env.schema;
      this.schemaId = env.schemaId;
      this.root = env.root || this;
      this.baseId = (_a2 = env.baseId) !== null && _a2 !== undefined ? _a2 : (0, resolve_1.normalizeId)(schema === null || schema === undefined ? undefined : schema[env.schemaId || "$id"]);
      this.schemaPath = env.schemaPath;
      this.localRefs = env.localRefs;
      this.meta = env.meta;
      this.$async = schema === null || schema === undefined ? undefined : schema.$async;
      this.refs = {};
    }
  }
  exports.SchemaEnv = SchemaEnv;
  function compileSchema(sch) {
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
      _ValidationError = gen.scopeValue("Error", {
        ref: validation_error_1.default,
        code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
      });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
      gen,
      allErrors: this.opts.allErrors,
      data: names_1.default.data,
      parentData: names_1.default.parentData,
      parentDataProperty: names_1.default.parentDataProperty,
      dataNames: [names_1.default.data],
      dataPathArr: [codegen_1.nil],
      dataLevel: 0,
      dataTypes: [],
      definedProperties: new Set,
      topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
      validateName,
      ValidationError: _ValidationError,
      schema: sch.schema,
      schemaEnv: sch,
      rootId,
      baseId: sch.baseId || rootId,
      schemaPath: codegen_1.nil,
      errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, codegen_1._)`""`,
      opts: this.opts,
      self: this
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      (0, validate_1.validateFunctionCode)(schemaCxt);
      gen.optimize(this.opts.code.optimize);
      const validateCode = gen.toString();
      sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
      if (this.opts.code.process)
        sourceCode = this.opts.code.process(sourceCode, sch);
      const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
      const validate4 = makeValidate(this, this.scope.get());
      this.scope.value(validateName, { ref: validate4 });
      validate4.errors = null;
      validate4.schema = sch.schema;
      validate4.schemaEnv = sch;
      if (sch.$async)
        validate4.$async = true;
      if (this.opts.code.source === true) {
        validate4.source = { validateName, validateCode, scopeValues: gen._values };
      }
      if (this.opts.unevaluated) {
        const { props, items } = schemaCxt;
        validate4.evaluated = {
          props: props instanceof codegen_1.Name ? undefined : props,
          items: items instanceof codegen_1.Name ? undefined : items,
          dynamicProps: props instanceof codegen_1.Name,
          dynamicItems: items instanceof codegen_1.Name
        };
        if (validate4.source)
          validate4.source.evaluated = (0, codegen_1.stringify)(validate4.evaluated);
      }
      sch.validate = validate4;
      return sch;
    } catch (e) {
      delete sch.validate;
      delete sch.validateName;
      if (sourceCode)
        this.logger.error("Error compiling schema, function code:", sourceCode);
      throw e;
    } finally {
      this._compilations.delete(sch);
    }
  }
  exports.compileSchema = compileSchema;
  function resolveRef2(root, baseId, ref) {
    var _a2;
    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
    const schOrFunc = root.refs[ref];
    if (schOrFunc)
      return schOrFunc;
    let _sch = resolve.call(this, root, ref);
    if (_sch === undefined) {
      const schema = (_a2 = root.localRefs) === null || _a2 === undefined ? undefined : _a2[ref];
      const { schemaId } = this.opts;
      if (schema)
        _sch = new SchemaEnv({ schema, schemaId, root, baseId });
    }
    if (_sch === undefined)
      return;
    return root.refs[ref] = inlineOrCompile.call(this, _sch);
  }
  exports.resolveRef = resolveRef2;
  function inlineOrCompile(sch) {
    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
      return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
  }
  function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
      if (sameSchemaEnv(sch, schEnv))
        return sch;
    }
  }
  exports.getCompilingSchema = getCompilingSchema;
  function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
  }
  function resolve(root, ref) {
    let sch;
    while (typeof (sch = this.refs[ref]) == "string")
      ref = sch;
    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
  }
  function resolveSchema(root, ref) {
    const p = this.opts.uriResolver.parse(ref);
    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
      return getJsonPointer.call(this, p, root);
    }
    const id = (0, resolve_1.normalizeId)(refPath);
    const schOrRef = this.refs[id] || this.schemas[id];
    if (typeof schOrRef == "string") {
      const sch = resolveSchema.call(this, root, schOrRef);
      if (typeof (sch === null || sch === undefined ? undefined : sch.schema) !== "object")
        return;
      return getJsonPointer.call(this, p, sch);
    }
    if (typeof (schOrRef === null || schOrRef === undefined ? undefined : schOrRef.schema) !== "object")
      return;
    if (!schOrRef.validate)
      compileSchema.call(this, schOrRef);
    if (id === (0, resolve_1.normalizeId)(ref)) {
      const { schema } = schOrRef;
      const { schemaId } = this.opts;
      const schId = schema[schemaId];
      if (schId)
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      return new SchemaEnv({ schema, schemaId, root, baseId });
    }
    return getJsonPointer.call(this, p, schOrRef);
  }
  exports.resolveSchema = resolveSchema;
  var PREVENT_SCOPE_CHANGE = new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a2;
    if (((_a2 = parsedRef.fragment) === null || _a2 === undefined ? undefined : _a2[0]) !== "/")
      return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
      if (typeof schema === "boolean")
        return;
      const partSchema = schema[(0, util_1.unescapeFragment)(part)];
      if (partSchema === undefined)
        return;
      schema = partSchema;
      const schId = typeof schema === "object" && schema[this.opts.schemaId];
      if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
      const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
      env = resolveSchema.call(this, root, $ref);
    }
    const { schemaId } = this.opts;
    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
    if (env.schema !== env.root.schema)
      return env;
    return;
  }
});

// node_modules/ajv/dist/refs/data.json
var require_data = __commonJS((exports, module) => {
  module.exports = {
    $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
    type: "object",
    required: ["$data"],
    properties: {
      $data: {
        type: "string",
        anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
      }
    },
    additionalProperties: false
  };
});

// node_modules/fast-uri/lib/utils.js
var require_utils2 = __commonJS((exports, module) => {
  var isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
  var isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
  function stringArrayToHexStripped(input) {
    let acc = "";
    let code = 0;
    let i = 0;
    for (i = 0;i < input.length; i++) {
      code = input[i].charCodeAt(0);
      if (code === 48) {
        continue;
      }
      if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
        return "";
      }
      acc += input[i];
      break;
    }
    for (i += 1;i < input.length; i++) {
      code = input[i].charCodeAt(0);
      if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
        return "";
      }
      acc += input[i];
    }
    return acc;
  }
  var nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
  function consumeIsZone(buffer) {
    buffer.length = 0;
    return true;
  }
  function consumeHextets(buffer, address, output) {
    if (buffer.length) {
      const hex3 = stringArrayToHexStripped(buffer);
      if (hex3 !== "") {
        address.push(hex3);
      } else {
        output.error = true;
        return false;
      }
      buffer.length = 0;
    }
    return true;
  }
  function getIPV6(input) {
    let tokenCount = 0;
    const output = { error: false, address: "", zone: "" };
    const address = [];
    const buffer = [];
    let endipv6Encountered = false;
    let endIpv6 = false;
    let consume = consumeHextets;
    for (let i = 0;i < input.length; i++) {
      const cursor = input[i];
      if (cursor === "[" || cursor === "]") {
        continue;
      }
      if (cursor === ":") {
        if (endipv6Encountered === true) {
          endIpv6 = true;
        }
        if (!consume(buffer, address, output)) {
          break;
        }
        if (++tokenCount > 7) {
          output.error = true;
          break;
        }
        if (i > 0 && input[i - 1] === ":") {
          endipv6Encountered = true;
        }
        address.push(":");
        continue;
      } else if (cursor === "%") {
        if (!consume(buffer, address, output)) {
          break;
        }
        consume = consumeIsZone;
      } else {
        buffer.push(cursor);
        continue;
      }
    }
    if (buffer.length) {
      if (consume === consumeIsZone) {
        output.zone = buffer.join("");
      } else if (endIpv6) {
        address.push(buffer.join(""));
      } else {
        address.push(stringArrayToHexStripped(buffer));
      }
    }
    output.address = address.join("");
    return output;
  }
  function normalizeIPv6(host) {
    if (findToken(host, ":") < 2) {
      return { host, isIPV6: false };
    }
    const ipv63 = getIPV6(host);
    if (!ipv63.error) {
      let newHost = ipv63.address;
      let escapedHost = ipv63.address;
      if (ipv63.zone) {
        newHost += "%" + ipv63.zone;
        escapedHost += "%25" + ipv63.zone;
      }
      return { host: newHost, isIPV6: true, escapedHost };
    } else {
      return { host, isIPV6: false };
    }
  }
  function findToken(str, token) {
    let ind = 0;
    for (let i = 0;i < str.length; i++) {
      if (str[i] === token)
        ind++;
    }
    return ind;
  }
  function removeDotSegments(path) {
    let input = path;
    const output = [];
    let nextSlash = -1;
    let len = 0;
    while (len = input.length) {
      if (len === 1) {
        if (input === ".") {
          break;
        } else if (input === "/") {
          output.push("/");
          break;
        } else {
          output.push(input);
          break;
        }
      } else if (len === 2) {
        if (input[0] === ".") {
          if (input[1] === ".") {
            break;
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/") {
          if (input[1] === "." || input[1] === "/") {
            output.push("/");
            break;
          }
        }
      } else if (len === 3) {
        if (input === "/..") {
          if (output.length !== 0) {
            output.pop();
          }
          output.push("/");
          break;
        }
      }
      if (input[0] === ".") {
        if (input[1] === ".") {
          if (input[2] === "/") {
            input = input.slice(3);
            continue;
          }
        } else if (input[1] === "/") {
          input = input.slice(2);
          continue;
        }
      } else if (input[0] === "/") {
        if (input[1] === ".") {
          if (input[2] === "/") {
            input = input.slice(2);
            continue;
          } else if (input[2] === ".") {
            if (input[3] === "/") {
              input = input.slice(3);
              if (output.length !== 0) {
                output.pop();
              }
              continue;
            }
          }
        }
      }
      if ((nextSlash = input.indexOf("/", 1)) === -1) {
        output.push(input);
        break;
      } else {
        output.push(input.slice(0, nextSlash));
        input = input.slice(nextSlash);
      }
    }
    return output.join("");
  }
  function normalizeComponentEncoding(component, esc2) {
    const func = esc2 !== true ? escape : unescape;
    if (component.scheme !== undefined) {
      component.scheme = func(component.scheme);
    }
    if (component.userinfo !== undefined) {
      component.userinfo = func(component.userinfo);
    }
    if (component.host !== undefined) {
      component.host = func(component.host);
    }
    if (component.path !== undefined) {
      component.path = func(component.path);
    }
    if (component.query !== undefined) {
      component.query = func(component.query);
    }
    if (component.fragment !== undefined) {
      component.fragment = func(component.fragment);
    }
    return component;
  }
  function recomposeAuthority(component) {
    const uriTokens = [];
    if (component.userinfo !== undefined) {
      uriTokens.push(component.userinfo);
      uriTokens.push("@");
    }
    if (component.host !== undefined) {
      let host = unescape(component.host);
      if (!isIPv4(host)) {
        const ipV6res = normalizeIPv6(host);
        if (ipV6res.isIPV6 === true) {
          host = `[${ipV6res.escapedHost}]`;
        } else {
          host = component.host;
        }
      }
      uriTokens.push(host);
    }
    if (typeof component.port === "number" || typeof component.port === "string") {
      uriTokens.push(":");
      uriTokens.push(String(component.port));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
  }
  module.exports = {
    nonSimpleDomain,
    recomposeAuthority,
    normalizeComponentEncoding,
    removeDotSegments,
    isIPv4,
    isUUID,
    normalizeIPv6,
    stringArrayToHexStripped
  };
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS((exports, module) => {
  var { isUUID } = require_utils2();
  var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
  var supportedSchemeNames = [
    "http",
    "https",
    "ws",
    "wss",
    "urn",
    "urn:uuid"
  ];
  function isValidSchemeName(name) {
    return supportedSchemeNames.indexOf(name) !== -1;
  }
  function wsIsSecure(wsComponent) {
    if (wsComponent.secure === true) {
      return true;
    } else if (wsComponent.secure === false) {
      return false;
    } else if (wsComponent.scheme) {
      return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
    } else {
      return false;
    }
  }
  function httpParse(component) {
    if (!component.host) {
      component.error = component.error || "HTTP URIs must have a host.";
    }
    return component;
  }
  function httpSerialize(component) {
    const secure = String(component.scheme).toLowerCase() === "https";
    if (component.port === (secure ? 443 : 80) || component.port === "") {
      component.port = undefined;
    }
    if (!component.path) {
      component.path = "/";
    }
    return component;
  }
  function wsParse(wsComponent) {
    wsComponent.secure = wsIsSecure(wsComponent);
    wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
    wsComponent.path = undefined;
    wsComponent.query = undefined;
    return wsComponent;
  }
  function wsSerialize(wsComponent) {
    if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
      wsComponent.port = undefined;
    }
    if (typeof wsComponent.secure === "boolean") {
      wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
      wsComponent.secure = undefined;
    }
    if (wsComponent.resourceName) {
      const [path, query] = wsComponent.resourceName.split("?");
      wsComponent.path = path && path !== "/" ? path : undefined;
      wsComponent.query = query;
      wsComponent.resourceName = undefined;
    }
    wsComponent.fragment = undefined;
    return wsComponent;
  }
  function urnParse(urnComponent, options) {
    if (!urnComponent.path) {
      urnComponent.error = "URN can not be parsed";
      return urnComponent;
    }
    const matches = urnComponent.path.match(URN_REG);
    if (matches) {
      const scheme = options.scheme || urnComponent.scheme || "urn";
      urnComponent.nid = matches[1].toLowerCase();
      urnComponent.nss = matches[2];
      const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
      const schemeHandler = getSchemeHandler(urnScheme);
      urnComponent.path = undefined;
      if (schemeHandler) {
        urnComponent = schemeHandler.parse(urnComponent, options);
      }
    } else {
      urnComponent.error = urnComponent.error || "URN can not be parsed.";
    }
    return urnComponent;
  }
  function urnSerialize(urnComponent, options) {
    if (urnComponent.nid === undefined) {
      throw new Error("URN without nid cannot be serialized");
    }
    const scheme = options.scheme || urnComponent.scheme || "urn";
    const nid = urnComponent.nid.toLowerCase();
    const urnScheme = `${scheme}:${options.nid || nid}`;
    const schemeHandler = getSchemeHandler(urnScheme);
    if (schemeHandler) {
      urnComponent = schemeHandler.serialize(urnComponent, options);
    }
    const uriComponent = urnComponent;
    const nss = urnComponent.nss;
    uriComponent.path = `${nid || options.nid}:${nss}`;
    options.skipEscape = true;
    return uriComponent;
  }
  function urnuuidParse(urnComponent, options) {
    const uuidComponent = urnComponent;
    uuidComponent.uuid = uuidComponent.nss;
    uuidComponent.nss = undefined;
    if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
      uuidComponent.error = uuidComponent.error || "UUID is not valid.";
    }
    return uuidComponent;
  }
  function urnuuidSerialize(uuidComponent) {
    const urnComponent = uuidComponent;
    urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
    return urnComponent;
  }
  var http = {
    scheme: "http",
    domainHost: true,
    parse: httpParse,
    serialize: httpSerialize
  };
  var https = {
    scheme: "https",
    domainHost: http.domainHost,
    parse: httpParse,
    serialize: httpSerialize
  };
  var ws = {
    scheme: "ws",
    domainHost: true,
    parse: wsParse,
    serialize: wsSerialize
  };
  var wss = {
    scheme: "wss",
    domainHost: ws.domainHost,
    parse: ws.parse,
    serialize: ws.serialize
  };
  var urn = {
    scheme: "urn",
    parse: urnParse,
    serialize: urnSerialize,
    skipNormalize: true
  };
  var urnuuid = {
    scheme: "urn:uuid",
    parse: urnuuidParse,
    serialize: urnuuidSerialize,
    skipNormalize: true
  };
  var SCHEMES = {
    http,
    https,
    ws,
    wss,
    urn,
    "urn:uuid": urnuuid
  };
  Object.setPrototypeOf(SCHEMES, null);
  function getSchemeHandler(scheme) {
    return scheme && (SCHEMES[scheme] || SCHEMES[scheme.toLowerCase()]) || undefined;
  }
  module.exports = {
    wsIsSecure,
    SCHEMES,
    isValidSchemeName,
    getSchemeHandler
  };
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS((exports, module) => {
  var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils2();
  var { SCHEMES, getSchemeHandler } = require_schemes();
  function normalize(uri2, options) {
    if (typeof uri2 === "string") {
      uri2 = serialize2(parse7(uri2, options), options);
    } else if (typeof uri2 === "object") {
      uri2 = parse7(serialize2(uri2, options), options);
    }
    return uri2;
  }
  function resolve(baseURI, relativeURI, options) {
    const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
    const resolved = resolveComponent(parse7(baseURI, schemelessOptions), parse7(relativeURI, schemelessOptions), schemelessOptions, true);
    schemelessOptions.skipEscape = true;
    return serialize2(resolved, schemelessOptions);
  }
  function resolveComponent(base, relative, options, skipNormalization) {
    const target = {};
    if (!skipNormalization) {
      base = parse7(serialize2(base, options), options);
      relative = parse7(serialize2(relative, options), options);
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
      target.scheme = relative.scheme;
      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || "");
      target.query = relative.query;
    } else {
      if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (!relative.path) {
          target.path = base.path;
          if (relative.query !== undefined) {
            target.query = relative.query;
          } else {
            target.query = base.query;
          }
        } else {
          if (relative.path[0] === "/") {
            target.path = removeDotSegments(relative.path);
          } else {
            if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
              target.path = "/" + relative.path;
            } else if (!base.path) {
              target.path = relative.path;
            } else {
              target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
            }
            target.path = removeDotSegments(target.path);
          }
          target.query = relative.query;
        }
        target.userinfo = base.userinfo;
        target.host = base.host;
        target.port = base.port;
      }
      target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
  }
  function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
      uriA = unescape(uriA);
      uriA = serialize2(normalizeComponentEncoding(parse7(uriA, options), true), { ...options, skipEscape: true });
    } else if (typeof uriA === "object") {
      uriA = serialize2(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
    }
    if (typeof uriB === "string") {
      uriB = unescape(uriB);
      uriB = serialize2(normalizeComponentEncoding(parse7(uriB, options), true), { ...options, skipEscape: true });
    } else if (typeof uriB === "object") {
      uriB = serialize2(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
    }
    return uriA.toLowerCase() === uriB.toLowerCase();
  }
  function serialize2(cmpts, opts) {
    const component = {
      host: cmpts.host,
      scheme: cmpts.scheme,
      userinfo: cmpts.userinfo,
      port: cmpts.port,
      path: cmpts.path,
      query: cmpts.query,
      nid: cmpts.nid,
      nss: cmpts.nss,
      uuid: cmpts.uuid,
      fragment: cmpts.fragment,
      reference: cmpts.reference,
      resourceName: cmpts.resourceName,
      secure: cmpts.secure,
      error: ""
    };
    const options = Object.assign({}, opts);
    const uriTokens = [];
    const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
    if (schemeHandler && schemeHandler.serialize)
      schemeHandler.serialize(component, options);
    if (component.path !== undefined) {
      if (!options.skipEscape) {
        component.path = escape(component.path);
        if (component.scheme !== undefined) {
          component.path = component.path.split("%3A").join(":");
        }
      } else {
        component.path = unescape(component.path);
      }
    }
    if (options.reference !== "suffix" && component.scheme) {
      uriTokens.push(component.scheme, ":");
    }
    const authority = recomposeAuthority(component);
    if (authority !== undefined) {
      if (options.reference !== "suffix") {
        uriTokens.push("//");
      }
      uriTokens.push(authority);
      if (component.path && component.path[0] !== "/") {
        uriTokens.push("/");
      }
    }
    if (component.path !== undefined) {
      let s = component.path;
      if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
        s = removeDotSegments(s);
      }
      if (authority === undefined && s[0] === "/" && s[1] === "/") {
        s = "/%2F" + s.slice(2);
      }
      uriTokens.push(s);
    }
    if (component.query !== undefined) {
      uriTokens.push("?", component.query);
    }
    if (component.fragment !== undefined) {
      uriTokens.push("#", component.fragment);
    }
    return uriTokens.join("");
  }
  var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function parse7(uri2, opts) {
    const options = Object.assign({}, opts);
    const parsed = {
      scheme: undefined,
      userinfo: undefined,
      host: "",
      port: undefined,
      path: "",
      query: undefined,
      fragment: undefined
    };
    let isIP = false;
    if (options.reference === "suffix") {
      if (options.scheme) {
        uri2 = options.scheme + ":" + uri2;
      } else {
        uri2 = "//" + uri2;
      }
    }
    const matches = uri2.match(URI_PARSE);
    if (matches) {
      parsed.scheme = matches[1];
      parsed.userinfo = matches[3];
      parsed.host = matches[4];
      parsed.port = parseInt(matches[5], 10);
      parsed.path = matches[6] || "";
      parsed.query = matches[7];
      parsed.fragment = matches[8];
      if (isNaN(parsed.port)) {
        parsed.port = matches[5];
      }
      if (parsed.host) {
        const ipv4result = isIPv4(parsed.host);
        if (ipv4result === false) {
          const ipv6result = normalizeIPv6(parsed.host);
          parsed.host = ipv6result.host.toLowerCase();
          isIP = ipv6result.isIPV6;
        } else {
          isIP = true;
        }
      }
      if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {
        parsed.reference = "same-document";
      } else if (parsed.scheme === undefined) {
        parsed.reference = "relative";
      } else if (parsed.fragment === undefined) {
        parsed.reference = "absolute";
      } else {
        parsed.reference = "uri";
      }
      if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
        parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
      }
      const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
      if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
        if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
          try {
            parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
          } catch (e) {
            parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
          }
        }
      }
      if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
        if (uri2.indexOf("%") !== -1) {
          if (parsed.scheme !== undefined) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (parsed.host !== undefined) {
            parsed.host = unescape(parsed.host);
          }
        }
        if (parsed.path) {
          parsed.path = escape(unescape(parsed.path));
        }
        if (parsed.fragment) {
          parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
        }
      }
      if (schemeHandler && schemeHandler.parse) {
        schemeHandler.parse(parsed, options);
      }
    } else {
      parsed.error = parsed.error || "URI can not be parsed.";
    }
    return parsed;
  }
  var fastUri = {
    SCHEMES,
    normalize,
    resolve,
    resolveComponent,
    equal,
    serialize: serialize2,
    parse: parse7
  };
  module.exports = fastUri;
  module.exports.default = fastUri;
  module.exports.fastUri = fastUri;
});

// node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var uri2 = require_fast_uri();
  uri2.code = 'require("ajv/dist/runtime/uri").default';
  exports.default = uri2;
});

// node_modules/ajv/dist/core.js
var require_core2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = undefined;
  var validate_1 = require_validate2();
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_1.KeywordCxt;
  } });
  var codegen_1 = require_codegen();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_1._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_1.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_1.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_1.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_1.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_1.CodeGen;
  } });
  var validation_error_1 = require_validation_error();
  var ref_error_1 = require_ref_error();
  var rules_1 = require_rules();
  var compile_1 = require_compile();
  var codegen_2 = require_codegen();
  var resolve_1 = require_resolve();
  var dataType_1 = require_dataType();
  var util_1 = require_util2();
  var $dataRefSchema = require_data();
  var uri_1 = require_uri();
  var defaultRegExp = (str, flags) => new RegExp(str, flags);
  defaultRegExp.code = "new RegExp";
  var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  var EXT_SCOPE_NAMES = new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  var removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  var deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  var MAX_EXPRESSION = 200;
  function requiredOptions(o) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    const s = o.strict;
    const _optz = (_a2 = o.code) === null || _a2 === undefined ? undefined : _a2.optimize;
    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
    const regExp = (_c = (_b = o.code) === null || _b === undefined ? undefined : _b.regExp) !== null && _c !== undefined ? _c : defaultRegExp;
    const uriResolver = (_d = o.uriResolver) !== null && _d !== undefined ? _d : uri_1.default;
    return {
      strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== undefined ? _e : s) !== null && _f !== undefined ? _f : true,
      strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== undefined ? _g : s) !== null && _h !== undefined ? _h : true,
      strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== undefined ? _j : s) !== null && _k !== undefined ? _k : "log",
      strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== undefined ? _l : s) !== null && _m !== undefined ? _m : "log",
      strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== undefined ? _o : s) !== null && _p !== undefined ? _p : false,
      code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
      loopRequired: (_q = o.loopRequired) !== null && _q !== undefined ? _q : MAX_EXPRESSION,
      loopEnum: (_r = o.loopEnum) !== null && _r !== undefined ? _r : MAX_EXPRESSION,
      meta: (_s = o.meta) !== null && _s !== undefined ? _s : true,
      messages: (_t = o.messages) !== null && _t !== undefined ? _t : true,
      inlineRefs: (_u = o.inlineRefs) !== null && _u !== undefined ? _u : true,
      schemaId: (_v = o.schemaId) !== null && _v !== undefined ? _v : "$id",
      addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== undefined ? _w : true,
      validateSchema: (_x = o.validateSchema) !== null && _x !== undefined ? _x : true,
      validateFormats: (_y = o.validateFormats) !== null && _y !== undefined ? _y : true,
      unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== undefined ? _z : true,
      int32range: (_0 = o.int32range) !== null && _0 !== undefined ? _0 : true,
      uriResolver
    };
  }

  class Ajv {
    constructor(opts = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = new Set;
      this._loading = {};
      this._cache = new Map;
      opts = this.opts = { ...opts, ...requiredOptions(opts) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger2(opts.logger);
      const formatOpt = opts.validateFormats;
      opts.validateFormats = false;
      this.RULES = (0, rules_1.getRules)();
      checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts.keywords)
        addInitialKeywords.call(this, opts.keywords);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas.call(this);
      opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta: meta3, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta3 && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta: meta3, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta3 == "object" ? meta3[schemaId] || meta3 : undefined;
    }
    validate(schemaKeyRef, data) {
      let v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v = this.compile(schemaKeyRef);
      }
      const valid = v(data);
      if (!("$async" in v))
        this.errors = v.errors;
      return valid;
    }
    compile(schema, _meta) {
      const sch = this._addSchema(schema, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema, meta3) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema, meta3);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_1.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref, missingRef }) {
        if (this.refs[ref]) {
          throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref) {
        const _schema = await _loadSchema.call(this, ref);
        if (!this.refs[ref])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref])
          this.addSchema(_schema, ref, meta3);
      }
      async function _loadSchema(ref) {
        const p = this._loading[ref];
        if (p)
          return p;
        try {
          return await (this._loading[ref] = loadSchema(ref));
        } finally {
          delete this._loading[ref];
        }
      }
    }
    addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema)) {
        for (const sch of schema)
          this.addSchema(sch, undefined, _meta, _validateSchema);
        return this;
      }
      let id;
      if (typeof schema === "object") {
        const { schemaId } = this.opts;
        id = schema[schemaId];
        if (id !== undefined && typeof id != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = (0, resolve_1.normalizeId)(key || id);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
      return this;
    }
    addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema, key, true, _validateSchema);
      return this;
    }
    validateSchema(schema, throwOrLogError) {
      if (typeof schema == "boolean")
        return true;
      let $schema;
      $schema = schema.$schema;
      if ($schema !== undefined && typeof $schema != "string") {
        throw new Error("$schema must be a string");
      }
      $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid = this.validate($schema, schema);
      if (!valid && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid;
    }
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === undefined) {
        const { schemaId } = this.opts;
        const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
        sch = compile_1.resolveSchema.call(this, root, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id = schemaKeyRef[this.opts.schemaId];
          if (id) {
            id = (0, resolve_1.normalizeId)(id);
            delete this.schemas[id];
            delete this.refs[id];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(definitions) {
      for (const def of definitions)
        this.addKeyword(def);
      return this;
    }
    addKeyword(kwdOrDef, def) {
      let keyword;
      if (typeof kwdOrDef == "string") {
        keyword = kwdOrDef;
        if (typeof def == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def.keyword = keyword;
        }
      } else if (typeof kwdOrDef == "object" && def === undefined) {
        def = kwdOrDef;
        keyword = def.keyword;
        if (Array.isArray(keyword) && !keyword.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword, def);
      if (!def) {
        (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def);
      const definition = {
        ...def,
        type: (0, dataType_1.getJSONTypes)(def.type),
        schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
      };
      (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
      return this;
    }
    getKeyword(keyword) {
      const rule = this.RULES.all[keyword];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    removeKeyword(keyword) {
      const { RULES } = this;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    addFormat(name, format2) {
      if (typeof format2 == "string")
        format2 = new RegExp(format2);
      this.formats[name] = format2;
      return this;
    }
    errorsText(errors4 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors4 || errors4.length === 0)
        return "No errors";
      return errors4.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules) {
          const rule = rules[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema = keywords[key];
          if ($data && schema)
            keywords[key] = schemaOrData(schema);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas4, regex2) {
      for (const keyRef in schemas4) {
        const sch = schemas4[keyRef];
        if (!regex2 || regex2.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas4[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas4[keyRef];
          }
        }
      }
    }
    _addSchema(schema, meta3, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id;
      const { schemaId } = this.opts;
      if (typeof schema == "object") {
        id = schema[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema);
      if (sch !== undefined)
        return sch;
      baseId = (0, resolve_1.normalizeId)(id || baseId);
      const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
      sch = new compile_1.SchemaEnv({ schema, schemaId, meta: meta3, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema, true);
      return sch;
    }
    _checkUnique(id) {
      if (this.schemas[id] || this.refs[id]) {
        throw new Error(`schema with key or id "${id}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_1.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_1.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  Ajv.ValidationError = validation_error_1.default;
  Ajv.MissingRefError = ref_error_1.default;
  exports.default = Ajv;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = (0, resolve_1.normalizeId)(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format2 = this.opts.formats[name];
      if (format2)
        this.addFormat(name, format2);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword in defs) {
      const def = defs[keyword];
      if (!def.keyword)
        def.keyword = keyword;
      this.addKeyword(def);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  var noLogs = { log() {}, warn() {}, error() {} };
  function getLogger2(logger2) {
    if (logger2 === false)
      return noLogs;
    if (logger2 === undefined)
      return console;
    if (logger2.log && logger2.warn && logger2.error)
      return logger2;
    throw new Error("logger must implement log, warn and error methods");
  }
  var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword, def) {
    const { RULES } = this;
    (0, util_1.eachItem)(keyword, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def)
      return;
    if (def.$data && !(("code" in def) || ("validate" in def))) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword, definition, dataType) {
    var _a2;
    const post = definition === null || definition === undefined ? undefined : definition.post;
    if (dataType && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword] = true;
    if (!definition)
      return;
    const rule = {
      keyword,
      definition: {
        ...definition,
        type: (0, dataType_1.getJSONTypes)(definition.type),
        schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword] = rule;
    (_a2 = definition.implements) === null || _a2 === undefined || _a2.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def) {
    let { metaSchema } = def;
    if (metaSchema === undefined)
      return;
    if (def.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def.validateSchema = this.compile(metaSchema, true);
  }
  var $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
  }
});

// node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var def = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.callRef = exports.getValidate = undefined;
  var ref_error_1 = require_ref_error();
  var code_1 = require_code3();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var compile_1 = require_compile();
  var util_1 = require_util2();
  var def = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
      const { gen, schema: $ref, it } = cxt;
      const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
      const { root } = env;
      if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
        return callRootRef();
      const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
      if (schOrEnv === undefined)
        throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
      if (schOrEnv instanceof compile_1.SchemaEnv)
        return callValidate(schOrEnv);
      return inlineRefSchema(schOrEnv);
      function callRootRef() {
        if (env === root)
          return callRef(cxt, validateName, env, env.$async);
        const rootName = gen.scopeValue("root", { ref: root });
        return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
      }
      function callValidate(sch) {
        const v = getValidate(cxt, sch);
        callRef(cxt, v, sch, sch.$async);
      }
      function inlineRefSchema(sch) {
        const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
        const valid = gen.name("valid");
        const schCxt = cxt.subschema({
          schema: sch,
          dataTypes: [],
          schemaPath: codegen_1.nil,
          topSchemaRef: schName,
          errSchemaPath: $ref
        }, valid);
        cxt.mergeEvaluated(schCxt);
        cxt.ok(valid);
      }
    }
  };
  function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
  }
  exports.getValidate = getValidate;
  function callRef(cxt, v, sch, $async) {
    const { gen, it } = cxt;
    const { allErrors, schemaEnv: env, opts } = it;
    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
    if ($async)
      callAsyncRef();
    else
      callSyncRef();
    function callAsyncRef() {
      if (!env.$async)
        throw new Error("async schema referenced by sync schema");
      const valid = gen.let("valid");
      gen.try(() => {
        gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
        addEvaluatedFrom(v);
        if (!allErrors)
          gen.assign(valid, true);
      }, (e) => {
        gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
        addErrorsFrom(e);
        if (!allErrors)
          gen.assign(valid, false);
      });
      cxt.ok(valid);
    }
    function callSyncRef() {
      cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
    }
    function addErrorsFrom(source) {
      const errs = (0, codegen_1._)`${source}.errors`;
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
      gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
      var _a2;
      if (!it.opts.unevaluated)
        return;
      const schEvaluated = (_a2 = sch === null || sch === undefined ? undefined : sch.validate) === null || _a2 === undefined ? undefined : _a2.evaluated;
      if (it.props !== true) {
        if (schEvaluated && !schEvaluated.dynamicProps) {
          if (schEvaluated.props !== undefined) {
            it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
          }
        } else {
          const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
          it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
        }
      }
      if (it.items !== true) {
        if (schEvaluated && !schEvaluated.dynamicItems) {
          if (schEvaluated.items !== undefined) {
            it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
          }
        } else {
          const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
          it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
        }
      }
    }
  }
  exports.callRef = callRef;
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/core/index.js
var require_core3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var id_1 = require_id();
  var ref_1 = require_ref();
  var core2 = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1.default
  ];
  exports.default = core2;
});

// node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var ops = codegen_1.operators;
  var KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
  };
  var error47 = {
    message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
  };
  var def = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error: error47,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error47 = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
  };
  var def = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error: error47,
    code(cxt) {
      const { gen, data, schemaCode, it } = cxt;
      const prec = it.opts.multipleOfPrecision;
      const res = gen.let("res");
      const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
      cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function ucs2length2(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
      length++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) === 56320)
          pos++;
      }
    }
    return length;
  }
  exports.default = ucs2length2;
  ucs2length2.code = 'require("ajv/dist/runtime/ucs2length").default';
});

// node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  var ucs2length_1 = require_ucs2length();
  var error47 = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxLength" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error: error47,
    code(cxt) {
      const { keyword, data, schemaCode, it } = cxt;
      const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
      const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
      cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code3();
  var codegen_1 = require_codegen();
  var error47 = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
  };
  var def = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error: error47,
    code(cxt) {
      const { data, $data, schema, schemaCode, it } = cxt;
      const u = it.opts.unicodeRegExp ? "u" : "";
      const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
      cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error47 = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxProperties" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error: error47,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code3();
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  var error47 = {
    message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
  };
  var def = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error: error47,
    code(cxt) {
      const { gen, schema, schemaCode, data, $data, it } = cxt;
      const { opts } = it;
      if (!$data && schema.length === 0)
        return;
      const useLoop = schema.length >= opts.loopRequired;
      if (it.allErrors)
        allErrorsMode();
      else
        exitOnErrorMode();
      if (opts.strictRequired) {
        const props = cxt.parentSchema.properties;
        const { definedProperties } = cxt.it;
        for (const requiredKey of schema) {
          if ((props === null || props === undefined ? undefined : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
            const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
            const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
            (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
          }
        }
      }
      function allErrorsMode() {
        if (useLoop || $data) {
          cxt.block$data(codegen_1.nil, loopAllRequired);
        } else {
          for (const prop of schema) {
            (0, code_1.checkReportMissingProp)(cxt, prop);
          }
        }
      }
      function exitOnErrorMode() {
        const missing = gen.let("missing");
        if (useLoop || $data) {
          const valid = gen.let("valid", true);
          cxt.block$data(valid, () => loopUntilMissing(missing, valid));
          cxt.ok(valid);
        } else {
          gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
      function loopAllRequired() {
        gen.forOf("prop", schemaCode, (prop) => {
          cxt.setParams({ missingProperty: prop });
          gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
        });
      }
      function loopUntilMissing(missing, valid) {
        cxt.setParams({ missingProperty: missing });
        gen.forOf(missing, schemaCode, () => {
          gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error();
            gen.break();
          });
        }, codegen_1.nil);
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error47 = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxItems" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error: error47,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var equal = require_fast_deep_equal();
  equal.code = 'require("ajv/dist/runtime/equal").default';
  exports.default = equal;
});

// node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dataType_1 = require_dataType();
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  var equal_1 = require_equal();
  var error47 = {
    message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
    params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
  };
  var def = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error: error47,
    code(cxt) {
      const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
      if (!$data && !schema)
        return;
      const valid = gen.let("valid");
      const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
      cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
      cxt.ok(valid);
      function validateUniqueItems() {
        const i = gen.let("i", (0, codegen_1._)`${data}.length`);
        const j = gen.let("j");
        cxt.setParams({ i, j });
        gen.assign(valid, true);
        gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
      }
      function canOptimize() {
        return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
      }
      function loopN(i, j) {
        const item = gen.name("item");
        const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
        const indices = gen.const("indices", (0, codegen_1._)`{}`);
        gen.for((0, codegen_1._)`;${i}--;`, () => {
          gen.let(item, (0, codegen_1._)`${data}[${i}]`);
          gen.if(wrongType, (0, codegen_1._)`continue`);
          if (itemTypes.length > 1)
            gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
          gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
            gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
            cxt.error();
            gen.assign(valid, false).break();
          }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
        });
      }
      function loopN2(i, j) {
        const eql = (0, util_1.useFunc)(gen, equal_1.default);
        const outer = gen.name("outer");
        gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
          cxt.error();
          gen.assign(valid, false).break(outer);
        })));
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  var equal_1 = require_equal();
  var error47 = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
  };
  var def = {
    keyword: "const",
    $data: true,
    error: error47,
    code(cxt) {
      const { gen, data, $data, schemaCode, schema } = cxt;
      if ($data || schema && typeof schema == "object") {
        cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
      } else {
        cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  var equal_1 = require_equal();
  var error47 = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
  };
  var def = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error: error47,
    code(cxt) {
      const { gen, data, $data, schema, schemaCode, it } = cxt;
      if (!$data && schema.length === 0)
        throw new Error("enum must have non-empty array");
      const useLoop = schema.length >= it.opts.loopEnum;
      let eql;
      const getEql = () => eql !== null && eql !== undefined ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
      let valid;
      if (useLoop || $data) {
        valid = gen.let("valid");
        cxt.block$data(valid, loopEnum);
      } else {
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const vSchema = gen.const("vSchema", schemaCode);
        valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
      }
      cxt.pass(valid);
      function loopEnum() {
        gen.assign(valid, false);
        gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
      }
      function equalCode(vSchema, i) {
        const sch = schema[i];
        return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var limitNumber_1 = require_limitNumber();
  var multipleOf_1 = require_multipleOf();
  var limitLength_1 = require_limitLength();
  var pattern_1 = require_pattern();
  var limitProperties_1 = require_limitProperties();
  var required_1 = require_required();
  var limitItems_1 = require_limitItems();
  var uniqueItems_1 = require_uniqueItems();
  var const_1 = require_const();
  var enum_1 = require_enum();
  var validation = [
    limitNumber_1.default,
    multipleOf_1.default,
    limitLength_1.default,
    pattern_1.default,
    limitProperties_1.default,
    required_1.default,
    limitItems_1.default,
    uniqueItems_1.default,
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default
  ];
  exports.default = validation;
});

// node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateAdditionalItems = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  var error47 = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  var def = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: error47,
    code(cxt) {
      const { parentSchema, it } = cxt;
      const { items } = parentSchema;
      if (!Array.isArray(items)) {
        (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      validateAdditionalItems(cxt, items);
    }
  };
  function validateAdditionalItems(cxt, items) {
    const { gen, schema, data, keyword, it } = cxt;
    it.items = true;
    const len = gen.const("len", (0, codegen_1._)`${data}.length`);
    if (schema === false) {
      cxt.setParams({ len: items.length });
      cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
    } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
      const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
      gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
      cxt.ok(valid);
    }
    function validateItems(valid) {
      gen.forRange("i", items.length, len, (i) => {
        cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
        if (!it.allErrors)
          gen.if((0, codegen_1.not)(valid), () => gen.break());
      });
    }
  }
  exports.validateAdditionalItems = validateAdditionalItems;
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateTuple = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  var code_1 = require_code3();
  var def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
      const { schema, it } = cxt;
      if (Array.isArray(schema))
        return validateTuple(cxt, "additionalItems", schema);
      it.items = true;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  function validateTuple(cxt, extraItems, schArr = cxt.schema) {
    const { gen, parentSchema, data, keyword, it } = cxt;
    checkStrictTuple(parentSchema);
    if (it.opts.unevaluated && schArr.length && it.items !== true) {
      it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
    }
    const valid = gen.name("valid");
    const len = gen.const("len", (0, codegen_1._)`${data}.length`);
    schArr.forEach((sch, i) => {
      if ((0, util_1.alwaysValidSchema)(it, sch))
        return;
      gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
        keyword,
        schemaProp: i,
        dataProp: i
      }, valid));
      cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
      const { opts, errSchemaPath } = it;
      const l = schArr.length;
      const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
      if (opts.strictTuples && !fullTuple) {
        const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
        (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
      }
    }
  }
  exports.validateTuple = validateTuple;
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var items_1 = require_items();
  var def = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  var code_1 = require_code3();
  var additionalItems_1 = require_additionalItems();
  var error47 = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  var def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: error47,
    code(cxt) {
      const { schema, parentSchema, it } = cxt;
      const { prefixItems } = parentSchema;
      it.items = true;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      if (prefixItems)
        (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
      else
        cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  var error47 = {
    message: ({ params: { min, max } }) => max === undefined ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
  };
  var def = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error: error47,
    code(cxt) {
      const { gen, schema, parentSchema, data, it } = cxt;
      let min;
      let max;
      const { minContains, maxContains } = parentSchema;
      if (it.opts.next) {
        min = minContains === undefined ? 1 : minContains;
        max = maxContains;
      } else {
        min = 1;
      }
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      cxt.setParams({ min, max });
      if (max === undefined && min === 0) {
        (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
        return;
      }
      if (max !== undefined && min > max) {
        (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
        cxt.fail();
        return;
      }
      if ((0, util_1.alwaysValidSchema)(it, schema)) {
        let cond = (0, codegen_1._)`${len} >= ${min}`;
        if (max !== undefined)
          cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
        cxt.pass(cond);
        return;
      }
      it.items = true;
      const valid = gen.name("valid");
      if (max === undefined && min === 1) {
        validateItems(valid, () => gen.if(valid, () => gen.break()));
      } else if (min === 0) {
        gen.let(valid, true);
        if (max !== undefined)
          gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
      } else {
        gen.let(valid, false);
        validateItemsWithCount();
      }
      cxt.result(valid, () => cxt.reset());
      function validateItemsWithCount() {
        const schValid = gen.name("_valid");
        const count = gen.let("count", 0);
        validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
      }
      function validateItems(_valid, block) {
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword: "contains",
            dataProp: i,
            dataPropType: util_1.Type.Num,
            compositeRule: true
          }, _valid);
          block();
        });
      }
      function checkLimits(count) {
        gen.code((0, codegen_1._)`${count}++`);
        if (max === undefined) {
          gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
        } else {
          gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
          if (min === 1)
            gen.assign(valid, true);
          else
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
        }
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  var code_1 = require_code3();
  exports.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
  };
  var def = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            (0, code_1.checkReportMissingProp)(cxt, depProp);
          }
        });
      } else {
        gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
        (0, code_1.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
  }
  exports.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword, it } = cxt;
    const valid = gen.name("valid");
    for (const prop in schemaDeps) {
      if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
        continue;
      gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
        const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
        cxt.mergeValidEvaluated(schCxt, valid);
      }, () => gen.var(valid, true));
      cxt.ok(valid);
    }
  }
  exports.validateSchemaDeps = validateSchemaDeps;
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  var error47 = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
  };
  var def = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: error47,
    code(cxt) {
      const { gen, schema, data, it } = cxt;
      if ((0, util_1.alwaysValidSchema)(it, schema))
        return;
      const valid = gen.name("valid");
      gen.forIn("key", data, (key) => {
        cxt.setParams({ propertyName: key });
        cxt.subschema({
          keyword: "propertyNames",
          data: key,
          dataTypes: ["string"],
          propertyName: key,
          compositeRule: true
        }, valid);
        gen.if((0, codegen_1.not)(valid), () => {
          cxt.error(true);
          if (!it.allErrors)
            gen.break();
        });
      });
      cxt.ok(valid);
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code3();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var util_1 = require_util2();
  var error47 = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
  };
  var def = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error: error47,
    code(cxt) {
      const { gen, schema, parentSchema, data, errsCount, it } = cxt;
      if (!errsCount)
        throw new Error("ajv implementation error");
      const { allErrors, opts } = it;
      it.props = true;
      if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
        return;
      const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
      const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
      checkAdditionalProperties();
      cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      function checkAdditionalProperties() {
        gen.forIn("key", data, (key) => {
          if (!props.length && !patProps.length)
            additionalPropertyCode(key);
          else
            gen.if(isAdditional(key), () => additionalPropertyCode(key));
        });
      }
      function isAdditional(key) {
        let definedProp;
        if (props.length > 8) {
          const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
          definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
        } else if (props.length) {
          definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
        } else {
          definedProp = codegen_1.nil;
        }
        if (patProps.length) {
          definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
        }
        return (0, codegen_1.not)(definedProp);
      }
      function deleteAdditional(key) {
        gen.code((0, codegen_1._)`delete ${data}[${key}]`);
      }
      function additionalPropertyCode(key) {
        if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
          deleteAdditional(key);
          return;
        }
        if (schema === false) {
          cxt.setParams({ additionalProperty: key });
          cxt.error();
          if (!allErrors)
            gen.break();
          return;
        }
        if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
          const valid = gen.name("valid");
          if (opts.removeAdditional === "failing") {
            applyAdditionalSchema(key, valid, false);
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.reset();
              deleteAdditional(key);
            });
          } else {
            applyAdditionalSchema(key, valid);
            if (!allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break());
          }
        }
      }
      function applyAdditionalSchema(key, valid, errors4) {
        const subschema = {
          keyword: "additionalProperties",
          dataProp: key,
          dataPropType: util_1.Type.Str
        };
        if (errors4 === false) {
          Object.assign(subschema, {
            compositeRule: true,
            createErrors: false,
            allErrors: false
          });
        }
        cxt.subschema(subschema, valid);
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var validate_1 = require_validate2();
  var code_1 = require_code3();
  var util_1 = require_util2();
  var additionalProperties_1 = require_additionalProperties();
  var def = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, parentSchema, data, it } = cxt;
      if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
        additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
      }
      const allProps = (0, code_1.allSchemaProperties)(schema);
      for (const prop of allProps) {
        it.definedProperties.add(prop);
      }
      if (it.opts.unevaluated && allProps.length && it.props !== true) {
        it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
      }
      const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
      if (properties.length === 0)
        return;
      const valid = gen.name("valid");
      for (const prop of properties) {
        if (hasDefault(prop)) {
          applyPropertySchema(prop);
        } else {
          gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
          applyPropertySchema(prop);
          if (!it.allErrors)
            gen.else().var(valid, true);
          gen.endIf();
        }
        cxt.it.definedProperties.add(prop);
        cxt.ok(valid);
      }
      function hasDefault(prop) {
        return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
      }
      function applyPropertySchema(prop) {
        cxt.subschema({
          keyword: "properties",
          schemaProp: prop,
          dataProp: prop
        }, valid);
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code3();
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  var util_2 = require_util2();
  var def = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, data, parentSchema, it } = cxt;
      const { opts } = it;
      const patterns = (0, code_1.allSchemaProperties)(schema);
      const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
      if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
        return;
      }
      const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
      const valid = gen.name("valid");
      if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
        it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
      }
      const { props } = it;
      validatePatternProperties();
      function validatePatternProperties() {
        for (const pat of patterns) {
          if (checkProperties)
            checkMatchingProperties(pat);
          if (it.allErrors) {
            validateProperties(pat);
          } else {
            gen.var(valid, true);
            validateProperties(pat);
            gen.if(valid);
          }
        }
      }
      function checkMatchingProperties(pat) {
        for (const prop in checkProperties) {
          if (new RegExp(pat).test(prop)) {
            (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
          }
        }
      }
      function validateProperties(pat) {
        gen.forIn("key", data, (key) => {
          gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
            const alwaysValid = alwaysValidPatterns.includes(pat);
            if (!alwaysValid) {
              cxt.subschema({
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: util_2.Type.Str
              }, valid);
            }
            if (it.opts.unevaluated && props !== true) {
              gen.assign((0, codegen_1._)`${props}[${key}]`, true);
            } else if (!alwaysValid && !it.allErrors) {
              gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          });
        });
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util2();
  var def = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
      const { gen, schema, it } = cxt;
      if ((0, util_1.alwaysValidSchema)(it, schema)) {
        cxt.fail();
        return;
      }
      const valid = gen.name("valid");
      cxt.subschema({
        keyword: "not",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, valid);
      cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code3();
  var def = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  var error47 = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
  };
  var def = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error: error47,
    code(cxt) {
      const { gen, schema, parentSchema, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (it.opts.discriminator && parentSchema.discriminator)
        return;
      const schArr = schema;
      const valid = gen.let("valid", false);
      const passing = gen.let("passing", null);
      const schValid = gen.name("_valid");
      cxt.setParams({ passing });
      gen.block(validateOneOf);
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
      function validateOneOf() {
        schArr.forEach((sch, i) => {
          let schCxt;
          if ((0, util_1.alwaysValidSchema)(it, sch)) {
            gen.var(schValid, true);
          } else {
            schCxt = cxt.subschema({
              keyword: "oneOf",
              schemaProp: i,
              compositeRule: true
            }, schValid);
          }
          if (i > 0) {
            gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
          }
          gen.if(schValid, () => {
            gen.assign(valid, true);
            gen.assign(passing, i);
            if (schCxt)
              cxt.mergeEvaluated(schCxt, codegen_1.Name);
          });
        });
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util2();
  var def = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
      const { gen, schema, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const valid = gen.name("valid");
      schema.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
        cxt.ok(valid);
        cxt.mergeEvaluated(schCxt);
      });
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util2();
  var error47 = {
    message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
  };
  var def = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error: error47,
    code(cxt) {
      const { gen, parentSchema, it } = cxt;
      if (parentSchema.then === undefined && parentSchema.else === undefined) {
        (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
      }
      const hasThen = hasSchema(it, "then");
      const hasElse = hasSchema(it, "else");
      if (!hasThen && !hasElse)
        return;
      const valid = gen.let("valid", true);
      const schValid = gen.name("_valid");
      validateIf();
      cxt.reset();
      if (hasThen && hasElse) {
        const ifClause = gen.let("ifClause");
        cxt.setParams({ ifClause });
        gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
      } else if (hasThen) {
        gen.if(schValid, validateClause("then"));
      } else {
        gen.if((0, codegen_1.not)(schValid), validateClause("else"));
      }
      cxt.pass(valid, () => cxt.error(true));
      function validateIf() {
        const schCxt = cxt.subschema({
          keyword: "if",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, schValid);
        cxt.mergeEvaluated(schCxt);
      }
      function validateClause(keyword, ifClause) {
        return () => {
          const schCxt = cxt.subschema({ keyword }, schValid);
          gen.assign(valid, schValid);
          cxt.mergeValidEvaluated(schCxt, valid);
          if (ifClause)
            gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
          else
            cxt.setParams({ ifClause: keyword });
        };
      }
    }
  };
  function hasSchema(it, keyword) {
    const schema = it.schema[keyword];
    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);
  }
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util2();
  var def = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword, parentSchema, it }) {
      if (parentSchema.if === undefined)
        (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var additionalItems_1 = require_additionalItems();
  var prefixItems_1 = require_prefixItems();
  var items_1 = require_items();
  var items2020_1 = require_items2020();
  var contains_1 = require_contains();
  var dependencies_1 = require_dependencies();
  var propertyNames_1 = require_propertyNames();
  var additionalProperties_1 = require_additionalProperties();
  var properties_1 = require_properties();
  var patternProperties_1 = require_patternProperties();
  var not_1 = require_not();
  var anyOf_1 = require_anyOf();
  var oneOf_1 = require_oneOf();
  var allOf_1 = require_allOf();
  var if_1 = require_if();
  var thenElse_1 = require_thenElse();
  function getApplicator(draft2020 = false) {
    const applicator = [
      not_1.default,
      anyOf_1.default,
      oneOf_1.default,
      allOf_1.default,
      if_1.default,
      thenElse_1.default,
      propertyNames_1.default,
      additionalProperties_1.default,
      dependencies_1.default,
      properties_1.default,
      patternProperties_1.default
    ];
    if (draft2020)
      applicator.push(prefixItems_1.default, items2020_1.default);
    else
      applicator.push(additionalItems_1.default, items_1.default);
    applicator.push(contains_1.default);
    return applicator;
  }
  exports.default = getApplicator;
});

// node_modules/ajv/dist/vocabularies/format/format.js
var require_format2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error47 = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
  };
  var def = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error: error47,
    code(cxt, ruleType) {
      const { gen, data, $data, schema, schemaCode, it } = cxt;
      const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
      if (!opts.validateFormats)
        return;
      if ($data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
        const fType = gen.let("fType");
        const format2 = gen.let("format");
        gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format2, fDef));
        cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
        function unknownFmt() {
          if (opts.strictSchema === false)
            return codegen_1.nil;
          return (0, codegen_1._)`${schemaCode} && !${format2}`;
        }
        function invalidFmt() {
          const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1._)`${format2}(${data})`;
          const validData = (0, codegen_1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
          return (0, codegen_1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
        }
      }
      function validateFormat() {
        const formatDef = self2.formats[schema];
        if (!formatDef) {
          unknownFormat();
          return;
        }
        if (formatDef === true)
          return;
        const [fmtType, format2, fmtRef] = getFormat(formatDef);
        if (fmtType === ruleType)
          cxt.pass(validCondition());
        function unknownFormat() {
          if (opts.strictSchema === false) {
            self2.logger.warn(unknownMsg());
            return;
          }
          throw new Error(unknownMsg());
          function unknownMsg() {
            return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
          }
        }
        function getFormat(fmtDef) {
          const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : undefined;
          const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
          if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
            return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
          }
          return ["string", fmtDef, fmt];
        }
        function validCondition() {
          if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
            if (!schemaEnv.$async)
              throw new Error("async format in sync schema");
            return (0, codegen_1._)`await ${fmtRef}(${data})`;
          }
          return typeof format2 == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
        }
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/vocabularies/format/index.js
var require_format3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var format_1 = require_format2();
  var format2 = [format_1.default];
  exports.default = format2;
});

// node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.contentVocabulary = exports.metadataVocabulary = undefined;
  exports.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ];
  exports.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ];
});

// node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var core_1 = require_core3();
  var validation_1 = require_validation();
  var applicator_1 = require_applicator();
  var format_1 = require_format3();
  var metadata_1 = require_metadata();
  var draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary
  ];
  exports.default = draft7Vocabularies;
});

// node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiscrError = undefined;
  var DiscrError;
  (function(DiscrError2) {
    DiscrError2["Tag"] = "tag";
    DiscrError2["Mapping"] = "mapping";
  })(DiscrError || (exports.DiscrError = DiscrError = {}));
});

// node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var types_1 = require_types();
  var compile_1 = require_compile();
  var ref_error_1 = require_ref_error();
  var util_1 = require_util2();
  var error47 = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
  };
  var def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: error47,
    code(cxt) {
      const { gen, data, schema, parentSchema, it } = cxt;
      const { oneOf } = parentSchema;
      if (!it.opts.discriminator) {
        throw new Error("discriminator: requires discriminator option");
      }
      const tagName = schema.propertyName;
      if (typeof tagName != "string")
        throw new Error("discriminator: requires propertyName");
      if (schema.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!oneOf)
        throw new Error("discriminator: requires oneOf keyword");
      const valid = gen.let("valid", false);
      const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
      gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
      cxt.ok(valid);
      function validateMapping() {
        const mapping = getMapping();
        gen.if(false);
        for (const tagValue in mapping) {
          gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
          gen.assign(valid, applyTagSchema(mapping[tagValue]));
        }
        gen.else();
        cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
        gen.endIf();
      }
      function applyTagSchema(schemaProp) {
        const _valid = gen.name("valid");
        const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
        cxt.mergeEvaluated(schCxt, codegen_1.Name);
        return _valid;
      }
      function getMapping() {
        var _a2;
        const oneOfMapping = {};
        const topRequired = hasRequired(parentSchema);
        let tagRequired = true;
        for (let i = 0;i < oneOf.length; i++) {
          let sch = oneOf[i];
          if ((sch === null || sch === undefined ? undefined : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
            const ref = sch.$ref;
            sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
            if (sch instanceof compile_1.SchemaEnv)
              sch = sch.schema;
            if (sch === undefined)
              throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
          }
          const propSch = (_a2 = sch === null || sch === undefined ? undefined : sch.properties) === null || _a2 === undefined ? undefined : _a2[tagName];
          if (typeof propSch != "object") {
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
          }
          tagRequired = tagRequired && (topRequired || hasRequired(sch));
          addMappings(propSch, i);
        }
        if (!tagRequired)
          throw new Error(`discriminator: "${tagName}" must be required`);
        return oneOfMapping;
        function hasRequired({ required: required2 }) {
          return Array.isArray(required2) && required2.includes(tagName);
        }
        function addMappings(sch, i) {
          if (sch.const) {
            addMapping(sch.const, i);
          } else if (sch.enum) {
            for (const tagValue of sch.enum) {
              addMapping(tagValue, i);
            }
          } else {
            throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
          }
        }
        function addMapping(tagValue, i) {
          if (typeof tagValue != "string" || tagValue in oneOfMapping) {
            throw new Error(`discriminator: "${tagName}" values must be unique strings`);
          }
          oneOfMapping[tagValue] = i;
        }
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS((exports, module) => {
  module.exports = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "http://json-schema.org/draft-07/schema#",
    title: "Core schema meta-schema",
    definitions: {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: { $ref: "#" }
      },
      nonNegativeInteger: {
        type: "integer",
        minimum: 0
      },
      nonNegativeIntegerDefault0: {
        allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
      },
      simpleTypes: {
        enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
      },
      stringArray: {
        type: "array",
        items: { type: "string" },
        uniqueItems: true,
        default: []
      }
    },
    type: ["object", "boolean"],
    properties: {
      $id: {
        type: "string",
        format: "uri-reference"
      },
      $schema: {
        type: "string",
        format: "uri"
      },
      $ref: {
        type: "string",
        format: "uri-reference"
      },
      $comment: {
        type: "string"
      },
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      default: true,
      readOnly: {
        type: "boolean",
        default: false
      },
      examples: {
        type: "array",
        items: true
      },
      multipleOf: {
        type: "number",
        exclusiveMinimum: 0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "number"
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "number"
      },
      maxLength: { $ref: "#/definitions/nonNegativeInteger" },
      minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      pattern: {
        type: "string",
        format: "regex"
      },
      additionalItems: { $ref: "#" },
      items: {
        anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
        default: true
      },
      maxItems: { $ref: "#/definitions/nonNegativeInteger" },
      minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      uniqueItems: {
        type: "boolean",
        default: false
      },
      contains: { $ref: "#" },
      maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
      minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      required: { $ref: "#/definitions/stringArray" },
      additionalProperties: { $ref: "#" },
      definitions: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      properties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        propertyNames: { format: "regex" },
        default: {}
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
        }
      },
      propertyNames: { $ref: "#" },
      const: true,
      enum: {
        type: "array",
        items: true,
        minItems: 1,
        uniqueItems: true
      },
      type: {
        anyOf: [
          { $ref: "#/definitions/simpleTypes" },
          {
            type: "array",
            items: { $ref: "#/definitions/simpleTypes" },
            minItems: 1,
            uniqueItems: true
          }
        ]
      },
      format: { type: "string" },
      contentMediaType: { type: "string" },
      contentEncoding: { type: "string" },
      if: { $ref: "#" },
      then: { $ref: "#" },
      else: { $ref: "#" },
      allOf: { $ref: "#/definitions/schemaArray" },
      anyOf: { $ref: "#/definitions/schemaArray" },
      oneOf: { $ref: "#/definitions/schemaArray" },
      not: { $ref: "#" }
    },
    default: true
  };
});

// node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = undefined;
  var core_1 = require_core2();
  var draft7_1 = require_draft7();
  var discriminator_1 = require_discriminator();
  var draft7MetaSchema = require_json_schema_draft_07();
  var META_SUPPORT_DATA = ["/properties"];
  var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";

  class Ajv extends core_1.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v) => this.addVocabulary(v));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined);
    }
  }
  exports.Ajv = Ajv;
  module.exports = exports = Ajv;
  module.exports.Ajv = Ajv;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = Ajv;
  var validate_1 = require_validate2();
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_1.KeywordCxt;
  } });
  var codegen_1 = require_codegen();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_1._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_1.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_1.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_1.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_1.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_1.CodeGen;
  } });
  var validation_error_1 = require_validation_error();
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return validation_error_1.default;
  } });
  var ref_error_1 = require_ref_error();
  Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_1.default;
  } });
});

// node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatNames = exports.fastFormats = exports.fullFormats = undefined;
  function fmtDef(validate4, compare2) {
    return { validate: validate4, compare: compare2 };
  }
  exports.fullFormats = {
    date: fmtDef(date8, compareDate),
    time: fmtDef(getTime(true), compareTime),
    "date-time": fmtDef(getDateTime(true), compareDateTime),
    "iso-time": fmtDef(getTime(), compareIsoTime),
    "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: uri2,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex: regex2,
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    byte,
    int32: { type: "number", validate: validateInt32 },
    int64: { type: "number", validate: validateInt64 },
    float: { type: "number", validate: validateNumber },
    double: { type: "number", validate: validateNumber },
    password: true,
    binary: true
  };
  exports.fastFormats = {
    ...exports.fullFormats,
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
    "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  };
  exports.formatNames = Object.keys(exports.fullFormats);
  function isLeapYear2(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  var DATE2 = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  var DAYS2 = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function date8(str) {
    const matches = DATE2.exec(str);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear2(year) ? 29 : DAYS2[month]);
  }
  function compareDate(d1, d2) {
    if (!(d1 && d2))
      return;
    if (d1 > d2)
      return 1;
    if (d1 < d2)
      return -1;
    return 0;
  }
  var TIME2 = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
  function getTime(strictTimeZone) {
    return function time(str) {
      const matches = TIME2.exec(str);
      if (!matches)
        return false;
      const hr = +matches[1];
      const min = +matches[2];
      const sec = +matches[3];
      const tz = matches[4];
      const tzSign = matches[5] === "-" ? -1 : 1;
      const tzH = +(matches[6] || 0);
      const tzM = +(matches[7] || 0);
      if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
        return false;
      if (hr <= 23 && min <= 59 && sec < 60)
        return true;
      const utcMin = min - tzM * tzSign;
      const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
      return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
    };
  }
  function compareTime(s1, s2) {
    if (!(s1 && s2))
      return;
    const t1 = new Date("2020-01-01T" + s1).valueOf();
    const t2 = new Date("2020-01-01T" + s2).valueOf();
    if (!(t1 && t2))
      return;
    return t1 - t2;
  }
  function compareIsoTime(t1, t2) {
    if (!(t1 && t2))
      return;
    const a1 = TIME2.exec(t1);
    const a2 = TIME2.exec(t2);
    if (!(a1 && a2))
      return;
    t1 = a1[1] + a1[2] + a1[3];
    t2 = a2[1] + a2[2] + a2[3];
    if (t1 > t2)
      return 1;
    if (t1 < t2)
      return -1;
    return 0;
  }
  var DATE_TIME_SEPARATOR2 = /t|\s/i;
  function getDateTime(strictTimeZone) {
    const time4 = getTime(strictTimeZone);
    return function date_time(str) {
      const dateTime = str.split(DATE_TIME_SEPARATOR2);
      return dateTime.length === 2 && date8(dateTime[0]) && time4(dateTime[1]);
    };
  }
  function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return;
    const d1 = new Date(dt1).valueOf();
    const d2 = new Date(dt2).valueOf();
    if (!(d1 && d2))
      return;
    return d1 - d2;
  }
  function compareIsoDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR2);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR2);
    const res = compareDate(d1, d2);
    if (res === undefined)
      return;
    return res || compareTime(t1, t2);
  }
  var NOT_URI_FRAGMENT2 = /\/|:/;
  var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function uri2(str) {
    return NOT_URI_FRAGMENT2.test(str) && URI.test(str);
  }
  var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function byte(str) {
    BYTE.lastIndex = 0;
    return BYTE.test(str);
  }
  var MIN_INT32 = -(2 ** 31);
  var MAX_INT32 = 2 ** 31 - 1;
  function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
  }
  function validateInt64(value) {
    return Number.isInteger(value);
  }
  function validateNumber() {
    return true;
  }
  var Z_ANCHOR2 = /[^\\]\\Z/;
  function regex2(str) {
    if (Z_ANCHOR2.test(str))
      return false;
    try {
      new RegExp(str);
      return true;
    } catch (e) {
      return false;
    }
  }
});

// node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatLimitDefinition = undefined;
  var ajv_1 = require_ajv();
  var codegen_1 = require_codegen();
  var ops = codegen_1.operators;
  var KWDs = {
    formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
  };
  var error47 = {
    message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
  };
  exports.formatLimitDefinition = {
    keyword: Object.keys(KWDs),
    type: "string",
    schemaType: "string",
    $data: true,
    error: error47,
    code(cxt) {
      const { gen, data, schemaCode, keyword, it } = cxt;
      const { opts, self: self2 } = it;
      if (!opts.validateFormats)
        return;
      const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
      if (fCxt.$data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
        cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
      }
      function validateFormat() {
        const format2 = fCxt.schema;
        const fmtDef = self2.formats[format2];
        if (!fmtDef || fmtDef === true)
          return;
        if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
          throw new Error(`"${keyword}": format "${format2}" does not define "compare" function`);
        }
        const fmt = gen.scopeValue("formats", {
          key: format2,
          ref: fmtDef,
          code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format2)}` : undefined
        });
        cxt.fail$data(compareCode(fmt));
      }
      function compareCode(fmt) {
        return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  var formatLimitPlugin = (ajv) => {
    ajv.addKeyword(exports.formatLimitDefinition);
    return ajv;
  };
  exports.default = formatLimitPlugin;
});

// node_modules/ajv-formats/dist/index.js
var require_dist4 = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var formats_1 = require_formats();
  var limit_1 = require_limit();
  var codegen_1 = require_codegen();
  var fullName = new codegen_1.Name("fullFormats");
  var fastName = new codegen_1.Name("fastFormats");
  var formatsPlugin = (ajv, opts = { keywords: true }) => {
    if (Array.isArray(opts)) {
      addFormats(ajv, opts, formats_1.fullFormats, fullName);
      return ajv;
    }
    const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts.formats || formats_1.formatNames;
    addFormats(ajv, list, formats, exportName);
    if (opts.keywords)
      (0, limit_1.default)(ajv);
    return ajv;
  };
  formatsPlugin.get = (name, mode = "full") => {
    const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f = formats[name];
    if (!f)
      throw new Error(`Unknown format "${name}"`);
    return f;
  };
  function addFormats(ajv, list, fs, exportName) {
    var _a2;
    var _b;
    (_a2 = (_b = ajv.opts.code).formats) !== null && _a2 !== undefined || (_b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`);
    for (const f of list)
      ajv.addFormat(f, fs[f]);
  }
  module.exports = exports = formatsPlugin;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = formatsPlugin;
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/validation/ajv-provider.js
function createDefaultAjvInstance() {
  const ajv = new import_ajv.Ajv({
    strict: false,
    validateFormats: true,
    validateSchema: false,
    allErrors: true
  });
  const addFormats = import_ajv_formats.default;
  addFormats(ajv);
  return ajv;
}

class AjvJsonSchemaValidator {
  constructor(ajv) {
    this._ajv = ajv !== null && ajv !== undefined ? ajv : createDefaultAjvInstance();
  }
  getValidator(schema) {
    var _a2;
    const ajvValidator = "$id" in schema && typeof schema.$id === "string" ? (_a2 = this._ajv.getSchema(schema.$id)) !== null && _a2 !== undefined ? _a2 : this._ajv.compile(schema) : this._ajv.compile(schema);
    return (input) => {
      const valid = ajvValidator(input);
      if (valid) {
        return {
          valid: true,
          data: input,
          errorMessage: undefined
        };
      } else {
        return {
          valid: false,
          data: undefined,
          errorMessage: this._ajv.errorsText(ajvValidator.errors)
        };
      }
    };
  }
}
var import_ajv, import_ajv_formats;
var init_ajv_provider = __esm(() => {
  import_ajv = __toESM(require_ajv(), 1);
  import_ajv_formats = __toESM(require_dist4(), 1);
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/client.js
class ExperimentalClientTasks {
  constructor(_client) {
    this._client = _client;
  }
  async* callToolStream(params, resultSchema = CallToolResultSchema, options) {
    var _a2;
    const clientInternal = this._client;
    const optionsWithTask = {
      ...options,
      task: (_a2 = options === null || options === undefined ? undefined : options.task) !== null && _a2 !== undefined ? _a2 : clientInternal.isToolTask(params.name) ? {} : undefined
    };
    const stream = clientInternal.requestStream({ method: "tools/call", params }, resultSchema, optionsWithTask);
    const validator2 = clientInternal.getToolOutputValidator(params.name);
    for await (const message of stream) {
      if (message.type === "result" && validator2) {
        const result = message.result;
        if (!result.structuredContent && !result.isError) {
          yield {
            type: "error",
            error: new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`)
          };
          return;
        }
        if (result.structuredContent) {
          try {
            const validationResult = validator2(result.structuredContent);
            if (!validationResult.valid) {
              yield {
                type: "error",
                error: new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`)
              };
              return;
            }
          } catch (error47) {
            if (error47 instanceof McpError) {
              yield { type: "error", error: error47 };
              return;
            }
            yield {
              type: "error",
              error: new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error47 instanceof Error ? error47.message : String(error47)}`)
            };
            return;
          }
        }
      }
      yield message;
    }
  }
  async getTask(taskId, options) {
    return this._client.getTask({ taskId }, options);
  }
  async getTaskResult(taskId, resultSchema, options) {
    return this._client.getTaskResult({ taskId }, resultSchema, options);
  }
  async listTasks(cursor, options) {
    return this._client.listTasks(cursor ? { cursor } : undefined, options);
  }
  async cancelTask(taskId, options) {
    return this._client.cancelTask({ taskId }, options);
  }
  requestStream(request, resultSchema, options) {
    return this._client.requestStream(request, resultSchema, options);
  }
}
var init_client = __esm(() => {
  init_types2();
});

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/helpers.js
function assertToolsCallTaskCapability(requests, method, entityName) {
  var _a2;
  if (!requests) {
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  }
  switch (method) {
    case "tools/call":
      if (!((_a2 = requests.tools) === null || _a2 === undefined ? undefined : _a2.call)) {
        throw new Error(`${entityName} does not support task creation for tools/call (required for ${method})`);
      }
      break;
    default:
      break;
  }
}
function assertClientRequestTaskCapability(requests, method, entityName) {
  var _a2, _b;
  if (!requests) {
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  }
  switch (method) {
    case "sampling/createMessage":
      if (!((_a2 = requests.sampling) === null || _a2 === undefined ? undefined : _a2.createMessage)) {
        throw new Error(`${entityName} does not support task creation for sampling/createMessage (required for ${method})`);
      }
      break;
    case "elicitation/create":
      if (!((_b = requests.elicitation) === null || _b === undefined ? undefined : _b.create)) {
        throw new Error(`${entityName} does not support task creation for elicitation/create (required for ${method})`);
      }
      break;
    default:
      break;
  }
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js
var exports_client = {};
__export(exports_client, {
  getSupportedElicitationModes: () => getSupportedElicitationModes,
  Client: () => Client2
});
function applyElicitationDefaults(schema, data) {
  if (!schema || data === null || typeof data !== "object")
    return;
  if (schema.type === "object" && schema.properties && typeof schema.properties === "object") {
    const obj = data;
    const props = schema.properties;
    for (const key of Object.keys(props)) {
      const propSchema = props[key];
      if (obj[key] === undefined && Object.prototype.hasOwnProperty.call(propSchema, "default")) {
        obj[key] = propSchema.default;
      }
      if (obj[key] !== undefined) {
        applyElicitationDefaults(propSchema, obj[key]);
      }
    }
  }
  if (Array.isArray(schema.anyOf)) {
    for (const sub of schema.anyOf) {
      applyElicitationDefaults(sub, data);
    }
  }
  if (Array.isArray(schema.oneOf)) {
    for (const sub of schema.oneOf) {
      applyElicitationDefaults(sub, data);
    }
  }
}
function getSupportedElicitationModes(capabilities) {
  if (!capabilities) {
    return { supportsFormMode: false, supportsUrlMode: false };
  }
  const hasFormCapability = capabilities.form !== undefined;
  const hasUrlCapability = capabilities.url !== undefined;
  const supportsFormMode = hasFormCapability || !hasFormCapability && !hasUrlCapability;
  const supportsUrlMode = hasUrlCapability;
  return { supportsFormMode, supportsUrlMode };
}
var Client2;
var init_client2 = __esm(() => {
  init_protocol();
  init_types2();
  init_ajv_provider();
  init_zod_compat();
  init_client();
  Client2 = class Client2 extends Protocol {
    constructor(_clientInfo, options) {
      var _a2, _b;
      super(options);
      this._clientInfo = _clientInfo;
      this._cachedToolOutputValidators = new Map;
      this._cachedKnownTaskTools = new Set;
      this._cachedRequiredTaskTools = new Set;
      this._capabilities = (_a2 = options === null || options === undefined ? undefined : options.capabilities) !== null && _a2 !== undefined ? _a2 : {};
      this._jsonSchemaValidator = (_b = options === null || options === undefined ? undefined : options.jsonSchemaValidator) !== null && _b !== undefined ? _b : new AjvJsonSchemaValidator;
    }
    get experimental() {
      if (!this._experimental) {
        this._experimental = {
          tasks: new ExperimentalClientTasks(this)
        };
      }
      return this._experimental;
    }
    registerCapabilities(capabilities) {
      if (this.transport) {
        throw new Error("Cannot register capabilities after connecting to transport");
      }
      this._capabilities = mergeCapabilities(this._capabilities, capabilities);
    }
    setRequestHandler(requestSchema, handler) {
      var _a2, _b, _c;
      const shape = getObjectShape(requestSchema);
      const methodSchema = shape === null || shape === undefined ? undefined : shape.method;
      if (!methodSchema) {
        throw new Error("Schema is missing a method literal");
      }
      let methodValue;
      if (isZ4Schema(methodSchema)) {
        const v4Schema = methodSchema;
        const v4Def = (_a2 = v4Schema._zod) === null || _a2 === undefined ? undefined : _a2.def;
        methodValue = (_b = v4Def === null || v4Def === undefined ? undefined : v4Def.value) !== null && _b !== undefined ? _b : v4Schema.value;
      } else {
        const v3Schema = methodSchema;
        const legacyDef = v3Schema._def;
        methodValue = (_c = legacyDef === null || legacyDef === undefined ? undefined : legacyDef.value) !== null && _c !== undefined ? _c : v3Schema.value;
      }
      if (typeof methodValue !== "string") {
        throw new Error("Schema method literal must be a string");
      }
      const method = methodValue;
      if (method === "elicitation/create") {
        const wrappedHandler = async (request, extra) => {
          var _a3, _b2, _c2;
          const validatedRequest = safeParse2(ElicitRequestSchema, request);
          if (!validatedRequest.success) {
            const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation request: ${errorMessage}`);
          }
          const { params } = validatedRequest.data;
          const mode = (_a3 = params.mode) !== null && _a3 !== undefined ? _a3 : "form";
          const { supportsFormMode, supportsUrlMode } = getSupportedElicitationModes(this._capabilities.elicitation);
          if (mode === "form" && !supportsFormMode) {
            throw new McpError(ErrorCode.InvalidParams, "Client does not support form-mode elicitation requests");
          }
          if (mode === "url" && !supportsUrlMode) {
            throw new McpError(ErrorCode.InvalidParams, "Client does not support URL-mode elicitation requests");
          }
          const result = await Promise.resolve(handler(request, extra));
          if (params.task) {
            const taskValidationResult = safeParse2(CreateTaskResultSchema, result);
            if (!taskValidationResult.success) {
              const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
              throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
            }
            return taskValidationResult.data;
          }
          const validationResult = safeParse2(ElicitResultSchema, result);
          if (!validationResult.success) {
            const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation result: ${errorMessage}`);
          }
          const validatedResult = validationResult.data;
          const requestedSchema = mode === "form" ? params.requestedSchema : undefined;
          if (mode === "form" && validatedResult.action === "accept" && validatedResult.content && requestedSchema) {
            if ((_c2 = (_b2 = this._capabilities.elicitation) === null || _b2 === undefined ? undefined : _b2.form) === null || _c2 === undefined ? undefined : _c2.applyDefaults) {
              try {
                applyElicitationDefaults(requestedSchema, validatedResult.content);
              } catch (_d) {}
            }
          }
          return validatedResult;
        };
        return super.setRequestHandler(requestSchema, wrappedHandler);
      }
      if (method === "sampling/createMessage") {
        const wrappedHandler = async (request, extra) => {
          const validatedRequest = safeParse2(CreateMessageRequestSchema, request);
          if (!validatedRequest.success) {
            const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid sampling request: ${errorMessage}`);
          }
          const { params } = validatedRequest.data;
          const result = await Promise.resolve(handler(request, extra));
          if (params.task) {
            const taskValidationResult = safeParse2(CreateTaskResultSchema, result);
            if (!taskValidationResult.success) {
              const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
              throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
            }
            return taskValidationResult.data;
          }
          const validationResult = safeParse2(CreateMessageResultSchema, result);
          if (!validationResult.success) {
            const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid sampling result: ${errorMessage}`);
          }
          return validationResult.data;
        };
        return super.setRequestHandler(requestSchema, wrappedHandler);
      }
      return super.setRequestHandler(requestSchema, handler);
    }
    assertCapability(capability, method) {
      var _a2;
      if (!((_a2 = this._serverCapabilities) === null || _a2 === undefined ? undefined : _a2[capability])) {
        throw new Error(`Server does not support ${capability} (required for ${method})`);
      }
    }
    async connect(transport, options) {
      await super.connect(transport);
      if (transport.sessionId !== undefined) {
        return;
      }
      try {
        const result = await this.request({
          method: "initialize",
          params: {
            protocolVersion: LATEST_PROTOCOL_VERSION,
            capabilities: this._capabilities,
            clientInfo: this._clientInfo
          }
        }, InitializeResultSchema, options);
        if (result === undefined) {
          throw new Error(`Server sent invalid initialize result: ${result}`);
        }
        if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {
          throw new Error(`Server's protocol version is not supported: ${result.protocolVersion}`);
        }
        this._serverCapabilities = result.capabilities;
        this._serverVersion = result.serverInfo;
        if (transport.setProtocolVersion) {
          transport.setProtocolVersion(result.protocolVersion);
        }
        this._instructions = result.instructions;
        await this.notification({
          method: "notifications/initialized"
        });
      } catch (error47) {
        this.close();
        throw error47;
      }
    }
    getServerCapabilities() {
      return this._serverCapabilities;
    }
    getServerVersion() {
      return this._serverVersion;
    }
    getInstructions() {
      return this._instructions;
    }
    assertCapabilityForMethod(method) {
      var _a2, _b, _c, _d, _e;
      switch (method) {
        case "logging/setLevel":
          if (!((_a2 = this._serverCapabilities) === null || _a2 === undefined ? undefined : _a2.logging)) {
            throw new Error(`Server does not support logging (required for ${method})`);
          }
          break;
        case "prompts/get":
        case "prompts/list":
          if (!((_b = this._serverCapabilities) === null || _b === undefined ? undefined : _b.prompts)) {
            throw new Error(`Server does not support prompts (required for ${method})`);
          }
          break;
        case "resources/list":
        case "resources/templates/list":
        case "resources/read":
        case "resources/subscribe":
        case "resources/unsubscribe":
          if (!((_c = this._serverCapabilities) === null || _c === undefined ? undefined : _c.resources)) {
            throw new Error(`Server does not support resources (required for ${method})`);
          }
          if (method === "resources/subscribe" && !this._serverCapabilities.resources.subscribe) {
            throw new Error(`Server does not support resource subscriptions (required for ${method})`);
          }
          break;
        case "tools/call":
        case "tools/list":
          if (!((_d = this._serverCapabilities) === null || _d === undefined ? undefined : _d.tools)) {
            throw new Error(`Server does not support tools (required for ${method})`);
          }
          break;
        case "completion/complete":
          if (!((_e = this._serverCapabilities) === null || _e === undefined ? undefined : _e.completions)) {
            throw new Error(`Server does not support completions (required for ${method})`);
          }
          break;
        case "initialize":
          break;
        case "ping":
          break;
      }
    }
    assertNotificationCapability(method) {
      var _a2;
      switch (method) {
        case "notifications/roots/list_changed":
          if (!((_a2 = this._capabilities.roots) === null || _a2 === undefined ? undefined : _a2.listChanged)) {
            throw new Error(`Client does not support roots list changed notifications (required for ${method})`);
          }
          break;
        case "notifications/initialized":
          break;
        case "notifications/cancelled":
          break;
        case "notifications/progress":
          break;
      }
    }
    assertRequestHandlerCapability(method) {
      if (!this._capabilities) {
        return;
      }
      switch (method) {
        case "sampling/createMessage":
          if (!this._capabilities.sampling) {
            throw new Error(`Client does not support sampling capability (required for ${method})`);
          }
          break;
        case "elicitation/create":
          if (!this._capabilities.elicitation) {
            throw new Error(`Client does not support elicitation capability (required for ${method})`);
          }
          break;
        case "roots/list":
          if (!this._capabilities.roots) {
            throw new Error(`Client does not support roots capability (required for ${method})`);
          }
          break;
        case "tasks/get":
        case "tasks/list":
        case "tasks/result":
        case "tasks/cancel":
          if (!this._capabilities.tasks) {
            throw new Error(`Client does not support tasks capability (required for ${method})`);
          }
          break;
        case "ping":
          break;
      }
    }
    assertTaskCapability(method) {
      var _a2, _b;
      assertToolsCallTaskCapability((_b = (_a2 = this._serverCapabilities) === null || _a2 === undefined ? undefined : _a2.tasks) === null || _b === undefined ? undefined : _b.requests, method, "Server");
    }
    assertTaskHandlerCapability(method) {
      var _a2;
      if (!this._capabilities) {
        return;
      }
      assertClientRequestTaskCapability((_a2 = this._capabilities.tasks) === null || _a2 === undefined ? undefined : _a2.requests, method, "Client");
    }
    async ping(options) {
      return this.request({ method: "ping" }, EmptyResultSchema, options);
    }
    async complete(params, options) {
      return this.request({ method: "completion/complete", params }, CompleteResultSchema, options);
    }
    async setLoggingLevel(level, options) {
      return this.request({ method: "logging/setLevel", params: { level } }, EmptyResultSchema, options);
    }
    async getPrompt(params, options) {
      return this.request({ method: "prompts/get", params }, GetPromptResultSchema, options);
    }
    async listPrompts(params, options) {
      return this.request({ method: "prompts/list", params }, ListPromptsResultSchema, options);
    }
    async listResources(params, options) {
      return this.request({ method: "resources/list", params }, ListResourcesResultSchema, options);
    }
    async listResourceTemplates(params, options) {
      return this.request({ method: "resources/templates/list", params }, ListResourceTemplatesResultSchema, options);
    }
    async readResource(params, options) {
      return this.request({ method: "resources/read", params }, ReadResourceResultSchema, options);
    }
    async subscribeResource(params, options) {
      return this.request({ method: "resources/subscribe", params }, EmptyResultSchema, options);
    }
    async unsubscribeResource(params, options) {
      return this.request({ method: "resources/unsubscribe", params }, EmptyResultSchema, options);
    }
    async callTool(params, resultSchema = CallToolResultSchema, options) {
      if (this.isToolTaskRequired(params.name)) {
        throw new McpError(ErrorCode.InvalidRequest, `Tool "${params.name}" requires task-based execution. Use client.experimental.tasks.callToolStream() instead.`);
      }
      const result = await this.request({ method: "tools/call", params }, resultSchema, options);
      const validator2 = this.getToolOutputValidator(params.name);
      if (validator2) {
        if (!result.structuredContent && !result.isError) {
          throw new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`);
        }
        if (result.structuredContent) {
          try {
            const validationResult = validator2(result.structuredContent);
            if (!validationResult.valid) {
              throw new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`);
            }
          } catch (error47) {
            if (error47 instanceof McpError) {
              throw error47;
            }
            throw new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error47 instanceof Error ? error47.message : String(error47)}`);
          }
        }
      }
      return result;
    }
    isToolTask(toolName) {
      var _a2, _b, _c, _d;
      if (!((_d = (_c = (_b = (_a2 = this._serverCapabilities) === null || _a2 === undefined ? undefined : _a2.tasks) === null || _b === undefined ? undefined : _b.requests) === null || _c === undefined ? undefined : _c.tools) === null || _d === undefined ? undefined : _d.call)) {
        return false;
      }
      return this._cachedKnownTaskTools.has(toolName);
    }
    isToolTaskRequired(toolName) {
      return this._cachedRequiredTaskTools.has(toolName);
    }
    cacheToolMetadata(tools) {
      var _a2;
      this._cachedToolOutputValidators.clear();
      this._cachedKnownTaskTools.clear();
      this._cachedRequiredTaskTools.clear();
      for (const tool2 of tools) {
        if (tool2.outputSchema) {
          const toolValidator = this._jsonSchemaValidator.getValidator(tool2.outputSchema);
          this._cachedToolOutputValidators.set(tool2.name, toolValidator);
        }
        const taskSupport = (_a2 = tool2.execution) === null || _a2 === undefined ? undefined : _a2.taskSupport;
        if (taskSupport === "required" || taskSupport === "optional") {
          this._cachedKnownTaskTools.add(tool2.name);
        }
        if (taskSupport === "required") {
          this._cachedRequiredTaskTools.add(tool2.name);
        }
      }
    }
    getToolOutputValidator(toolName) {
      return this._cachedToolOutputValidators.get(toolName);
    }
    async listTools(params, options) {
      const result = await this.request({ method: "tools/list", params }, ListToolsResultSchema, options);
      this.cacheToolMetadata(result.tools);
      return result;
    }
    async sendRootsListChanged() {
      return this.notification({ method: "notifications/roots/list_changed" });
    }
  };
});

// node_modules/@langchain/core/dist/_virtual/rolldown_runtime.js
var __defProp2 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, {
      get: all[name],
      enumerable: true
    });
};

// node_modules/@langchain/core/dist/documents/document.js
var Document = class {
  pageContent;
  metadata;
  id;
  constructor(fields) {
    this.pageContent = fields.pageContent !== undefined ? fields.pageContent.toString() : "";
    this.metadata = fields.metadata ?? {};
    this.id = fields.id;
  }
};

// node_modules/@langchain/core/dist/load/map_keys.js
var import_decamelize = __toESM(require_decamelize(), 1);
var import_camelcase = __toESM(require_camelcase(), 1);
function keyToJson(key, map) {
  return map?.[key] || import_decamelize.default(key);
}
function mapKeys(fields, mapper, map) {
  const mapped = {};
  for (const key in fields)
    if (Object.hasOwn(fields, key))
      mapped[mapper(key, map)] = fields[key];
  return mapped;
}

// node_modules/@langchain/core/dist/load/serializable.js
var serializable_exports = {};
__export2(serializable_exports, {
  Serializable: () => Serializable,
  get_lc_unique_name: () => get_lc_unique_name
});
function shallowCopy(obj) {
  return Array.isArray(obj) ? [...obj] : { ...obj };
}
function replaceSecrets(root, secretsMap) {
  const result = shallowCopy(root);
  for (const [path, secretId] of Object.entries(secretsMap)) {
    const [last, ...partsReverse] = path.split(".").reverse();
    let current = result;
    for (const part of partsReverse.reverse()) {
      if (current[part] === undefined)
        break;
      current[part] = shallowCopy(current[part]);
      current = current[part];
    }
    if (current[last] !== undefined)
      current[last] = {
        lc: 1,
        type: "secret",
        id: [secretId]
      };
  }
  return result;
}
function get_lc_unique_name(serializableClass) {
  const parentClass = Object.getPrototypeOf(serializableClass);
  const lcNameIsSubclassed = typeof serializableClass.lc_name === "function" && (typeof parentClass.lc_name !== "function" || serializableClass.lc_name() !== parentClass.lc_name());
  if (lcNameIsSubclassed)
    return serializableClass.lc_name();
  else
    return serializableClass.name;
}
var Serializable = class Serializable2 {
  lc_serializable = false;
  lc_kwargs;
  static lc_name() {
    return this.name;
  }
  get lc_id() {
    return [...this.lc_namespace, get_lc_unique_name(this.constructor)];
  }
  get lc_secrets() {
    return;
  }
  get lc_attributes() {
    return;
  }
  get lc_aliases() {
    return;
  }
  get lc_serializable_keys() {
    return;
  }
  constructor(kwargs, ..._args) {
    if (this.lc_serializable_keys !== undefined)
      this.lc_kwargs = Object.fromEntries(Object.entries(kwargs || {}).filter(([key]) => this.lc_serializable_keys?.includes(key)));
    else
      this.lc_kwargs = kwargs ?? {};
  }
  toJSON() {
    if (!this.lc_serializable)
      return this.toJSONNotImplemented();
    if (this.lc_kwargs instanceof Serializable2 || typeof this.lc_kwargs !== "object" || Array.isArray(this.lc_kwargs))
      return this.toJSONNotImplemented();
    const aliases = {};
    const secrets = {};
    const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {
      acc[key] = key in this ? this[key] : this.lc_kwargs[key];
      return acc;
    }, {});
    for (let current = Object.getPrototypeOf(this);current; current = Object.getPrototypeOf(current)) {
      Object.assign(aliases, Reflect.get(current, "lc_aliases", this));
      Object.assign(secrets, Reflect.get(current, "lc_secrets", this));
      Object.assign(kwargs, Reflect.get(current, "lc_attributes", this));
    }
    Object.keys(secrets).forEach((keyPath) => {
      let read = this;
      let write = kwargs;
      const [last, ...partsReverse] = keyPath.split(".").reverse();
      for (const key of partsReverse.reverse()) {
        if (!(key in read) || read[key] === undefined)
          return;
        if (!(key in write) || write[key] === undefined) {
          if (typeof read[key] === "object" && read[key] != null)
            write[key] = {};
          else if (Array.isArray(read[key]))
            write[key] = [];
        }
        read = read[key];
        write = write[key];
      }
      if (last in read && read[last] !== undefined)
        write[last] = write[last] || read[last];
    });
    return {
      lc: 1,
      type: "constructor",
      id: this.lc_id,
      kwargs: mapKeys(Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs, keyToJson, aliases)
    };
  }
  toJSONNotImplemented() {
    return {
      lc: 1,
      type: "not_implemented",
      id: this.lc_id
    };
  }
};

// node_modules/@langchain/core/dist/tools/utils.js
function _isToolCall(toolCall) {
  return !!(toolCall && typeof toolCall === "object" && ("type" in toolCall) && toolCall.type === "tool_call");
}
var ToolInputParsingException = class extends Error {
  output;
  constructor(message, output) {
    super(message);
    this.output = output;
  }
};

// node_modules/@langchain/core/dist/singletons/async_local_storage/globals.js
var TRACING_ALS_KEY = Symbol.for("ls:tracing_async_local_storage");
var _CONTEXT_VARIABLES_KEY = Symbol.for("lc:context_variables");
var setGlobalAsyncLocalStorageInstance = (instance) => {
  globalThis[TRACING_ALS_KEY] = instance;
};
var getGlobalAsyncLocalStorageInstance = () => {
  return globalThis[TRACING_ALS_KEY];
};

// node_modules/@langchain/core/dist/messages/content/data.js
function isDataContentBlock(content_block) {
  return typeof content_block === "object" && content_block !== null && "type" in content_block && typeof content_block.type === "string" && "source_type" in content_block && (content_block.source_type === "url" || content_block.source_type === "base64" || content_block.source_type === "text" || content_block.source_type === "id");
}
function isURLContentBlock(content_block) {
  return isDataContentBlock(content_block) && content_block.source_type === "url" && "url" in content_block && typeof content_block.url === "string";
}
function isBase64ContentBlock(content_block) {
  return isDataContentBlock(content_block) && content_block.source_type === "base64" && "data" in content_block && typeof content_block.data === "string";
}
function isIDContentBlock(content_block) {
  return isDataContentBlock(content_block) && content_block.source_type === "id" && "id" in content_block && typeof content_block.id === "string";
}
function parseBase64DataUrl({ dataUrl: data_url, asTypedArray = false }) {
  const formatMatch = data_url.match(/^data:(\w+\/\w+);base64,([A-Za-z0-9+/]+=*)$/);
  let mime_type;
  if (formatMatch) {
    mime_type = formatMatch[1].toLowerCase();
    const data = asTypedArray ? Uint8Array.from(atob(formatMatch[2]), (c) => c.charCodeAt(0)) : formatMatch[2];
    return {
      mime_type,
      data
    };
  }
  return;
}

// node_modules/@langchain/core/dist/messages/block_translators/utils.js
function _isContentBlock(block, type) {
  return _isObject(block) && block.type === type;
}
function _isObject(value) {
  return typeof value === "object" && value !== null;
}
function _isArray(value) {
  return Array.isArray(value);
}
function _isString(value) {
  return typeof value === "string";
}
function _isNumber(value) {
  return typeof value === "number";
}
function _isBytesArray(value) {
  return value instanceof Uint8Array;
}
function safeParseJson(value) {
  try {
    return JSON.parse(value);
  } catch {
    return;
  }
}
var iife = (fn) => fn();

// node_modules/@langchain/core/dist/messages/block_translators/anthropic.js
function convertAnthropicAnnotation(citation) {
  if (citation.type === "char_location" && _isString(citation.document_title) && _isNumber(citation.start_char_index) && _isNumber(citation.end_char_index) && _isString(citation.cited_text)) {
    const { document_title, start_char_index, end_char_index, cited_text, ...rest } = citation;
    return {
      ...rest,
      type: "citation",
      source: "char",
      title: document_title ?? undefined,
      startIndex: start_char_index,
      endIndex: end_char_index,
      citedText: cited_text
    };
  }
  if (citation.type === "page_location" && _isString(citation.document_title) && _isNumber(citation.start_page_number) && _isNumber(citation.end_page_number) && _isString(citation.cited_text)) {
    const { document_title, start_page_number, end_page_number, cited_text, ...rest } = citation;
    return {
      ...rest,
      type: "citation",
      source: "page",
      title: document_title ?? undefined,
      startIndex: start_page_number,
      endIndex: end_page_number,
      citedText: cited_text
    };
  }
  if (citation.type === "content_block_location" && _isString(citation.document_title) && _isNumber(citation.start_block_index) && _isNumber(citation.end_block_index) && _isString(citation.cited_text)) {
    const { document_title, start_block_index, end_block_index, cited_text, ...rest } = citation;
    return {
      ...rest,
      type: "citation",
      source: "block",
      title: document_title ?? undefined,
      startIndex: start_block_index,
      endIndex: end_block_index,
      citedText: cited_text
    };
  }
  if (citation.type === "web_search_result_location" && _isString(citation.url) && _isString(citation.title) && _isString(citation.encrypted_index) && _isString(citation.cited_text)) {
    const { url, title, encrypted_index, cited_text, ...rest } = citation;
    return {
      ...rest,
      type: "citation",
      source: "url",
      url,
      title,
      startIndex: Number(encrypted_index),
      endIndex: Number(encrypted_index),
      citedText: cited_text
    };
  }
  if (citation.type === "search_result_location" && _isString(citation.source) && _isString(citation.title) && _isNumber(citation.start_block_index) && _isNumber(citation.end_block_index) && _isString(citation.cited_text)) {
    const { source, title, start_block_index, end_block_index, cited_text, ...rest } = citation;
    return {
      ...rest,
      type: "citation",
      source: "search",
      url: source,
      title: title ?? undefined,
      startIndex: start_block_index,
      endIndex: end_block_index,
      citedText: cited_text
    };
  }
  return;
}
function convertToV1FromAnthropicContentBlock(block) {
  if (_isContentBlock(block, "document") && _isObject(block.source) && "type" in block.source) {
    if (block.source.type === "base64" && _isString(block.source.media_type) && _isString(block.source.data))
      return {
        type: "file",
        mimeType: block.source.media_type,
        data: block.source.data
      };
    else if (block.source.type === "url" && _isString(block.source.url))
      return {
        type: "file",
        url: block.source.url
      };
    else if (block.source.type === "file" && _isString(block.source.file_id))
      return {
        type: "file",
        fileId: block.source.file_id
      };
    else if (block.source.type === "text" && _isString(block.source.data))
      return {
        type: "file",
        mimeType: String(block.source.media_type ?? "text/plain"),
        data: block.source.data
      };
  } else if (_isContentBlock(block, "image") && _isObject(block.source) && "type" in block.source) {
    if (block.source.type === "base64" && _isString(block.source.media_type) && _isString(block.source.data))
      return {
        type: "image",
        mimeType: block.source.media_type,
        data: block.source.data
      };
    else if (block.source.type === "url" && _isString(block.source.url))
      return {
        type: "image",
        url: block.source.url
      };
    else if (block.source.type === "file" && _isString(block.source.file_id))
      return {
        type: "image",
        fileId: block.source.file_id
      };
  }
  return;
}
function convertToV1FromAnthropicInput(content) {
  function* iterateContent() {
    for (const block of content) {
      const stdBlock = convertToV1FromAnthropicContentBlock(block);
      if (stdBlock)
        yield stdBlock;
      else
        yield block;
    }
  }
  return Array.from(iterateContent());
}
function convertToV1FromAnthropicMessage(message) {
  function* iterateContent() {
    const content = typeof message.content === "string" ? [{
      type: "text",
      text: message.content
    }] : message.content;
    for (const block of content) {
      if (_isContentBlock(block, "text") && _isString(block.text)) {
        const { text, citations, ...rest } = block;
        if (_isArray(citations) && citations.length) {
          const _citations = citations.reduce((acc, item) => {
            const citation = convertAnthropicAnnotation(item);
            if (citation)
              return [...acc, citation];
            return acc;
          }, []);
          yield {
            ...rest,
            type: "text",
            text,
            annotations: _citations
          };
          continue;
        } else {
          yield {
            ...rest,
            type: "text",
            text
          };
          continue;
        }
      } else if (_isContentBlock(block, "thinking") && _isString(block.thinking)) {
        const { thinking, signature, ...rest } = block;
        yield {
          ...rest,
          type: "reasoning",
          reasoning: thinking,
          signature
        };
        continue;
      } else if (_isContentBlock(block, "redacted_thinking")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "tool_use") && _isString(block.name) && _isString(block.id)) {
        yield {
          type: "tool_call",
          id: block.id,
          name: block.name,
          args: block.input
        };
        continue;
      } else if (_isContentBlock(block, "input_json_delta")) {
        if (_isAIMessageChunk(message) && message.tool_call_chunks?.length) {
          const tool_call_chunk = message.tool_call_chunks[0];
          yield {
            type: "tool_call_chunk",
            id: tool_call_chunk.id,
            name: tool_call_chunk.name,
            args: tool_call_chunk.args,
            index: tool_call_chunk.index
          };
          continue;
        }
      } else if (_isContentBlock(block, "server_tool_use") && _isString(block.name) && _isString(block.id)) {
        const { name, id } = block;
        if (name === "web_search") {
          const query = iife(() => {
            if (typeof block.input === "string")
              return block.input;
            else if (_isObject(block.input) && _isString(block.input.query))
              return block.input.query;
            else if (_isString(block.partial_json)) {
              const json = safeParseJson(block.partial_json);
              if (json?.query)
                return json.query;
            }
            return "";
          });
          yield {
            id,
            type: "server_tool_call",
            name: "web_search",
            args: { query }
          };
          continue;
        } else if (block.name === "code_execution") {
          const code = iife(() => {
            if (typeof block.input === "string")
              return block.input;
            else if (_isObject(block.input) && _isString(block.input.code))
              return block.input.code;
            else if (_isString(block.partial_json)) {
              const json = safeParseJson(block.partial_json);
              if (json?.code)
                return json.code;
            }
            return "";
          });
          yield {
            id,
            type: "server_tool_call",
            name: "code_execution",
            args: { code }
          };
          continue;
        }
      } else if (_isContentBlock(block, "web_search_tool_result") && _isString(block.tool_use_id) && _isArray(block.content)) {
        const { content: content$1, tool_use_id } = block;
        const urls = content$1.reduce((acc, content$2) => {
          if (_isContentBlock(content$2, "web_search_result"))
            return [...acc, content$2.url];
          return acc;
        }, []);
        yield {
          type: "server_tool_call_result",
          name: "web_search",
          toolCallId: tool_use_id,
          status: "success",
          output: { urls }
        };
        continue;
      } else if (_isContentBlock(block, "code_execution_tool_result") && _isString(block.tool_use_id) && _isObject(block.content)) {
        yield {
          type: "server_tool_call_result",
          name: "code_execution",
          toolCallId: block.tool_use_id,
          status: "success",
          output: block.content
        };
        continue;
      } else if (_isContentBlock(block, "mcp_tool_use")) {
        yield {
          id: block.id,
          type: "server_tool_call",
          name: "mcp_tool_use",
          args: block.input
        };
        continue;
      } else if (_isContentBlock(block, "mcp_tool_result") && _isString(block.tool_use_id) && _isObject(block.content)) {
        yield {
          type: "server_tool_call_result",
          name: "mcp_tool_use",
          toolCallId: block.tool_use_id,
          status: "success",
          output: block.content
        };
        continue;
      } else if (_isContentBlock(block, "container_upload")) {
        yield {
          type: "server_tool_call",
          name: "container_upload",
          args: block.input
        };
        continue;
      } else if (_isContentBlock(block, "search_result")) {
        yield {
          id: block.id,
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "tool_result")) {
        yield {
          id: block.id,
          type: "non_standard",
          value: block
        };
        continue;
      } else {
        const stdBlock = convertToV1FromAnthropicContentBlock(block);
        if (stdBlock) {
          yield stdBlock;
          continue;
        }
      }
      yield {
        type: "non_standard",
        value: block
      };
    }
  }
  return Array.from(iterateContent());
}
var ChatAnthropicTranslator = {
  translateContent: convertToV1FromAnthropicMessage,
  translateContentChunk: convertToV1FromAnthropicMessage
};
function _isAIMessageChunk(message) {
  return typeof message?._getType === "function" && typeof message.concat === "function" && message._getType() === "ai";
}

// node_modules/@langchain/core/dist/messages/block_translators/data.js
function convertToV1FromDataContentBlock(block) {
  if (isURLContentBlock(block))
    return {
      type: block.type,
      mimeType: block.mime_type,
      url: block.url,
      metadata: block.metadata
    };
  if (isBase64ContentBlock(block))
    return {
      type: block.type,
      mimeType: block.mime_type ?? "application/octet-stream",
      data: block.data,
      metadata: block.metadata
    };
  if (isIDContentBlock(block))
    return {
      type: block.type,
      mimeType: block.mime_type,
      fileId: block.id,
      metadata: block.metadata
    };
  return block;
}
function convertToV1FromDataContent(content) {
  return content.map(convertToV1FromDataContentBlock);
}
function isOpenAIDataBlock(block) {
  if (_isContentBlock(block, "image_url") && _isObject(block.image_url))
    return true;
  if (_isContentBlock(block, "input_audio") && _isObject(block.input_audio))
    return true;
  if (_isContentBlock(block, "file") && _isObject(block.file))
    return true;
  return false;
}
function convertToV1FromOpenAIDataBlock(block) {
  if (_isContentBlock(block, "image_url") && _isObject(block.image_url) && _isString(block.image_url.url)) {
    const parsed = parseBase64DataUrl({ dataUrl: block.image_url.url });
    if (parsed)
      return {
        type: "image",
        mimeType: parsed.mime_type,
        data: parsed.data
      };
    else
      return {
        type: "image",
        url: block.image_url.url
      };
  } else if (_isContentBlock(block, "input_audio") && _isObject(block.input_audio) && _isString(block.input_audio.data) && _isString(block.input_audio.format))
    return {
      type: "audio",
      data: block.input_audio.data,
      mimeType: `audio/${block.input_audio.format}`
    };
  else if (_isContentBlock(block, "file") && _isObject(block.file) && _isString(block.file.data)) {
    const parsed = parseBase64DataUrl({ dataUrl: block.file.data });
    if (parsed)
      return {
        type: "file",
        data: parsed.data,
        mimeType: parsed.mime_type
      };
    else if (_isString(block.file.file_id))
      return {
        type: "file",
        fileId: block.file.file_id
      };
  }
  return block;
}

// node_modules/@langchain/core/dist/messages/block_translators/openai.js
function convertToV1FromChatCompletions(message) {
  const blocks = [];
  if (typeof message.content === "string")
    blocks.push({
      type: "text",
      text: message.content
    });
  else
    blocks.push(...convertToV1FromChatCompletionsInput(message.content));
  for (const toolCall of message.tool_calls ?? [])
    blocks.push({
      type: "tool_call",
      id: toolCall.id,
      name: toolCall.name,
      args: toolCall.args
    });
  return blocks;
}
function convertToV1FromChatCompletionsChunk(message) {
  const blocks = [];
  if (typeof message.content === "string")
    blocks.push({
      type: "text",
      text: message.content
    });
  else
    blocks.push(...convertToV1FromChatCompletionsInput(message.content));
  for (const toolCall of message.tool_calls ?? [])
    blocks.push({
      type: "tool_call",
      id: toolCall.id,
      name: toolCall.name,
      args: toolCall.args
    });
  return blocks;
}
function convertToV1FromChatCompletionsInput(blocks) {
  const convertedBlocks = [];
  for (const block of blocks)
    if (isOpenAIDataBlock(block))
      convertedBlocks.push(convertToV1FromOpenAIDataBlock(block));
    else
      convertedBlocks.push(block);
  return convertedBlocks;
}
function convertResponsesAnnotation(annotation) {
  if (annotation.type === "url_citation") {
    const { url, title, start_index, end_index } = annotation;
    return {
      type: "citation",
      url,
      title,
      startIndex: start_index,
      endIndex: end_index
    };
  }
  if (annotation.type === "file_citation") {
    const { file_id, filename, index } = annotation;
    return {
      type: "citation",
      title: filename,
      startIndex: index,
      endIndex: index,
      fileId: file_id
    };
  }
  return annotation;
}
function convertToV1FromResponses(message) {
  function* iterateContent() {
    if (_isObject(message.additional_kwargs?.reasoning) && _isArray(message.additional_kwargs.reasoning.summary)) {
      const summary = message.additional_kwargs.reasoning.summary.reduce((acc, item) => {
        if (_isObject(item) && _isString(item.text))
          return `${acc}${item.text}`;
        return acc;
      }, "");
      yield {
        type: "reasoning",
        reasoning: summary
      };
    }
    const content = typeof message.content === "string" ? [{
      type: "text",
      text: message.content
    }] : message.content;
    for (const block of content)
      if (_isContentBlock(block, "text")) {
        const { text, annotations, ...rest } = block;
        if (Array.isArray(annotations))
          yield {
            ...rest,
            type: "text",
            text: String(text),
            annotations: annotations.map(convertResponsesAnnotation)
          };
        else
          yield {
            ...rest,
            type: "text",
            text: String(text)
          };
      }
    for (const toolCall of message.tool_calls ?? [])
      yield {
        type: "tool_call",
        id: toolCall.id,
        name: toolCall.name,
        args: toolCall.args
      };
    if (_isObject(message.additional_kwargs) && _isArray(message.additional_kwargs.tool_outputs))
      for (const toolOutput of message.additional_kwargs.tool_outputs) {
        if (_isContentBlock(toolOutput, "web_search_call")) {
          yield {
            id: toolOutput.id,
            type: "server_tool_call",
            name: "web_search",
            args: { query: toolOutput.query }
          };
          continue;
        } else if (_isContentBlock(toolOutput, "file_search_call")) {
          yield {
            id: toolOutput.id,
            type: "server_tool_call",
            name: "file_search",
            args: { query: toolOutput.query }
          };
          continue;
        } else if (_isContentBlock(toolOutput, "computer_call")) {
          yield {
            type: "non_standard",
            value: toolOutput
          };
          continue;
        } else if (_isContentBlock(toolOutput, "code_interpreter_call")) {
          if (_isString(toolOutput.code))
            yield {
              id: toolOutput.id,
              type: "server_tool_call",
              name: "code_interpreter",
              args: { code: toolOutput.code }
            };
          if (_isArray(toolOutput.outputs)) {
            const returnCode = iife(() => {
              if (toolOutput.status === "in_progress")
                return;
              if (toolOutput.status === "completed")
                return 0;
              if (toolOutput.status === "incomplete")
                return 127;
              if (toolOutput.status === "interpreting")
                return;
              if (toolOutput.status === "failed")
                return 1;
              return;
            });
            for (const output of toolOutput.outputs)
              if (_isContentBlock(output, "logs")) {
                yield {
                  type: "server_tool_call_result",
                  toolCallId: toolOutput.id ?? "",
                  status: "success",
                  output: {
                    type: "code_interpreter_output",
                    returnCode: returnCode ?? 0,
                    stderr: [0, undefined].includes(returnCode) ? undefined : String(output.logs),
                    stdout: [0, undefined].includes(returnCode) ? String(output.logs) : undefined
                  }
                };
                continue;
              }
          }
          continue;
        } else if (_isContentBlock(toolOutput, "mcp_call")) {
          yield {
            id: toolOutput.id,
            type: "server_tool_call",
            name: "mcp_call",
            args: toolOutput.input
          };
          continue;
        } else if (_isContentBlock(toolOutput, "mcp_list_tools")) {
          yield {
            id: toolOutput.id,
            type: "server_tool_call",
            name: "mcp_list_tools",
            args: toolOutput.input
          };
          continue;
        } else if (_isContentBlock(toolOutput, "mcp_approval_request")) {
          yield {
            type: "non_standard",
            value: toolOutput
          };
          continue;
        } else if (_isContentBlock(toolOutput, "image_generation_call")) {
          yield {
            type: "non_standard",
            value: toolOutput
          };
          continue;
        }
        if (_isObject(toolOutput))
          yield {
            type: "non_standard",
            value: toolOutput
          };
      }
  }
  return Array.from(iterateContent());
}
function convertToV1FromResponsesChunk(message) {
  function* iterateContent() {
    yield* convertToV1FromResponses(message);
    for (const toolCallChunk of message.tool_call_chunks ?? [])
      yield {
        type: "tool_call_chunk",
        id: toolCallChunk.id,
        name: toolCallChunk.name,
        args: toolCallChunk.args
      };
  }
  return Array.from(iterateContent());
}
var ChatOpenAITranslator = {
  translateContent: (message) => {
    if (typeof message.content === "string")
      return convertToV1FromChatCompletions(message);
    return convertToV1FromResponses(message);
  },
  translateContentChunk: (message) => {
    if (typeof message.content === "string")
      return convertToV1FromChatCompletionsChunk(message);
    return convertToV1FromResponsesChunk(message);
  }
};

// node_modules/@langchain/core/dist/messages/message.js
function isMessage(message) {
  return typeof message === "object" && message !== null && "type" in message && "content" in message && (typeof message.content === "string" || Array.isArray(message.content));
}

// node_modules/@langchain/core/dist/messages/format.js
function convertToFormattedString(message, format = "pretty") {
  if (format === "pretty")
    return convertToPrettyString(message);
  return JSON.stringify(message);
}
function convertToPrettyString(message) {
  const lines = [];
  const title = ` ${message.type.charAt(0).toUpperCase() + message.type.slice(1)} Message `;
  const sepLen = Math.floor((80 - title.length) / 2);
  const sep = "=".repeat(sepLen);
  const secondSep = title.length % 2 === 0 ? sep : `${sep}=`;
  lines.push(`${sep}${title}${secondSep}`);
  if (message.type === "ai") {
    const aiMessage = message;
    if (aiMessage.tool_calls && aiMessage.tool_calls.length > 0) {
      lines.push("Tool Calls:");
      for (const tc of aiMessage.tool_calls) {
        lines.push(`  ${tc.name} (${tc.id})`);
        lines.push(` Call ID: ${tc.id}`);
        lines.push("  Args:");
        for (const [key, value] of Object.entries(tc.args))
          lines.push(`    ${key}: ${typeof value === "object" ? JSON.stringify(value) : value}`);
      }
    }
  }
  if (message.type === "tool") {
    const toolMessage = message;
    if (toolMessage.name)
      lines.push(`Name: ${toolMessage.name}`);
  }
  if (typeof message.content === "string" && message.content.trim()) {
    if (lines.length > 1)
      lines.push("");
    lines.push(message.content);
  }
  return lines.join(`
`);
}

// node_modules/@langchain/core/dist/messages/base.js
var MESSAGE_SYMBOL = Symbol.for("langchain.message");
function mergeContent(firstContent, secondContent) {
  if (typeof firstContent === "string") {
    if (firstContent === "")
      return secondContent;
    if (typeof secondContent === "string")
      return firstContent + secondContent;
    else if (Array.isArray(secondContent) && secondContent.length === 0)
      return firstContent;
    else if (Array.isArray(secondContent) && secondContent.some((c) => isDataContentBlock(c)))
      return [{
        type: "text",
        source_type: "text",
        text: firstContent
      }, ...secondContent];
    else
      return [{
        type: "text",
        text: firstContent
      }, ...secondContent];
  } else if (Array.isArray(secondContent))
    return _mergeLists(firstContent, secondContent) ?? [...firstContent, ...secondContent];
  else if (secondContent === "")
    return firstContent;
  else if (Array.isArray(firstContent) && firstContent.some((c) => isDataContentBlock(c)))
    return [...firstContent, {
      type: "file",
      source_type: "text",
      text: secondContent
    }];
  else
    return [...firstContent, {
      type: "text",
      text: secondContent
    }];
}
function _mergeStatus(left, right) {
  if (left === "error" || right === "error")
    return "error";
  return "success";
}
function stringifyWithDepthLimit(obj, depthLimit) {
  function helper(obj$1, currentDepth) {
    if (typeof obj$1 !== "object" || obj$1 === null || obj$1 === undefined)
      return obj$1;
    if (currentDepth >= depthLimit) {
      if (Array.isArray(obj$1))
        return "[Array]";
      return "[Object]";
    }
    if (Array.isArray(obj$1))
      return obj$1.map((item) => helper(item, currentDepth + 1));
    const result = {};
    for (const key of Object.keys(obj$1))
      result[key] = helper(obj$1[key], currentDepth + 1);
    return result;
  }
  return JSON.stringify(helper(obj, 0), null, 2);
}
var BaseMessage = class extends Serializable {
  lc_namespace = ["langchain_core", "messages"];
  lc_serializable = true;
  get lc_aliases() {
    return {
      additional_kwargs: "additional_kwargs",
      response_metadata: "response_metadata"
    };
  }
  [MESSAGE_SYMBOL] = true;
  id;
  name;
  content;
  additional_kwargs;
  response_metadata;
  _getType() {
    return this.type;
  }
  getType() {
    return this._getType();
  }
  constructor(arg) {
    const fields = typeof arg === "string" || Array.isArray(arg) ? { content: arg } : arg;
    if (!fields.additional_kwargs)
      fields.additional_kwargs = {};
    if (!fields.response_metadata)
      fields.response_metadata = {};
    super(fields);
    this.name = fields.name;
    if (fields.content === undefined && fields.contentBlocks !== undefined) {
      this.content = fields.contentBlocks;
      this.response_metadata = {
        output_version: "v1",
        ...fields.response_metadata
      };
    } else if (fields.content !== undefined) {
      this.content = fields.content ?? [];
      this.response_metadata = fields.response_metadata;
    } else {
      this.content = [];
      this.response_metadata = fields.response_metadata;
    }
    this.additional_kwargs = fields.additional_kwargs;
    this.id = fields.id;
  }
  get text() {
    if (typeof this.content === "string")
      return this.content;
    if (!Array.isArray(this.content))
      return "";
    return this.content.map((c) => {
      if (typeof c === "string")
        return c;
      if (c.type === "text")
        return c.text;
      return "";
    }).join("");
  }
  get contentBlocks() {
    const blocks = typeof this.content === "string" ? [{
      type: "text",
      text: this.content
    }] : this.content;
    const parsingSteps = [
      convertToV1FromDataContent,
      convertToV1FromChatCompletionsInput,
      convertToV1FromAnthropicInput
    ];
    const parsedBlocks = parsingSteps.reduce((blocks$1, step) => step(blocks$1), blocks);
    return parsedBlocks;
  }
  toDict() {
    return {
      type: this.getType(),
      data: this.toJSON().kwargs
    };
  }
  static lc_name() {
    return "BaseMessage";
  }
  get _printableFields() {
    return {
      id: this.id,
      content: this.content,
      name: this.name,
      additional_kwargs: this.additional_kwargs,
      response_metadata: this.response_metadata
    };
  }
  static isInstance(obj) {
    return typeof obj === "object" && obj !== null && MESSAGE_SYMBOL in obj && obj[MESSAGE_SYMBOL] === true && isMessage(obj);
  }
  _updateId(value) {
    this.id = value;
    this.lc_kwargs.id = value;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.lc_name();
  }
  [Symbol.for("nodejs.util.inspect.custom")](depth) {
    if (depth === null)
      return this;
    const printable = stringifyWithDepthLimit(this._printableFields, Math.max(4, depth));
    return `${this.constructor.lc_name()} ${printable}`;
  }
  toFormattedString(format = "pretty") {
    return convertToFormattedString(this, format);
  }
};
function _mergeDicts(left = {}, right = {}) {
  const merged = { ...left };
  for (const [key, value] of Object.entries(right))
    if (merged[key] == null)
      merged[key] = value;
    else if (value == null)
      continue;
    else if (typeof merged[key] !== typeof value || Array.isArray(merged[key]) !== Array.isArray(value))
      throw new Error(`field[${key}] already exists in the message chunk, but with a different type.`);
    else if (typeof merged[key] === "string")
      if (key === "type")
        continue;
      else if ([
        "id",
        "name",
        "output_version",
        "model_provider"
      ].includes(key)) {
        if (value)
          merged[key] = value;
      } else
        merged[key] += value;
    else if (typeof merged[key] === "object" && !Array.isArray(merged[key]))
      merged[key] = _mergeDicts(merged[key], value);
    else if (Array.isArray(merged[key]))
      merged[key] = _mergeLists(merged[key], value);
    else if (merged[key] === value)
      continue;
    else
      console.warn(`field[${key}] already exists in this message chunk and value has unsupported type.`);
  return merged;
}
function _mergeLists(left, right) {
  if (left === undefined && right === undefined)
    return;
  else if (left === undefined || right === undefined)
    return left || right;
  else {
    const merged = [...left];
    for (const item of right)
      if (typeof item === "object" && item !== null && "index" in item && typeof item.index === "number") {
        const toMerge = merged.findIndex((leftItem) => {
          const isObject = typeof leftItem === "object";
          const indiciesMatch = "index" in leftItem && leftItem.index === item.index;
          const idsMatch = "id" in leftItem && "id" in item && leftItem?.id === item?.id;
          const eitherItemMissingID = !("id" in leftItem) || !leftItem?.id || !("id" in item) || !item?.id;
          return isObject && indiciesMatch && (idsMatch || eitherItemMissingID);
        });
        if (toMerge !== -1 && typeof merged[toMerge] === "object" && merged[toMerge] !== null)
          merged[toMerge] = _mergeDicts(merged[toMerge], item);
        else
          merged.push(item);
      } else if (typeof item === "object" && item !== null && "text" in item && item.text === "")
        continue;
      else
        merged.push(item);
    return merged;
  }
}
function _mergeObj(left, right) {
  if (!left && !right)
    throw new Error("Cannot merge two undefined objects.");
  if (!left || !right)
    return left || right;
  else if (typeof left !== typeof right)
    throw new Error(`Cannot merge objects of different types.
Left ${typeof left}
Right ${typeof right}`);
  else if (typeof left === "string" && typeof right === "string")
    return left + right;
  else if (Array.isArray(left) && Array.isArray(right))
    return _mergeLists(left, right);
  else if (typeof left === "object" && typeof right === "object")
    return _mergeDicts(left, right);
  else if (left === right)
    return left;
  else
    throw new Error(`Can not merge objects of different types.
Left ${left}
Right ${right}`);
}
var BaseMessageChunk = class BaseMessageChunk2 extends BaseMessage {
  static isInstance(obj) {
    if (!super.isInstance(obj))
      return false;
    let proto = Object.getPrototypeOf(obj);
    while (proto !== null) {
      if (proto === BaseMessageChunk2.prototype)
        return true;
      proto = Object.getPrototypeOf(proto);
    }
    return false;
  }
};

// node_modules/@langchain/core/dist/messages/tool.js
var tool_exports = {};
__export2(tool_exports, {
  ToolMessage: () => ToolMessage,
  ToolMessageChunk: () => ToolMessageChunk,
  defaultToolCallParser: () => defaultToolCallParser,
  isDirectToolOutput: () => isDirectToolOutput,
  isToolMessage: () => isToolMessage,
  isToolMessageChunk: () => isToolMessageChunk
});
function isDirectToolOutput(x) {
  return x != null && typeof x === "object" && "lc_direct_tool_output" in x && x.lc_direct_tool_output === true;
}
var ToolMessage = class extends BaseMessage {
  static lc_name() {
    return "ToolMessage";
  }
  get lc_aliases() {
    return { tool_call_id: "tool_call_id" };
  }
  lc_direct_tool_output = true;
  type = "tool";
  status;
  tool_call_id;
  metadata;
  artifact;
  constructor(fields, tool_call_id, name) {
    const toolMessageFields = typeof fields === "string" || Array.isArray(fields) ? {
      content: fields,
      name,
      tool_call_id
    } : fields;
    super(toolMessageFields);
    this.tool_call_id = toolMessageFields.tool_call_id;
    this.artifact = toolMessageFields.artifact;
    this.status = toolMessageFields.status;
    this.metadata = toolMessageFields.metadata;
  }
  static isInstance(message) {
    return super.isInstance(message) && message.type === "tool";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_call_id: this.tool_call_id,
      artifact: this.artifact
    };
  }
};
var ToolMessageChunk = class extends BaseMessageChunk {
  type = "tool";
  tool_call_id;
  status;
  artifact;
  constructor(fields) {
    super(fields);
    this.tool_call_id = fields.tool_call_id;
    this.artifact = fields.artifact;
    this.status = fields.status;
  }
  static lc_name() {
    return "ToolMessageChunk";
  }
  concat(chunk) {
    const Cls = this.constructor;
    return new Cls({
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
      artifact: _mergeObj(this.artifact, chunk.artifact),
      tool_call_id: this.tool_call_id,
      id: this.id ?? chunk.id,
      status: _mergeStatus(this.status, chunk.status)
    });
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_call_id: this.tool_call_id,
      artifact: this.artifact
    };
  }
};
function defaultToolCallParser(rawToolCalls) {
  const toolCalls = [];
  const invalidToolCalls = [];
  for (const toolCall of rawToolCalls)
    if (!toolCall.function)
      continue;
    else {
      const functionName = toolCall.function.name;
      try {
        const functionArgs = JSON.parse(toolCall.function.arguments);
        toolCalls.push({
          name: functionName || "",
          args: functionArgs || {},
          id: toolCall.id
        });
      } catch {
        invalidToolCalls.push({
          name: functionName,
          args: toolCall.function.arguments,
          id: toolCall.id,
          error: "Malformed args."
        });
      }
    }
  return [toolCalls, invalidToolCalls];
}
function isToolMessage(x) {
  return typeof x === "object" && x !== null && "getType" in x && typeof x.getType === "function" && x.getType() === "tool";
}
function isToolMessageChunk(x) {
  return x._getType() === "tool";
}

// node_modules/@langchain/core/dist/utils/json.js
function strictParsePartialJson(s) {
  try {
    return JSON.parse(s);
  } catch {}
  const buffer = s.trim();
  if (buffer.length === 0)
    throw new Error("Unexpected end of JSON input");
  let pos = 0;
  function skipWhitespace() {
    while (pos < buffer.length && /\s/.test(buffer[pos]))
      pos += 1;
  }
  function parseString() {
    if (buffer[pos] !== '"')
      throw new Error(`Expected '"' at position ${pos}, got '${buffer[pos]}'`);
    pos += 1;
    let result = "";
    let escaped = false;
    while (pos < buffer.length) {
      const char = buffer[pos];
      if (escaped) {
        if (char === "n")
          result += `
`;
        else if (char === "t")
          result += "\t";
        else if (char === "r")
          result += "\r";
        else if (char === "\\")
          result += "\\";
        else if (char === '"')
          result += '"';
        else if (char === "b")
          result += "\b";
        else if (char === "f")
          result += "\f";
        else if (char === "/")
          result += "/";
        else if (char === "u") {
          const hex = buffer.substring(pos + 1, pos + 5);
          if (/^[0-9A-Fa-f]{0,4}$/.test(hex)) {
            if (hex.length === 4)
              result += String.fromCharCode(Number.parseInt(hex, 16));
            else
              result += `u${hex}`;
            pos += hex.length;
          } else
            throw new Error(`Invalid unicode escape sequence '\\u${hex}' at position ${pos}`);
        } else
          throw new Error(`Invalid escape sequence '\\${char}' at position ${pos}`);
        escaped = false;
      } else if (char === "\\")
        escaped = true;
      else if (char === '"') {
        pos += 1;
        return result;
      } else
        result += char;
      pos += 1;
    }
    if (escaped)
      result += "\\";
    return result;
  }
  function parseNumber() {
    const start = pos;
    let numStr = "";
    if (buffer[pos] === "-") {
      numStr += "-";
      pos += 1;
    }
    if (pos < buffer.length && buffer[pos] === "0") {
      numStr += "0";
      pos += 1;
      if (buffer[pos] >= "0" && buffer[pos] <= "9")
        throw new Error(`Invalid number at position ${start}`);
    }
    if (pos < buffer.length && buffer[pos] >= "1" && buffer[pos] <= "9")
      while (pos < buffer.length && buffer[pos] >= "0" && buffer[pos] <= "9") {
        numStr += buffer[pos];
        pos += 1;
      }
    if (pos < buffer.length && buffer[pos] === ".") {
      numStr += ".";
      pos += 1;
      while (pos < buffer.length && buffer[pos] >= "0" && buffer[pos] <= "9") {
        numStr += buffer[pos];
        pos += 1;
      }
    }
    if (pos < buffer.length && (buffer[pos] === "e" || buffer[pos] === "E")) {
      numStr += buffer[pos];
      pos += 1;
      if (pos < buffer.length && (buffer[pos] === "+" || buffer[pos] === "-")) {
        numStr += buffer[pos];
        pos += 1;
      }
      while (pos < buffer.length && buffer[pos] >= "0" && buffer[pos] <= "9") {
        numStr += buffer[pos];
        pos += 1;
      }
    }
    if (numStr === "-")
      return -0;
    const num = Number.parseFloat(numStr);
    if (Number.isNaN(num)) {
      pos = start;
      throw new Error(`Invalid number '${numStr}' at position ${start}`);
    }
    return num;
  }
  function parseValue() {
    skipWhitespace();
    if (pos >= buffer.length)
      throw new Error(`Unexpected end of input at position ${pos}`);
    const char = buffer[pos];
    if (char === "{")
      return parseObject();
    if (char === "[")
      return parseArray();
    if (char === '"')
      return parseString();
    if ("null".startsWith(buffer.substring(pos, pos + 4))) {
      pos += Math.min(4, buffer.length - pos);
      return null;
    }
    if ("true".startsWith(buffer.substring(pos, pos + 4))) {
      pos += Math.min(4, buffer.length - pos);
      return true;
    }
    if ("false".startsWith(buffer.substring(pos, pos + 5))) {
      pos += Math.min(5, buffer.length - pos);
      return false;
    }
    if (char === "-" || char >= "0" && char <= "9")
      return parseNumber();
    throw new Error(`Unexpected character '${char}' at position ${pos}`);
  }
  function parseArray() {
    if (buffer[pos] !== "[")
      throw new Error(`Expected '[' at position ${pos}, got '${buffer[pos]}'`);
    const arr = [];
    pos += 1;
    skipWhitespace();
    if (pos >= buffer.length)
      return arr;
    if (buffer[pos] === "]") {
      pos += 1;
      return arr;
    }
    while (pos < buffer.length) {
      skipWhitespace();
      if (pos >= buffer.length)
        return arr;
      arr.push(parseValue());
      skipWhitespace();
      if (pos >= buffer.length)
        return arr;
      if (buffer[pos] === "]") {
        pos += 1;
        return arr;
      } else if (buffer[pos] === ",") {
        pos += 1;
        continue;
      }
      throw new Error(`Expected ',' or ']' at position ${pos}, got '${buffer[pos]}'`);
    }
    return arr;
  }
  function parseObject() {
    if (buffer[pos] !== "{")
      throw new Error(`Expected '{' at position ${pos}, got '${buffer[pos]}'`);
    const obj = {};
    pos += 1;
    skipWhitespace();
    if (pos >= buffer.length)
      return obj;
    if (buffer[pos] === "}") {
      pos += 1;
      return obj;
    }
    while (pos < buffer.length) {
      skipWhitespace();
      if (pos >= buffer.length)
        return obj;
      const key = parseString();
      skipWhitespace();
      if (pos >= buffer.length)
        return obj;
      if (buffer[pos] !== ":")
        throw new Error(`Expected ':' at position ${pos}, got '${buffer[pos]}'`);
      pos += 1;
      skipWhitespace();
      if (pos >= buffer.length)
        return obj;
      obj[key] = parseValue();
      skipWhitespace();
      if (pos >= buffer.length)
        return obj;
      if (buffer[pos] === "}") {
        pos += 1;
        return obj;
      } else if (buffer[pos] === ",") {
        pos += 1;
        continue;
      }
      throw new Error(`Expected ',' or '}' at position ${pos}, got '${buffer[pos]}'`);
    }
    return obj;
  }
  const value = parseValue();
  skipWhitespace();
  if (pos < buffer.length)
    throw new Error(`Unexpected character '${buffer[pos]}' at position ${pos}`);
  return value;
}
function parsePartialJson(s) {
  try {
    if (typeof s === "undefined")
      return null;
    return strictParsePartialJson(s);
  } catch {
    return null;
  }
}

// node_modules/@langchain/core/dist/messages/block_translators/bedrock_converse.js
function convertFileFormatToMimeType(format) {
  switch (format) {
    case "csv":
      return "text/csv";
    case "doc":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "docx":
      return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "html":
      return "text/html";
    case "md":
      return "text/markdown";
    case "pdf":
      return "application/pdf";
    case "txt":
      return "text/plain";
    case "xls":
      return "application/vnd.ms-excel";
    case "xlsx":
      return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    case "gif":
      return "image/gif";
    case "jpeg":
      return "image/jpeg";
    case "jpg":
      return "image/jpeg";
    case "png":
      return "image/png";
    case "webp":
      return "image/webp";
    case "flv":
      return "video/flv";
    case "mkv":
      return "video/mkv";
    case "mov":
      return "video/mov";
    case "mp4":
      return "video/mp4";
    case "mpeg":
      return "video/mpeg";
    case "mpg":
      return "video/mpg";
    case "three_gp":
      return "video/three_gp";
    case "webm":
      return "video/webm";
    case "wmv":
      return "video/wmv";
    default:
      return "application/octet-stream";
  }
}
function convertConverseDocumentBlock(block) {
  if (_isObject(block.document) && _isObject(block.document.source)) {
    const format = _isObject(block.document) && _isString(block.document.format) ? block.document.format : "";
    const mimeType = convertFileFormatToMimeType(format);
    if (_isObject(block.document.source)) {
      if (_isObject(block.document.source.s3Location) && _isString(block.document.source.s3Location.uri))
        return {
          type: "file",
          mimeType,
          fileId: block.document.source.s3Location.uri
        };
      if (_isBytesArray(block.document.source.bytes))
        return {
          type: "file",
          mimeType,
          data: block.document.source.bytes
        };
      if (_isString(block.document.source.text))
        return {
          type: "file",
          mimeType,
          data: Buffer.from(block.document.source.text).toString("base64")
        };
      if (_isArray(block.document.source.content)) {
        const data = block.document.source.content.reduce((acc, item) => {
          if (_isObject(item) && _isString(item.text))
            return acc + item.text;
          return acc;
        }, "");
        return {
          type: "file",
          mimeType,
          data
        };
      }
    }
  }
  return {
    type: "non_standard",
    value: block
  };
}
function convertConverseImageBlock(block) {
  if (_isContentBlock(block, "image") && _isObject(block.image)) {
    const format = _isObject(block.image) && _isString(block.image.format) ? block.image.format : "";
    const mimeType = convertFileFormatToMimeType(format);
    if (_isObject(block.image.source)) {
      if (_isObject(block.image.source.s3Location) && _isString(block.image.source.s3Location.uri))
        return {
          type: "image",
          mimeType,
          fileId: block.image.source.s3Location.uri
        };
      if (_isBytesArray(block.image.source.bytes))
        return {
          type: "image",
          mimeType,
          data: block.image.source.bytes
        };
    }
  }
  return {
    type: "non_standard",
    value: block
  };
}
function convertConverseVideoBlock(block) {
  if (_isContentBlock(block, "video") && _isObject(block.video)) {
    const format = _isObject(block.video) && _isString(block.video.format) ? block.video.format : "";
    const mimeType = convertFileFormatToMimeType(format);
    if (_isObject(block.video.source)) {
      if (_isObject(block.video.source.s3Location) && _isString(block.video.source.s3Location.uri))
        return {
          type: "video",
          mimeType,
          fileId: block.video.source.s3Location.uri
        };
      if (_isBytesArray(block.video.source.bytes))
        return {
          type: "video",
          mimeType,
          data: block.video.source.bytes
        };
    }
  }
  return {
    type: "non_standard",
    value: block
  };
}
function convertToV1FromChatBedrockConverseMessage(message) {
  function* iterateContent() {
    const content = typeof message.content === "string" ? [{
      type: "text",
      text: message.content
    }] : message.content;
    for (const block of content) {
      if (_isContentBlock(block, "cache_point")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "citations_content") && _isObject(block.citationsContent)) {
        const text = _isArray(block.citationsContent.content) ? block.citationsContent.content.reduce((acc, item) => {
          if (_isObject(item) && _isString(item.text))
            return acc + item.text;
          return acc;
        }, "") : "";
        const annotations = _isArray(block.citationsContent.citations) ? block.citationsContent.citations.reduce((acc, item) => {
          if (_isObject(item)) {
            const citedText = _isArray(item.sourceContent) ? item.sourceContent.reduce((acc$1, item$1) => {
              if (_isObject(item$1) && _isString(item$1.text))
                return acc$1 + item$1.text;
              return acc$1;
            }, "") : "";
            const properties = iife(() => {
              if (_isObject(item.location)) {
                const location2 = item.location.documentChar || item.location.documentPage || item.location.documentChunk;
                if (_isObject(location2))
                  return {
                    source: _isNumber(location2.documentIndex) ? location2.documentIndex.toString() : undefined,
                    startIndex: _isNumber(location2.start) ? location2.start : undefined,
                    endIndex: _isNumber(location2.end) ? location2.end : undefined
                  };
              }
              return {};
            });
            acc.push({
              type: "citation",
              citedText,
              ...properties
            });
          }
          return acc;
        }, []) : [];
        yield {
          type: "text",
          text,
          annotations
        };
        continue;
      } else if (_isContentBlock(block, "document") && _isObject(block.document)) {
        yield convertConverseDocumentBlock(block);
        continue;
      } else if (_isContentBlock(block, "guard_content")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "image") && _isObject(block.image)) {
        yield convertConverseImageBlock(block);
        continue;
      } else if (_isContentBlock(block, "reasoning_content") && _isString(block.reasoningText)) {
        yield {
          type: "reasoning",
          reasoning: block.reasoningText
        };
        continue;
      } else if (_isContentBlock(block, "text") && _isString(block.text)) {
        yield {
          type: "text",
          text: block.text
        };
        continue;
      } else if (_isContentBlock(block, "tool_result")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "tool_call"))
        continue;
      else if (_isContentBlock(block, "video") && _isObject(block.video)) {
        yield convertConverseVideoBlock(block);
        continue;
      }
      yield {
        type: "non_standard",
        value: block
      };
    }
  }
  return Array.from(iterateContent());
}
var ChatBedrockConverseTranslator = {
  translateContent: convertToV1FromChatBedrockConverseMessage,
  translateContentChunk: convertToV1FromChatBedrockConverseMessage
};

// node_modules/@langchain/core/dist/messages/block_translators/google_genai.js
function convertToV1FromChatGoogleMessage(message) {
  function* iterateContent() {
    const content = typeof message.content === "string" ? [{
      type: "text",
      text: message.content
    }] : message.content;
    for (const block of content) {
      if (_isContentBlock(block, "text") && _isString(block.text)) {
        yield {
          type: "text",
          text: block.text
        };
        continue;
      } else if (_isContentBlock(block, "inlineData") && _isObject(block.inlineData) && _isString(block.inlineData.mimeType) && _isString(block.inlineData.data)) {
        yield {
          type: "file",
          mimeType: block.inlineData.mimeType,
          data: block.inlineData.data
        };
        continue;
      } else if (_isContentBlock(block, "functionCall") && _isObject(block.functionCall) && _isString(block.functionCall.name) && _isObject(block.functionCall.args)) {
        yield {
          type: "tool_call",
          id: message.id,
          name: block.functionCall.name,
          args: block.functionCall.args
        };
        continue;
      } else if (_isContentBlock(block, "functionResponse")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "fileData") && _isObject(block.fileData) && _isString(block.fileData.mimeType) && _isString(block.fileData.fileUri)) {
        yield {
          type: "file",
          mimeType: block.fileData.mimeType,
          fileId: block.fileData.fileUri
        };
        continue;
      } else if (_isContentBlock(block, "executableCode")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      } else if (_isContentBlock(block, "codeExecutionResult")) {
        yield {
          type: "non_standard",
          value: block
        };
        continue;
      }
      yield {
        type: "non_standard",
        value: block
      };
    }
  }
  return Array.from(iterateContent());
}
var ChatGoogleGenAITranslator = {
  translateContent: convertToV1FromChatGoogleMessage,
  translateContentChunk: convertToV1FromChatGoogleMessage
};

// node_modules/@langchain/core/dist/messages/block_translators/google_vertexai.js
function convertToV1FromChatVertexMessage(message) {
  function* iterateContent() {
    const content = typeof message.content === "string" ? [{
      type: "text",
      text: message.content
    }] : message.content;
    for (const block of content) {
      if (_isContentBlock(block, "reasoning") && _isString(block.reasoning)) {
        const signature = iife(() => {
          const reasoningIndex = content.indexOf(block);
          if (_isArray(message.additional_kwargs?.signatures) && reasoningIndex >= 0)
            return message.additional_kwargs.signatures.at(reasoningIndex);
          return;
        });
        if (_isString(signature))
          yield {
            type: "reasoning",
            reasoning: block.reasoning,
            signature
          };
        else
          yield {
            type: "reasoning",
            reasoning: block.reasoning
          };
        continue;
      } else if (_isContentBlock(block, "text") && _isString(block.text)) {
        yield {
          type: "text",
          text: block.text
        };
        continue;
      } else if (_isContentBlock(block, "image_url")) {
        if (_isString(block.image_url))
          if (block.image_url.startsWith("data:")) {
            const dataUrlRegex = /^data:([^;]+);base64,(.+)$/;
            const match = block.image_url.match(dataUrlRegex);
            if (match)
              yield {
                type: "image",
                data: match[2],
                mimeType: match[1]
              };
            else
              yield {
                type: "image",
                url: block.image_url
              };
          } else
            yield {
              type: "image",
              url: block.image_url
            };
        continue;
      } else if (_isContentBlock(block, "media") && _isString(block.mimeType) && _isString(block.data)) {
        yield {
          type: "file",
          mimeType: block.mimeType,
          data: block.data
        };
        continue;
      }
      yield {
        type: "non_standard",
        value: block
      };
    }
  }
  return Array.from(iterateContent());
}
var ChatVertexTranslator = {
  translateContent: convertToV1FromChatVertexMessage,
  translateContentChunk: convertToV1FromChatVertexMessage
};

// node_modules/@langchain/core/dist/messages/block_translators/index.js
globalThis.lc_block_translators_registry ??= new Map([
  ["anthropic", ChatAnthropicTranslator],
  ["bedrock-converse", ChatBedrockConverseTranslator],
  ["google-genai", ChatGoogleGenAITranslator],
  ["google-vertexai", ChatVertexTranslator],
  ["openai", ChatOpenAITranslator]
]);
function getTranslator(modelProvider) {
  return globalThis.lc_block_translators_registry.get(modelProvider);
}

// node_modules/@langchain/core/dist/messages/metadata.js
function mergeResponseMetadata(a, b) {
  const output = _mergeDicts(a ?? {}, b ?? {});
  return output;
}
function mergeModalitiesTokenDetails(a, b) {
  const output = {};
  if (a?.audio !== undefined || b?.audio !== undefined)
    output.audio = (a?.audio ?? 0) + (b?.audio ?? 0);
  if (a?.image !== undefined || b?.image !== undefined)
    output.image = (a?.image ?? 0) + (b?.image ?? 0);
  if (a?.video !== undefined || b?.video !== undefined)
    output.video = (a?.video ?? 0) + (b?.video ?? 0);
  if (a?.document !== undefined || b?.document !== undefined)
    output.document = (a?.document ?? 0) + (b?.document ?? 0);
  if (a?.text !== undefined || b?.text !== undefined)
    output.text = (a?.text ?? 0) + (b?.text ?? 0);
  return output;
}
function mergeInputTokenDetails(a, b) {
  const output = { ...mergeModalitiesTokenDetails(a, b) };
  if (a?.cache_read !== undefined || b?.cache_read !== undefined)
    output.cache_read = (a?.cache_read ?? 0) + (b?.cache_read ?? 0);
  if (a?.cache_creation !== undefined || b?.cache_creation !== undefined)
    output.cache_creation = (a?.cache_creation ?? 0) + (b?.cache_creation ?? 0);
  return output;
}
function mergeOutputTokenDetails(a, b) {
  const output = { ...mergeModalitiesTokenDetails(a, b) };
  if (a?.reasoning !== undefined || b?.reasoning !== undefined)
    output.reasoning = (a?.reasoning ?? 0) + (b?.reasoning ?? 0);
  return output;
}
function mergeUsageMetadata(a, b) {
  return {
    input_tokens: (a?.input_tokens ?? 0) + (b?.input_tokens ?? 0),
    output_tokens: (a?.output_tokens ?? 0) + (b?.output_tokens ?? 0),
    total_tokens: (a?.total_tokens ?? 0) + (b?.total_tokens ?? 0),
    input_token_details: mergeInputTokenDetails(a?.input_token_details, b?.input_token_details),
    output_token_details: mergeOutputTokenDetails(a?.output_token_details, b?.output_token_details)
  };
}

// node_modules/@langchain/core/dist/messages/ai.js
var AIMessageChunk = class extends BaseMessageChunk {
  type = "ai";
  tool_calls = [];
  invalid_tool_calls = [];
  tool_call_chunks = [];
  usage_metadata;
  constructor(fields) {
    let initParams;
    if (typeof fields === "string" || Array.isArray(fields))
      initParams = {
        content: fields,
        tool_calls: [],
        invalid_tool_calls: [],
        tool_call_chunks: []
      };
    else if (fields.tool_call_chunks === undefined || fields.tool_call_chunks.length === 0)
      initParams = {
        ...fields,
        tool_calls: fields.tool_calls ?? [],
        invalid_tool_calls: [],
        tool_call_chunks: [],
        usage_metadata: fields.usage_metadata !== undefined ? fields.usage_metadata : undefined
      };
    else
      initParams = {
        ...fields,
        ...collapseToolCallChunks(fields.tool_call_chunks ?? []),
        usage_metadata: fields.usage_metadata !== undefined ? fields.usage_metadata : undefined
      };
    super(initParams);
    this.tool_call_chunks = initParams.tool_call_chunks ?? this.tool_call_chunks;
    this.tool_calls = initParams.tool_calls ?? this.tool_calls;
    this.invalid_tool_calls = initParams.invalid_tool_calls ?? this.invalid_tool_calls;
    this.usage_metadata = initParams.usage_metadata;
  }
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      tool_calls: "tool_calls",
      invalid_tool_calls: "invalid_tool_calls",
      tool_call_chunks: "tool_call_chunks"
    };
  }
  static lc_name() {
    return "AIMessageChunk";
  }
  get contentBlocks() {
    if (this.response_metadata && "output_version" in this.response_metadata && this.response_metadata.output_version === "v1")
      return this.content;
    if (this.response_metadata && "model_provider" in this.response_metadata && typeof this.response_metadata.model_provider === "string") {
      const translator = getTranslator(this.response_metadata.model_provider);
      if (translator)
        return translator.translateContent(this);
    }
    const blocks = super.contentBlocks;
    if (this.tool_calls) {
      if (typeof this.content !== "string") {
        const contentToolCalls = this.content.filter((block) => block.type === "tool_call").map((block) => block.id);
        for (const toolCall of this.tool_calls)
          if (toolCall.id && !contentToolCalls.includes(toolCall.id))
            blocks.push({
              ...toolCall,
              type: "tool_call",
              id: toolCall.id,
              name: toolCall.name,
              args: toolCall.args
            });
      }
    }
    return blocks;
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_calls: this.tool_calls,
      tool_call_chunks: this.tool_call_chunks,
      invalid_tool_calls: this.invalid_tool_calls,
      usage_metadata: this.usage_metadata
    };
  }
  concat(chunk) {
    const combinedFields = {
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
      response_metadata: mergeResponseMetadata(this.response_metadata, chunk.response_metadata),
      tool_call_chunks: [],
      id: this.id ?? chunk.id
    };
    if (this.tool_call_chunks !== undefined || chunk.tool_call_chunks !== undefined) {
      const rawToolCalls = _mergeLists(this.tool_call_chunks, chunk.tool_call_chunks);
      if (rawToolCalls !== undefined && rawToolCalls.length > 0)
        combinedFields.tool_call_chunks = rawToolCalls;
    }
    if (this.usage_metadata !== undefined || chunk.usage_metadata !== undefined)
      combinedFields.usage_metadata = mergeUsageMetadata(this.usage_metadata, chunk.usage_metadata);
    const Cls = this.constructor;
    return new Cls(combinedFields);
  }
  static isInstance(obj) {
    return super.isInstance(obj) && obj.type === "ai";
  }
};

// node_modules/@langchain/core/dist/messages/utils.js
function getBufferString(messages, humanPrefix = "Human", aiPrefix = "AI") {
  const string_messages = [];
  for (const m of messages) {
    let role;
    if (m._getType() === "human")
      role = humanPrefix;
    else if (m._getType() === "ai")
      role = aiPrefix;
    else if (m._getType() === "system")
      role = "System";
    else if (m._getType() === "tool")
      role = "Tool";
    else if (m._getType() === "generic")
      role = m.role;
    else
      throw new Error(`Got unsupported message type: ${m._getType()}`);
    const nameStr = m.name ? `${m.name}, ` : "";
    const readableContent = typeof m.content === "string" ? m.content : JSON.stringify(m.content, null, 2);
    string_messages.push(`${role}: ${nameStr}${readableContent}`);
  }
  return string_messages.join(`
`);
}
function collapseToolCallChunks(chunks) {
  const groupedToolCallChunks = chunks.reduce((acc, chunk) => {
    const matchedChunkIndex = acc.findIndex(([match]) => {
      if ("id" in chunk && chunk.id && "index" in chunk && chunk.index !== undefined)
        return chunk.id === match.id && chunk.index === match.index;
      if ("id" in chunk && chunk.id)
        return chunk.id === match.id;
      if ("index" in chunk && chunk.index !== undefined)
        return chunk.index === match.index;
      return false;
    });
    if (matchedChunkIndex !== -1)
      acc[matchedChunkIndex].push(chunk);
    else
      acc.push([chunk]);
    return acc;
  }, []);
  const toolCalls = [];
  const invalidToolCalls = [];
  for (const chunks$1 of groupedToolCallChunks) {
    let parsedArgs = null;
    const name = chunks$1[0]?.name ?? "";
    const joinedArgs = chunks$1.map((c) => c.args || "").join("").trim();
    const argsStr = joinedArgs.length ? joinedArgs : "{}";
    const id = chunks$1[0]?.id;
    try {
      parsedArgs = parsePartialJson(argsStr);
      if (!id || parsedArgs === null || typeof parsedArgs !== "object" || Array.isArray(parsedArgs))
        throw new Error("Malformed tool call chunk args.");
      toolCalls.push({
        name,
        args: parsedArgs,
        id,
        type: "tool_call"
      });
    } catch {
      invalidToolCalls.push({
        name,
        args: argsStr,
        id,
        error: "Malformed args.",
        type: "invalid_tool_call"
      });
    }
  }
  return {
    tool_call_chunks: chunks,
    tool_calls: toolCalls,
    invalid_tool_calls: invalidToolCalls
  };
}

// node_modules/@langchain/core/dist/utils/env.js
var env_exports = {};
__export2(env_exports, {
  getEnv: () => getEnv,
  getEnvironmentVariable: () => getEnvironmentVariable,
  getRuntimeEnvironment: () => getRuntimeEnvironment,
  isBrowser: () => isBrowser,
  isDeno: () => isDeno,
  isJsDom: () => isJsDom,
  isNode: () => isNode,
  isWebWorker: () => isWebWorker
});
var isBrowser = () => typeof window !== "undefined" && typeof window.document !== "undefined";
var isWebWorker = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
var isJsDom = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && navigator.userAgent.includes("jsdom");
var isDeno = () => typeof Deno !== "undefined";
var isNode = () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !isDeno();
var getEnv = () => {
  let env;
  if (isBrowser())
    env = "browser";
  else if (isNode())
    env = "node";
  else if (isWebWorker())
    env = "webworker";
  else if (isJsDom())
    env = "jsdom";
  else if (isDeno())
    env = "deno";
  else
    env = "other";
  return env;
};
var runtimeEnvironment;
function getRuntimeEnvironment() {
  if (runtimeEnvironment === undefined) {
    const env = getEnv();
    runtimeEnvironment = {
      library: "langchain-js",
      runtime: env
    };
  }
  return runtimeEnvironment;
}
function getEnvironmentVariable(name) {
  try {
    if (typeof process !== "undefined")
      return process.env?.[name];
    else if (isDeno())
      return Deno?.env.get(name);
    else
      return;
  } catch {
    return;
  }
}

// node_modules/uuid/wrapper.mjs
var import_dist = __toESM(require_dist(), 1);
var v1 = import_dist.default.v1;
var v1ToV6 = import_dist.default.v1ToV6;
var v3 = import_dist.default.v3;
var v4 = import_dist.default.v4;
var v5 = import_dist.default.v5;
var v6 = import_dist.default.v6;
var v6ToV1 = import_dist.default.v6ToV1;
var v7 = import_dist.default.v7;
var NIL = import_dist.default.NIL;
var MAX = import_dist.default.MAX;
var version = import_dist.default.version;
var validate = import_dist.default.validate;
var stringify = import_dist.default.stringify;
var parse = import_dist.default.parse;

// node_modules/@langchain/core/dist/callbacks/base.js
var base_exports = {};
__export2(base_exports, {
  BaseCallbackHandler: () => BaseCallbackHandler,
  callbackHandlerPrefersStreaming: () => callbackHandlerPrefersStreaming,
  isBaseCallbackHandler: () => isBaseCallbackHandler
});
var BaseCallbackHandlerMethodsClass = class {
};
function callbackHandlerPrefersStreaming(x) {
  return "lc_prefer_streaming" in x && x.lc_prefer_streaming;
}
var BaseCallbackHandler = class extends BaseCallbackHandlerMethodsClass {
  lc_serializable = false;
  get lc_namespace() {
    return [
      "langchain_core",
      "callbacks",
      this.name
    ];
  }
  get lc_secrets() {
    return;
  }
  get lc_attributes() {
    return;
  }
  get lc_aliases() {
    return;
  }
  get lc_serializable_keys() {
    return;
  }
  static lc_name() {
    return this.name;
  }
  get lc_id() {
    return [...this.lc_namespace, get_lc_unique_name(this.constructor)];
  }
  lc_kwargs;
  ignoreLLM = false;
  ignoreChain = false;
  ignoreAgent = false;
  ignoreRetriever = false;
  ignoreCustomEvent = false;
  raiseError = false;
  awaitHandlers = getEnvironmentVariable("LANGCHAIN_CALLBACKS_BACKGROUND") === "false";
  constructor(input) {
    super();
    this.lc_kwargs = input || {};
    if (input) {
      this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;
      this.ignoreChain = input.ignoreChain ?? this.ignoreChain;
      this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;
      this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;
      this.ignoreCustomEvent = input.ignoreCustomEvent ?? this.ignoreCustomEvent;
      this.raiseError = input.raiseError ?? this.raiseError;
      this.awaitHandlers = this.raiseError || (input._awaitHandler ?? this.awaitHandlers);
    }
  }
  copy() {
    return new this.constructor(this);
  }
  toJSON() {
    return Serializable.prototype.toJSON.call(this);
  }
  toJSONNotImplemented() {
    return Serializable.prototype.toJSONNotImplemented.call(this);
  }
  static fromMethods(methods) {

    class Handler extends BaseCallbackHandler {
      name = v7();
      constructor() {
        super();
        Object.assign(this, methods);
      }
    }
    return new Handler;
  }
};
var isBaseCallbackHandler = (x) => {
  const callbackHandler = x;
  return callbackHandler !== undefined && typeof callbackHandler.copy === "function" && typeof callbackHandler.name === "string" && typeof callbackHandler.awaitHandlers === "boolean";
};

// node_modules/langsmith/dist/experimental/otel/constants.js
var GEN_AI_OPERATION_NAME = "gen_ai.operation.name";
var GEN_AI_SYSTEM = "gen_ai.system";
var GEN_AI_REQUEST_MODEL = "gen_ai.request.model";
var GEN_AI_RESPONSE_MODEL = "gen_ai.response.model";
var GEN_AI_USAGE_INPUT_TOKENS = "gen_ai.usage.input_tokens";
var GEN_AI_USAGE_OUTPUT_TOKENS = "gen_ai.usage.output_tokens";
var GEN_AI_USAGE_TOTAL_TOKENS = "gen_ai.usage.total_tokens";
var GEN_AI_REQUEST_MAX_TOKENS = "gen_ai.request.max_tokens";
var GEN_AI_REQUEST_TEMPERATURE = "gen_ai.request.temperature";
var GEN_AI_REQUEST_TOP_P = "gen_ai.request.top_p";
var GEN_AI_REQUEST_FREQUENCY_PENALTY = "gen_ai.request.frequency_penalty";
var GEN_AI_REQUEST_PRESENCE_PENALTY = "gen_ai.request.presence_penalty";
var GEN_AI_RESPONSE_FINISH_REASONS = "gen_ai.response.finish_reasons";
var GENAI_PROMPT = "gen_ai.prompt";
var GENAI_COMPLETION = "gen_ai.completion";
var GEN_AI_REQUEST_EXTRA_QUERY = "gen_ai.request.extra_query";
var GEN_AI_REQUEST_EXTRA_BODY = "gen_ai.request.extra_body";
var GEN_AI_SERIALIZED_NAME = "gen_ai.serialized.name";
var GEN_AI_SERIALIZED_SIGNATURE = "gen_ai.serialized.signature";
var GEN_AI_SERIALIZED_DOC = "gen_ai.serialized.doc";
var GEN_AI_RESPONSE_ID = "gen_ai.response.id";
var GEN_AI_RESPONSE_SERVICE_TIER = "gen_ai.response.service_tier";
var GEN_AI_RESPONSE_SYSTEM_FINGERPRINT = "gen_ai.response.system_fingerprint";
var GEN_AI_USAGE_INPUT_TOKEN_DETAILS = "gen_ai.usage.input_token_details";
var GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS = "gen_ai.usage.output_token_details";
var LANGSMITH_SESSION_ID = "langsmith.trace.session_id";
var LANGSMITH_SESSION_NAME = "langsmith.trace.session_name";
var LANGSMITH_RUN_TYPE = "langsmith.span.kind";
var LANGSMITH_NAME = "langsmith.trace.name";
var LANGSMITH_METADATA = "langsmith.metadata";
var LANGSMITH_TAGS = "langsmith.span.tags";
var LANGSMITH_REQUEST_STREAMING = "langsmith.request.streaming";
var LANGSMITH_REQUEST_HEADERS = "langsmith.request.headers";
// node_modules/langsmith/dist/singletons/fetch.js
var DEFAULT_FETCH_IMPLEMENTATION = (...args) => fetch(...args);
var LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for("ls:fetch_implementation");
var _globalFetchImplementationIsNodeFetch = () => {
  const fetchImpl = globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY];
  if (!fetchImpl)
    return false;
  return typeof fetchImpl === "function" && "Headers" in fetchImpl && "Request" in fetchImpl && "Response" in fetchImpl;
};
var _getFetchImplementation = (debug) => {
  return async (...args) => {
    if (debug || getLangSmithEnvironmentVariable("DEBUG") === "true") {
      const [url, options] = args;
      console.log(`\u2192 ${options?.method || "GET"} ${url}`);
    }
    const res = await (globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ?? DEFAULT_FETCH_IMPLEMENTATION)(...args);
    if (debug || getLangSmithEnvironmentVariable("DEBUG") === "true") {
      console.log(`\u2190 ${res.status} ${res.statusText} ${res.url}`);
    }
    return res;
  };
};
// node_modules/langsmith/dist/utils/project.js
var getDefaultProjectName = () => {
  return getLangSmithEnvironmentVariable("PROJECT") ?? getEnvironmentVariable2("LANGCHAIN_SESSION") ?? "default";
};
// node_modules/langsmith/dist/utils/warn.js
var warnedMessages = {};
function warnOnce(message) {
  if (!warnedMessages[message]) {
    console.warn(message);
    warnedMessages[message] = true;
  }
}

// node_modules/langsmith/dist/utils/_uuid.js
var UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function assertUuid(str, which) {
  if (!UUID_REGEX.test(str)) {
    const msg = which !== undefined ? `Invalid UUID for ${which}: ${str}` : `Invalid UUID: ${str}`;
    throw new Error(msg);
  }
  return str;
}
function uuid7FromTime(timestamp) {
  const msecs = typeof timestamp === "string" ? Date.parse(timestamp) : timestamp;
  return v7({ msecs, seq: 0 });
}
// node_modules/langsmith/dist/index.js
var __version__ = "0.3.87";

// node_modules/langsmith/dist/utils/env.js
var globalEnv;
var isBrowser2 = () => typeof window !== "undefined" && typeof window.document !== "undefined";
var isWebWorker2 = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
var isJsDom2 = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && navigator.userAgent.includes("jsdom");
var isDeno2 = () => typeof Deno !== "undefined";
var isNode2 = () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !isDeno2();
var getEnv2 = () => {
  if (globalEnv) {
    return globalEnv;
  }
  if (typeof Bun !== "undefined") {
    globalEnv = "bun";
  } else if (isBrowser2()) {
    globalEnv = "browser";
  } else if (isNode2()) {
    globalEnv = "node";
  } else if (isWebWorker2()) {
    globalEnv = "webworker";
  } else if (isJsDom2()) {
    globalEnv = "jsdom";
  } else if (isDeno2()) {
    globalEnv = "deno";
  } else {
    globalEnv = "other";
  }
  return globalEnv;
};
var runtimeEnvironment2;
function getRuntimeEnvironment2() {
  if (runtimeEnvironment2 === undefined) {
    const env = getEnv2();
    const releaseEnv = getShas();
    runtimeEnvironment2 = {
      library: "langsmith",
      runtime: env,
      sdk: "langsmith-js",
      sdk_version: __version__,
      ...releaseEnv
    };
  }
  return runtimeEnvironment2;
}
function getLangSmithEnvVarsMetadata() {
  const allEnvVars = getLangSmithEnvironmentVariables();
  const envVars = {};
  const excluded = [
    "LANGCHAIN_API_KEY",
    "LANGCHAIN_ENDPOINT",
    "LANGCHAIN_TRACING_V2",
    "LANGCHAIN_PROJECT",
    "LANGCHAIN_SESSION",
    "LANGSMITH_API_KEY",
    "LANGSMITH_ENDPOINT",
    "LANGSMITH_TRACING_V2",
    "LANGSMITH_PROJECT",
    "LANGSMITH_SESSION"
  ];
  for (const [key, value] of Object.entries(allEnvVars)) {
    if (typeof value === "string" && !excluded.includes(key) && !key.toLowerCase().includes("key") && !key.toLowerCase().includes("secret") && !key.toLowerCase().includes("token")) {
      if (key === "LANGCHAIN_REVISION_ID") {
        envVars["revision_id"] = value;
      } else {
        envVars[key] = value;
      }
    }
  }
  return envVars;
}
function getLangSmithEnvironmentVariables() {
  const envVars = {};
  try {
    if (typeof process !== "undefined" && process.env) {
      for (const [key, value] of Object.entries(process.env)) {
        if ((key.startsWith("LANGCHAIN_") || key.startsWith("LANGSMITH_")) && value != null) {
          if ((key.toLowerCase().includes("key") || key.toLowerCase().includes("secret") || key.toLowerCase().includes("token")) && typeof value === "string") {
            envVars[key] = value.slice(0, 2) + "*".repeat(value.length - 4) + value.slice(-2);
          } else {
            envVars[key] = value;
          }
        }
      }
    }
  } catch (e) {}
  return envVars;
}
function getEnvironmentVariable2(name) {
  try {
    return typeof process !== "undefined" ? process.env?.[name] : undefined;
  } catch (e) {
    return;
  }
}
function getLangSmithEnvironmentVariable(name) {
  return getEnvironmentVariable2(`LANGSMITH_${name}`) || getEnvironmentVariable2(`LANGCHAIN_${name}`);
}
var cachedCommitSHAs;
function getShas() {
  if (cachedCommitSHAs !== undefined) {
    return cachedCommitSHAs;
  }
  const common_release_envs = [
    "VERCEL_GIT_COMMIT_SHA",
    "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
    "COMMIT_REF",
    "RENDER_GIT_COMMIT",
    "CI_COMMIT_SHA",
    "CIRCLE_SHA1",
    "CF_PAGES_COMMIT_SHA",
    "REACT_APP_GIT_SHA",
    "SOURCE_VERSION",
    "GITHUB_SHA",
    "TRAVIS_COMMIT",
    "GIT_COMMIT",
    "BUILD_VCS_NUMBER",
    "bamboo_planRepository_revision",
    "Build.SourceVersion",
    "BITBUCKET_COMMIT",
    "DRONE_COMMIT_SHA",
    "SEMAPHORE_GIT_SHA",
    "BUILDKITE_COMMIT"
  ];
  const shas = {};
  for (const env of common_release_envs) {
    const envVar = getEnvironmentVariable2(env);
    if (envVar !== undefined) {
      shas[env] = envVar;
    }
  }
  cachedCommitSHAs = shas;
  return shas;
}
function getOtelEnabled() {
  return getEnvironmentVariable2("OTEL_ENABLED") === "true" || getLangSmithEnvironmentVariable("OTEL_ENABLED") === "true";
}

// node_modules/langsmith/dist/singletons/otel.js
class MockTracer {
  constructor() {
    Object.defineProperty(this, "hasWarned", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
  }
  startActiveSpan(_name, ...args) {
    if (!this.hasWarned && getOtelEnabled()) {
      console.warn("You have enabled OTEL export via the `OTEL_ENABLED` or `LANGSMITH_OTEL_ENABLED` environment variable, but have not initialized the required OTEL instances. " + 'Please add:\n```\nimport { initializeOTEL } from "langsmith/experimental/otel/setup";\ninitializeOTEL();\n```\nat the beginning of your code.');
      this.hasWarned = true;
    }
    let fn;
    if (args.length === 1 && typeof args[0] === "function") {
      fn = args[0];
    } else if (args.length === 2 && typeof args[1] === "function") {
      fn = args[1];
    } else if (args.length === 3 && typeof args[2] === "function") {
      fn = args[2];
    }
    if (typeof fn === "function") {
      return fn();
    }
    return;
  }
}

class MockOTELTrace {
  constructor() {
    Object.defineProperty(this, "mockTracer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new MockTracer
    });
  }
  getTracer(_name, _version) {
    return this.mockTracer;
  }
  getActiveSpan() {
    return;
  }
  setSpan(context, _span) {
    return context;
  }
  getSpan(_context) {
    return;
  }
  setSpanContext(context, _spanContext) {
    return context;
  }
  getTracerProvider() {
    return;
  }
  setGlobalTracerProvider(_tracerProvider) {
    return false;
  }
}

class MockOTELContext {
  active() {
    return {};
  }
  with(_context, fn) {
    return fn();
  }
}
var OTEL_TRACE_KEY = Symbol.for("ls:otel_trace");
var OTEL_CONTEXT_KEY = Symbol.for("ls:otel_context");
var OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY = Symbol.for("ls:otel_get_default_otlp_tracer_provider");
var mockOTELTrace = new MockOTELTrace;
var mockOTELContext = new MockOTELContext;

class OTELProvider {
  getTraceInstance() {
    return globalThis[OTEL_TRACE_KEY] ?? mockOTELTrace;
  }
  getContextInstance() {
    return globalThis[OTEL_CONTEXT_KEY] ?? mockOTELContext;
  }
  initializeGlobalInstances(otel) {
    if (globalThis[OTEL_TRACE_KEY] === undefined) {
      globalThis[OTEL_TRACE_KEY] = otel.trace;
    }
    if (globalThis[OTEL_CONTEXT_KEY] === undefined) {
      globalThis[OTEL_CONTEXT_KEY] = otel.context;
    }
  }
  setDefaultOTLPTracerComponents(components) {
    globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] = components;
  }
  getDefaultOTLPTracerComponents() {
    return globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] ?? undefined;
  }
}
var OTELProviderSingleton = new OTELProvider;
function getOTELTrace() {
  return OTELProviderSingleton.getTraceInstance();
}
function getOTELContext() {
  return OTELProviderSingleton.getContextInstance();
}
function getDefaultOTLPTracerComponents() {
  return OTELProviderSingleton.getDefaultOTLPTracerComponents();
}

// node_modules/langsmith/dist/experimental/otel/translator.js
var WELL_KNOWN_OPERATION_NAMES = {
  llm: "chat",
  tool: "execute_tool",
  retriever: "embeddings",
  embedding: "embeddings",
  prompt: "chat"
};
function getOperationName(runType) {
  return WELL_KNOWN_OPERATION_NAMES[runType] || runType;
}

class LangSmithToOTELTranslator {
  constructor() {
    Object.defineProperty(this, "spans", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Map
    });
  }
  exportBatch(operations, otelContextMap) {
    for (const op of operations) {
      try {
        if (!op.run) {
          continue;
        }
        if (op.operation === "post") {
          const span = this.createSpanForRun(op, op.run, otelContextMap.get(op.id));
          if (span && !op.run.end_time) {
            this.spans.set(op.id, span);
          }
        } else {
          this.updateSpanForRun(op, op.run);
        }
      } catch (e) {
        console.error(`Error processing operation ${op.id}:`, e);
      }
    }
  }
  createSpanForRun(op, runInfo, otelContext) {
    const activeSpan = otelContext && getOTELTrace().getSpan(otelContext);
    if (!activeSpan) {
      return;
    }
    try {
      return this.finishSpanSetup(activeSpan, runInfo, op);
    } catch (e) {
      console.error(`Failed to create span for run ${op.id}:`, e);
      return;
    }
  }
  finishSpanSetup(span, runInfo, op) {
    this.setSpanAttributes(span, runInfo, op);
    if (runInfo.error) {
      span.setStatus({ code: 2 });
      span.recordException(new Error(runInfo.error));
    } else {
      span.setStatus({ code: 1 });
    }
    if (runInfo.end_time) {
      span.end(new Date(runInfo.end_time));
    }
    return span;
  }
  updateSpanForRun(op, runInfo) {
    try {
      const span = this.spans.get(op.id);
      if (!span) {
        console.debug(`No span found for run ${op.id} during update`);
        return;
      }
      this.setSpanAttributes(span, runInfo, op);
      if (runInfo.error) {
        span.setStatus({ code: 2 });
        span.recordException(new Error(runInfo.error));
      } else {
        span.setStatus({ code: 1 });
      }
      const endTime = runInfo.end_time;
      if (endTime) {
        span.end(new Date(endTime));
        this.spans.delete(op.id);
      }
    } catch (e) {
      console.error(`Failed to update span for run ${op.id}:`, e);
    }
  }
  extractModelName(runInfo) {
    if (runInfo.extra?.metadata) {
      const metadata = runInfo.extra.metadata;
      if (metadata.ls_model_name) {
        return metadata.ls_model_name;
      }
      if (metadata.invocation_params) {
        const invocationParams = metadata.invocation_params;
        if (invocationParams.model) {
          return invocationParams.model;
        } else if (invocationParams.model_name) {
          return invocationParams.model_name;
        }
      }
    }
    return;
  }
  setSpanAttributes(span, runInfo, op) {
    if ("run_type" in runInfo && runInfo.run_type) {
      span.setAttribute(LANGSMITH_RUN_TYPE, runInfo.run_type);
      const operationName = getOperationName(runInfo.run_type || "chain");
      span.setAttribute(GEN_AI_OPERATION_NAME, operationName);
    }
    if ("name" in runInfo && runInfo.name) {
      span.setAttribute(LANGSMITH_NAME, runInfo.name);
    }
    if ("session_id" in runInfo && runInfo.session_id) {
      span.setAttribute(LANGSMITH_SESSION_ID, runInfo.session_id);
    }
    if ("session_name" in runInfo && runInfo.session_name) {
      span.setAttribute(LANGSMITH_SESSION_NAME, runInfo.session_name);
    }
    this.setGenAiSystem(span, runInfo);
    const modelName = this.extractModelName(runInfo);
    if (modelName) {
      span.setAttribute(GEN_AI_REQUEST_MODEL, modelName);
    }
    if ("prompt_tokens" in runInfo && typeof runInfo.prompt_tokens === "number") {
      span.setAttribute(GEN_AI_USAGE_INPUT_TOKENS, runInfo.prompt_tokens);
    }
    if ("completion_tokens" in runInfo && typeof runInfo.completion_tokens === "number") {
      span.setAttribute(GEN_AI_USAGE_OUTPUT_TOKENS, runInfo.completion_tokens);
    }
    if ("total_tokens" in runInfo && typeof runInfo.total_tokens === "number") {
      span.setAttribute(GEN_AI_USAGE_TOTAL_TOKENS, runInfo.total_tokens);
    }
    this.setInvocationParameters(span, runInfo);
    const metadata = runInfo.extra?.metadata || {};
    for (const [key, value] of Object.entries(metadata)) {
      if (value !== null && value !== undefined) {
        span.setAttribute(`${LANGSMITH_METADATA}.${key}`, String(value));
      }
    }
    const tags = runInfo.tags;
    if (tags && Array.isArray(tags)) {
      span.setAttribute(LANGSMITH_TAGS, tags.join(", "));
    } else if (tags) {
      span.setAttribute(LANGSMITH_TAGS, String(tags));
    }
    if ("serialized" in runInfo && typeof runInfo.serialized === "object") {
      const serialized = runInfo.serialized;
      if (serialized.name) {
        span.setAttribute(GEN_AI_SERIALIZED_NAME, String(serialized.name));
      }
      if (serialized.signature) {
        span.setAttribute(GEN_AI_SERIALIZED_SIGNATURE, String(serialized.signature));
      }
      if (serialized.doc) {
        span.setAttribute(GEN_AI_SERIALIZED_DOC, String(serialized.doc));
      }
    }
    this.setIOAttributes(span, op);
  }
  setGenAiSystem(span, runInfo) {
    let system = "langchain";
    const modelName = this.extractModelName(runInfo);
    if (modelName) {
      const modelLower = modelName.toLowerCase();
      if (modelLower.includes("anthropic") || modelLower.startsWith("claude")) {
        system = "anthropic";
      } else if (modelLower.includes("bedrock")) {
        system = "aws.bedrock";
      } else if (modelLower.includes("azure") && modelLower.includes("openai")) {
        system = "az.ai.openai";
      } else if (modelLower.includes("azure") && modelLower.includes("inference")) {
        system = "az.ai.inference";
      } else if (modelLower.includes("cohere")) {
        system = "cohere";
      } else if (modelLower.includes("deepseek")) {
        system = "deepseek";
      } else if (modelLower.includes("gemini")) {
        system = "gemini";
      } else if (modelLower.includes("groq")) {
        system = "groq";
      } else if (modelLower.includes("watson") || modelLower.includes("ibm")) {
        system = "ibm.watsonx.ai";
      } else if (modelLower.includes("mistral")) {
        system = "mistral_ai";
      } else if (modelLower.includes("gpt") || modelLower.includes("openai")) {
        system = "openai";
      } else if (modelLower.includes("perplexity") || modelLower.includes("sonar")) {
        system = "perplexity";
      } else if (modelLower.includes("vertex")) {
        system = "vertex_ai";
      } else if (modelLower.includes("xai") || modelLower.includes("grok")) {
        system = "xai";
      }
    }
    span.setAttribute(GEN_AI_SYSTEM, system);
  }
  setInvocationParameters(span, runInfo) {
    if (!runInfo.extra?.metadata?.invocation_params) {
      return;
    }
    const invocationParams = runInfo.extra.metadata.invocation_params;
    if (invocationParams.max_tokens !== undefined) {
      span.setAttribute(GEN_AI_REQUEST_MAX_TOKENS, invocationParams.max_tokens);
    }
    if (invocationParams.temperature !== undefined) {
      span.setAttribute(GEN_AI_REQUEST_TEMPERATURE, invocationParams.temperature);
    }
    if (invocationParams.top_p !== undefined) {
      span.setAttribute(GEN_AI_REQUEST_TOP_P, invocationParams.top_p);
    }
    if (invocationParams.frequency_penalty !== undefined) {
      span.setAttribute(GEN_AI_REQUEST_FREQUENCY_PENALTY, invocationParams.frequency_penalty);
    }
    if (invocationParams.presence_penalty !== undefined) {
      span.setAttribute(GEN_AI_REQUEST_PRESENCE_PENALTY, invocationParams.presence_penalty);
    }
  }
  setIOAttributes(span, op) {
    if (op.run.inputs) {
      try {
        const inputs = op.run.inputs;
        if (typeof inputs === "object" && inputs !== null) {
          if (inputs.model && Array.isArray(inputs.messages)) {
            span.setAttribute(GEN_AI_REQUEST_MODEL, inputs.model);
          }
          if (inputs.stream !== undefined) {
            span.setAttribute(LANGSMITH_REQUEST_STREAMING, inputs.stream);
          }
          if (inputs.extra_headers) {
            span.setAttribute(LANGSMITH_REQUEST_HEADERS, JSON.stringify(inputs.extra_headers));
          }
          if (inputs.extra_query) {
            span.setAttribute(GEN_AI_REQUEST_EXTRA_QUERY, JSON.stringify(inputs.extra_query));
          }
          if (inputs.extra_body) {
            span.setAttribute(GEN_AI_REQUEST_EXTRA_BODY, JSON.stringify(inputs.extra_body));
          }
        }
        span.setAttribute(GENAI_PROMPT, JSON.stringify(inputs));
      } catch (e) {
        console.debug(`Failed to process inputs for run ${op.id}`, e);
      }
    }
    if (op.run.outputs) {
      try {
        const outputs = op.run.outputs;
        const tokenUsage = this.getUnifiedRunTokens(outputs);
        if (tokenUsage) {
          span.setAttribute(GEN_AI_USAGE_INPUT_TOKENS, tokenUsage[0]);
          span.setAttribute(GEN_AI_USAGE_OUTPUT_TOKENS, tokenUsage[1]);
          span.setAttribute(GEN_AI_USAGE_TOTAL_TOKENS, tokenUsage[0] + tokenUsage[1]);
        }
        if (outputs && typeof outputs === "object") {
          if (outputs.model) {
            span.setAttribute(GEN_AI_RESPONSE_MODEL, String(outputs.model));
          }
          if (outputs.id) {
            span.setAttribute(GEN_AI_RESPONSE_ID, outputs.id);
          }
          if (outputs.choices && Array.isArray(outputs.choices)) {
            const finishReasons = outputs.choices.map((choice) => choice.finish_reason).filter((reason) => reason).map(String);
            if (finishReasons.length > 0) {
              span.setAttribute(GEN_AI_RESPONSE_FINISH_REASONS, finishReasons.join(", "));
            }
          }
          if (outputs.service_tier) {
            span.setAttribute(GEN_AI_RESPONSE_SERVICE_TIER, outputs.service_tier);
          }
          if (outputs.system_fingerprint) {
            span.setAttribute(GEN_AI_RESPONSE_SYSTEM_FINGERPRINT, outputs.system_fingerprint);
          }
          if (outputs.usage_metadata && typeof outputs.usage_metadata === "object") {
            const usageMetadata = outputs.usage_metadata;
            if (usageMetadata.input_token_details) {
              span.setAttribute(GEN_AI_USAGE_INPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.input_token_details));
            }
            if (usageMetadata.output_token_details) {
              span.setAttribute(GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.output_token_details));
            }
          }
        }
        span.setAttribute(GENAI_COMPLETION, JSON.stringify(outputs));
      } catch (e) {
        console.debug(`Failed to process outputs for run ${op.id}`, e);
      }
    }
  }
  getUnifiedRunTokens(outputs) {
    if (!outputs) {
      return null;
    }
    let tokenUsage = this.extractUnifiedRunTokens(outputs.usage_metadata);
    if (tokenUsage) {
      return tokenUsage;
    }
    const keys = Object.keys(outputs);
    for (const key of keys) {
      const haystack = outputs[key];
      if (!haystack || typeof haystack !== "object") {
        continue;
      }
      tokenUsage = this.extractUnifiedRunTokens(haystack.usage_metadata);
      if (tokenUsage) {
        return tokenUsage;
      }
      if (haystack.lc === 1 && haystack.kwargs && typeof haystack.kwargs === "object") {
        tokenUsage = this.extractUnifiedRunTokens(haystack.kwargs.usage_metadata);
        if (tokenUsage) {
          return tokenUsage;
        }
      }
    }
    const generations = outputs.generations || [];
    if (!Array.isArray(generations)) {
      return null;
    }
    const flatGenerations = Array.isArray(generations[0]) ? generations.flat() : generations;
    for (const generation of flatGenerations) {
      if (typeof generation === "object" && generation.message && typeof generation.message === "object" && generation.message.kwargs && typeof generation.message.kwargs === "object") {
        tokenUsage = this.extractUnifiedRunTokens(generation.message.kwargs.usage_metadata);
        if (tokenUsage) {
          return tokenUsage;
        }
      }
    }
    return null;
  }
  extractUnifiedRunTokens(outputs) {
    if (!outputs || typeof outputs !== "object") {
      return null;
    }
    if (typeof outputs.input_tokens !== "number" || typeof outputs.output_tokens !== "number") {
      return null;
    }
    return [outputs.input_tokens, outputs.output_tokens];
  }
}

// node_modules/langsmith/dist/utils/is-network-error/index.js
var objectToString = Object.prototype.toString;
var isError = (value) => objectToString.call(value) === "[object Error]";
var errorMessages = new Set([
  "network error",
  "Failed to fetch",
  "NetworkError when attempting to fetch resource.",
  "The Internet connection appears to be offline.",
  "Network request failed",
  "fetch failed",
  "terminated",
  " A network error occurred.",
  "Network connection lost"
]);
function isNetworkError(error) {
  const isValid = error && isError(error) && error.name === "TypeError" && typeof error.message === "string";
  if (!isValid) {
    return false;
  }
  const { message, stack } = error;
  if (message === "Load failed") {
    return stack === undefined || "__sentry_captured__" in error;
  }
  if (message.startsWith("error sending request for url")) {
    return true;
  }
  return errorMessages.has(message);
}

// node_modules/langsmith/dist/utils/p-retry/index.js
function validateRetries(retries) {
  if (typeof retries === "number") {
    if (retries < 0) {
      throw new TypeError("Expected `retries` to be a non-negative number.");
    }
    if (Number.isNaN(retries)) {
      throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
    }
  } else if (retries !== undefined) {
    throw new TypeError("Expected `retries` to be a number or Infinity.");
  }
}
function validateNumberOption(name, value, { min = 0, allowInfinity = false } = {}) {
  if (value === undefined) {
    return;
  }
  if (typeof value !== "number" || Number.isNaN(value)) {
    throw new TypeError(`Expected \`${name}\` to be a number${allowInfinity ? " or Infinity" : ""}.`);
  }
  if (!allowInfinity && !Number.isFinite(value)) {
    throw new TypeError(`Expected \`${name}\` to be a finite number.`);
  }
  if (value < min) {
    throw new TypeError(`Expected \`${name}\` to be \u2265 ${min}.`);
  }
}

class AbortError extends Error {
  constructor(message) {
    super();
    if (message instanceof Error) {
      this.originalError = message;
      ({ message } = message);
    } else {
      this.originalError = new Error(message);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message;
  }
}
function calculateDelay(retriesConsumed, options) {
  const attempt = Math.max(1, retriesConsumed + 1);
  const random = options.randomize ? Math.random() + 1 : 1;
  let timeout = Math.round(random * options.minTimeout * options.factor ** (attempt - 1));
  timeout = Math.min(timeout, options.maxTimeout);
  return timeout;
}
function calculateRemainingTime(start, max) {
  if (!Number.isFinite(max)) {
    return max;
  }
  return max - (performance.now() - start);
}
async function onAttemptFailure({ error, attemptNumber, retriesConsumed, startTime, options }) {
  const normalizedError = error instanceof Error ? error : new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
  if (normalizedError instanceof AbortError) {
    throw normalizedError.originalError;
  }
  const retriesLeft = Number.isFinite(options.retries) ? Math.max(0, options.retries - retriesConsumed) : options.retries;
  const maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;
  const context = Object.freeze({
    error: normalizedError,
    attemptNumber,
    retriesLeft,
    retriesConsumed
  });
  await options.onFailedAttempt(context);
  if (calculateRemainingTime(startTime, maxRetryTime) <= 0) {
    throw normalizedError;
  }
  const consumeRetry = await options.shouldConsumeRetry(context);
  const remainingTime = calculateRemainingTime(startTime, maxRetryTime);
  if (remainingTime <= 0 || retriesLeft <= 0) {
    throw normalizedError;
  }
  if (normalizedError instanceof TypeError && !isNetworkError(normalizedError)) {
    if (consumeRetry) {
      throw normalizedError;
    }
    options.signal?.throwIfAborted();
    return false;
  }
  if (!await options.shouldRetry(context)) {
    throw normalizedError;
  }
  if (!consumeRetry) {
    options.signal?.throwIfAborted();
    return false;
  }
  const delayTime = calculateDelay(retriesConsumed, options);
  const finalDelay = Math.min(delayTime, remainingTime);
  if (finalDelay > 0) {
    await new Promise((resolve, reject) => {
      const onAbort = () => {
        clearTimeout(timeoutToken);
        options.signal?.removeEventListener("abort", onAbort);
        reject(options.signal.reason);
      };
      const timeoutToken = setTimeout(() => {
        options.signal?.removeEventListener("abort", onAbort);
        resolve();
      }, finalDelay);
      if (options.unref) {
        timeoutToken.unref?.();
      }
      options.signal?.addEventListener("abort", onAbort, { once: true });
    });
  }
  options.signal?.throwIfAborted();
  return true;
}
async function pRetry(input, options = {}) {
  options = { ...options };
  validateRetries(options.retries);
  if (Object.hasOwn(options, "forever")) {
    throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  }
  options.retries ??= 10;
  options.factor ??= 2;
  options.minTimeout ??= 1000;
  options.maxTimeout ??= Number.POSITIVE_INFINITY;
  options.maxRetryTime ??= Number.POSITIVE_INFINITY;
  options.randomize ??= false;
  options.onFailedAttempt ??= () => {};
  options.shouldRetry ??= () => true;
  options.shouldConsumeRetry ??= () => true;
  validateNumberOption("factor", options.factor, {
    min: 0,
    allowInfinity: false
  });
  validateNumberOption("minTimeout", options.minTimeout, {
    min: 0,
    allowInfinity: false
  });
  validateNumberOption("maxTimeout", options.maxTimeout, {
    min: 0,
    allowInfinity: true
  });
  validateNumberOption("maxRetryTime", options.maxRetryTime, {
    min: 0,
    allowInfinity: true
  });
  if (!(options.factor > 0)) {
    options.factor = 1;
  }
  options.signal?.throwIfAborted();
  let attemptNumber = 0;
  let retriesConsumed = 0;
  const startTime = performance.now();
  while (Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true) {
    attemptNumber++;
    try {
      options.signal?.throwIfAborted();
      const result = await input(attemptNumber);
      options.signal?.throwIfAborted();
      return result;
    } catch (error) {
      if (await onAttemptFailure({
        error,
        attemptNumber,
        retriesConsumed,
        startTime,
        options
      })) {
        retriesConsumed++;
      }
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}

// node_modules/langsmith/dist/utils/async_caller.js
var import_p_queue = __toESM(require_dist2(), 1);
var STATUS_RETRYABLE = [
  408,
  425,
  429,
  500,
  502,
  503,
  504
];

class AsyncCaller {
  constructor(params) {
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "maxRetries", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "maxQueueSizeBytes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "queue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "onFailedResponseHook", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "queueSizeBytes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    this.maxConcurrency = params.maxConcurrency ?? Infinity;
    this.maxRetries = params.maxRetries ?? 6;
    this.maxQueueSizeBytes = params.maxQueueSizeBytes;
    if ("default" in import_p_queue.default) {
      this.queue = new import_p_queue.default.default({
        concurrency: this.maxConcurrency
      });
    } else {
      this.queue = new import_p_queue.default({ concurrency: this.maxConcurrency });
    }
    this.onFailedResponseHook = params?.onFailedResponseHook;
  }
  call(callable, ...args) {
    return this.callWithOptions({}, callable, ...args);
  }
  callWithOptions(options, callable, ...args) {
    const sizeBytes = options.sizeBytes ?? 0;
    if (this.maxQueueSizeBytes !== undefined && sizeBytes > 0 && this.queueSizeBytes + sizeBytes > this.maxQueueSizeBytes) {
      return Promise.reject(new Error(`Queue size limit (${this.maxQueueSizeBytes} bytes) exceeded. ` + `Current queue size: ${this.queueSizeBytes} bytes, attempted addition: ${sizeBytes} bytes.`));
    }
    if (sizeBytes > 0) {
      this.queueSizeBytes += sizeBytes;
    }
    const onFailedResponseHook = this.onFailedResponseHook;
    let promise = this.queue.add(() => pRetry(() => callable(...args).catch((error) => {
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error(error);
      }
    }), {
      async onFailedAttempt({ error }) {
        if (error.message.startsWith("Cancel") || error.message.startsWith("TimeoutError") || error.name === "TimeoutError" || error.message.startsWith("AbortError")) {
          throw error;
        }
        if (error?.code === "ECONNABORTED") {
          throw error;
        }
        const response = error?.response;
        if (onFailedResponseHook) {
          const handled = await onFailedResponseHook(response);
          if (handled) {
            return;
          }
        }
        const status = response?.status ?? error?.status;
        if (status) {
          if (!STATUS_RETRYABLE.includes(+status)) {
            throw error;
          }
        }
      },
      retries: this.maxRetries,
      randomize: true
    }), { throwOnTimeout: true });
    if (sizeBytes > 0) {
      promise = promise.finally(() => {
        this.queueSizeBytes -= sizeBytes;
      });
    }
    if (options.signal) {
      return Promise.race([
        promise,
        new Promise((_, reject) => {
          options.signal?.addEventListener("abort", () => {
            reject(new Error("AbortError"));
          });
        })
      ]);
    }
    return promise;
  }
}

// node_modules/langsmith/dist/utils/messages.js
function isLangChainMessage(message) {
  return typeof message?._getType === "function";
}
function convertLangChainMessageToExample(message) {
  const converted = {
    type: message._getType(),
    data: { content: message.content }
  };
  if (message?.additional_kwargs && Object.keys(message.additional_kwargs).length > 0) {
    converted.data.additional_kwargs = { ...message.additional_kwargs };
  }
  return converted;
}

// node_modules/langsmith/dist/utils/prompts.js
var import_semver = __toESM(require_semver2(), 1);
function parsePromptIdentifier(identifier) {
  if (!identifier || identifier.split("/").length > 2 || identifier.startsWith("/") || identifier.endsWith("/") || identifier.split(":").length > 2) {
    throw new Error(`Invalid identifier format: ${identifier}`);
  }
  const [ownerNamePart, commitPart] = identifier.split(":");
  const commit = commitPart || "latest";
  if (ownerNamePart.includes("/")) {
    const [owner, name] = ownerNamePart.split("/", 2);
    if (!owner || !name) {
      throw new Error(`Invalid identifier format: ${identifier}`);
    }
    return [owner, name, commit];
  } else {
    if (!ownerNamePart) {
      throw new Error(`Invalid identifier format: ${identifier}`);
    }
    return ["-", ownerNamePart, commit];
  }
}

// node_modules/langsmith/dist/utils/error.js
class LangSmithConflictError extends Error {
  constructor(message) {
    super(message);
    Object.defineProperty(this, "status", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.name = "LangSmithConflictError";
    this.status = 409;
  }
}
async function raiseForStatus(response, context, consumeOnSuccess) {
  let errorBody;
  if (response.ok) {
    if (consumeOnSuccess) {
      errorBody = await response.text();
    }
    return;
  }
  if (response.status === 403) {
    try {
      const errorData = await response.json();
      const errorCode = errorData?.error;
      if (errorCode === "org_scoped_key_requires_workspace") {
        errorBody = "This API key is org-scoped and requires workspace specification. " + "Please provide 'workspaceId' parameter, " + "or set LANGSMITH_WORKSPACE_ID environment variable.";
      }
    } catch (e) {
      const errorWithStatus = new Error(`${response.status} ${response.statusText}`);
      errorWithStatus.status = response?.status;
      throw errorWithStatus;
    }
  }
  if (errorBody === undefined) {
    try {
      errorBody = await response.text();
    } catch (e) {
      errorBody = "";
    }
  }
  const fullMessage = `Failed to ${context}. Received status [${response.status}]: ${response.statusText}. Message: ${errorBody}`;
  if (response.status === 409) {
    throw new LangSmithConflictError(fullMessage);
  }
  const err = new Error(fullMessage);
  err.status = response.status;
  throw err;
}
var ERR_CONFLICTING_ENDPOINTS = "ERR_CONFLICTING_ENDPOINTS";

class ConflictingEndpointsError extends Error {
  constructor() {
    super("You cannot provide both LANGSMITH_ENDPOINT / LANGCHAIN_ENDPOINT " + "and LANGSMITH_RUNS_ENDPOINTS.");
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ERR_CONFLICTING_ENDPOINTS
    });
    this.name = "ConflictingEndpointsError";
  }
}
function isConflictingEndpointsError(err) {
  return typeof err === "object" && err !== null && err.code === ERR_CONFLICTING_ENDPOINTS;
}

// node_modules/langsmith/dist/utils/fast-safe-stringify/index.js
var LIMIT_REPLACE_NODE = "[...]";
var CIRCULAR_REPLACE_NODE = { result: "[Circular]" };
var arr = [];
var replacerStack = [];
var encoder = new TextEncoder;
function defaultOptions() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function encodeString(str) {
  return encoder.encode(str);
}
function serializeWellKnownTypes(val) {
  if (val && typeof val === "object" && val !== null) {
    if (val instanceof Map) {
      return Object.fromEntries(val);
    } else if (val instanceof Set) {
      return Array.from(val);
    } else if (val instanceof Date) {
      return val.toISOString();
    } else if (val instanceof RegExp) {
      return val.toString();
    } else if (val instanceof Error) {
      return {
        name: val.name,
        message: val.message
      };
    }
  } else if (typeof val === "bigint") {
    return val.toString();
  }
  return val;
}
function createDefaultReplacer(userReplacer) {
  return function(key, val) {
    if (userReplacer) {
      const userResult = userReplacer.call(this, key, val);
      if (userResult !== undefined) {
        return userResult;
      }
    }
    return serializeWellKnownTypes(val);
  };
}
function serialize(obj, errorContext, replacer, spacer, options) {
  try {
    const str = JSON.stringify(obj, createDefaultReplacer(replacer), spacer);
    return encodeString(str);
  } catch (e) {
    if (!e.message?.includes("Converting circular structure to JSON")) {
      console.warn(`[WARNING]: LangSmith received unserializable value.${errorContext ? `
Context: ${errorContext}` : ""}`);
      return encodeString("[Unserializable]");
    }
    getLangSmithEnvironmentVariable("SUPPRESS_CIRCULAR_JSON_WARNINGS") !== "true" && console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${errorContext ? `
Context: ${errorContext}` : ""}`);
    if (typeof options === "undefined") {
      options = defaultOptions();
    }
    decirc(obj, "", 0, [], undefined, 0, options);
    let res;
    try {
      if (replacerStack.length === 0) {
        res = JSON.stringify(obj, replacer, spacer);
      } else {
        res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
      }
    } catch (_) {
      return encodeString("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      while (arr.length !== 0) {
        const part = arr.pop();
        if (part.length === 4) {
          Object.defineProperty(part[0], part[1], part[3]);
        } else {
          part[0][part[1]] = part[2];
        }
      }
    }
    return encodeString(res);
  }
}
function setReplace(replace, val, k, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
  if (propertyDescriptor.get !== undefined) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k, { value: replace });
      arr.push([parent, k, val, propertyDescriptor]);
    } else {
      replacerStack.push([val, k, replace]);
    }
  } else {
    parent[k] = replace;
    arr.push([parent, k, val]);
  }
}
function decirc(val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i;
  if (typeof val === "object" && val !== null) {
    for (i = 0;i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
        return;
      }
    }
    if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i = 0;i < val.length; i++) {
        decirc(val[i], i, i, stack, val, depth, options);
      }
    } else {
      val = serializeWellKnownTypes(val);
      var keys = Object.keys(val);
      for (i = 0;i < keys.length; i++) {
        var key = keys[i];
        decirc(val[key], key, i, stack, val, depth, options);
      }
    }
    stack.pop();
  }
}
function replaceGetterValues(replacer) {
  replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
    return v;
  };
  return function(key, val) {
    if (replacerStack.length > 0) {
      for (var i = 0;i < replacerStack.length; i++) {
        var part = replacerStack[i];
        if (part[1] === key && part[0] === val) {
          val = part[2];
          replacerStack.splice(i, 1);
          break;
        }
      }
    }
    return replacer.call(this, key, val);
  };
}

// node_modules/langsmith/dist/client.js
function mergeRuntimeEnvIntoRun(run, cachedEnvVars, omitTracedRuntimeInfo) {
  if (omitTracedRuntimeInfo) {
    return run;
  }
  const runtimeEnv = getRuntimeEnvironment2();
  const envVars = cachedEnvVars ?? getLangSmithEnvVarsMetadata();
  const extra = run.extra ?? {};
  const metadata = extra.metadata;
  run.extra = {
    ...extra,
    runtime: {
      ...runtimeEnv,
      ...extra?.runtime
    },
    metadata: {
      ...envVars,
      ...envVars.revision_id || "revision_id" in run && run.revision_id ? {
        revision_id: ("revision_id" in run ? run.revision_id : undefined) ?? envVars.revision_id
      } : {},
      ...metadata
    }
  };
  return run;
}
var getTracingSamplingRate = (configRate) => {
  const samplingRateStr = configRate?.toString() ?? getLangSmithEnvironmentVariable("TRACING_SAMPLING_RATE");
  if (samplingRateStr === undefined) {
    return;
  }
  const samplingRate = parseFloat(samplingRateStr);
  if (samplingRate < 0 || samplingRate > 1) {
    throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);
  }
  return samplingRate;
};
var isLocalhost = (url) => {
  const strippedUrl = url.replace("http://", "").replace("https://", "");
  const hostname = strippedUrl.split("/")[0].split(":")[0];
  return hostname === "localhost" || hostname === "127.0.0.1" || hostname === "::1";
};
async function toArray(iterable) {
  const result = [];
  for await (const item of iterable) {
    result.push(item);
  }
  return result;
}
function trimQuotes(str) {
  if (str === undefined) {
    return;
  }
  return str.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
}
var handle429 = async (response) => {
  if (response?.status === 429) {
    const retryAfter = parseInt(response.headers.get("retry-after") ?? "10", 10) * 1000;
    if (retryAfter > 0) {
      await new Promise((resolve) => setTimeout(resolve, retryAfter));
      return true;
    }
  }
  return false;
};
function _formatFeedbackScore(score) {
  if (typeof score === "number") {
    return Number(score.toFixed(4));
  }
  return score;
}
var DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES = 24 * 1024 * 1024;
var DEFAULT_MAX_SIZE_BYTES = 1024 * 1024 * 1024;
var SERVER_INFO_REQUEST_TIMEOUT_MS = 1e4;
var DEFAULT_BATCH_SIZE_LIMIT = 100;
var DEFAULT_API_URL = "https://api.smith.langchain.com";

class AutoBatchQueue {
  constructor(maxSizeBytes) {
    Object.defineProperty(this, "items", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "sizeBytes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "maxSizeBytes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.maxSizeBytes = maxSizeBytes ?? DEFAULT_MAX_SIZE_BYTES;
  }
  peek() {
    return this.items[0];
  }
  push(item) {
    let itemPromiseResolve;
    const itemPromise = new Promise((resolve) => {
      itemPromiseResolve = resolve;
    });
    const size = serialize(item.item, `Serializing run with id: ${item.item.id}`).length;
    if (this.sizeBytes + size > this.maxSizeBytes && this.items.length > 0) {
      console.warn(`AutoBatchQueue size limit (${this.maxSizeBytes} bytes) exceeded. Dropping run with id: ${item.item.id}. ` + `Current queue size: ${this.sizeBytes} bytes, attempted addition: ${size} bytes.`);
      itemPromiseResolve();
      return itemPromise;
    }
    this.items.push({
      action: item.action,
      payload: item.item,
      otelContext: item.otelContext,
      apiKey: item.apiKey,
      apiUrl: item.apiUrl,
      itemPromiseResolve,
      itemPromise,
      size
    });
    this.sizeBytes += size;
    return itemPromise;
  }
  pop({ upToSizeBytes, upToSize }) {
    if (upToSizeBytes < 1) {
      throw new Error("Number of bytes to pop off may not be less than 1.");
    }
    const popped = [];
    let poppedSizeBytes = 0;
    while (poppedSizeBytes + (this.peek()?.size ?? 0) < upToSizeBytes && this.items.length > 0 && popped.length < upToSize) {
      const item = this.items.shift();
      if (item) {
        popped.push(item);
        poppedSizeBytes += item.size;
        this.sizeBytes -= item.size;
      }
    }
    if (popped.length === 0 && this.items.length > 0) {
      const item = this.items.shift();
      popped.push(item);
      poppedSizeBytes += item.size;
      this.sizeBytes -= item.size;
    }
    return [
      popped.map((it) => ({
        action: it.action,
        item: it.payload,
        otelContext: it.otelContext,
        apiKey: it.apiKey,
        apiUrl: it.apiUrl,
        size: it.size
      })),
      () => popped.forEach((it) => it.itemPromiseResolve())
    ];
  }
}

class Client {
  get _fetch() {
    return this.fetchImplementation || _getFetchImplementation(this.debug);
  }
  constructor(config = {}) {
    Object.defineProperty(this, "apiKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "apiUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "webUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "workspaceId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "caller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "batchIngestCaller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "timeout_ms", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_tenantId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    Object.defineProperty(this, "hideInputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "hideOutputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "omitTracedRuntimeInfo", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "tracingSampleRate", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "filteredPostUuids", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Set
    });
    Object.defineProperty(this, "autoBatchTracing", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "autoBatchQueue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "autoBatchTimeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "autoBatchAggregationDelayMs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 250
    });
    Object.defineProperty(this, "batchSizeBytesLimit", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "batchSizeLimit", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "fetchOptions", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "settings", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "blockOnRootRunFinalization", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: getEnvironmentVariable2("LANGSMITH_TRACING_BACKGROUND") === "false"
    });
    Object.defineProperty(this, "traceBatchConcurrency", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5
    });
    Object.defineProperty(this, "_serverInfo", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_getServerInfoPromise", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "manualFlushMode", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "langSmithToOTELTranslator", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "fetchImplementation", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "cachedLSEnvVarsForMetadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "multipartStreamingDisabled", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "debug", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: getEnvironmentVariable2("LANGSMITH_DEBUG") === "true"
    });
    const defaultConfig = Client.getDefaultClientConfig();
    this.tracingSampleRate = getTracingSamplingRate(config.tracingSamplingRate);
    this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? "";
    if (this.apiUrl.endsWith("/")) {
      this.apiUrl = this.apiUrl.slice(0, -1);
    }
    this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);
    this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);
    if (this.webUrl?.endsWith("/")) {
      this.webUrl = this.webUrl.slice(0, -1);
    }
    this.workspaceId = trimQuotes(config.workspaceId ?? getLangSmithEnvironmentVariable("WORKSPACE_ID"));
    this.timeout_ms = config.timeout_ms ?? 90000;
    this.caller = new AsyncCaller({
      ...config.callerOptions ?? {},
      maxRetries: 4,
      debug: config.debug ?? this.debug
    });
    this.traceBatchConcurrency = config.traceBatchConcurrency ?? this.traceBatchConcurrency;
    if (this.traceBatchConcurrency < 1) {
      throw new Error("Trace batch concurrency must be positive.");
    }
    this.debug = config.debug ?? this.debug;
    this.fetchImplementation = config.fetchImplementation;
    const maxMemory = config.maxIngestMemoryBytes ?? DEFAULT_MAX_SIZE_BYTES;
    this.batchIngestCaller = new AsyncCaller({
      maxRetries: 4,
      maxConcurrency: this.traceBatchConcurrency,
      maxQueueSizeBytes: maxMemory,
      ...config.callerOptions ?? {},
      onFailedResponseHook: handle429,
      debug: config.debug ?? this.debug
    });
    this.hideInputs = config.hideInputs ?? config.anonymizer ?? defaultConfig.hideInputs;
    this.hideOutputs = config.hideOutputs ?? config.anonymizer ?? defaultConfig.hideOutputs;
    this.omitTracedRuntimeInfo = config.omitTracedRuntimeInfo ?? false;
    this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;
    this.autoBatchQueue = new AutoBatchQueue(maxMemory);
    this.blockOnRootRunFinalization = config.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;
    this.batchSizeBytesLimit = config.batchSizeBytesLimit;
    this.batchSizeLimit = config.batchSizeLimit;
    this.fetchOptions = config.fetchOptions || {};
    this.manualFlushMode = config.manualFlushMode ?? this.manualFlushMode;
    if (getOtelEnabled()) {
      this.langSmithToOTELTranslator = new LangSmithToOTELTranslator;
    }
    this.cachedLSEnvVarsForMetadata = getLangSmithEnvVarsMetadata();
  }
  static getDefaultClientConfig() {
    const apiKey = getLangSmithEnvironmentVariable("API_KEY");
    const apiUrl = getLangSmithEnvironmentVariable("ENDPOINT") ?? DEFAULT_API_URL;
    const hideInputs = getLangSmithEnvironmentVariable("HIDE_INPUTS") === "true";
    const hideOutputs = getLangSmithEnvironmentVariable("HIDE_OUTPUTS") === "true";
    return {
      apiUrl,
      apiKey,
      webUrl: undefined,
      hideInputs,
      hideOutputs
    };
  }
  getHostUrl() {
    if (this.webUrl) {
      return this.webUrl;
    } else if (isLocalhost(this.apiUrl)) {
      this.webUrl = "http://localhost:3000";
      return this.webUrl;
    } else if (this.apiUrl.endsWith("/api/v1")) {
      this.webUrl = this.apiUrl.replace("/api/v1", "");
      return this.webUrl;
    } else if (this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api")) {
      this.webUrl = this.apiUrl.replace("/api", "");
      return this.webUrl;
    } else if (this.apiUrl.split(".", 1)[0].includes("dev")) {
      this.webUrl = "https://dev.smith.langchain.com";
      return this.webUrl;
    } else if (this.apiUrl.split(".", 1)[0].includes("eu")) {
      this.webUrl = "https://eu.smith.langchain.com";
      return this.webUrl;
    } else if (this.apiUrl.split(".", 1)[0].includes("beta")) {
      this.webUrl = "https://beta.smith.langchain.com";
      return this.webUrl;
    } else {
      this.webUrl = "https://smith.langchain.com";
      return this.webUrl;
    }
  }
  get headers() {
    const headers = {
      "User-Agent": `langsmith-js/${__version__}`
    };
    if (this.apiKey) {
      headers["x-api-key"] = `${this.apiKey}`;
    }
    if (this.workspaceId) {
      headers["x-tenant-id"] = this.workspaceId;
    }
    return headers;
  }
  _getPlatformEndpointPath(path) {
    const needsV1Prefix = this.apiUrl.slice(-3) !== "/v1" && this.apiUrl.slice(-4) !== "/v1/";
    return needsV1Prefix ? `/v1/platform/${path}` : `/platform/${path}`;
  }
  async processInputs(inputs) {
    if (this.hideInputs === false) {
      return inputs;
    }
    if (this.hideInputs === true) {
      return {};
    }
    if (typeof this.hideInputs === "function") {
      return this.hideInputs(inputs);
    }
    return inputs;
  }
  async processOutputs(outputs) {
    if (this.hideOutputs === false) {
      return outputs;
    }
    if (this.hideOutputs === true) {
      return {};
    }
    if (typeof this.hideOutputs === "function") {
      return this.hideOutputs(outputs);
    }
    return outputs;
  }
  async prepareRunCreateOrUpdateInputs(run) {
    const runParams = { ...run };
    if (runParams.inputs !== undefined) {
      runParams.inputs = await this.processInputs(runParams.inputs);
    }
    if (runParams.outputs !== undefined) {
      runParams.outputs = await this.processOutputs(runParams.outputs);
    }
    return runParams;
  }
  async _getResponse(path, queryParams) {
    const paramsString = queryParams?.toString() ?? "";
    const url = `${this.apiUrl}${path}?${paramsString}`;
    const response = await this.caller.call(async () => {
      const res = await this._fetch(url, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, `fetch ${path}`);
      return res;
    });
    return response;
  }
  async _get(path, queryParams) {
    const response = await this._getResponse(path, queryParams);
    return response.json();
  }
  async* _getPaginated(path, queryParams = new URLSearchParams, transform) {
    let offset = Number(queryParams.get("offset")) || 0;
    const limit = Number(queryParams.get("limit")) || 100;
    while (true) {
      queryParams.set("offset", String(offset));
      queryParams.set("limit", String(limit));
      const url = `${this.apiUrl}${path}?${queryParams}`;
      const response = await this.caller.call(async () => {
        const res = await this._fetch(url, {
          method: "GET",
          headers: this.headers,
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        await raiseForStatus(res, `fetch ${path}`);
        return res;
      });
      const items = transform ? transform(await response.json()) : await response.json();
      if (items.length === 0) {
        break;
      }
      yield items;
      if (items.length < limit) {
        break;
      }
      offset += items.length;
    }
  }
  async* _getCursorPaginatedList(path, body = null, requestMethod = "POST", dataKey = "runs") {
    const bodyParams = body ? { ...body } : {};
    while (true) {
      const body2 = JSON.stringify(bodyParams);
      const response = await this.caller.call(async () => {
        const res = await this._fetch(`${this.apiUrl}${path}`, {
          method: requestMethod,
          headers: { ...this.headers, "Content-Type": "application/json" },
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions,
          body: body2
        });
        await raiseForStatus(res, `fetch ${path}`);
        return res;
      });
      const responseBody = await response.json();
      if (!responseBody) {
        break;
      }
      if (!responseBody[dataKey]) {
        break;
      }
      yield responseBody[dataKey];
      const cursors = responseBody.cursors;
      if (!cursors) {
        break;
      }
      if (!cursors.next) {
        break;
      }
      bodyParams.cursor = cursors.next;
    }
  }
  _shouldSample() {
    if (this.tracingSampleRate === undefined) {
      return true;
    }
    return Math.random() < this.tracingSampleRate;
  }
  _filterForSampling(runs, patch = false) {
    if (this.tracingSampleRate === undefined) {
      return runs;
    }
    if (patch) {
      const sampled = [];
      for (const run of runs) {
        if (!this.filteredPostUuids.has(run.trace_id)) {
          sampled.push(run);
        } else if (run.id === run.trace_id) {
          this.filteredPostUuids.delete(run.trace_id);
        }
      }
      return sampled;
    } else {
      const sampled = [];
      for (const run of runs) {
        const traceId = run.trace_id ?? run.id;
        if (this.filteredPostUuids.has(traceId)) {
          continue;
        }
        if (run.id === traceId) {
          if (this._shouldSample()) {
            sampled.push(run);
          } else {
            this.filteredPostUuids.add(traceId);
          }
        } else {
          sampled.push(run);
        }
      }
      return sampled;
    }
  }
  async _getBatchSizeLimitBytes() {
    const serverInfo = await this._ensureServerInfo();
    return this.batchSizeBytesLimit ?? serverInfo.batch_ingest_config?.size_limit_bytes ?? DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES;
  }
  async _getBatchSizeLimit() {
    const serverInfo = await this._ensureServerInfo();
    return this.batchSizeLimit ?? serverInfo.batch_ingest_config?.size_limit ?? DEFAULT_BATCH_SIZE_LIMIT;
  }
  async _getDatasetExamplesMultiPartSupport() {
    const serverInfo = await this._ensureServerInfo();
    return serverInfo.instance_flags?.dataset_examples_multipart_enabled ?? false;
  }
  drainAutoBatchQueue({ batchSizeLimitBytes, batchSizeLimit }) {
    const promises = [];
    while (this.autoBatchQueue.items.length > 0) {
      const [batch, done] = this.autoBatchQueue.pop({
        upToSizeBytes: batchSizeLimitBytes,
        upToSize: batchSizeLimit
      });
      if (!batch.length) {
        done();
        break;
      }
      const batchesByDestination = batch.reduce((acc, item) => {
        const apiUrl = item.apiUrl ?? this.apiUrl;
        const apiKey = item.apiKey ?? this.apiKey;
        const isDefault = item.apiKey === this.apiKey && item.apiUrl === this.apiUrl;
        const batchKey = isDefault ? "default" : `${apiUrl}|${apiKey}`;
        if (!acc[batchKey]) {
          acc[batchKey] = [];
        }
        acc[batchKey].push(item);
        return acc;
      }, {});
      const batchPromises = [];
      for (const [batchKey, batch2] of Object.entries(batchesByDestination)) {
        const batchPromise = this._processBatch(batch2, {
          apiUrl: batchKey === "default" ? undefined : batchKey.split("|")[0],
          apiKey: batchKey === "default" ? undefined : batchKey.split("|")[1]
        });
        batchPromises.push(batchPromise);
      }
      const allBatchesPromise = Promise.all(batchPromises).finally(done);
      promises.push(allBatchesPromise);
    }
    return Promise.all(promises);
  }
  async _processBatch(batch, options) {
    if (!batch.length) {
      return;
    }
    const batchSizeBytes = batch.reduce((sum, item) => sum + (item.size ?? 0), 0);
    try {
      if (this.langSmithToOTELTranslator !== undefined) {
        this._sendBatchToOTELTranslator(batch);
      } else {
        const ingestParams = {
          runCreates: batch.filter((item) => item.action === "create").map((item) => item.item),
          runUpdates: batch.filter((item) => item.action === "update").map((item) => item.item)
        };
        const serverInfo = await this._ensureServerInfo();
        if (serverInfo?.batch_ingest_config?.use_multipart_endpoint) {
          const useGzip = serverInfo?.instance_flags?.gzip_body_enabled;
          await this.multipartIngestRuns(ingestParams, {
            ...options,
            useGzip,
            sizeBytes: batchSizeBytes
          });
        } else {
          await this.batchIngestRuns(ingestParams, {
            ...options,
            sizeBytes: batchSizeBytes
          });
        }
      }
    } catch (e) {
      console.error("Error exporting batch:", e);
    }
  }
  _sendBatchToOTELTranslator(batch) {
    if (this.langSmithToOTELTranslator !== undefined) {
      const otelContextMap = new Map;
      const operations = [];
      for (const item of batch) {
        if (item.item.id && item.otelContext) {
          otelContextMap.set(item.item.id, item.otelContext);
          if (item.action === "create") {
            operations.push({
              operation: "post",
              id: item.item.id,
              trace_id: item.item.trace_id ?? item.item.id,
              run: item.item
            });
          } else {
            operations.push({
              operation: "patch",
              id: item.item.id,
              trace_id: item.item.trace_id ?? item.item.id,
              run: item.item
            });
          }
        }
      }
      this.langSmithToOTELTranslator.exportBatch(operations, otelContextMap);
    }
  }
  async processRunOperation(item) {
    clearTimeout(this.autoBatchTimeout);
    this.autoBatchTimeout = undefined;
    item.item = mergeRuntimeEnvIntoRun(item.item, this.cachedLSEnvVarsForMetadata, this.omitTracedRuntimeInfo);
    const itemPromise = this.autoBatchQueue.push(item);
    if (this.manualFlushMode) {
      return itemPromise;
    }
    const sizeLimitBytes = await this._getBatchSizeLimitBytes();
    const sizeLimit = await this._getBatchSizeLimit();
    if (this.autoBatchQueue.sizeBytes > sizeLimitBytes || this.autoBatchQueue.items.length > sizeLimit) {
      this.drainAutoBatchQueue({
        batchSizeLimitBytes: sizeLimitBytes,
        batchSizeLimit: sizeLimit
      });
    }
    if (this.autoBatchQueue.items.length > 0) {
      this.autoBatchTimeout = setTimeout(() => {
        this.autoBatchTimeout = undefined;
        this.drainAutoBatchQueue({
          batchSizeLimitBytes: sizeLimitBytes,
          batchSizeLimit: sizeLimit
        });
      }, this.autoBatchAggregationDelayMs);
    }
    return itemPromise;
  }
  async _getServerInfo() {
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/info`, {
        method: "GET",
        headers: { Accept: "application/json" },
        signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT_MS),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "get server info");
      return res;
    });
    const json = await response.json();
    if (this.debug) {
      console.log(`
=== LangSmith Server Configuration ===
` + JSON.stringify(json, null, 2) + `
`);
    }
    return json;
  }
  async _ensureServerInfo() {
    if (this._getServerInfoPromise === undefined) {
      this._getServerInfoPromise = (async () => {
        if (this._serverInfo === undefined) {
          try {
            this._serverInfo = await this._getServerInfo();
          } catch (e) {
            console.warn(`[LANGSMITH]: Failed to fetch info on supported operations. Falling back to batch operations and default limits. Info: ${e.status ?? "Unspecified status code"} ${e.message}`);
          }
        }
        return this._serverInfo ?? {};
      })();
    }
    return this._getServerInfoPromise.then((serverInfo) => {
      if (this._serverInfo === undefined) {
        this._getServerInfoPromise = undefined;
      }
      return serverInfo;
    });
  }
  async _getSettings() {
    if (!this.settings) {
      this.settings = this._get("/settings");
    }
    return await this.settings;
  }
  async flush() {
    const sizeLimitBytes = await this._getBatchSizeLimitBytes();
    const sizeLimit = await this._getBatchSizeLimit();
    await this.drainAutoBatchQueue({
      batchSizeLimitBytes: sizeLimitBytes,
      batchSizeLimit: sizeLimit
    });
  }
  _cloneCurrentOTELContext() {
    const otel_trace = getOTELTrace();
    const otel_context = getOTELContext();
    if (this.langSmithToOTELTranslator !== undefined) {
      const currentSpan = otel_trace.getActiveSpan();
      if (currentSpan) {
        return otel_trace.setSpan(otel_context.active(), currentSpan);
      }
    }
    return;
  }
  async createRun(run, options) {
    if (!this._filterForSampling([run]).length) {
      return;
    }
    const headers = {
      ...this.headers,
      "Content-Type": "application/json"
    };
    const session_name = run.project_name;
    delete run.project_name;
    const runCreate = await this.prepareRunCreateOrUpdateInputs({
      session_name,
      ...run,
      start_time: run.start_time ?? Date.now()
    });
    if (this.autoBatchTracing && runCreate.trace_id !== undefined && runCreate.dotted_order !== undefined) {
      const otelContext = this._cloneCurrentOTELContext();
      this.processRunOperation({
        action: "create",
        item: runCreate,
        otelContext,
        apiKey: options?.apiKey,
        apiUrl: options?.apiUrl
      }).catch(console.error);
      return;
    }
    const mergedRunCreateParam = mergeRuntimeEnvIntoRun(runCreate, this.cachedLSEnvVarsForMetadata, this.omitTracedRuntimeInfo);
    if (options?.apiKey !== undefined) {
      headers["x-api-key"] = options.apiKey;
    }
    if (options?.workspaceId !== undefined) {
      headers["x-tenant-id"] = options.workspaceId;
    }
    const body = serialize(mergedRunCreateParam, `Creating run with id: ${mergedRunCreateParam.id}`);
    await this.caller.call(async () => {
      const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs`, {
        method: "POST",
        headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "create run", true);
      return res;
    });
  }
  async batchIngestRuns({ runCreates, runUpdates }, options) {
    if (runCreates === undefined && runUpdates === undefined) {
      return;
    }
    let preparedCreateParams = await Promise.all(runCreates?.map((create) => this.prepareRunCreateOrUpdateInputs(create)) ?? []);
    let preparedUpdateParams = await Promise.all(runUpdates?.map((update) => this.prepareRunCreateOrUpdateInputs(update)) ?? []);
    if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
      const createById = preparedCreateParams.reduce((params, run) => {
        if (!run.id) {
          return params;
        }
        params[run.id] = run;
        return params;
      }, {});
      const standaloneUpdates = [];
      for (const updateParam of preparedUpdateParams) {
        if (updateParam.id !== undefined && createById[updateParam.id]) {
          createById[updateParam.id] = {
            ...createById[updateParam.id],
            ...updateParam
          };
        } else {
          standaloneUpdates.push(updateParam);
        }
      }
      preparedCreateParams = Object.values(createById);
      preparedUpdateParams = standaloneUpdates;
    }
    const rawBatch = {
      post: preparedCreateParams,
      patch: preparedUpdateParams
    };
    if (!rawBatch.post.length && !rawBatch.patch.length) {
      return;
    }
    const batchChunks = {
      post: [],
      patch: []
    };
    for (const k of ["post", "patch"]) {
      const key = k;
      const batchItems = rawBatch[key].reverse();
      let batchItem = batchItems.pop();
      while (batchItem !== undefined) {
        batchChunks[key].push(batchItem);
        batchItem = batchItems.pop();
      }
    }
    if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {
      const runIds = batchChunks.post.map((item) => item.id).concat(batchChunks.patch.map((item) => item.id)).join(",");
      await this._postBatchIngestRuns(serialize(batchChunks, `Ingesting runs with ids: ${runIds}`), options);
    }
  }
  async _postBatchIngestRuns(body, options) {
    const headers = {
      ...this.headers,
      "Content-Type": "application/json",
      Accept: "application/json"
    };
    if (options?.apiKey !== undefined) {
      headers["x-api-key"] = options.apiKey;
    }
    await this.batchIngestCaller.callWithOptions({ sizeBytes: options?.sizeBytes }, async () => {
      const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/batch`, {
        method: "POST",
        headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "batch create run", true);
      return res;
    });
  }
  async multipartIngestRuns({ runCreates, runUpdates }, options) {
    if (runCreates === undefined && runUpdates === undefined) {
      return;
    }
    const allAttachments = {};
    let preparedCreateParams = [];
    for (const create of runCreates ?? []) {
      const preparedCreate = await this.prepareRunCreateOrUpdateInputs(create);
      if (preparedCreate.id !== undefined && preparedCreate.attachments !== undefined) {
        allAttachments[preparedCreate.id] = preparedCreate.attachments;
      }
      delete preparedCreate.attachments;
      preparedCreateParams.push(preparedCreate);
    }
    let preparedUpdateParams = [];
    for (const update of runUpdates ?? []) {
      preparedUpdateParams.push(await this.prepareRunCreateOrUpdateInputs(update));
    }
    const invalidRunCreate = preparedCreateParams.find((runCreate) => {
      return runCreate.trace_id === undefined || runCreate.dotted_order === undefined;
    });
    if (invalidRunCreate !== undefined) {
      throw new Error(`Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run`);
    }
    const invalidRunUpdate = preparedUpdateParams.find((runUpdate) => {
      return runUpdate.trace_id === undefined || runUpdate.dotted_order === undefined;
    });
    if (invalidRunUpdate !== undefined) {
      throw new Error(`Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run`);
    }
    if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
      const createById = preparedCreateParams.reduce((params, run) => {
        if (!run.id) {
          return params;
        }
        params[run.id] = run;
        return params;
      }, {});
      const standaloneUpdates = [];
      for (const updateParam of preparedUpdateParams) {
        if (updateParam.id !== undefined && createById[updateParam.id]) {
          createById[updateParam.id] = {
            ...createById[updateParam.id],
            ...updateParam
          };
        } else {
          standaloneUpdates.push(updateParam);
        }
      }
      preparedCreateParams = Object.values(createById);
      preparedUpdateParams = standaloneUpdates;
    }
    if (preparedCreateParams.length === 0 && preparedUpdateParams.length === 0) {
      return;
    }
    const accumulatedContext = [];
    const accumulatedParts = [];
    for (const [method, payloads] of [
      ["post", preparedCreateParams],
      ["patch", preparedUpdateParams]
    ]) {
      for (const originalPayload of payloads) {
        const { inputs, outputs, events, extra, error, serialized, attachments, ...payload } = originalPayload;
        const fields = { inputs, outputs, events, extra, error, serialized };
        const stringifiedPayload = serialize(payload, `Serializing for multipart ingestion of run with id: ${payload.id}`);
        accumulatedParts.push({
          name: `${method}.${payload.id}`,
          payload: new Blob([stringifiedPayload], {
            type: `application/json; length=${stringifiedPayload.length}`
          })
        });
        for (const [key, value] of Object.entries(fields)) {
          if (value === undefined) {
            continue;
          }
          const stringifiedValue = serialize(value, `Serializing ${key} for multipart ingestion of run with id: ${payload.id}`);
          accumulatedParts.push({
            name: `${method}.${payload.id}.${key}`,
            payload: new Blob([stringifiedValue], {
              type: `application/json; length=${stringifiedValue.length}`
            })
          });
        }
        if (payload.id !== undefined) {
          const attachments2 = allAttachments[payload.id];
          if (attachments2) {
            delete allAttachments[payload.id];
            for (const [name, attachment] of Object.entries(attachments2)) {
              let contentType;
              let content;
              if (Array.isArray(attachment)) {
                [contentType, content] = attachment;
              } else {
                contentType = attachment.mimeType;
                content = attachment.data;
              }
              if (name.includes(".")) {
                console.warn(`Skipping attachment '${name}' for run ${payload.id}: Invalid attachment name. ` + `Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
                continue;
              }
              accumulatedParts.push({
                name: `attachment.${payload.id}.${name}`,
                payload: new Blob([content], {
                  type: `${contentType}; length=${content.byteLength}`
                })
              });
            }
          }
        }
        accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);
      }
    }
    await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join("; "), options);
  }
  async _createNodeFetchBody(parts, boundary) {
    const chunks = [];
    for (const part of parts) {
      chunks.push(new Blob([`--${boundary}\r
`]));
      chunks.push(new Blob([
        `Content-Disposition: form-data; name="${part.name}"\r
`,
        `Content-Type: ${part.payload.type}\r
\r
`
      ]));
      chunks.push(part.payload);
      chunks.push(new Blob([`\r
`]));
    }
    chunks.push(new Blob([`--${boundary}--\r
`]));
    const body = new Blob(chunks);
    const arrayBuffer = await body.arrayBuffer();
    return arrayBuffer;
  }
  async _createMultipartStream(parts, boundary) {
    const encoder2 = new TextEncoder;
    const stream = new ReadableStream({
      async start(controller) {
        const writeChunk = async (chunk) => {
          if (typeof chunk === "string") {
            controller.enqueue(encoder2.encode(chunk));
          } else {
            controller.enqueue(chunk);
          }
        };
        for (const part of parts) {
          await writeChunk(`--${boundary}\r
`);
          await writeChunk(`Content-Disposition: form-data; name="${part.name}"\r
`);
          await writeChunk(`Content-Type: ${part.payload.type}\r
\r
`);
          const payloadStream = part.payload.stream();
          const reader = payloadStream.getReader();
          try {
            let result;
            while (!(result = await reader.read()).done) {
              controller.enqueue(result.value);
            }
          } finally {
            reader.releaseLock();
          }
          await writeChunk(`\r
`);
        }
        await writeChunk(`--${boundary}--\r
`);
        controller.close();
      }
    });
    return stream;
  }
  async _sendMultipartRequest(parts, context, options) {
    const boundary = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2);
    const isNodeFetch = _globalFetchImplementationIsNodeFetch();
    const buildBuffered = () => this._createNodeFetchBody(parts, boundary);
    const buildStream = () => this._createMultipartStream(parts, boundary);
    const sendWithRetry = async (bodyFactory) => {
      return this.batchIngestCaller.callWithOptions({ sizeBytes: options?.sizeBytes }, async () => {
        const body = await bodyFactory();
        const headers = {
          ...this.headers,
          "Content-Type": `multipart/form-data; boundary=${boundary}`
        };
        if (options?.apiKey !== undefined) {
          headers["x-api-key"] = options.apiKey;
        }
        let transformedBody = body;
        if (options?.useGzip && typeof body === "object" && "pipeThrough" in body) {
          transformedBody = body.pipeThrough(new CompressionStream("gzip"));
          headers["Content-Encoding"] = "gzip";
        }
        const response = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/multipart`, {
          method: "POST",
          headers,
          body: transformedBody,
          duplex: "half",
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        await raiseForStatus(response, `Failed to send multipart request`, true);
        return response;
      });
    };
    try {
      let res;
      let streamedAttempt = false;
      if (!isNodeFetch && !this.multipartStreamingDisabled && getEnv2() !== "bun") {
        streamedAttempt = true;
        res = await sendWithRetry(buildStream);
      } else {
        res = await sendWithRetry(buildBuffered);
      }
      if ((!this.multipartStreamingDisabled || streamedAttempt) && res.status === 422 && (options?.apiUrl ?? this.apiUrl) !== DEFAULT_API_URL) {
        console.warn(`Streaming multipart upload to ${options?.apiUrl ?? this.apiUrl}/runs/multipart failed. ` + `This usually means the host does not support chunked uploads. ` + `Retrying with a buffered upload for operation "${context}".`);
        this.multipartStreamingDisabled = true;
        res = await sendWithRetry(buildBuffered);
      }
    } catch (e) {
      console.warn(`${e.message.trim()}

Context: ${context}`);
    }
  }
  async updateRun(runId, run, options) {
    assertUuid(runId);
    if (run.inputs) {
      run.inputs = await this.processInputs(run.inputs);
    }
    if (run.outputs) {
      run.outputs = await this.processOutputs(run.outputs);
    }
    const data = { ...run, id: runId };
    if (!this._filterForSampling([data], true).length) {
      return;
    }
    if (this.autoBatchTracing && data.trace_id !== undefined && data.dotted_order !== undefined) {
      const otelContext = this._cloneCurrentOTELContext();
      if (run.end_time !== undefined && data.parent_run_id === undefined && this.blockOnRootRunFinalization && !this.manualFlushMode) {
        await this.processRunOperation({
          action: "update",
          item: data,
          otelContext,
          apiKey: options?.apiKey,
          apiUrl: options?.apiUrl
        }).catch(console.error);
        return;
      } else {
        this.processRunOperation({
          action: "update",
          item: data,
          otelContext,
          apiKey: options?.apiKey,
          apiUrl: options?.apiUrl
        }).catch(console.error);
      }
      return;
    }
    const headers = {
      ...this.headers,
      "Content-Type": "application/json"
    };
    if (options?.apiKey !== undefined) {
      headers["x-api-key"] = options.apiKey;
    }
    if (options?.workspaceId !== undefined) {
      headers["x-tenant-id"] = options.workspaceId;
    }
    const body = serialize(run, `Serializing payload to update run with id: ${runId}`);
    await this.caller.call(async () => {
      const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/${runId}`, {
        method: "PATCH",
        headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "update run", true);
      return res;
    });
  }
  async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {
    assertUuid(runId);
    let run = await this._get(`/runs/${runId}`);
    if (loadChildRuns) {
      run = await this._loadChildRuns(run);
    }
    return run;
  }
  async getRunUrl({ runId, run, projectOpts }) {
    if (run !== undefined) {
      let sessionId;
      if (run.session_id) {
        sessionId = run.session_id;
      } else if (projectOpts?.projectName) {
        sessionId = (await this.readProject({ projectName: projectOpts?.projectName })).id;
      } else if (projectOpts?.projectId) {
        sessionId = projectOpts?.projectId;
      } else {
        const project = await this.readProject({
          projectName: getLangSmithEnvironmentVariable("PROJECT") || "default"
        });
        sessionId = project.id;
      }
      const tenantId = await this._getTenantId();
      return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;
    } else if (runId !== undefined) {
      const run_ = await this.readRun(runId);
      if (!run_.app_path) {
        throw new Error(`Run ${runId} has no app_path`);
      }
      const baseUrl = this.getHostUrl();
      return `${baseUrl}${run_.app_path}`;
    } else {
      throw new Error("Must provide either runId or run");
    }
  }
  async _loadChildRuns(run) {
    const childRuns = await toArray(this.listRuns({
      isRoot: false,
      projectId: run.session_id,
      traceId: run.trace_id
    }));
    const treemap = {};
    const runs = {};
    childRuns.sort((a, b) => (a?.dotted_order ?? "").localeCompare(b?.dotted_order ?? ""));
    for (const childRun of childRuns) {
      if (childRun.parent_run_id === null || childRun.parent_run_id === undefined) {
        throw new Error(`Child run ${childRun.id} has no parent`);
      }
      if (childRun.dotted_order?.startsWith(run.dotted_order ?? "") && childRun.id !== run.id) {
        if (!(childRun.parent_run_id in treemap)) {
          treemap[childRun.parent_run_id] = [];
        }
        treemap[childRun.parent_run_id].push(childRun);
        runs[childRun.id] = childRun;
      }
    }
    run.child_runs = treemap[run.id] || [];
    for (const runId in treemap) {
      if (runId !== run.id) {
        runs[runId].child_runs = treemap[runId];
      }
    }
    return run;
  }
  async* listRuns(props) {
    const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select, order } = props;
    let projectIds = [];
    if (projectId) {
      projectIds = Array.isArray(projectId) ? projectId : [projectId];
    }
    if (projectName) {
      const projectNames = Array.isArray(projectName) ? projectName : [projectName];
      const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));
      projectIds.push(...projectIds_);
    }
    const default_select = [
      "app_path",
      "completion_cost",
      "completion_tokens",
      "dotted_order",
      "end_time",
      "error",
      "events",
      "extra",
      "feedback_stats",
      "first_token_time",
      "id",
      "inputs",
      "name",
      "outputs",
      "parent_run_id",
      "parent_run_ids",
      "prompt_cost",
      "prompt_tokens",
      "reference_example_id",
      "run_type",
      "session_id",
      "start_time",
      "status",
      "tags",
      "total_cost",
      "total_tokens",
      "trace_id"
    ];
    const body = {
      session: projectIds.length ? projectIds : null,
      run_type: runType,
      reference_example: referenceExampleId,
      query,
      filter,
      trace_filter: traceFilter,
      tree_filter: treeFilter,
      execution_order: executionOrder,
      parent_run: parentRunId,
      start_time: startTime ? startTime.toISOString() : null,
      error,
      id,
      limit,
      trace: traceId,
      select: select ? select : default_select,
      is_root: isRoot,
      order
    };
    if (body.select.includes("child_run_ids")) {
      warnOnce("Deprecated: 'child_run_ids' in the listRuns select parameter is deprecated and will be removed in a future version.");
    }
    let runsYielded = 0;
    for await (const runs of this._getCursorPaginatedList("/runs/query", body)) {
      if (limit) {
        if (runsYielded >= limit) {
          break;
        }
        if (runs.length + runsYielded > limit) {
          const newRuns = runs.slice(0, limit - runsYielded);
          yield* newRuns;
          break;
        }
        runsYielded += runs.length;
        yield* runs;
      } else {
        yield* runs;
      }
    }
  }
  async* listGroupRuns(props) {
    const { projectId, projectName, groupBy, filter, startTime, endTime, limit, offset } = props;
    const sessionId = projectId || (await this.readProject({ projectName })).id;
    const baseBody = {
      session_id: sessionId,
      group_by: groupBy,
      filter,
      start_time: startTime ? startTime.toISOString() : null,
      end_time: endTime ? endTime.toISOString() : null,
      limit: Number(limit) || 100
    };
    let currentOffset = Number(offset) || 0;
    const path = "/runs/group";
    const url = `${this.apiUrl}${path}`;
    while (true) {
      const currentBody = {
        ...baseBody,
        offset: currentOffset
      };
      const filteredPayload = Object.fromEntries(Object.entries(currentBody).filter(([_, value]) => value !== undefined));
      const body = JSON.stringify(filteredPayload);
      const response = await this.caller.call(async () => {
        const res = await this._fetch(url, {
          method: "POST",
          headers: { ...this.headers, "Content-Type": "application/json" },
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions,
          body
        });
        await raiseForStatus(res, `Failed to fetch ${path}`);
        return res;
      });
      const items = await response.json();
      const { groups, total } = items;
      if (groups.length === 0) {
        break;
      }
      for (const thread of groups) {
        yield thread;
      }
      currentOffset += groups.length;
      if (currentOffset >= total) {
        break;
      }
    }
  }
  async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType }) {
    let projectIds_ = projectIds || [];
    if (projectNames) {
      projectIds_ = [
        ...projectIds || [],
        ...await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)))
      ];
    }
    const payload = {
      id,
      trace,
      parent_run: parentRun,
      run_type: runType,
      session: projectIds_,
      reference_example: referenceExampleIds,
      start_time: startTime,
      end_time: endTime,
      error,
      query,
      filter,
      trace_filter: traceFilter,
      tree_filter: treeFilter,
      is_root: isRoot,
      data_source_type: dataSourceType
    };
    const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value]) => value !== undefined));
    const body = JSON.stringify(filteredPayload);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/runs/stats`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "get run stats");
      return res;
    });
    const result = await response.json();
    return result;
  }
  async shareRun(runId, { shareId } = {}) {
    const data = {
      run_id: runId,
      share_token: shareId || v4()
    };
    assertUuid(runId);
    const body = JSON.stringify(data);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {
        method: "PUT",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "share run");
      return res;
    });
    const result = await response.json();
    if (result === null || !("share_token" in result)) {
      throw new Error("Invalid response from server");
    }
    return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
  }
  async unshareRun(runId) {
    assertUuid(runId);
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "unshare run", true);
      return res;
    });
  }
  async readRunSharedLink(runId) {
    assertUuid(runId);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "read run shared link");
      return res;
    });
    const result = await response.json();
    if (result === null || !("share_token" in result)) {
      return;
    }
    return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
  }
  async listSharedRuns(shareToken, { runIds } = {}) {
    const queryParams = new URLSearchParams({
      share_token: shareToken
    });
    if (runIds !== undefined) {
      for (const runId of runIds) {
        queryParams.append("id", runId);
      }
    }
    assertUuid(shareToken);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "list shared runs");
      return res;
    });
    const runs = await response.json();
    return runs;
  }
  async readDatasetSharedSchema(datasetId, datasetName) {
    if (!datasetId && !datasetName) {
      throw new Error("Either datasetId or datasetName must be given");
    }
    if (!datasetId) {
      const dataset = await this.readDataset({ datasetName });
      datasetId = dataset.id;
    }
    assertUuid(datasetId);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "read dataset shared schema");
      return res;
    });
    const shareSchema = await response.json();
    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
    return shareSchema;
  }
  async shareDataset(datasetId, datasetName) {
    if (!datasetId && !datasetName) {
      throw new Error("Either datasetId or datasetName must be given");
    }
    if (!datasetId) {
      const dataset = await this.readDataset({ datasetName });
      datasetId = dataset.id;
    }
    const data = {
      dataset_id: datasetId
    };
    assertUuid(datasetId);
    const body = JSON.stringify(data);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {
        method: "PUT",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "share dataset");
      return res;
    });
    const shareSchema = await response.json();
    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
    return shareSchema;
  }
  async unshareDataset(datasetId) {
    assertUuid(datasetId);
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "unshare dataset", true);
      return res;
    });
  }
  async readSharedDataset(shareToken) {
    assertUuid(shareToken);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/datasets`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "read shared dataset");
      return res;
    });
    const dataset = await response.json();
    return dataset;
  }
  async listSharedExamples(shareToken, options) {
    const params = {};
    if (options?.exampleIds) {
      params.id = options.exampleIds;
    }
    const urlParams = new URLSearchParams;
    Object.entries(params).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach((v) => urlParams.append(key, v));
      } else {
        urlParams.append(key, value);
      }
    });
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "list shared examples");
      return res;
    });
    const result = await response.json();
    if (!response.ok) {
      if ("detail" in result) {
        throw new Error(`Failed to list shared examples.
Status: ${response.status}
Message: ${Array.isArray(result.detail) ? result.detail.join(`
`) : "Unspecified error"}`);
      }
      throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);
    }
    return result.map((example) => ({
      ...example,
      _hostUrl: this.getHostUrl()
    }));
  }
  async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {
    const upsert_ = upsert ? `?upsert=true` : "";
    const endpoint = `${this.apiUrl}/sessions${upsert_}`;
    const extra = projectExtra || {};
    if (metadata) {
      extra["metadata"] = metadata;
    }
    const body = {
      name: projectName,
      extra,
      description
    };
    if (referenceDatasetId !== null) {
      body["reference_dataset_id"] = referenceDatasetId;
    }
    const serializedBody = JSON.stringify(body);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(endpoint, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: serializedBody
      });
      await raiseForStatus(res, "create project");
      return res;
    });
    const result = await response.json();
    return result;
  }
  async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {
    const endpoint = `${this.apiUrl}/sessions/${projectId}`;
    let extra = projectExtra;
    if (metadata) {
      extra = { ...extra || {}, metadata };
    }
    const body = JSON.stringify({
      name,
      extra,
      description,
      end_time: endTime ? new Date(endTime).toISOString() : null
    });
    const response = await this.caller.call(async () => {
      const res = await this._fetch(endpoint, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "update project");
      return res;
    });
    const result = await response.json();
    return result;
  }
  async hasProject({ projectId, projectName }) {
    let path = "/sessions";
    const params = new URLSearchParams;
    if (projectId !== undefined && projectName !== undefined) {
      throw new Error("Must provide either projectName or projectId, not both");
    } else if (projectId !== undefined) {
      assertUuid(projectId);
      path += `/${projectId}`;
    } else if (projectName !== undefined) {
      params.append("name", projectName);
    } else {
      throw new Error("Must provide projectName or projectId");
    }
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}${path}?${params}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "has project");
      return res;
    });
    try {
      const result = await response.json();
      if (!response.ok) {
        return false;
      }
      if (Array.isArray(result)) {
        return result.length > 0;
      }
      return true;
    } catch (e) {
      return false;
    }
  }
  async readProject({ projectId, projectName, includeStats }) {
    let path = "/sessions";
    const params = new URLSearchParams;
    if (projectId !== undefined && projectName !== undefined) {
      throw new Error("Must provide either projectName or projectId, not both");
    } else if (projectId !== undefined) {
      assertUuid(projectId);
      path += `/${projectId}`;
    } else if (projectName !== undefined) {
      params.append("name", projectName);
    } else {
      throw new Error("Must provide projectName or projectId");
    }
    if (includeStats !== undefined) {
      params.append("include_stats", includeStats.toString());
    }
    const response = await this._get(path, params);
    let result;
    if (Array.isArray(response)) {
      if (response.length === 0) {
        throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);
      }
      result = response[0];
    } else {
      result = response;
    }
    return result;
  }
  async getProjectUrl({ projectId, projectName }) {
    if (projectId === undefined && projectName === undefined) {
      throw new Error("Must provide either projectName or projectId");
    }
    const project = await this.readProject({ projectId, projectName });
    const tenantId = await this._getTenantId();
    return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;
  }
  async getDatasetUrl({ datasetId, datasetName }) {
    if (datasetId === undefined && datasetName === undefined) {
      throw new Error("Must provide either datasetName or datasetId");
    }
    const dataset = await this.readDataset({ datasetId, datasetName });
    const tenantId = await this._getTenantId();
    return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;
  }
  async _getTenantId() {
    if (this._tenantId !== null) {
      return this._tenantId;
    }
    const queryParams = new URLSearchParams({ limit: "1" });
    for await (const projects of this._getPaginated("/sessions", queryParams)) {
      this._tenantId = projects[0].tenant_id;
      return projects[0].tenant_id;
    }
    throw new Error("No projects found to resolve tenant.");
  }
  async* listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, includeStats, datasetVersion, referenceFree, metadata } = {}) {
    const params = new URLSearchParams;
    if (projectIds !== undefined) {
      for (const projectId of projectIds) {
        params.append("id", projectId);
      }
    }
    if (name !== undefined) {
      params.append("name", name);
    }
    if (nameContains !== undefined) {
      params.append("name_contains", nameContains);
    }
    if (referenceDatasetId !== undefined) {
      params.append("reference_dataset", referenceDatasetId);
    } else if (referenceDatasetName !== undefined) {
      const dataset = await this.readDataset({
        datasetName: referenceDatasetName
      });
      params.append("reference_dataset", dataset.id);
    }
    if (includeStats !== undefined) {
      params.append("include_stats", includeStats.toString());
    }
    if (datasetVersion !== undefined) {
      params.append("dataset_version", datasetVersion);
    }
    if (referenceFree !== undefined) {
      params.append("reference_free", referenceFree.toString());
    }
    if (metadata !== undefined) {
      params.append("metadata", JSON.stringify(metadata));
    }
    for await (const projects of this._getPaginated("/sessions", params)) {
      yield* projects;
    }
  }
  async deleteProject({ projectId, projectName }) {
    let projectId_;
    if (projectId === undefined && projectName === undefined) {
      throw new Error("Must provide projectName or projectId");
    } else if (projectId !== undefined && projectName !== undefined) {
      throw new Error("Must provide either projectName or projectId, not both");
    } else if (projectId === undefined) {
      projectId_ = (await this.readProject({ projectName })).id;
    } else {
      projectId_ = projectId;
    }
    assertUuid(projectId_);
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/sessions/${projectId_}`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, `delete session ${projectId_} (${projectName})`, true);
      return res;
    });
  }
  async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {
    const url = `${this.apiUrl}/datasets/upload`;
    const formData = new FormData;
    formData.append("file", csvFile, fileName);
    inputKeys.forEach((key) => {
      formData.append("input_keys", key);
    });
    outputKeys.forEach((key) => {
      formData.append("output_keys", key);
    });
    if (description) {
      formData.append("description", description);
    }
    if (dataType) {
      formData.append("data_type", dataType);
    }
    if (name) {
      formData.append("name", name);
    }
    const response = await this.caller.call(async () => {
      const res = await this._fetch(url, {
        method: "POST",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: formData
      });
      await raiseForStatus(res, "upload CSV");
      return res;
    });
    const result = await response.json();
    return result;
  }
  async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata } = {}) {
    const body = {
      name,
      description,
      extra: metadata ? { metadata } : undefined
    };
    if (dataType) {
      body.data_type = dataType;
    }
    if (inputsSchema) {
      body.inputs_schema_definition = inputsSchema;
    }
    if (outputsSchema) {
      body.outputs_schema_definition = outputsSchema;
    }
    const serializedBody = JSON.stringify(body);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: serializedBody
      });
      await raiseForStatus(res, "create dataset");
      return res;
    });
    const result = await response.json();
    return result;
  }
  async readDataset({ datasetId, datasetName }) {
    let path = "/datasets";
    const params = new URLSearchParams({ limit: "1" });
    if (datasetId && datasetName) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId) {
      assertUuid(datasetId);
      path += `/${datasetId}`;
    } else if (datasetName) {
      params.append("name", datasetName);
    } else {
      throw new Error("Must provide datasetName or datasetId");
    }
    const response = await this._get(path, params);
    let result;
    if (Array.isArray(response)) {
      if (response.length === 0) {
        throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);
      }
      result = response[0];
    } else {
      result = response;
    }
    return result;
  }
  async hasDataset({ datasetId, datasetName }) {
    try {
      await this.readDataset({ datasetId, datasetName });
      return true;
    } catch (e) {
      if (e instanceof Error && e.message.toLocaleLowerCase().includes("not found")) {
        return false;
      }
      throw e;
    }
  }
  async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion }) {
    let datasetId_ = datasetId;
    if (datasetId_ === undefined && datasetName === undefined) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ !== undefined && datasetName !== undefined) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId_ === undefined) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    }
    const urlParams = new URLSearchParams({
      from_version: typeof fromVersion === "string" ? fromVersion : fromVersion.toISOString(),
      to_version: typeof toVersion === "string" ? toVersion : toVersion.toISOString()
    });
    const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);
    return response;
  }
  async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {
    const path = "/datasets";
    if (datasetId !== undefined) {} else if (datasetName !== undefined) {
      datasetId = (await this.readDataset({ datasetName })).id;
    } else {
      throw new Error("Must provide either datasetName or datasetId");
    }
    const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);
    const datasetText = await response.text();
    const dataset = datasetText.trim().split(`
`).map((line) => JSON.parse(line));
    return dataset;
  }
  async* listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata } = {}) {
    const path = "/datasets";
    const params = new URLSearchParams({
      limit: limit.toString(),
      offset: offset.toString()
    });
    if (datasetIds !== undefined) {
      for (const id_ of datasetIds) {
        params.append("id", id_);
      }
    }
    if (datasetName !== undefined) {
      params.append("name", datasetName);
    }
    if (datasetNameContains !== undefined) {
      params.append("name_contains", datasetNameContains);
    }
    if (metadata !== undefined) {
      params.append("metadata", JSON.stringify(metadata));
    }
    for await (const datasets of this._getPaginated(path, params)) {
      yield* datasets;
    }
  }
  async updateDataset(props) {
    const { datasetId, datasetName, ...update } = props;
    if (!datasetId && !datasetName) {
      throw new Error("Must provide either datasetName or datasetId");
    }
    const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;
    assertUuid(_datasetId);
    const body = JSON.stringify(update);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "update dataset");
      return res;
    });
    return await response.json();
  }
  async updateDatasetTag(props) {
    const { datasetId, datasetName, asOf, tag } = props;
    if (!datasetId && !datasetName) {
      throw new Error("Must provide either datasetName or datasetId");
    }
    const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;
    assertUuid(_datasetId);
    const body = JSON.stringify({
      as_of: typeof asOf === "string" ? asOf : asOf.toISOString(),
      tag
    });
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}/tags`, {
        method: "PUT",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "update dataset tags", true);
      return res;
    });
  }
  async deleteDataset({ datasetId, datasetName }) {
    let path = "/datasets";
    let datasetId_ = datasetId;
    if (datasetId !== undefined && datasetName !== undefined) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetName !== undefined) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    }
    if (datasetId_ !== undefined) {
      assertUuid(datasetId_);
      path += `/${datasetId_}`;
    } else {
      throw new Error("Must provide datasetName or datasetId");
    }
    await this.caller.call(async () => {
      const res = await this._fetch(this.apiUrl + path, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, `delete ${path}`, true);
      return res;
    });
  }
  async indexDataset({ datasetId, datasetName, tag }) {
    let datasetId_ = datasetId;
    if (!datasetId_ && !datasetName) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ && datasetName) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (!datasetId_) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    }
    assertUuid(datasetId_);
    const data = {
      tag
    };
    const body = JSON.stringify(data);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/index`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "index dataset");
      return res;
    });
    await response.json();
  }
  async similarExamples(inputs, datasetId, limit, { filter } = {}) {
    const data = {
      limit,
      inputs
    };
    if (filter !== undefined) {
      data["filter"] = filter;
    }
    assertUuid(datasetId);
    const body = JSON.stringify(data);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/search`, {
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        method: "POST",
        body
      });
      await raiseForStatus(res, "fetch similar examples");
      return res;
    });
    const result = await response.json();
    return result["examples"];
  }
  async createExample(inputsOrUpdate, outputs, options) {
    if (isExampleCreate(inputsOrUpdate)) {
      if (outputs !== undefined || options !== undefined) {
        throw new Error("Cannot provide outputs or options when using ExampleCreate object");
      }
    }
    let datasetId_ = outputs ? options?.datasetId : inputsOrUpdate.dataset_id;
    const datasetName_ = outputs ? options?.datasetName : inputsOrUpdate.dataset_name;
    if (datasetId_ === undefined && datasetName_ === undefined) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ !== undefined && datasetName_ !== undefined) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId_ === undefined) {
      const dataset = await this.readDataset({ datasetName: datasetName_ });
      datasetId_ = dataset.id;
    }
    const createdAt_ = (outputs ? options?.createdAt : inputsOrUpdate.created_at) || new Date;
    let data;
    if (!isExampleCreate(inputsOrUpdate)) {
      data = {
        inputs: inputsOrUpdate,
        outputs,
        created_at: createdAt_?.toISOString(),
        id: options?.exampleId,
        metadata: options?.metadata,
        split: options?.split,
        source_run_id: options?.sourceRunId,
        use_source_run_io: options?.useSourceRunIO,
        use_source_run_attachments: options?.useSourceRunAttachments,
        attachments: options?.attachments
      };
    } else {
      data = inputsOrUpdate;
    }
    const response = await this._uploadExamplesMultipart(datasetId_, [data]);
    const example = await this.readExample(response.example_ids?.[0] ?? v4());
    return example;
  }
  async createExamples(propsOrUploads) {
    if (Array.isArray(propsOrUploads)) {
      if (propsOrUploads.length === 0) {
        return [];
      }
      const uploads = propsOrUploads;
      let datasetId_2 = uploads[0].dataset_id;
      const datasetName_2 = uploads[0].dataset_name;
      if (datasetId_2 === undefined && datasetName_2 === undefined) {
        throw new Error("Must provide either datasetName or datasetId");
      } else if (datasetId_2 !== undefined && datasetName_2 !== undefined) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId_2 === undefined) {
        const dataset = await this.readDataset({ datasetName: datasetName_2 });
        datasetId_2 = dataset.id;
      }
      const response2 = await this._uploadExamplesMultipart(datasetId_2, uploads);
      const examples2 = await Promise.all(response2.example_ids.map((id) => this.readExample(id)));
      return examples2;
    }
    const { inputs, outputs, metadata, splits, sourceRunIds, useSourceRunIOs, useSourceRunAttachments, attachments, exampleIds, datasetId, datasetName } = propsOrUploads;
    if (inputs === undefined) {
      throw new Error("Must provide inputs when using legacy parameters");
    }
    let datasetId_ = datasetId;
    const datasetName_ = datasetName;
    if (datasetId_ === undefined && datasetName_ === undefined) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ !== undefined && datasetName_ !== undefined) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId_ === undefined) {
      const dataset = await this.readDataset({ datasetName: datasetName_ });
      datasetId_ = dataset.id;
    }
    const formattedExamples = inputs.map((input, idx) => {
      return {
        dataset_id: datasetId_,
        inputs: input,
        outputs: outputs?.[idx],
        metadata: metadata?.[idx],
        split: splits?.[idx],
        id: exampleIds?.[idx],
        attachments: attachments?.[idx],
        source_run_id: sourceRunIds?.[idx],
        use_source_run_io: useSourceRunIOs?.[idx],
        use_source_run_attachments: useSourceRunAttachments?.[idx]
      };
    });
    const response = await this._uploadExamplesMultipart(datasetId_, formattedExamples);
    const examples = await Promise.all(response.example_ids.map((id) => this.readExample(id)));
    return examples;
  }
  async createLLMExample(input, generation, options) {
    return this.createExample({ input }, { output: generation }, options);
  }
  async createChatExample(input, generations, options) {
    const finalInput = input.map((message) => {
      if (isLangChainMessage(message)) {
        return convertLangChainMessageToExample(message);
      }
      return message;
    });
    const finalOutput = isLangChainMessage(generations) ? convertLangChainMessageToExample(generations) : generations;
    return this.createExample({ input: finalInput }, { output: finalOutput }, options);
  }
  async readExample(exampleId) {
    assertUuid(exampleId);
    const path = `/examples/${exampleId}`;
    const rawExample = await this._get(path);
    const { attachment_urls, ...rest } = rawExample;
    const example = rest;
    if (attachment_urls) {
      example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {
        acc[key.slice("attachment.".length)] = {
          presigned_url: value.presigned_url,
          mime_type: value.mime_type
        };
        return acc;
      }, {});
    }
    return example;
  }
  async* listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter, includeAttachments } = {}) {
    let datasetId_;
    if (datasetId !== undefined && datasetName !== undefined) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId !== undefined) {
      datasetId_ = datasetId;
    } else if (datasetName !== undefined) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    } else {
      throw new Error("Must provide a datasetName or datasetId");
    }
    const params = new URLSearchParams({ dataset: datasetId_ });
    const dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf?.toISOString() : undefined;
    if (dataset_version) {
      params.append("as_of", dataset_version);
    }
    const inlineS3Urls_ = inlineS3Urls ?? true;
    params.append("inline_s3_urls", inlineS3Urls_.toString());
    if (exampleIds !== undefined) {
      for (const id_ of exampleIds) {
        params.append("id", id_);
      }
    }
    if (splits !== undefined) {
      for (const split of splits) {
        params.append("splits", split);
      }
    }
    if (metadata !== undefined) {
      const serializedMetadata = JSON.stringify(metadata);
      params.append("metadata", serializedMetadata);
    }
    if (limit !== undefined) {
      params.append("limit", limit.toString());
    }
    if (offset !== undefined) {
      params.append("offset", offset.toString());
    }
    if (filter !== undefined) {
      params.append("filter", filter);
    }
    if (includeAttachments === true) {
      ["attachment_urls", "outputs", "metadata"].forEach((field) => params.append("select", field));
    }
    let i = 0;
    for await (const rawExamples of this._getPaginated("/examples", params)) {
      for (const rawExample of rawExamples) {
        const { attachment_urls, ...rest } = rawExample;
        const example = rest;
        if (attachment_urls) {
          example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {
            acc[key.slice("attachment.".length)] = {
              presigned_url: value.presigned_url,
              mime_type: value.mime_type || undefined
            };
            return acc;
          }, {});
        }
        yield example;
        i++;
      }
      if (limit !== undefined && i >= limit) {
        break;
      }
    }
  }
  async deleteExample(exampleId) {
    assertUuid(exampleId);
    const path = `/examples/${exampleId}`;
    await this.caller.call(async () => {
      const res = await this._fetch(this.apiUrl + path, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, `delete ${path}`, true);
      return res;
    });
  }
  async deleteExamples(exampleIds, options) {
    exampleIds.forEach((id) => assertUuid(id));
    if (options?.hardDelete) {
      const path = this._getPlatformEndpointPath("datasets/examples/delete");
      await this.caller.call(async () => {
        const res = await this._fetch(`${this.apiUrl}${path}`, {
          method: "POST",
          headers: { ...this.headers, "Content-Type": "application/json" },
          body: JSON.stringify({
            example_ids: exampleIds,
            hard_delete: true
          }),
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        await raiseForStatus(res, "hard delete examples", true);
        return res;
      });
    } else {
      const params = new URLSearchParams;
      exampleIds.forEach((id) => params.append("example_ids", id));
      await this.caller.call(async () => {
        const res = await this._fetch(`${this.apiUrl}/examples?${params.toString()}`, {
          method: "DELETE",
          headers: this.headers,
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        await raiseForStatus(res, "delete examples", true);
        return res;
      });
    }
  }
  async updateExample(exampleIdOrUpdate, update) {
    let exampleId;
    if (update) {
      exampleId = exampleIdOrUpdate;
    } else {
      exampleId = exampleIdOrUpdate.id;
    }
    assertUuid(exampleId);
    let updateToUse;
    if (update) {
      updateToUse = { id: exampleId, ...update };
    } else {
      updateToUse = exampleIdOrUpdate;
    }
    let datasetId;
    if (updateToUse.dataset_id !== undefined) {
      datasetId = updateToUse.dataset_id;
    } else {
      const example = await this.readExample(exampleId);
      datasetId = example.dataset_id;
    }
    return this._updateExamplesMultipart(datasetId, [updateToUse]);
  }
  async updateExamples(update) {
    let datasetId;
    if (update[0].dataset_id === undefined) {
      const example = await this.readExample(update[0].id);
      datasetId = example.dataset_id;
    } else {
      datasetId = update[0].dataset_id;
    }
    return this._updateExamplesMultipart(datasetId, update);
  }
  async readDatasetVersion({ datasetId, datasetName, asOf, tag }) {
    let resolvedDatasetId;
    if (!datasetId) {
      const dataset = await this.readDataset({ datasetName });
      resolvedDatasetId = dataset.id;
    } else {
      resolvedDatasetId = datasetId;
    }
    assertUuid(resolvedDatasetId);
    if (asOf && tag || !asOf && !tag) {
      throw new Error("Exactly one of asOf and tag must be specified.");
    }
    const params = new URLSearchParams;
    if (asOf !== undefined) {
      params.append("as_of", typeof asOf === "string" ? asOf : asOf.toISOString());
    }
    if (tag !== undefined) {
      params.append("tag", tag);
    }
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${resolvedDatasetId}/version?${params.toString()}`, {
        method: "GET",
        headers: { ...this.headers },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "read dataset version");
      return res;
    });
    return await response.json();
  }
  async listDatasetSplits({ datasetId, datasetName, asOf }) {
    let datasetId_;
    if (datasetId === undefined && datasetName === undefined) {
      throw new Error("Must provide dataset name or ID");
    } else if (datasetId !== undefined && datasetName !== undefined) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId === undefined) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    } else {
      datasetId_ = datasetId;
    }
    assertUuid(datasetId_);
    const params = new URLSearchParams;
    const dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf?.toISOString() : undefined;
    if (dataset_version) {
      params.append("as_of", dataset_version);
    }
    const response = await this._get(`/datasets/${datasetId_}/splits`, params);
    return response;
  }
  async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false }) {
    let datasetId_;
    if (datasetId === undefined && datasetName === undefined) {
      throw new Error("Must provide dataset name or ID");
    } else if (datasetId !== undefined && datasetName !== undefined) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId === undefined) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    } else {
      datasetId_ = datasetId;
    }
    assertUuid(datasetId_);
    const data = {
      split_name: splitName,
      examples: exampleIds.map((id) => {
        assertUuid(id);
        return id;
      }),
      remove
    };
    const body = JSON.stringify(data);
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/splits`, {
        method: "PUT",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "update dataset splits", true);
      return res;
    });
  }
  async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample } = { loadChildRuns: false }) {
    warnOnce("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");
    let run_;
    if (typeof run === "string") {
      run_ = await this.readRun(run, { loadChildRuns });
    } else if (typeof run === "object" && "id" in run) {
      run_ = run;
    } else {
      throw new Error(`Invalid run type: ${typeof run}`);
    }
    if (run_.reference_example_id !== null && run_.reference_example_id !== undefined) {
      referenceExample = await this.readExample(run_.reference_example_id);
    }
    const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);
    const [_, feedbacks] = await this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);
    return feedbacks[0];
  }
  async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = "api", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId }) {
    if (!runId && !projectId) {
      throw new Error("One of runId or projectId must be provided");
    }
    if (runId && projectId) {
      throw new Error("Only one of runId or projectId can be provided");
    }
    const feedback_source = {
      type: feedbackSourceType ?? "api",
      metadata: sourceInfo ?? {}
    };
    if (sourceRunId !== undefined && feedback_source?.metadata !== undefined && !feedback_source.metadata["__run"]) {
      feedback_source.metadata["__run"] = { run_id: sourceRunId };
    }
    if (feedback_source?.metadata !== undefined && feedback_source.metadata["__run"]?.run_id !== undefined) {
      assertUuid(feedback_source.metadata["__run"].run_id);
    }
    const feedback = {
      id: feedbackId ?? v4(),
      run_id: runId,
      key,
      score: _formatFeedbackScore(score),
      value,
      correction,
      comment,
      feedback_source,
      comparative_experiment_id: comparativeExperimentId,
      feedbackConfig,
      session_id: projectId
    };
    const body = JSON.stringify(feedback);
    const url = `${this.apiUrl}/feedback`;
    await this.caller.call(async () => {
      const res = await this._fetch(url, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "create feedback", true);
      return res;
    });
    return feedback;
  }
  async updateFeedback(feedbackId, { score, value, correction, comment }) {
    const feedbackUpdate = {};
    if (score !== undefined && score !== null) {
      feedbackUpdate["score"] = _formatFeedbackScore(score);
    }
    if (value !== undefined && value !== null) {
      feedbackUpdate["value"] = value;
    }
    if (correction !== undefined && correction !== null) {
      feedbackUpdate["correction"] = correction;
    }
    if (comment !== undefined && comment !== null) {
      feedbackUpdate["comment"] = comment;
    }
    assertUuid(feedbackId);
    const body = JSON.stringify(feedbackUpdate);
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/feedback/${feedbackId}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "update feedback", true);
      return res;
    });
  }
  async readFeedback(feedbackId) {
    assertUuid(feedbackId);
    const path = `/feedback/${feedbackId}`;
    const response = await this._get(path);
    return response;
  }
  async deleteFeedback(feedbackId) {
    assertUuid(feedbackId);
    const path = `/feedback/${feedbackId}`;
    await this.caller.call(async () => {
      const res = await this._fetch(this.apiUrl + path, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, `delete ${path}`, true);
      return res;
    });
  }
  async* listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {
    const queryParams = new URLSearchParams;
    if (runIds) {
      for (const runId of runIds) {
        assertUuid(runId);
        queryParams.append("run", runId);
      }
    }
    if (feedbackKeys) {
      for (const key of feedbackKeys) {
        queryParams.append("key", key);
      }
    }
    if (feedbackSourceTypes) {
      for (const type of feedbackSourceTypes) {
        queryParams.append("source", type);
      }
    }
    for await (const feedbacks of this._getPaginated("/feedback", queryParams)) {
      yield* feedbacks;
    }
  }
  async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig } = {}) {
    const body = {
      run_id: runId,
      feedback_key: feedbackKey,
      feedback_config: feedbackConfig
    };
    if (expiration) {
      if (typeof expiration === "string") {
        body["expires_at"] = expiration;
      } else if (expiration?.hours || expiration?.minutes || expiration?.days) {
        body["expires_in"] = expiration;
      }
    } else {
      body["expires_in"] = {
        hours: 3
      };
    }
    const serializedBody = JSON.stringify(body);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/feedback/tokens`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: serializedBody
      });
      await raiseForStatus(res, "create presigned feedback token");
      return res;
    });
    return await response.json();
  }
  async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id }) {
    if (experimentIds.length === 0) {
      throw new Error("At least one experiment is required");
    }
    if (!referenceDatasetId) {
      referenceDatasetId = (await this.readProject({
        projectId: experimentIds[0]
      })).reference_dataset_id;
    }
    if (!referenceDatasetId == null) {
      throw new Error("A reference dataset is required");
    }
    const body = {
      id,
      name,
      experiment_ids: experimentIds,
      reference_dataset_id: referenceDatasetId,
      description,
      created_at: (createdAt ?? new Date)?.toISOString(),
      extra: {}
    };
    if (metadata)
      body.extra["metadata"] = metadata;
    const serializedBody = JSON.stringify(body);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/datasets/comparative`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: serializedBody
      });
      await raiseForStatus(res, "create comparative experiment");
      return res;
    });
    return response.json();
  }
  async* listPresignedFeedbackTokens(runId) {
    assertUuid(runId);
    const params = new URLSearchParams({ run_id: runId });
    for await (const tokens of this._getPaginated("/feedback/tokens", params)) {
      yield* tokens;
    }
  }
  _selectEvalResults(results) {
    let results_;
    if ("results" in results) {
      results_ = results.results;
    } else if (Array.isArray(results)) {
      results_ = results;
    } else {
      results_ = [results];
    }
    return results_;
  }
  async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
    const evalResults = this._selectEvalResults(evaluatorResponse);
    const feedbacks = [];
    for (const res of evalResults) {
      let sourceInfo_ = sourceInfo || {};
      if (res.evaluatorInfo) {
        sourceInfo_ = { ...res.evaluatorInfo, ...sourceInfo_ };
      }
      let runId_ = null;
      if (res.targetRunId) {
        runId_ = res.targetRunId;
      } else if (run) {
        runId_ = run.id;
      }
      feedbacks.push(await this.createFeedback(runId_, res.key, {
        score: res.score,
        value: res.value,
        comment: res.comment,
        correction: res.correction,
        sourceInfo: sourceInfo_,
        sourceRunId: res.sourceRunId,
        feedbackConfig: res.feedbackConfig,
        feedbackSourceType: "model"
      }));
    }
    return [evalResults, feedbacks];
  }
  async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
    const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);
    return results;
  }
  async* listAnnotationQueues(options = {}) {
    const { queueIds, name, nameContains, limit } = options;
    const params = new URLSearchParams;
    if (queueIds) {
      queueIds.forEach((id, i) => {
        assertUuid(id, `queueIds[${i}]`);
        params.append("ids", id);
      });
    }
    if (name)
      params.append("name", name);
    if (nameContains)
      params.append("name_contains", nameContains);
    params.append("limit", (limit !== undefined ? Math.min(limit, 100) : 100).toString());
    let count = 0;
    for await (const queues of this._getPaginated("/annotation-queues", params)) {
      yield* queues;
      count++;
      if (limit !== undefined && count >= limit)
        break;
    }
  }
  async createAnnotationQueue(options) {
    const { name, description, queueId, rubricInstructions } = options;
    const body = {
      name,
      description,
      id: queueId || v4(),
      rubric_instructions: rubricInstructions
    };
    const serializedBody = JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v]) => v !== undefined)));
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/annotation-queues`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: serializedBody
      });
      await raiseForStatus(res, "create annotation queue");
      return res;
    });
    return response.json();
  }
  async readAnnotationQueue(queueId) {
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "read annotation queue");
      return res;
    });
    return response.json();
  }
  async updateAnnotationQueue(queueId, options) {
    const { name, description, rubricInstructions } = options;
    const body = JSON.stringify({
      name,
      description,
      rubric_instructions: rubricInstructions
    });
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
        method: "PATCH",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "update annotation queue", true);
      return res;
    });
  }
  async deleteAnnotationQueue(queueId) {
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
        method: "DELETE",
        headers: { ...this.headers, Accept: "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "delete annotation queue", true);
      return res;
    });
  }
  async addRunsToAnnotationQueue(queueId, runIds) {
    const body = JSON.stringify(runIds.map((id, i) => assertUuid(id, `runIds[${i}]`).toString()));
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/runs`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "add runs to annotation queue", true);
      return res;
    });
  }
  async getRunFromAnnotationQueue(queueId, index) {
    const baseUrl = `/annotation-queues/${assertUuid(queueId, "queueId")}/run`;
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}${baseUrl}/${index}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "get run from annotation queue");
      return res;
    });
    return response.json();
  }
  async deleteRunFromAnnotationQueue(queueId, queueRunId) {
    await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/runs/${assertUuid(queueRunId, "queueRunId")}`, {
        method: "DELETE",
        headers: { ...this.headers, Accept: "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "delete run from annotation queue", true);
      return res;
    });
  }
  async getSizeFromAnnotationQueue(queueId) {
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/size`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "get size from annotation queue");
      return res;
    });
    return response.json();
  }
  async _currentTenantIsOwner(owner) {
    const settings = await this._getSettings();
    return owner == "-" || settings.tenant_handle === owner;
  }
  async _ownerConflictError(action, owner) {
    const settings = await this._getSettings();
    return new Error(`Cannot ${action} for another tenant.

      Current tenant: ${settings.tenant_handle}

      Requested tenant: ${owner}`);
  }
  async _getLatestCommitHash(promptOwnerAndName) {
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "get latest commit hash");
      return res;
    });
    const json = await response.json();
    if (json.commits.length === 0) {
      return;
    }
    return json.commits[0].commit_hash;
  }
  async _likeOrUnlikePrompt(promptIdentifier, like) {
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    const body = JSON.stringify({ like });
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/likes/${owner}/${promptName}`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, `${like ? "like" : "unlike"} prompt`);
      return res;
    });
    return response.json();
  }
  async _getPromptUrl(promptIdentifier) {
    const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);
    if (!await this._currentTenantIsOwner(owner)) {
      if (commitHash !== "latest") {
        return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;
      } else {
        return `${this.getHostUrl()}/hub/${owner}/${promptName}`;
      }
    } else {
      const settings = await this._getSettings();
      if (commitHash !== "latest") {
        return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;
      } else {
        return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;
      }
    }
  }
  async promptExists(promptIdentifier) {
    const prompt = await this.getPrompt(promptIdentifier);
    return !!prompt;
  }
  async likePrompt(promptIdentifier) {
    return this._likeOrUnlikePrompt(promptIdentifier, true);
  }
  async unlikePrompt(promptIdentifier) {
    return this._likeOrUnlikePrompt(promptIdentifier, false);
  }
  async* listCommits(promptOwnerAndName) {
    for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams, (res) => res.commits)) {
      yield* commits;
    }
  }
  async* listPrompts(options) {
    const params = new URLSearchParams;
    params.append("sort_field", options?.sortField ?? "updated_at");
    params.append("sort_direction", "desc");
    params.append("is_archived", (!!options?.isArchived).toString());
    if (options?.isPublic !== undefined) {
      params.append("is_public", options.isPublic.toString());
    }
    if (options?.query) {
      params.append("query", options.query);
    }
    for await (const prompts of this._getPaginated("/repos", params, (res) => res.repos)) {
      yield* prompts;
    }
  }
  async getPrompt(promptIdentifier) {
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      if (res?.status === 404) {
        return null;
      }
      await raiseForStatus(res, "get prompt");
      return res;
    });
    const result = await response?.json();
    if (result?.repo) {
      return result.repo;
    } else {
      return null;
    }
  }
  async createPrompt(promptIdentifier, options) {
    const settings = await this._getSettings();
    if (options?.isPublic && !settings.tenant_handle) {
      throw new Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle.
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
    }
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    if (!await this._currentTenantIsOwner(owner)) {
      throw await this._ownerConflictError("create a prompt", owner);
    }
    const data = {
      repo_handle: promptName,
      ...options?.description && { description: options.description },
      ...options?.readme && { readme: options.readme },
      ...options?.tags && { tags: options.tags },
      is_public: !!options?.isPublic
    };
    const body = JSON.stringify(data);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/repos/`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "create prompt");
      return res;
    });
    const { repo } = await response.json();
    return repo;
  }
  async createCommit(promptIdentifier, object, options) {
    if (!await this.promptExists(promptIdentifier)) {
      throw new Error("Prompt does not exist, you must create it first.");
    }
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    const resolvedParentCommitHash = options?.parentCommitHash === "latest" || !options?.parentCommitHash ? await this._getLatestCommitHash(`${owner}/${promptName}`) : options?.parentCommitHash;
    const payload = {
      manifest: JSON.parse(JSON.stringify(object)),
      parent_commit: resolvedParentCommitHash
    };
    const body = JSON.stringify(payload);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}`, {
        method: "POST",
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "create commit");
      return res;
    });
    const result = await response.json();
    return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : ""}`);
  }
  async updateExamplesMultipart(datasetId, updates = []) {
    return this._updateExamplesMultipart(datasetId, updates);
  }
  async _updateExamplesMultipart(datasetId, updates = []) {
    if (!await this._getDatasetExamplesMultiPartSupport()) {
      throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    }
    const formData = new FormData;
    for (const example of updates) {
      const exampleId = example.id;
      const exampleBody = {
        ...example.metadata && { metadata: example.metadata },
        ...example.split && { split: example.split }
      };
      const stringifiedExample = serialize(exampleBody, `Serializing body for example with id: ${exampleId}`);
      const exampleBlob = new Blob([stringifiedExample], {
        type: "application/json"
      });
      formData.append(exampleId, exampleBlob);
      if (example.inputs) {
        const stringifiedInputs = serialize(example.inputs, `Serializing inputs for example with id: ${exampleId}`);
        const inputsBlob = new Blob([stringifiedInputs], {
          type: "application/json"
        });
        formData.append(`${exampleId}.inputs`, inputsBlob);
      }
      if (example.outputs) {
        const stringifiedOutputs = serialize(example.outputs, `Serializing outputs whle updating example with id: ${exampleId}`);
        const outputsBlob = new Blob([stringifiedOutputs], {
          type: "application/json"
        });
        formData.append(`${exampleId}.outputs`, outputsBlob);
      }
      if (example.attachments) {
        for (const [name, attachment] of Object.entries(example.attachments)) {
          let mimeType;
          let data;
          if (Array.isArray(attachment)) {
            [mimeType, data] = attachment;
          } else {
            mimeType = attachment.mimeType;
            data = attachment.data;
          }
          const attachmentBlob = new Blob([data], {
            type: `${mimeType}; length=${data.byteLength}`
          });
          formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);
        }
      }
      if (example.attachments_operations) {
        const stringifiedAttachmentsOperations = serialize(example.attachments_operations, `Serializing attachments while updating example with id: ${exampleId}`);
        const attachmentsOperationsBlob = new Blob([stringifiedAttachmentsOperations], {
          type: "application/json"
        });
        formData.append(`${exampleId}.attachments_operations`, attachmentsOperationsBlob);
      }
    }
    const datasetIdToUse = datasetId ?? updates[0]?.dataset_id;
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetIdToUse}/examples`)}`, {
        method: "PATCH",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: formData
      });
      await raiseForStatus(res, "update examples");
      return res;
    });
    return response.json();
  }
  async uploadExamplesMultipart(datasetId, uploads = []) {
    return this._uploadExamplesMultipart(datasetId, uploads);
  }
  async _uploadExamplesMultipart(datasetId, uploads = []) {
    if (!await this._getDatasetExamplesMultiPartSupport()) {
      throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    }
    const formData = new FormData;
    for (const example of uploads) {
      const exampleId = (example.id ?? v4()).toString();
      const exampleBody = {
        created_at: example.created_at,
        ...example.metadata && { metadata: example.metadata },
        ...example.split && { split: example.split },
        ...example.source_run_id && { source_run_id: example.source_run_id },
        ...example.use_source_run_io && {
          use_source_run_io: example.use_source_run_io
        },
        ...example.use_source_run_attachments && {
          use_source_run_attachments: example.use_source_run_attachments
        }
      };
      const stringifiedExample = serialize(exampleBody, `Serializing body for uploaded example with id: ${exampleId}`);
      const exampleBlob = new Blob([stringifiedExample], {
        type: "application/json"
      });
      formData.append(exampleId, exampleBlob);
      if (example.inputs) {
        const stringifiedInputs = serialize(example.inputs, `Serializing inputs for uploaded example with id: ${exampleId}`);
        const inputsBlob = new Blob([stringifiedInputs], {
          type: "application/json"
        });
        formData.append(`${exampleId}.inputs`, inputsBlob);
      }
      if (example.outputs) {
        const stringifiedOutputs = serialize(example.outputs, `Serializing outputs for uploaded example with id: ${exampleId}`);
        const outputsBlob = new Blob([stringifiedOutputs], {
          type: "application/json"
        });
        formData.append(`${exampleId}.outputs`, outputsBlob);
      }
      if (example.attachments) {
        for (const [name, attachment] of Object.entries(example.attachments)) {
          let mimeType;
          let data;
          if (Array.isArray(attachment)) {
            [mimeType, data] = attachment;
          } else {
            mimeType = attachment.mimeType;
            data = attachment.data;
          }
          const attachmentBlob = new Blob([data], {
            type: `${mimeType}; length=${data.byteLength}`
          });
          formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);
        }
      }
    }
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetId}/examples`)}`, {
        method: "POST",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: formData
      });
      await raiseForStatus(res, "upload examples");
      return res;
    });
    return response.json();
  }
  async updatePrompt(promptIdentifier, options) {
    if (!await this.promptExists(promptIdentifier)) {
      throw new Error("Prompt does not exist, you must create it first.");
    }
    const [owner, promptName] = parsePromptIdentifier(promptIdentifier);
    if (!await this._currentTenantIsOwner(owner)) {
      throw await this._ownerConflictError("update a prompt", owner);
    }
    const payload = {};
    if (options?.description !== undefined)
      payload.description = options.description;
    if (options?.readme !== undefined)
      payload.readme = options.readme;
    if (options?.tags !== undefined)
      payload.tags = options.tags;
    if (options?.isPublic !== undefined)
      payload.is_public = options.isPublic;
    if (options?.isArchived !== undefined)
      payload.is_archived = options.isArchived;
    if (Object.keys(payload).length === 0) {
      throw new Error("No valid update options provided");
    }
    const body = JSON.stringify(payload);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {
        method: "PATCH",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body
      });
      await raiseForStatus(res, "update prompt");
      return res;
    });
    return response.json();
  }
  async deletePrompt(promptIdentifier) {
    if (!await this.promptExists(promptIdentifier)) {
      throw new Error("Prompt does not exist, you must create it first.");
    }
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    if (!await this._currentTenantIsOwner(owner)) {
      throw await this._ownerConflictError("delete a prompt", owner);
    }
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "delete prompt");
      return res;
    });
    return response.json();
  }
  async pullPromptCommit(promptIdentifier, options) {
    const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);
    const response = await this.caller.call(async () => {
      const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}/${commitHash}${options?.includeModel ? "?include_model=true" : ""}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "pull prompt commit");
      return res;
    });
    const result = await response.json();
    return {
      owner,
      repo: promptName,
      commit_hash: result.commit_hash,
      manifest: result.manifest,
      examples: result.examples
    };
  }
  async _pullPrompt(promptIdentifier, options) {
    const promptObject = await this.pullPromptCommit(promptIdentifier, {
      includeModel: options?.includeModel
    });
    const prompt = JSON.stringify(promptObject.manifest);
    return prompt;
  }
  async pushPrompt(promptIdentifier, options) {
    if (await this.promptExists(promptIdentifier)) {
      if (options && Object.keys(options).some((key) => key !== "object")) {
        await this.updatePrompt(promptIdentifier, {
          description: options?.description,
          readme: options?.readme,
          tags: options?.tags,
          isPublic: options?.isPublic
        });
      }
    } else {
      await this.createPrompt(promptIdentifier, {
        description: options?.description,
        readme: options?.readme,
        tags: options?.tags,
        isPublic: options?.isPublic
      });
    }
    if (!options?.object) {
      return await this._getPromptUrl(promptIdentifier);
    }
    const url = await this.createCommit(promptIdentifier, options?.object, {
      parentCommitHash: options?.parentCommitHash
    });
    return url;
  }
  async clonePublicDataset(tokenOrUrl, options = {}) {
    const { sourceApiUrl = this.apiUrl, datasetName } = options;
    const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);
    const sourceClient = new Client({
      apiUrl: parsedApiUrl,
      apiKey: "placeholder"
    });
    const ds = await sourceClient.readSharedDataset(tokenUuid);
    const finalDatasetName = datasetName || ds.name;
    try {
      if (await this.hasDataset({ datasetId: finalDatasetName })) {
        console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);
        return;
      }
    } catch (_) {}
    const examples = await sourceClient.listSharedExamples(tokenUuid);
    const dataset = await this.createDataset(finalDatasetName, {
      description: ds.description,
      dataType: ds.data_type || "kv",
      inputsSchema: ds.inputs_schema_definition ?? undefined,
      outputsSchema: ds.outputs_schema_definition ?? undefined
    });
    try {
      await this.createExamples({
        inputs: examples.map((e) => e.inputs),
        outputs: examples.flatMap((e) => e.outputs ? [e.outputs] : []),
        datasetId: dataset.id
      });
    } catch (e) {
      console.error(`An error occurred while creating dataset ${finalDatasetName}. ` + "You should delete it manually.");
      throw e;
    }
  }
  parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = "dataset") {
    try {
      assertUuid(urlOrToken);
      return [apiUrl, urlOrToken];
    } catch (_) {}
    try {
      const parsedUrl = new URL(urlOrToken);
      const pathParts = parsedUrl.pathname.split("/").filter((part) => part !== "");
      if (pathParts.length >= numParts) {
        const tokenUuid = pathParts[pathParts.length - numParts];
        return [apiUrl, tokenUuid];
      } else {
        throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);
      }
    } catch (error) {
      throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);
    }
  }
  async awaitPendingTraceBatches() {
    if (this.manualFlushMode) {
      console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches.");
      return Promise.resolve();
    }
    await Promise.all([
      ...this.autoBatchQueue.items.map(({ itemPromise }) => itemPromise),
      this.batchIngestCaller.queue.onIdle()
    ]);
    if (this.langSmithToOTELTranslator !== undefined) {
      await getDefaultOTLPTracerComponents()?.DEFAULT_LANGSMITH_SPAN_PROCESSOR?.forceFlush();
    }
  }
}
function isExampleCreate(input) {
  return "dataset_id" in input || "dataset_name" in input;
}

// node_modules/langsmith/dist/env.js
var isTracingEnabled = (tracingEnabled) => {
  if (tracingEnabled !== undefined) {
    return tracingEnabled;
  }
  const envVars = ["TRACING_V2", "TRACING"];
  return !!envVars.find((envVar) => getLangSmithEnvironmentVariable(envVar) === "true");
};

// node_modules/langsmith/dist/singletons/constants.js
var _LC_CONTEXT_VARIABLES_KEY = Symbol.for("lc:context_variables");
var _REPLICA_TRACE_ROOTS_KEY = Symbol.for("langsmith:replica_trace_roots");

// node_modules/langsmith/dist/utils/context_vars.js
function getContextVar(runTree, key) {
  if (_LC_CONTEXT_VARIABLES_KEY in runTree) {
    const contextVars = runTree[_LC_CONTEXT_VARIABLES_KEY];
    return contextVars[key];
  }
  return;
}
function setContextVar(runTree, key, value) {
  const contextVars = _LC_CONTEXT_VARIABLES_KEY in runTree ? runTree[_LC_CONTEXT_VARIABLES_KEY] : {};
  contextVars[key] = value;
  runTree[_LC_CONTEXT_VARIABLES_KEY] = contextVars;
}

// node_modules/langsmith/dist/run_trees.js
var TIMESTAMP_LENGTH = 36;
var UUID_NAMESPACE_DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
function getReplicaKey(replica) {
  const sortedKeys = Object.keys(replica).sort();
  const keyData = sortedKeys.map((key) => `${key}:${replica[key] ?? ""}`).join("|");
  return v5(keyData, UUID_NAMESPACE_DNS);
}
function stripNonAlphanumeric(input) {
  return input.replace(/[-:.]/g, "");
}
function getMicrosecondPrecisionDatestring(epoch, executionOrder = 1) {
  const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, "0");
  return `${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`;
}
function convertToDottedOrderFormat(epoch, runId, executionOrder = 1) {
  const microsecondPrecisionDatestring = getMicrosecondPrecisionDatestring(epoch, executionOrder);
  return {
    dottedOrder: stripNonAlphanumeric(microsecondPrecisionDatestring) + runId,
    microsecondPrecisionDatestring
  };
}

class Baggage {
  constructor(metadata, tags, project_name, replicas) {
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "project_name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "replicas", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.metadata = metadata;
    this.tags = tags;
    this.project_name = project_name;
    this.replicas = replicas;
  }
  static fromHeader(value) {
    const items = value.split(",");
    let metadata = {};
    let tags = [];
    let project_name;
    let replicas;
    for (const item of items) {
      const [key, uriValue] = item.split("=");
      const value2 = decodeURIComponent(uriValue);
      if (key === "langsmith-metadata") {
        metadata = JSON.parse(value2);
      } else if (key === "langsmith-tags") {
        tags = value2.split(",");
      } else if (key === "langsmith-project") {
        project_name = value2;
      } else if (key === "langsmith-replicas") {
        replicas = JSON.parse(value2);
      }
    }
    return new Baggage(metadata, tags, project_name, replicas);
  }
  toHeader() {
    const items = [];
    if (this.metadata && Object.keys(this.metadata).length > 0) {
      items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);
    }
    if (this.tags && this.tags.length > 0) {
      items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`);
    }
    if (this.project_name) {
      items.push(`langsmith-project=${encodeURIComponent(this.project_name)}`);
    }
    return items.join(",");
  }
}

class RunTree {
  constructor(originalConfig) {
    Object.defineProperty(this, "id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "run_type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "project_name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "parent_run", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "parent_run_id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "child_runs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "start_time", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "end_time", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "extra", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "error", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "serialized", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "inputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "outputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "reference_example_id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "events", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "trace_id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "dotted_order", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "tracingEnabled", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "execution_order", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "child_execution_order", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "attachments", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "replicas", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "distributedParentId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "_serialized_start_time", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    if (isRunTree(originalConfig)) {
      Object.assign(this, { ...originalConfig });
      return;
    }
    const defaultConfig = RunTree.getDefaultConfig();
    const { metadata, ...config } = originalConfig;
    const client = config.client ?? RunTree.getSharedClient();
    const dedupedMetadata = {
      ...metadata,
      ...config?.extra?.metadata
    };
    config.extra = { ...config.extra, metadata: dedupedMetadata };
    if ("id" in config && config.id == null) {
      delete config.id;
    }
    Object.assign(this, { ...defaultConfig, ...config, client });
    this.execution_order ??= 1;
    this.child_execution_order ??= 1;
    if (!this.dotted_order) {
      this._serialized_start_time = getMicrosecondPrecisionDatestring(this.start_time, this.execution_order);
    }
    if (!this.id) {
      this.id = uuid7FromTime(this._serialized_start_time ?? this.start_time);
    }
    if (!this.trace_id) {
      if (this.parent_run) {
        this.trace_id = this.parent_run.trace_id ?? this.id;
      } else {
        this.trace_id = this.id;
      }
    }
    this.replicas = _ensureWriteReplicas(this.replicas);
    if (!this.dotted_order) {
      const { dottedOrder } = convertToDottedOrderFormat(this.start_time, this.id, this.execution_order);
      if (this.parent_run) {
        this.dotted_order = this.parent_run.dotted_order + "." + dottedOrder;
      } else {
        this.dotted_order = dottedOrder;
      }
    }
  }
  set metadata(metadata) {
    this.extra = {
      ...this.extra,
      metadata: {
        ...this.extra?.metadata,
        ...metadata
      }
    };
  }
  get metadata() {
    return this.extra?.metadata;
  }
  static getDefaultConfig() {
    const start_time = Date.now();
    return {
      run_type: "chain",
      project_name: getDefaultProjectName(),
      child_runs: [],
      api_url: getEnvironmentVariable2("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984",
      api_key: getEnvironmentVariable2("LANGCHAIN_API_KEY"),
      caller_options: {},
      start_time,
      serialized: {},
      inputs: {},
      extra: {}
    };
  }
  static getSharedClient() {
    if (!RunTree.sharedClient) {
      RunTree.sharedClient = new Client;
    }
    return RunTree.sharedClient;
  }
  createChild(config) {
    const child_execution_order = this.child_execution_order + 1;
    const inheritedReplicas = this.replicas?.map((replica) => {
      const { reroot, ...rest } = replica;
      return rest;
    });
    const childReplicas = config.replicas ?? inheritedReplicas;
    const child = new RunTree({
      ...config,
      parent_run: this,
      project_name: this.project_name,
      replicas: childReplicas,
      client: this.client,
      tracingEnabled: this.tracingEnabled,
      execution_order: child_execution_order,
      child_execution_order
    });
    if (_LC_CONTEXT_VARIABLES_KEY in this) {
      child[_LC_CONTEXT_VARIABLES_KEY] = this[_LC_CONTEXT_VARIABLES_KEY];
    }
    const LC_CHILD = Symbol.for("lc:child_config");
    const presentConfig = config.extra?.[LC_CHILD] ?? this.extra[LC_CHILD];
    if (isRunnableConfigLike(presentConfig)) {
      const newConfig = { ...presentConfig };
      const callbacks = isCallbackManagerLike(newConfig.callbacks) ? newConfig.callbacks.copy?.() : undefined;
      if (callbacks) {
        Object.assign(callbacks, { _parentRunId: child.id });
        callbacks.handlers?.find(isLangChainTracerLike)?.updateFromRunTree?.(child);
        newConfig.callbacks = callbacks;
      }
      child.extra[LC_CHILD] = newConfig;
    }
    const visited = new Set;
    let current = this;
    while (current != null && !visited.has(current.id)) {
      visited.add(current.id);
      current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);
      current = current.parent_run;
    }
    this.child_runs.push(child);
    return child;
  }
  async end(outputs, error, endTime = Date.now(), metadata) {
    this.outputs = this.outputs ?? outputs;
    this.error = this.error ?? error;
    this.end_time = this.end_time ?? endTime;
    if (metadata && Object.keys(metadata).length > 0) {
      this.extra = this.extra ? { ...this.extra, metadata: { ...this.extra.metadata, ...metadata } } : { metadata };
    }
  }
  _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {
    const runExtra = run.extra ?? {};
    if (runExtra?.runtime?.library === undefined) {
      if (!runExtra.runtime) {
        runExtra.runtime = {};
      }
      if (runtimeEnv) {
        for (const [k, v] of Object.entries(runtimeEnv)) {
          if (!runExtra.runtime[k]) {
            runExtra.runtime[k] = v;
          }
        }
      }
    }
    let child_runs;
    let parent_run_id;
    if (!excludeChildRuns) {
      child_runs = run.child_runs.map((child_run) => this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));
      parent_run_id = undefined;
    } else {
      parent_run_id = run.parent_run?.id ?? run.parent_run_id;
      child_runs = [];
    }
    return {
      id: run.id,
      name: run.name,
      start_time: run._serialized_start_time ?? run.start_time,
      end_time: run.end_time,
      run_type: run.run_type,
      reference_example_id: run.reference_example_id,
      extra: runExtra,
      serialized: run.serialized,
      error: run.error,
      inputs: run.inputs,
      outputs: run.outputs,
      session_name: run.project_name,
      child_runs,
      parent_run_id,
      trace_id: run.trace_id,
      dotted_order: run.dotted_order,
      tags: run.tags,
      attachments: run.attachments,
      events: run.events
    };
  }
  _sliceParentId(parentId, run) {
    if (run.dotted_order) {
      const segs = run.dotted_order.split(".");
      let startIdx = null;
      for (let idx = 0;idx < segs.length; idx++) {
        const segId = segs[idx].slice(-TIMESTAMP_LENGTH);
        if (segId === parentId) {
          startIdx = idx;
          break;
        }
      }
      if (startIdx !== null) {
        const trimmedSegs = segs.slice(startIdx + 1);
        run.dotted_order = trimmedSegs.join(".");
        if (trimmedSegs.length > 0) {
          run.trace_id = trimmedSegs[0].slice(-TIMESTAMP_LENGTH);
        } else {
          run.trace_id = run.id;
        }
      }
    }
    if (run.parent_run_id === parentId) {
      run.parent_run_id = undefined;
    }
  }
  _setReplicaTraceRoot(replicaKey, traceRootId) {
    const replicaTraceRoots = getContextVar(this, _REPLICA_TRACE_ROOTS_KEY) ?? {};
    replicaTraceRoots[replicaKey] = traceRootId;
    setContextVar(this, _REPLICA_TRACE_ROOTS_KEY, replicaTraceRoots);
    for (const child of this.child_runs) {
      child._setReplicaTraceRoot(replicaKey, traceRootId);
    }
  }
  _remapForProject(params) {
    const { projectName, runtimeEnv, excludeChildRuns = true, reroot = false, distributedParentId, apiUrl, apiKey, workspaceId } = params;
    const baseRun = this._convertToCreate(this, runtimeEnv, excludeChildRuns);
    if (projectName === this.project_name) {
      return {
        ...baseRun,
        session_name: projectName
      };
    }
    if (reroot) {
      if (distributedParentId) {
        this._sliceParentId(distributedParentId, baseRun);
      } else {
        baseRun.parent_run_id = undefined;
        if (baseRun.dotted_order) {
          const segs = baseRun.dotted_order.split(".");
          if (segs.length > 0) {
            baseRun.dotted_order = segs[segs.length - 1];
            baseRun.trace_id = baseRun.id;
          }
        }
      }
      const replicaKey = getReplicaKey({
        projectName,
        apiUrl,
        apiKey,
        workspaceId
      });
      this._setReplicaTraceRoot(replicaKey, baseRun.id);
    }
    let ancestorRerootedTraceId;
    if (!reroot) {
      const replicaTraceRoots = getContextVar(this, _REPLICA_TRACE_ROOTS_KEY) ?? {};
      const replicaKey = getReplicaKey({
        projectName,
        apiUrl,
        apiKey,
        workspaceId
      });
      ancestorRerootedTraceId = replicaTraceRoots[replicaKey];
      if (ancestorRerootedTraceId) {
        baseRun.trace_id = ancestorRerootedTraceId;
        if (baseRun.dotted_order) {
          const segs = baseRun.dotted_order.split(".");
          let rootIdx = null;
          for (let idx = 0;idx < segs.length; idx++) {
            const segId = segs[idx].slice(-TIMESTAMP_LENGTH);
            if (segId === ancestorRerootedTraceId) {
              rootIdx = idx;
              break;
            }
          }
          if (rootIdx !== null) {
            const trimmedSegs = segs.slice(rootIdx);
            baseRun.dotted_order = trimmedSegs.join(".");
          }
        }
      }
    }
    const oldId = baseRun.id;
    const newId = v5(`${oldId}:${projectName}`, UUID_NAMESPACE_DNS);
    let newTraceId;
    if (baseRun.trace_id) {
      newTraceId = v5(`${baseRun.trace_id}:${projectName}`, UUID_NAMESPACE_DNS);
    } else {
      newTraceId = newId;
    }
    let newParentId;
    if (baseRun.parent_run_id) {
      newParentId = v5(`${baseRun.parent_run_id}:${projectName}`, UUID_NAMESPACE_DNS);
    }
    let newDottedOrder;
    if (baseRun.dotted_order) {
      const segs = baseRun.dotted_order.split(".");
      const remappedSegs = segs.map((seg) => {
        const segId = seg.slice(-TIMESTAMP_LENGTH);
        const remappedId = v5(`${segId}:${projectName}`, UUID_NAMESPACE_DNS);
        return seg.slice(0, -TIMESTAMP_LENGTH) + remappedId;
      });
      newDottedOrder = remappedSegs.join(".");
    }
    return {
      ...baseRun,
      id: newId,
      trace_id: newTraceId,
      parent_run_id: newParentId,
      dotted_order: newDottedOrder,
      session_name: projectName
    };
  }
  async postRun(excludeChildRuns = true) {
    try {
      const runtimeEnv = getRuntimeEnvironment2();
      if (this.replicas && this.replicas.length > 0) {
        for (const { projectName, apiKey, apiUrl, workspaceId, reroot } of this.replicas) {
          const runCreate = this._remapForProject({
            projectName: projectName ?? this.project_name,
            runtimeEnv,
            excludeChildRuns: true,
            reroot,
            distributedParentId: this.distributedParentId,
            apiUrl,
            apiKey,
            workspaceId
          });
          await this.client.createRun(runCreate, {
            apiKey,
            apiUrl,
            workspaceId
          });
        }
      } else {
        const runCreate = this._convertToCreate(this, runtimeEnv, excludeChildRuns);
        await this.client.createRun(runCreate);
      }
      if (!excludeChildRuns) {
        warnOnce("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
        for (const childRun of this.child_runs) {
          await childRun.postRun(false);
        }
      }
    } catch (error) {
      console.error(`Error in postRun for run ${this.id}:`, error);
    }
  }
  async patchRun(options) {
    if (this.replicas && this.replicas.length > 0) {
      for (const { projectName, apiKey, apiUrl, workspaceId, updates, reroot } of this.replicas) {
        const runData = this._remapForProject({
          projectName: projectName ?? this.project_name,
          runtimeEnv: undefined,
          excludeChildRuns: true,
          reroot,
          distributedParentId: this.distributedParentId,
          apiUrl,
          apiKey,
          workspaceId
        });
        const updatePayload = {
          id: runData.id,
          name: runData.name,
          run_type: runData.run_type,
          start_time: runData.start_time,
          outputs: runData.outputs,
          error: runData.error,
          parent_run_id: runData.parent_run_id,
          session_name: runData.session_name,
          reference_example_id: runData.reference_example_id,
          end_time: runData.end_time,
          dotted_order: runData.dotted_order,
          trace_id: runData.trace_id,
          events: runData.events,
          tags: runData.tags,
          extra: runData.extra,
          attachments: this.attachments,
          ...updates
        };
        if (!options?.excludeInputs) {
          updatePayload.inputs = runData.inputs;
        }
        await this.client.updateRun(runData.id, updatePayload, {
          apiKey,
          apiUrl,
          workspaceId
        });
      }
    } else {
      try {
        const runUpdate = {
          name: this.name,
          run_type: this.run_type,
          start_time: this._serialized_start_time ?? this.start_time,
          end_time: this.end_time,
          error: this.error,
          outputs: this.outputs,
          parent_run_id: this.parent_run?.id ?? this.parent_run_id,
          reference_example_id: this.reference_example_id,
          extra: this.extra,
          events: this.events,
          dotted_order: this.dotted_order,
          trace_id: this.trace_id,
          tags: this.tags,
          attachments: this.attachments,
          session_name: this.project_name
        };
        if (!options?.excludeInputs) {
          runUpdate.inputs = this.inputs;
        }
        await this.client.updateRun(this.id, runUpdate);
      } catch (error) {
        console.error(`Error in patchRun for run ${this.id}`, error);
      }
    }
  }
  toJSON() {
    return this._convertToCreate(this, undefined, false);
  }
  addEvent(event) {
    if (!this.events) {
      this.events = [];
    }
    if (typeof event === "string") {
      this.events.push({
        name: "event",
        time: new Date().toISOString(),
        message: event
      });
    } else {
      this.events.push({
        ...event,
        time: event.time ?? new Date().toISOString()
      });
    }
  }
  static fromRunnableConfig(parentConfig, props) {
    const callbackManager = parentConfig?.callbacks;
    let parentRun;
    let projectName;
    let client;
    let tracingEnabled = isTracingEnabled();
    if (callbackManager) {
      const parentRunId = callbackManager?.getParentRunId?.() ?? "";
      const langChainTracer = callbackManager?.handlers?.find((handler) => handler?.name == "langchain_tracer");
      parentRun = langChainTracer?.getRun?.(parentRunId);
      projectName = langChainTracer?.projectName;
      client = langChainTracer?.client;
      tracingEnabled = tracingEnabled || !!langChainTracer;
    }
    if (!parentRun) {
      return new RunTree({
        ...props,
        client,
        tracingEnabled,
        project_name: projectName
      });
    }
    const parentRunTree = new RunTree({
      name: parentRun.name,
      id: parentRun.id,
      trace_id: parentRun.trace_id,
      dotted_order: parentRun.dotted_order,
      client,
      tracingEnabled,
      project_name: projectName,
      tags: [
        ...new Set((parentRun?.tags ?? []).concat(parentConfig?.tags ?? []))
      ],
      extra: {
        metadata: {
          ...parentRun?.extra?.metadata,
          ...parentConfig?.metadata
        }
      }
    });
    return parentRunTree.createChild(props);
  }
  static fromDottedOrder(dottedOrder) {
    return this.fromHeaders({ "langsmith-trace": dottedOrder });
  }
  static fromHeaders(headers, inheritArgs) {
    const rawHeaders = "get" in headers && typeof headers.get === "function" ? {
      "langsmith-trace": headers.get("langsmith-trace"),
      baggage: headers.get("baggage")
    } : headers;
    const headerTrace = rawHeaders["langsmith-trace"];
    if (!headerTrace || typeof headerTrace !== "string")
      return;
    const parentDottedOrder = headerTrace.trim();
    const parsedDottedOrder = parentDottedOrder.split(".").map((part) => {
      const [strTime, uuid2] = part.split("Z");
      return { strTime, time: Date.parse(strTime + "Z"), uuid: uuid2 };
    });
    const traceId = parsedDottedOrder[0].uuid;
    const config = {
      ...inheritArgs,
      name: inheritArgs?.["name"] ?? "parent",
      run_type: inheritArgs?.["run_type"] ?? "chain",
      start_time: inheritArgs?.["start_time"] ?? Date.now(),
      id: parsedDottedOrder.at(-1)?.uuid,
      trace_id: traceId,
      dotted_order: parentDottedOrder
    };
    if (rawHeaders["baggage"] && typeof rawHeaders["baggage"] === "string") {
      const baggage = Baggage.fromHeader(rawHeaders["baggage"]);
      config.metadata = baggage.metadata;
      config.tags = baggage.tags;
      config.project_name = baggage.project_name;
      config.replicas = baggage.replicas;
    }
    const runTree = new RunTree(config);
    runTree.distributedParentId = runTree.id;
    return runTree;
  }
  toHeaders(headers) {
    const result = {
      "langsmith-trace": this.dotted_order,
      baggage: new Baggage(this.extra?.metadata, this.tags, this.project_name, this.replicas).toHeader()
    };
    if (headers) {
      for (const [key, value] of Object.entries(result)) {
        headers.set(key, value);
      }
    }
    return result;
  }
}
Object.defineProperty(RunTree, "sharedClient", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: null
});
function isRunTree(x) {
  return x != null && typeof x.createChild === "function" && typeof x.postRun === "function";
}
function isLangChainTracerLike(x) {
  return typeof x === "object" && x != null && typeof x.name === "string" && x.name === "langchain_tracer";
}
function containsLangChainTracerLike(x) {
  return Array.isArray(x) && x.some((callback) => isLangChainTracerLike(callback));
}
function isCallbackManagerLike(x) {
  return typeof x === "object" && x != null && Array.isArray(x.handlers);
}
function isRunnableConfigLike(x) {
  const callbacks = x?.callbacks;
  return x != null && typeof callbacks === "object" && (containsLangChainTracerLike(callbacks?.handlers) || containsLangChainTracerLike(callbacks));
}
function _getWriteReplicasFromEnv() {
  const envVar = getEnvironmentVariable2("LANGSMITH_RUNS_ENDPOINTS");
  if (!envVar)
    return [];
  try {
    const parsed = JSON.parse(envVar);
    if (Array.isArray(parsed)) {
      const replicas = [];
      for (const item of parsed) {
        if (typeof item !== "object" || item === null) {
          console.warn(`Invalid item type in LANGSMITH_RUNS_ENDPOINTS: ` + `expected object, got ${typeof item}`);
          continue;
        }
        if (typeof item.api_url !== "string") {
          console.warn(`Invalid api_url type in LANGSMITH_RUNS_ENDPOINTS: ` + `expected string, got ${typeof item.api_url}`);
          continue;
        }
        if (typeof item.api_key !== "string") {
          console.warn(`Invalid api_key type in LANGSMITH_RUNS_ENDPOINTS: ` + `expected string, got ${typeof item.api_key}`);
          continue;
        }
        replicas.push({
          apiUrl: item.api_url.replace(/\/$/, ""),
          apiKey: item.api_key
        });
      }
      return replicas;
    } else if (typeof parsed === "object" && parsed !== null) {
      _checkEndpointEnvUnset(parsed);
      const replicas = [];
      for (const [url, key] of Object.entries(parsed)) {
        const cleanUrl = url.replace(/\/$/, "");
        if (typeof key === "string") {
          replicas.push({
            apiUrl: cleanUrl,
            apiKey: key
          });
        } else {
          console.warn(`Invalid value type in LANGSMITH_RUNS_ENDPOINTS for URL ${url}: ` + `expected string, got ${typeof key}`);
          continue;
        }
      }
      return replicas;
    } else {
      console.warn("Invalid LANGSMITH_RUNS_ENDPOINTS \u2013 must be valid JSON array of " + `objects with api_url and api_key properties, or object mapping url->apiKey, got ${typeof parsed}`);
      return [];
    }
  } catch (e) {
    if (isConflictingEndpointsError(e)) {
      throw e;
    }
    console.warn("Invalid LANGSMITH_RUNS_ENDPOINTS \u2013 must be valid JSON array of " + "objects with api_url and api_key properties, or object mapping url->apiKey");
    return [];
  }
}
function _ensureWriteReplicas(replicas) {
  if (replicas) {
    return replicas.map((replica) => {
      if (Array.isArray(replica)) {
        return {
          projectName: replica[0],
          updates: replica[1]
        };
      }
      return replica;
    });
  }
  return _getWriteReplicasFromEnv();
}
function _checkEndpointEnvUnset(parsed) {
  if (Object.keys(parsed).length > 0 && getLangSmithEnvironmentVariable("ENDPOINT")) {
    throw new ConflictingEndpointsError;
  }
}
// node_modules/@langchain/core/dist/tracers/base.js
var base_exports2 = {};
__export2(base_exports2, {
  BaseTracer: () => BaseTracer,
  isBaseTracer: () => isBaseTracer
});
var convertRunTreeToRun = (runTree) => {
  if (!runTree)
    return;
  runTree.events = runTree.events ?? [];
  runTree.child_runs = runTree.child_runs ?? [];
  return runTree;
};
function convertRunToRunTree(run, parentRun) {
  if (!run)
    return;
  return new RunTree({
    ...run,
    start_time: run._serialized_start_time ?? run.start_time,
    parent_run: convertRunToRunTree(parentRun),
    child_runs: run.child_runs.map((r) => convertRunToRunTree(r)).filter((r) => r !== undefined),
    extra: {
      ...run.extra,
      runtime: getRuntimeEnvironment()
    },
    tracingEnabled: false
  });
}
function _coerceToDict(value, defaultKey) {
  return value && !Array.isArray(value) && typeof value === "object" ? value : { [defaultKey]: value };
}
function isBaseTracer(x) {
  return typeof x._addRunToRunMap === "function";
}
var BaseTracer = class extends BaseCallbackHandler {
  runMap = /* @__PURE__ */ new Map;
  runTreeMap = /* @__PURE__ */ new Map;
  usesRunTreeMap = false;
  constructor(_fields) {
    super(...arguments);
  }
  copy() {
    return this;
  }
  getRunById(runId) {
    if (runId === undefined)
      return;
    return this.usesRunTreeMap ? convertRunTreeToRun(this.runTreeMap.get(runId)) : this.runMap.get(runId);
  }
  stringifyError(error) {
    if (error instanceof Error)
      return error.message + (error?.stack ? `

${error.stack}` : "");
    if (typeof error === "string")
      return error;
    return `${error}`;
  }
  _addChildRun(parentRun, childRun) {
    parentRun.child_runs.push(childRun);
  }
  _addRunToRunMap(run) {
    const { dottedOrder: currentDottedOrder, microsecondPrecisionDatestring } = convertToDottedOrderFormat(new Date(run.start_time).getTime(), run.id, run.execution_order);
    const storedRun = { ...run };
    const parentRun = this.getRunById(storedRun.parent_run_id);
    if (storedRun.parent_run_id !== undefined)
      if (parentRun) {
        this._addChildRun(parentRun, storedRun);
        parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);
        storedRun.trace_id = parentRun.trace_id;
        if (parentRun.dotted_order !== undefined) {
          storedRun.dotted_order = [parentRun.dotted_order, currentDottedOrder].join(".");
          storedRun._serialized_start_time = microsecondPrecisionDatestring;
        }
      } else
        storedRun.parent_run_id = undefined;
    else {
      storedRun.trace_id = storedRun.id;
      storedRun.dotted_order = currentDottedOrder;
      storedRun._serialized_start_time = microsecondPrecisionDatestring;
    }
    if (this.usesRunTreeMap) {
      const runTree = convertRunToRunTree(storedRun, parentRun);
      if (runTree !== undefined)
        this.runTreeMap.set(storedRun.id, runTree);
    } else
      this.runMap.set(storedRun.id, storedRun);
    return storedRun;
  }
  async _endTrace(run) {
    const parentRun = run.parent_run_id !== undefined && this.getRunById(run.parent_run_id);
    if (parentRun)
      parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);
    else
      await this.persistRun(run);
    await this.onRunUpdate?.(run);
    if (this.usesRunTreeMap)
      this.runTreeMap.delete(run.id);
    else
      this.runMap.delete(run.id);
  }
  _getExecutionOrder(parentRunId) {
    const parentRun = parentRunId !== undefined && this.getRunById(parentRunId);
    if (!parentRun)
      return 1;
    return parentRun.child_execution_order + 1;
  }
  _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const finalExtraParams = metadata ? {
      ...extraParams,
      metadata
    } : extraParams;
    const run = {
      id: runId,
      name: name ?? llm.id[llm.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: llm,
      events: [{
        name: "start",
        time: new Date(start_time).toISOString()
      }],
      inputs: { prompts },
      execution_order,
      child_runs: [],
      child_execution_order: execution_order,
      run_type: "llm",
      extra: finalExtraParams ?? {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
    const run = this.getRunById(runId) ?? this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);
    await this.onRunCreate?.(run);
    await this.onLLMStart?.(run);
    return run;
  }
  _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const finalExtraParams = metadata ? {
      ...extraParams,
      metadata
    } : extraParams;
    const run = {
      id: runId,
      name: name ?? llm.id[llm.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: llm,
      events: [{
        name: "start",
        time: new Date(start_time).toISOString()
      }],
      inputs: { messages },
      execution_order,
      child_runs: [],
      child_execution_order: execution_order,
      run_type: "llm",
      extra: finalExtraParams ?? {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
    const run = this.getRunById(runId) ?? this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);
    await this.onRunCreate?.(run);
    await this.onLLMStart?.(run);
    return run;
  }
  async handleLLMEnd(output, runId, _parentRunId, _tags, extraParams) {
    const run = this.getRunById(runId);
    if (!run || run?.run_type !== "llm")
      throw new Error("No LLM run to end.");
    run.end_time = Date.now();
    run.outputs = output;
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString()
    });
    run.extra = {
      ...run.extra,
      ...extraParams
    };
    await this.onLLMEnd?.(run);
    await this._endTrace(run);
    return run;
  }
  async handleLLMError(error, runId, _parentRunId, _tags, extraParams) {
    const run = this.getRunById(runId);
    if (!run || run?.run_type !== "llm")
      throw new Error("No LLM run to end.");
    run.end_time = Date.now();
    run.error = this.stringifyError(error);
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString()
    });
    run.extra = {
      ...run.extra,
      ...extraParams
    };
    await this.onLLMError?.(run);
    await this._endTrace(run);
    return run;
  }
  _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run = {
      id: runId,
      name: name ?? chain.id[chain.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: chain,
      events: [{
        name: "start",
        time: new Date(start_time).toISOString()
      }],
      inputs,
      execution_order,
      child_execution_order: execution_order,
      run_type: runType ?? "chain",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
    const run = this.getRunById(runId) ?? this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);
    await this.onRunCreate?.(run);
    await this.onChainStart?.(run);
    return run;
  }
  async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {
    const run = this.getRunById(runId);
    if (!run)
      throw new Error("No chain run to end.");
    run.end_time = Date.now();
    run.outputs = _coerceToDict(outputs, "output");
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString()
    });
    if (kwargs?.inputs !== undefined)
      run.inputs = _coerceToDict(kwargs.inputs, "input");
    await this.onChainEnd?.(run);
    await this._endTrace(run);
    return run;
  }
  async handleChainError(error, runId, _parentRunId, _tags, kwargs) {
    const run = this.getRunById(runId);
    if (!run)
      throw new Error("No chain run to end.");
    run.end_time = Date.now();
    run.error = this.stringifyError(error);
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString()
    });
    if (kwargs?.inputs !== undefined)
      run.inputs = _coerceToDict(kwargs.inputs, "input");
    await this.onChainError?.(run);
    await this._endTrace(run);
    return run;
  }
  _createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run = {
      id: runId,
      name: name ?? tool.id[tool.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: tool,
      events: [{
        name: "start",
        time: new Date(start_time).toISOString()
      }],
      inputs: { input },
      execution_order,
      child_execution_order: execution_order,
      run_type: "tool",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
    const run = this.getRunById(runId) ?? this._createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name);
    await this.onRunCreate?.(run);
    await this.onToolStart?.(run);
    return run;
  }
  async handleToolEnd(output, runId) {
    const run = this.getRunById(runId);
    if (!run || run?.run_type !== "tool")
      throw new Error("No tool run to end");
    run.end_time = Date.now();
    run.outputs = { output };
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString()
    });
    await this.onToolEnd?.(run);
    await this._endTrace(run);
    return run;
  }
  async handleToolError(error, runId) {
    const run = this.getRunById(runId);
    if (!run || run?.run_type !== "tool")
      throw new Error("No tool run to end");
    run.end_time = Date.now();
    run.error = this.stringifyError(error);
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString()
    });
    await this.onToolError?.(run);
    await this._endTrace(run);
    return run;
  }
  async handleAgentAction(action, runId) {
    const run = this.getRunById(runId);
    if (!run || run?.run_type !== "chain")
      return;
    const agentRun = run;
    agentRun.actions = agentRun.actions || [];
    agentRun.actions.push(action);
    agentRun.events.push({
      name: "agent_action",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action }
    });
    await this.onAgentAction?.(run);
  }
  async handleAgentEnd(action, runId) {
    const run = this.getRunById(runId);
    if (!run || run?.run_type !== "chain")
      return;
    run.events.push({
      name: "agent_end",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action }
    });
    await this.onAgentEnd?.(run);
  }
  _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run = {
      id: runId,
      name: name ?? retriever.id[retriever.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: retriever,
      events: [{
        name: "start",
        time: new Date(start_time).toISOString()
      }],
      inputs: { query },
      execution_order,
      child_execution_order: execution_order,
      run_type: "retriever",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
    const run = this.getRunById(runId) ?? this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);
    await this.onRunCreate?.(run);
    await this.onRetrieverStart?.(run);
    return run;
  }
  async handleRetrieverEnd(documents, runId) {
    const run = this.getRunById(runId);
    if (!run || run?.run_type !== "retriever")
      throw new Error("No retriever run to end");
    run.end_time = Date.now();
    run.outputs = { documents };
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString()
    });
    await this.onRetrieverEnd?.(run);
    await this._endTrace(run);
    return run;
  }
  async handleRetrieverError(error, runId) {
    const run = this.getRunById(runId);
    if (!run || run?.run_type !== "retriever")
      throw new Error("No retriever run to end");
    run.end_time = Date.now();
    run.error = this.stringifyError(error);
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString()
    });
    await this.onRetrieverError?.(run);
    await this._endTrace(run);
    return run;
  }
  async handleText(text, runId) {
    const run = this.getRunById(runId);
    if (!run || run?.run_type !== "chain")
      return;
    run.events.push({
      name: "text",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { text }
    });
    await this.onText?.(run);
  }
  async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {
    const run = this.getRunById(runId);
    if (!run || run?.run_type !== "llm")
      throw new Error(`Invalid "runId" provided to "handleLLMNewToken" callback.`);
    run.events.push({
      name: "new_token",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: {
        token,
        idx,
        chunk: fields?.chunk
      }
    });
    await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });
    return run;
  }
};

// node_modules/@langchain/core/dist/tracers/console.js
var import_ansi_styles = __toESM(require_ansi_styles(), 1);
var console_exports = {};
__export2(console_exports, { ConsoleCallbackHandler: () => ConsoleCallbackHandler });
function wrap(style, text) {
  return `${style.open}${text}${style.close}`;
}
function tryJsonStringify(obj, fallback) {
  try {
    return JSON.stringify(obj, null, 2);
  } catch {
    return fallback;
  }
}
function formatKVMapItem(value) {
  if (typeof value === "string")
    return value.trim();
  if (value === null || value === undefined)
    return value;
  return tryJsonStringify(value, value.toString());
}
function elapsed(run) {
  if (!run.end_time)
    return "";
  const elapsed$1 = run.end_time - run.start_time;
  if (elapsed$1 < 1000)
    return `${elapsed$1}ms`;
  return `${(elapsed$1 / 1000).toFixed(2)}s`;
}
var { color } = import_ansi_styles.default;
var ConsoleCallbackHandler = class extends BaseTracer {
  name = "console_callback_handler";
  persistRun(_run) {
    return Promise.resolve();
  }
  getParents(run) {
    const parents = [];
    let currentRun = run;
    while (currentRun.parent_run_id) {
      const parent = this.runMap.get(currentRun.parent_run_id);
      if (parent) {
        parents.push(parent);
        currentRun = parent;
      } else
        break;
    }
    return parents;
  }
  getBreadcrumbs(run) {
    const parents = this.getParents(run).reverse();
    const string = [...parents, run].map((parent, i, arr2) => {
      const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;
      return i === arr2.length - 1 ? wrap(import_ansi_styles.default.bold, name) : name;
    }).join(" > ");
    return wrap(color.grey, string);
  }
  onChainStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.green, "[chain/start]")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
  }
  onChainEnd(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.cyan, "[chain/end]")} [${crumbs}] [${elapsed(run)}] Exiting Chain run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
  }
  onChainError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.red, "[chain/error]")} [${crumbs}] [${elapsed(run)}] Chain run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
  }
  onLLMStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    const inputs = "prompts" in run.inputs ? { prompts: run.inputs.prompts.map((p) => p.trim()) } : run.inputs;
    console.log(`${wrap(color.green, "[llm/start]")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(inputs, "[inputs]")}`);
  }
  onLLMEnd(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.cyan, "[llm/end]")} [${crumbs}] [${elapsed(run)}] Exiting LLM run with output: ${tryJsonStringify(run.outputs, "[response]")}`);
  }
  onLLMError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.red, "[llm/error]")} [${crumbs}] [${elapsed(run)}] LLM run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
  }
  onToolStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.green, "[tool/start]")} [${crumbs}] Entering Tool run with input: "${formatKVMapItem(run.inputs.input)}"`);
  }
  onToolEnd(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.cyan, "[tool/end]")} [${crumbs}] [${elapsed(run)}] Exiting Tool run with output: "${formatKVMapItem(run.outputs?.output)}"`);
  }
  onToolError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.red, "[tool/error]")} [${crumbs}] [${elapsed(run)}] Tool run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
  }
  onRetrieverStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.green, "[retriever/start]")} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
  }
  onRetrieverEnd(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.cyan, "[retriever/end]")} [${crumbs}] [${elapsed(run)}] Exiting Retriever run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
  }
  onRetrieverError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.red, "[retriever/error]")} [${crumbs}] [${elapsed(run)}] Retriever run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
  }
  onAgentAction(run) {
    const agentRun = run;
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.blue, "[agent/action]")} [${crumbs}] Agent selected action: ${tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], "[action]")}`);
  }
};
// node_modules/@langchain/core/dist/singletons/tracer.js
var client;
var getDefaultLangChainClientSingleton = () => {
  if (client === undefined) {
    const clientParams = getEnvironmentVariable("LANGCHAIN_CALLBACKS_BACKGROUND") === "false" ? { blockOnRootRunFinalization: true } : {};
    client = new Client(clientParams);
  }
  return client;
};

// node_modules/langsmith/dist/singletons/traceable.js
class MockAsyncLocalStorage {
  getStore() {
    return;
  }
  run(_, callback) {
    return callback();
  }
}
var TRACING_ALS_KEY2 = Symbol.for("ls:tracing_async_local_storage");
var mockAsyncLocalStorage = new MockAsyncLocalStorage;

class AsyncLocalStorageProvider {
  getInstance() {
    return globalThis[TRACING_ALS_KEY2] ?? mockAsyncLocalStorage;
  }
  initializeGlobalInstance(instance) {
    if (globalThis[TRACING_ALS_KEY2] === undefined) {
      globalThis[TRACING_ALS_KEY2] = instance;
    }
  }
}
var AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider;
function getCurrentRunTree(permitAbsentRunTree = false) {
  const runTree = AsyncLocalStorageProviderSingleton.getInstance().getStore();
  if (!permitAbsentRunTree && runTree === undefined) {
    throw new Error(`Could not get the current run tree.

Please make sure you are calling this method within a traceable function and that tracing is enabled.`);
  }
  return runTree;
}
var ROOT = Symbol.for("langsmith:traceable:root");
function isTraceableFunction(x) {
  return typeof x === "function" && "langsmith:traceable" in x;
}
// node_modules/@langchain/core/dist/tracers/tracer_langchain.js
var tracer_langchain_exports = {};
__export2(tracer_langchain_exports, { LangChainTracer: () => LangChainTracer });
var LangChainTracer = class LangChainTracer2 extends BaseTracer {
  name = "langchain_tracer";
  projectName;
  exampleId;
  client;
  replicas;
  usesRunTreeMap = true;
  constructor(fields = {}) {
    super(fields);
    const { exampleId, projectName, client: client2, replicas } = fields;
    this.projectName = projectName ?? getDefaultProjectName();
    this.replicas = replicas;
    this.exampleId = exampleId;
    this.client = client2 ?? getDefaultLangChainClientSingleton();
    const traceableTree = LangChainTracer2.getTraceableRunTree();
    if (traceableTree)
      this.updateFromRunTree(traceableTree);
  }
  async persistRun(_run) {}
  async onRunCreate(run) {
    const runTree = this.getRunTreeWithTracingConfig(run.id);
    await runTree?.postRun();
  }
  async onRunUpdate(run) {
    const runTree = this.getRunTreeWithTracingConfig(run.id);
    await runTree?.patchRun();
  }
  getRun(id) {
    return this.runTreeMap.get(id);
  }
  updateFromRunTree(runTree) {
    this.runTreeMap.set(runTree.id, runTree);
    let rootRun = runTree;
    const visited = /* @__PURE__ */ new Set;
    while (rootRun.parent_run) {
      if (visited.has(rootRun.id))
        break;
      visited.add(rootRun.id);
      if (!rootRun.parent_run)
        break;
      rootRun = rootRun.parent_run;
    }
    visited.clear();
    const queue = [rootRun];
    while (queue.length > 0) {
      const current = queue.shift();
      if (!current || visited.has(current.id))
        continue;
      visited.add(current.id);
      this.runTreeMap.set(current.id, current);
      if (current.child_runs)
        queue.push(...current.child_runs);
    }
    this.client = runTree.client ?? this.client;
    this.replicas = runTree.replicas ?? this.replicas;
    this.projectName = runTree.project_name ?? this.projectName;
    this.exampleId = runTree.reference_example_id ?? this.exampleId;
  }
  getRunTreeWithTracingConfig(id) {
    const runTree = this.runTreeMap.get(id);
    if (!runTree)
      return;
    return new RunTree({
      ...runTree,
      client: this.client,
      project_name: this.projectName,
      replicas: this.replicas,
      reference_example_id: this.exampleId,
      tracingEnabled: true
    });
  }
  static getTraceableRunTree() {
    try {
      return getCurrentRunTree(true);
    } catch {
      return;
    }
  }
};

// node_modules/@langchain/core/dist/singletons/callbacks.js
var import_p_queue2 = __toESM(require_dist2(), 1);
var queue;
function createQueue() {
  const PQueue = "default" in import_p_queue2.default ? import_p_queue2.default.default : import_p_queue2.default;
  return new PQueue({
    autoStart: true,
    concurrency: 1
  });
}
function getQueue() {
  if (typeof queue === "undefined")
    queue = createQueue();
  return queue;
}
async function consumeCallback(promiseFn, wait) {
  if (wait === true) {
    const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
    if (asyncLocalStorageInstance !== undefined)
      await asyncLocalStorageInstance.run(undefined, async () => promiseFn());
    else
      await promiseFn();
  } else {
    queue = getQueue();
    queue.add(async () => {
      const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
      if (asyncLocalStorageInstance !== undefined)
        await asyncLocalStorageInstance.run(undefined, async () => promiseFn());
      else
        await promiseFn();
    });
  }
}
async function awaitAllCallbacks() {
  const defaultClient = getDefaultLangChainClientSingleton();
  await Promise.allSettled([typeof queue !== "undefined" ? queue.onIdle() : Promise.resolve(), defaultClient.awaitPendingTraceBatches()]);
}

// node_modules/@langchain/core/dist/callbacks/promises.js
var promises_exports = {};
__export2(promises_exports, {
  awaitAllCallbacks: () => awaitAllCallbacks,
  consumeCallback: () => consumeCallback
});

// node_modules/@langchain/core/dist/utils/callbacks.js
var isTracingEnabled2 = (tracingEnabled) => {
  if (tracingEnabled !== undefined)
    return tracingEnabled;
  const envVars = [
    "LANGSMITH_TRACING_V2",
    "LANGCHAIN_TRACING_V2",
    "LANGSMITH_TRACING",
    "LANGCHAIN_TRACING"
  ];
  return !!envVars.find((envVar) => getEnvironmentVariable(envVar) === "true");
};

// node_modules/@langchain/core/dist/singletons/async_local_storage/context.js
function getContextVariable(name) {
  const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
  if (asyncLocalStorageInstance === undefined)
    return;
  const runTree = asyncLocalStorageInstance.getStore();
  return runTree?.[_CONTEXT_VARIABLES_KEY]?.[name];
}
var LC_CONFIGURE_HOOKS_KEY = Symbol("lc:configure_hooks");
var _getConfigureHooks = () => getContextVariable(LC_CONFIGURE_HOOKS_KEY) || [];

// node_modules/@langchain/core/dist/callbacks/manager.js
var manager_exports = {};
__export2(manager_exports, {
  BaseCallbackManager: () => BaseCallbackManager,
  BaseRunManager: () => BaseRunManager,
  CallbackManager: () => CallbackManager,
  CallbackManagerForChainRun: () => CallbackManagerForChainRun,
  CallbackManagerForLLMRun: () => CallbackManagerForLLMRun,
  CallbackManagerForRetrieverRun: () => CallbackManagerForRetrieverRun,
  CallbackManagerForToolRun: () => CallbackManagerForToolRun,
  ensureHandler: () => ensureHandler,
  parseCallbackConfigArg: () => parseCallbackConfigArg
});
function parseCallbackConfigArg(arg) {
  if (!arg)
    return {};
  else if (Array.isArray(arg) || "name" in arg)
    return { callbacks: arg };
  else
    return arg;
}
var BaseCallbackManager = class {
  setHandler(handler) {
    return this.setHandlers([handler]);
  }
};
var BaseRunManager = class {
  constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {
    this.runId = runId;
    this.handlers = handlers;
    this.inheritableHandlers = inheritableHandlers;
    this.tags = tags;
    this.inheritableTags = inheritableTags;
    this.metadata = metadata;
    this.inheritableMetadata = inheritableMetadata;
    this._parentRunId = _parentRunId;
  }
  get parentRunId() {
    return this._parentRunId;
  }
  async handleText(text) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      try {
        await handler.handleText?.(text, this.runId, this._parentRunId, this.tags);
      } catch (err) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleText: ${err}`);
        if (handler.raiseError)
          throw err;
      }
    }, handler.awaitHandlers)));
  }
  async handleCustomEvent(eventName, data, _runId, _tags, _metadata) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      try {
        await handler.handleCustomEvent?.(eventName, data, this.runId, this.tags, this.metadata);
      } catch (err) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);
        if (handler.raiseError)
          throw err;
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForRetrieverRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag)
      manager.addTags([tag], false);
    return manager;
  }
  async handleRetrieverEnd(documents) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreRetriever)
        try {
          await handler.handleRetrieverEnd?.(documents, this.runId, this._parentRunId, this.tags);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleRetriever`);
          if (handler.raiseError)
            throw err;
        }
    }, handler.awaitHandlers)));
  }
  async handleRetrieverError(err) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreRetriever)
        try {
          await handler.handleRetrieverError?.(err, this.runId, this._parentRunId, this.tags);
        } catch (error) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);
          if (handler.raiseError)
            throw err;
        }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForLLMRun = class extends BaseRunManager {
  async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreLLM)
        try {
          await handler.handleLLMNewToken?.(token, idx ?? {
            prompt: 0,
            completion: 0
          }, this.runId, this._parentRunId, this.tags, fields);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);
          if (handler.raiseError)
            throw err;
        }
    }, handler.awaitHandlers)));
  }
  async handleLLMError(err, _runId, _parentRunId, _tags, extraParams) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreLLM)
        try {
          await handler.handleLLMError?.(err, this.runId, this._parentRunId, this.tags, extraParams);
        } catch (err$1) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleLLMError: ${err$1}`);
          if (handler.raiseError)
            throw err$1;
        }
    }, handler.awaitHandlers)));
  }
  async handleLLMEnd(output, _runId, _parentRunId, _tags, extraParams) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreLLM)
        try {
          await handler.handleLLMEnd?.(output, this.runId, this._parentRunId, this.tags, extraParams);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);
          if (handler.raiseError)
            throw err;
        }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForChainRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag)
      manager.addTags([tag], false);
    return manager;
  }
  async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreChain)
        try {
          await handler.handleChainError?.(err, this.runId, this._parentRunId, this.tags, kwargs);
        } catch (err$1) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleChainError: ${err$1}`);
          if (handler.raiseError)
            throw err$1;
        }
    }, handler.awaitHandlers)));
  }
  async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreChain)
        try {
          await handler.handleChainEnd?.(output, this.runId, this._parentRunId, this.tags, kwargs);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);
          if (handler.raiseError)
            throw err;
        }
    }, handler.awaitHandlers)));
  }
  async handleAgentAction(action) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreAgent)
        try {
          await handler.handleAgentAction?.(action, this.runId, this._parentRunId, this.tags);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);
          if (handler.raiseError)
            throw err;
        }
    }, handler.awaitHandlers)));
  }
  async handleAgentEnd(action) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreAgent)
        try {
          await handler.handleAgentEnd?.(action, this.runId, this._parentRunId, this.tags);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);
          if (handler.raiseError)
            throw err;
        }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForToolRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag)
      manager.addTags([tag], false);
    return manager;
  }
  async handleToolError(err) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreAgent)
        try {
          await handler.handleToolError?.(err, this.runId, this._parentRunId, this.tags);
        } catch (err$1) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleToolError: ${err$1}`);
          if (handler.raiseError)
            throw err$1;
        }
    }, handler.awaitHandlers)));
  }
  async handleToolEnd(output) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreAgent)
        try {
          await handler.handleToolEnd?.(output, this.runId, this._parentRunId, this.tags);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);
          if (handler.raiseError)
            throw err;
        }
    }, handler.awaitHandlers)));
  }
};
var CallbackManager = class CallbackManager2 extends BaseCallbackManager {
  handlers = [];
  inheritableHandlers = [];
  tags = [];
  inheritableTags = [];
  metadata = {};
  inheritableMetadata = {};
  name = "callback_manager";
  _parentRunId;
  constructor(parentRunId, options) {
    super();
    this.handlers = options?.handlers ?? this.handlers;
    this.inheritableHandlers = options?.inheritableHandlers ?? this.inheritableHandlers;
    this.tags = options?.tags ?? this.tags;
    this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;
    this.metadata = options?.metadata ?? this.metadata;
    this.inheritableMetadata = options?.inheritableMetadata ?? this.inheritableMetadata;
    this._parentRunId = parentRunId;
  }
  getParentRunId() {
    return this._parentRunId;
  }
  async handleLLMStart(llm, prompts, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {
    return Promise.all(prompts.map(async (prompt, idx) => {
      const runId_ = idx === 0 && runId ? runId : v7();
      await Promise.all(this.handlers.map((handler) => {
        if (handler.ignoreLLM)
          return;
        if (isBaseTracer(handler))
          handler._createRunForLLMStart(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
        return consumeCallback(async () => {
          try {
            await handler.handleLLMStart?.(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
            if (handler.raiseError)
              throw err;
          }
        }, handler.awaitHandlers);
      }));
      return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChatModelStart(llm, messages, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {
    return Promise.all(messages.map(async (messageGroup, idx) => {
      const runId_ = idx === 0 && runId ? runId : v7();
      await Promise.all(this.handlers.map((handler) => {
        if (handler.ignoreLLM)
          return;
        if (isBaseTracer(handler))
          handler._createRunForChatModelStart(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
        return consumeCallback(async () => {
          try {
            if (handler.handleChatModelStart)
              await handler.handleChatModelStart?.(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
            else if (handler.handleLLMStart) {
              const messageString = getBufferString(messageGroup);
              await handler.handleLLMStart?.(llm, [messageString], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
            }
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
            if (handler.raiseError)
              throw err;
          }
        }, handler.awaitHandlers);
      }));
      return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChainStart(chain, inputs, runId = v7(), runType = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {
    await Promise.all(this.handlers.map((handler) => {
      if (handler.ignoreChain)
        return;
      if (isBaseTracer(handler))
        handler._createRunForChainStart(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);
      return consumeCallback(async () => {
        try {
          await handler.handleChainStart?.(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);
          if (handler.raiseError)
            throw err;
        }
      }, handler.awaitHandlers);
    }));
    return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleToolStart(tool, input, runId = v7(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {
    await Promise.all(this.handlers.map((handler) => {
      if (handler.ignoreAgent)
        return;
      if (isBaseTracer(handler))
        handler._createRunForToolStart(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);
      return consumeCallback(async () => {
        try {
          await handler.handleToolStart?.(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);
          if (handler.raiseError)
            throw err;
        }
      }, handler.awaitHandlers);
    }));
    return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleRetrieverStart(retriever, query, runId = v7(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {
    await Promise.all(this.handlers.map((handler) => {
      if (handler.ignoreRetriever)
        return;
      if (isBaseTracer(handler))
        handler._createRunForRetrieverStart(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);
      return consumeCallback(async () => {
        try {
          await handler.handleRetrieverStart?.(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);
          if (handler.raiseError)
            throw err;
        }
      }, handler.awaitHandlers);
    }));
    return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleCustomEvent(eventName, data, runId, _tags, _metadata) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      if (!handler.ignoreCustomEvent)
        try {
          await handler.handleCustomEvent?.(eventName, data, runId, this.tags, this.metadata);
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);
          if (handler.raiseError)
            throw err;
        }
    }, handler.awaitHandlers)));
  }
  addHandler(handler, inherit = true) {
    this.handlers.push(handler);
    if (inherit)
      this.inheritableHandlers.push(handler);
  }
  removeHandler(handler) {
    this.handlers = this.handlers.filter((_handler) => _handler !== handler);
    this.inheritableHandlers = this.inheritableHandlers.filter((_handler) => _handler !== handler);
  }
  setHandlers(handlers, inherit = true) {
    this.handlers = [];
    this.inheritableHandlers = [];
    for (const handler of handlers)
      this.addHandler(handler, inherit);
  }
  addTags(tags, inherit = true) {
    this.removeTags(tags);
    this.tags.push(...tags);
    if (inherit)
      this.inheritableTags.push(...tags);
  }
  removeTags(tags) {
    this.tags = this.tags.filter((tag) => !tags.includes(tag));
    this.inheritableTags = this.inheritableTags.filter((tag) => !tags.includes(tag));
  }
  addMetadata(metadata, inherit = true) {
    this.metadata = {
      ...this.metadata,
      ...metadata
    };
    if (inherit)
      this.inheritableMetadata = {
        ...this.inheritableMetadata,
        ...metadata
      };
  }
  removeMetadata(metadata) {
    for (const key of Object.keys(metadata)) {
      delete this.metadata[key];
      delete this.inheritableMetadata[key];
    }
  }
  copy(additionalHandlers = [], inherit = true) {
    const manager = new CallbackManager2(this._parentRunId);
    for (const handler of this.handlers) {
      const inheritable = this.inheritableHandlers.includes(handler);
      manager.addHandler(handler, inheritable);
    }
    for (const tag of this.tags) {
      const inheritable = this.inheritableTags.includes(tag);
      manager.addTags([tag], inheritable);
    }
    for (const key of Object.keys(this.metadata)) {
      const inheritable = Object.keys(this.inheritableMetadata).includes(key);
      manager.addMetadata({ [key]: this.metadata[key] }, inheritable);
    }
    for (const handler of additionalHandlers) {
      if (manager.handlers.filter((h) => h.name === "console_callback_handler").some((h) => h.name === handler.name))
        continue;
      manager.addHandler(handler, inherit);
    }
    return manager;
  }
  static fromHandlers(handlers) {

    class Handler extends BaseCallbackHandler {
      name = v7();
      constructor() {
        super();
        Object.assign(this, handlers);
      }
    }
    const manager = new this;
    manager.addHandler(new Handler);
    return manager;
  }
  static configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
    return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options);
  }
  static _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
    let callbackManager;
    if (inheritableHandlers || localHandlers) {
      if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {
        callbackManager = new CallbackManager2;
        callbackManager.setHandlers(inheritableHandlers?.map(ensureHandler) ?? [], true);
      } else
        callbackManager = inheritableHandlers;
      callbackManager = callbackManager.copy(Array.isArray(localHandlers) ? localHandlers.map(ensureHandler) : localHandlers?.handlers, false);
    }
    const verboseEnabled = getEnvironmentVariable("LANGCHAIN_VERBOSE") === "true" || options?.verbose;
    const tracingV2Enabled = LangChainTracer.getTraceableRunTree()?.tracingEnabled || isTracingEnabled2();
    const tracingEnabled = tracingV2Enabled || (getEnvironmentVariable("LANGCHAIN_TRACING") ?? false);
    if (verboseEnabled || tracingEnabled) {
      if (!callbackManager)
        callbackManager = new CallbackManager2;
      if (verboseEnabled && !callbackManager.handlers.some((handler) => handler.name === ConsoleCallbackHandler.prototype.name)) {
        const consoleHandler = new ConsoleCallbackHandler;
        callbackManager.addHandler(consoleHandler, true);
      }
      if (tracingEnabled && !callbackManager.handlers.some((handler) => handler.name === "langchain_tracer")) {
        if (tracingV2Enabled) {
          const tracerV2 = new LangChainTracer;
          callbackManager.addHandler(tracerV2, true);
        }
      }
      if (tracingV2Enabled) {
        const implicitRunTree = LangChainTracer.getTraceableRunTree();
        if (implicitRunTree && callbackManager._parentRunId === undefined) {
          callbackManager._parentRunId = implicitRunTree.id;
          const tracerV2 = callbackManager.handlers.find((handler) => handler.name === "langchain_tracer");
          tracerV2?.updateFromRunTree(implicitRunTree);
        }
      }
    }
    for (const { contextVar, inheritable = true, handlerClass, envVar } of _getConfigureHooks()) {
      const createIfNotInContext = envVar && getEnvironmentVariable(envVar) === "true" && handlerClass;
      let handler;
      const contextVarValue = contextVar !== undefined ? getContextVariable(contextVar) : undefined;
      if (contextVarValue && isBaseCallbackHandler(contextVarValue))
        handler = contextVarValue;
      else if (createIfNotInContext)
        handler = new handlerClass({});
      if (handler !== undefined) {
        if (!callbackManager)
          callbackManager = new CallbackManager2;
        if (!callbackManager.handlers.some((h) => h.name === handler.name))
          callbackManager.addHandler(handler, inheritable);
      }
    }
    if (inheritableTags || localTags) {
      if (callbackManager) {
        callbackManager.addTags(inheritableTags ?? []);
        callbackManager.addTags(localTags ?? [], false);
      }
    }
    if (inheritableMetadata || localMetadata) {
      if (callbackManager) {
        callbackManager.addMetadata(inheritableMetadata ?? {});
        callbackManager.addMetadata(localMetadata ?? {}, false);
      }
    }
    return callbackManager;
  }
};
function ensureHandler(handler) {
  if ("name" in handler)
    return handler;
  return BaseCallbackHandler.fromMethods(handler);
}

// node_modules/@langchain/core/dist/singletons/async_local_storage/index.js
var MockAsyncLocalStorage2 = class {
  getStore() {
    return;
  }
  run(_store, callback) {
    return callback();
  }
  enterWith(_store) {
    return;
  }
};
var mockAsyncLocalStorage2 = new MockAsyncLocalStorage2;
var LC_CHILD_KEY = Symbol.for("lc:child_config");
var AsyncLocalStorageProvider2 = class {
  getInstance() {
    return getGlobalAsyncLocalStorageInstance() ?? mockAsyncLocalStorage2;
  }
  getRunnableConfig() {
    const storage = this.getInstance();
    return storage.getStore()?.extra?.[LC_CHILD_KEY];
  }
  runWithConfig(config, callback, avoidCreatingRootRunTree) {
    const callbackManager = CallbackManager._configureSync(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);
    const storage = this.getInstance();
    const previousValue = storage.getStore();
    const parentRunId = callbackManager?.getParentRunId();
    const langChainTracer = callbackManager?.handlers?.find((handler) => handler?.name === "langchain_tracer");
    let runTree;
    if (langChainTracer && parentRunId)
      runTree = langChainTracer.getRunTreeWithTracingConfig(parentRunId);
    else if (!avoidCreatingRootRunTree)
      runTree = new RunTree({
        name: "<runnable_lambda>",
        tracingEnabled: false
      });
    if (runTree)
      runTree.extra = {
        ...runTree.extra,
        [LC_CHILD_KEY]: config
      };
    if (previousValue !== undefined && previousValue[_CONTEXT_VARIABLES_KEY] !== undefined) {
      if (runTree === undefined)
        runTree = {};
      runTree[_CONTEXT_VARIABLES_KEY] = previousValue[_CONTEXT_VARIABLES_KEY];
    }
    return storage.run(runTree, callback);
  }
  initializeGlobalInstance(instance) {
    if (getGlobalAsyncLocalStorageInstance() === undefined)
      setGlobalAsyncLocalStorageInstance(instance);
  }
};
var AsyncLocalStorageProviderSingleton2 = new AsyncLocalStorageProvider2;

// node_modules/@langchain/core/dist/singletons/index.js
var singletons_exports = {};
__export2(singletons_exports, {
  AsyncLocalStorageProviderSingleton: () => AsyncLocalStorageProviderSingleton2,
  MockAsyncLocalStorage: () => MockAsyncLocalStorage2,
  _CONTEXT_VARIABLES_KEY: () => _CONTEXT_VARIABLES_KEY
});

// node_modules/@langchain/core/dist/runnables/config.js
var DEFAULT_RECURSION_LIMIT = 25;
async function getCallbackManagerForConfig(config) {
  return CallbackManager._configureSync(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);
}
function mergeConfigs(...configs) {
  const copy = {};
  for (const options of configs.filter((c) => !!c))
    for (const key of Object.keys(options))
      if (key === "metadata")
        copy[key] = {
          ...copy[key],
          ...options[key]
        };
      else if (key === "tags") {
        const baseKeys = copy[key] ?? [];
        copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];
      } else if (key === "configurable")
        copy[key] = {
          ...copy[key],
          ...options[key]
        };
      else if (key === "timeout") {
        if (copy.timeout === undefined)
          copy.timeout = options.timeout;
        else if (options.timeout !== undefined)
          copy.timeout = Math.min(copy.timeout, options.timeout);
      } else if (key === "signal") {
        if (copy.signal === undefined)
          copy.signal = options.signal;
        else if (options.signal !== undefined)
          if ("any" in AbortSignal)
            copy.signal = AbortSignal.any([copy.signal, options.signal]);
          else
            copy.signal = options.signal;
      } else if (key === "callbacks") {
        const baseCallbacks = copy.callbacks;
        const providedCallbacks = options.callbacks;
        if (Array.isArray(providedCallbacks))
          if (!baseCallbacks)
            copy.callbacks = providedCallbacks;
          else if (Array.isArray(baseCallbacks))
            copy.callbacks = baseCallbacks.concat(providedCallbacks);
          else {
            const manager = baseCallbacks.copy();
            for (const callback of providedCallbacks)
              manager.addHandler(ensureHandler(callback), true);
            copy.callbacks = manager;
          }
        else if (providedCallbacks)
          if (!baseCallbacks)
            copy.callbacks = providedCallbacks;
          else if (Array.isArray(baseCallbacks)) {
            const manager = providedCallbacks.copy();
            for (const callback of baseCallbacks)
              manager.addHandler(ensureHandler(callback), true);
            copy.callbacks = manager;
          } else
            copy.callbacks = new CallbackManager(providedCallbacks._parentRunId, {
              handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),
              inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),
              tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),
              inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),
              metadata: {
                ...baseCallbacks.metadata,
                ...providedCallbacks.metadata
              }
            });
      } else {
        const typedKey = key;
        copy[typedKey] = options[typedKey] ?? copy[typedKey];
      }
  return copy;
}
var PRIMITIVES = new Set([
  "string",
  "number",
  "boolean"
]);
function ensureConfig(config) {
  const implicitConfig = AsyncLocalStorageProviderSingleton2.getRunnableConfig();
  let empty = {
    tags: [],
    metadata: {},
    recursionLimit: 25,
    runId: undefined
  };
  if (implicitConfig) {
    const { runId, runName, ...rest } = implicitConfig;
    empty = Object.entries(rest).reduce((currentConfig, [key, value]) => {
      if (value !== undefined)
        currentConfig[key] = value;
      return currentConfig;
    }, empty);
  }
  if (config)
    empty = Object.entries(config).reduce((currentConfig, [key, value]) => {
      if (value !== undefined)
        currentConfig[key] = value;
      return currentConfig;
    }, empty);
  if (empty?.configurable) {
    for (const key of Object.keys(empty.configurable))
      if (PRIMITIVES.has(typeof empty.configurable[key]) && !empty.metadata?.[key]) {
        if (!empty.metadata)
          empty.metadata = {};
        empty.metadata[key] = empty.configurable[key];
      }
  }
  if (empty.timeout !== undefined) {
    if (empty.timeout <= 0)
      throw new Error("Timeout must be a positive number");
    const originalTimeoutMs = empty.timeout;
    const timeoutSignal = AbortSignal.timeout(originalTimeoutMs);
    if (!empty.metadata)
      empty.metadata = {};
    if (empty.metadata.timeoutMs === undefined)
      empty.metadata.timeoutMs = originalTimeoutMs;
    if (empty.signal !== undefined) {
      if ("any" in AbortSignal)
        empty.signal = AbortSignal.any([empty.signal, timeoutSignal]);
    } else
      empty.signal = timeoutSignal;
    delete empty.timeout;
  }
  return empty;
}
function patchConfig(config = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, runId } = {}) {
  const newConfig = ensureConfig(config);
  if (callbacks !== undefined) {
    delete newConfig.runName;
    newConfig.callbacks = callbacks;
  }
  if (recursionLimit !== undefined)
    newConfig.recursionLimit = recursionLimit;
  if (maxConcurrency !== undefined)
    newConfig.maxConcurrency = maxConcurrency;
  if (runName !== undefined)
    newConfig.runName = runName;
  if (configurable !== undefined)
    newConfig.configurable = {
      ...newConfig.configurable,
      ...configurable
    };
  if (runId !== undefined)
    delete newConfig.runId;
  return newConfig;
}
function pickRunnableConfigKeys(config) {
  if (!config)
    return;
  return {
    configurable: config.configurable,
    recursionLimit: config.recursionLimit,
    callbacks: config.callbacks,
    tags: config.tags,
    metadata: config.metadata,
    maxConcurrency: config.maxConcurrency,
    timeout: config.timeout,
    signal: config.signal,
    store: config.store
  };
}

// node_modules/@langchain/core/dist/utils/signal.js
async function raceWithSignal(promise, signal) {
  if (signal === undefined)
    return promise;
  let listener;
  return Promise.race([promise.catch((err) => {
    if (!signal?.aborted)
      throw err;
    else
      return;
  }), new Promise((_, reject) => {
    listener = () => {
      reject(getAbortSignalError(signal));
    };
    signal.addEventListener("abort", listener);
    if (signal.aborted)
      reject(getAbortSignalError(signal));
  })]).finally(() => signal.removeEventListener("abort", listener));
}
function getAbortSignalError(signal) {
  if (signal?.reason instanceof Error)
    return signal.reason;
  if (typeof signal?.reason === "string")
    return new Error(signal.reason);
  return /* @__PURE__ */ new Error("Aborted");
}

// node_modules/@langchain/core/dist/utils/stream.js
var stream_exports = {};
__export2(stream_exports, {
  AsyncGeneratorWithSetup: () => AsyncGeneratorWithSetup,
  IterableReadableStream: () => IterableReadableStream,
  atee: () => atee,
  concat: () => concat,
  pipeGeneratorWithSetup: () => pipeGeneratorWithSetup
});
var IterableReadableStream = class IterableReadableStream2 extends ReadableStream {
  reader;
  ensureReader() {
    if (!this.reader)
      this.reader = this.getReader();
  }
  async next() {
    this.ensureReader();
    try {
      const result = await this.reader.read();
      if (result.done) {
        this.reader.releaseLock();
        return {
          done: true,
          value: undefined
        };
      } else
        return {
          done: false,
          value: result.value
        };
    } catch (e) {
      this.reader.releaseLock();
      throw e;
    }
  }
  async return() {
    this.ensureReader();
    if (this.locked) {
      const cancelPromise = this.reader.cancel();
      this.reader.releaseLock();
      await cancelPromise;
    }
    return {
      done: true,
      value: undefined
    };
  }
  async throw(e) {
    this.ensureReader();
    if (this.locked) {
      const cancelPromise = this.reader.cancel();
      this.reader.releaseLock();
      await cancelPromise;
    }
    throw e;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async[Symbol.asyncDispose]() {
    await this.return();
  }
  static fromReadableStream(stream) {
    const reader = stream.getReader();
    return new IterableReadableStream2({
      start(controller) {
        return pump();
        function pump() {
          return reader.read().then(({ done, value }) => {
            if (done) {
              controller.close();
              return;
            }
            controller.enqueue(value);
            return pump();
          });
        }
      },
      cancel() {
        reader.releaseLock();
      }
    });
  }
  static fromAsyncGenerator(generator) {
    return new IterableReadableStream2({
      async pull(controller) {
        const { value, done } = await generator.next();
        if (done)
          controller.close();
        controller.enqueue(value);
      },
      async cancel(reason) {
        await generator.return(reason);
      }
    });
  }
};
function atee(iter, length = 2) {
  const buffers = Array.from({ length }, () => []);
  return buffers.map(async function* makeIter(buffer) {
    while (true)
      if (buffer.length === 0) {
        const result = await iter.next();
        for (const buffer$1 of buffers)
          buffer$1.push(result);
      } else if (buffer[0].done)
        return;
      else
        yield buffer.shift().value;
  });
}
function concat(first, second) {
  if (Array.isArray(first) && Array.isArray(second))
    return first.concat(second);
  else if (typeof first === "string" && typeof second === "string")
    return first + second;
  else if (typeof first === "number" && typeof second === "number")
    return first + second;
  else if ("concat" in first && typeof first.concat === "function")
    return first.concat(second);
  else if (typeof first === "object" && typeof second === "object") {
    const chunk = { ...first };
    for (const [key, value] of Object.entries(second))
      if (key in chunk && !Array.isArray(chunk[key]))
        chunk[key] = concat(chunk[key], value);
      else
        chunk[key] = value;
    return chunk;
  } else
    throw new Error(`Cannot concat ${typeof first} and ${typeof second}`);
}
var AsyncGeneratorWithSetup = class {
  generator;
  setup;
  config;
  signal;
  firstResult;
  firstResultUsed = false;
  constructor(params) {
    this.generator = params.generator;
    this.config = params.config;
    this.signal = params.signal ?? this.config?.signal;
    this.setup = new Promise((resolve, reject) => {
      AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(params.config), async () => {
        this.firstResult = params.generator.next();
        if (params.startSetup)
          this.firstResult.then(params.startSetup).then(resolve, reject);
        else
          this.firstResult.then((_result) => resolve(undefined), reject);
      }, true);
    });
  }
  async next(...args) {
    this.signal?.throwIfAborted();
    if (!this.firstResultUsed) {
      this.firstResultUsed = true;
      return this.firstResult;
    }
    return AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(this.config), this.signal ? async () => {
      return raceWithSignal(this.generator.next(...args), this.signal);
    } : async () => {
      return this.generator.next(...args);
    }, true);
  }
  async return(value) {
    return this.generator.return(value);
  }
  async throw(e) {
    return this.generator.throw(e);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async[Symbol.asyncDispose]() {
    await this.return();
  }
};
async function pipeGeneratorWithSetup(to, generator, startSetup, signal, ...args) {
  const gen = new AsyncGeneratorWithSetup({
    generator,
    startSetup,
    signal
  });
  const setup = await gen.setup;
  return {
    output: to(gen, setup, ...args),
    setup
  };
}

// node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js
/*!
* https://github.com/Starcounter-Jack/JSON-Patch
* (c) 2017-2022 Joachim Wester
* MIT licensed
*/
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
  return _hasOwnProperty.call(obj, key);
}
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    const keys$1 = new Array(obj.length);
    for (let k = 0;k < keys$1.length; k++)
      keys$1[k] = "" + k;
    return keys$1;
  }
  if (Object.keys)
    return Object.keys(obj);
  let keys = [];
  for (let i in obj)
    if (hasOwnProperty(obj, i))
      keys.push(i);
  return keys;
}
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    case "undefined":
      return null;
    default:
      return obj;
  }
}
function isInteger(str) {
  let i = 0;
  const len = str.length;
  let charCode;
  while (i < len) {
    charCode = str.charCodeAt(i);
    if (charCode >= 48 && charCode <= 57) {
      i++;
      continue;
    }
    return false;
  }
  return true;
}
function escapePathComponent(path) {
  if (path.indexOf("/") === -1 && path.indexOf("~") === -1)
    return path;
  return path.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapePathComponent(path) {
  return path.replace(/~1/g, "/").replace(/~0/g, "~");
}
function hasUndefined(obj) {
  if (obj === undefined)
    return true;
  if (obj) {
    if (Array.isArray(obj)) {
      for (let i$1 = 0, len = obj.length;i$1 < len; i$1++)
        if (hasUndefined(obj[i$1]))
          return true;
    } else if (typeof obj === "object") {
      const objKeys = _objectKeys(obj);
      const objKeysLength = objKeys.length;
      for (var i = 0;i < objKeysLength; i++)
        if (hasUndefined(obj[objKeys[i]]))
          return true;
    }
  }
  return false;
}
function patchErrorMessageFormatter(message, args) {
  const messageParts = [message];
  for (const key in args) {
    const value = typeof args[key] === "object" ? JSON.stringify(args[key], null, 2) : args[key];
    if (typeof value !== "undefined")
      messageParts.push(`${key}: ${value}`);
  }
  return messageParts.join(`
`);
}
var PatchError = class extends Error {
  constructor(message, name, index, operation, tree) {
    super(patchErrorMessageFormatter(message, {
      name,
      index,
      operation,
      tree
    }));
    this.name = name;
    this.index = index;
    this.operation = operation;
    this.tree = tree;
    Object.setPrototypeOf(this, new.target.prototype);
    this.message = patchErrorMessageFormatter(message, {
      name,
      index,
      operation,
      tree
    });
  }
};

// node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js
var core_exports = {};
__export2(core_exports, {
  JsonPatchError: () => JsonPatchError,
  _areEquals: () => _areEquals,
  applyOperation: () => applyOperation,
  applyPatch: () => applyPatch,
  applyReducer: () => applyReducer,
  deepClone: () => deepClone,
  getValueByPointer: () => getValueByPointer,
  validate: () => validate2,
  validator: () => validator
});
var JsonPatchError = PatchError;
var deepClone = _deepClone;
function isDangerousKey(key) {
  return Object.getOwnPropertyNames(Object.prototype).includes(key);
}
var objOps = {
  add: function(obj, key, document2) {
    if (isDangerousKey(key))
      throw new TypeError("JSON-Patch: modifying `__proto__`, `constructor`, or `prototype` prop is banned for security reasons");
    obj[key] = this.value;
    return { newDocument: document2 };
  },
  remove: function(obj, key, document2) {
    if (isDangerousKey(key))
      throw new TypeError("JSON-Patch: modifying `__proto__`, `constructor`, or `prototype` prop is banned for security reasons");
    var removed = obj[key];
    delete obj[key];
    return {
      newDocument: document2,
      removed
    };
  },
  replace: function(obj, key, document2) {
    if (isDangerousKey(key))
      throw new TypeError("JSON-Patch: modifying `__proto__`, `constructor`, or `prototype` prop is banned for security reasons");
    var removed = obj[key];
    obj[key] = this.value;
    return {
      newDocument: document2,
      removed
    };
  },
  move: function(obj, key, document2) {
    let removed = getValueByPointer(document2, this.path);
    if (removed)
      removed = _deepClone(removed);
    const originalValue = applyOperation(document2, {
      op: "remove",
      path: this.from
    }).removed;
    applyOperation(document2, {
      op: "add",
      path: this.path,
      value: originalValue
    });
    return {
      newDocument: document2,
      removed
    };
  },
  copy: function(obj, key, document2) {
    const valueToCopy = getValueByPointer(document2, this.from);
    applyOperation(document2, {
      op: "add",
      path: this.path,
      value: _deepClone(valueToCopy)
    });
    return { newDocument: document2 };
  },
  test: function(obj, key, document2) {
    return {
      newDocument: document2,
      test: _areEquals(obj[key], this.value)
    };
  },
  _get: function(obj, key, document2) {
    this.value = obj[key];
    return { newDocument: document2 };
  }
};
var arrOps = {
  add: function(arr2, i, document2) {
    if (isInteger(i))
      arr2.splice(i, 0, this.value);
    else
      arr2[i] = this.value;
    return {
      newDocument: document2,
      index: i
    };
  },
  remove: function(arr2, i, document2) {
    var removedList = arr2.splice(i, 1);
    return {
      newDocument: document2,
      removed: removedList[0]
    };
  },
  replace: function(arr2, i, document2) {
    var removed = arr2[i];
    arr2[i] = this.value;
    return {
      newDocument: document2,
      removed
    };
  },
  move: objOps.move,
  copy: objOps.copy,
  test: objOps.test,
  _get: objOps._get
};
function getValueByPointer(document2, pointer) {
  if (pointer == "")
    return document2;
  var getOriginalDestination = {
    op: "_get",
    path: pointer
  };
  applyOperation(document2, getOriginalDestination);
  return getOriginalDestination.value;
}
function applyOperation(document2, operation, validateOperation = false, mutateDocument = true, banPrototypeModifications = true, index = 0) {
  if (validateOperation)
    if (typeof validateOperation == "function")
      validateOperation(operation, 0, document2, operation.path);
    else
      validator(operation, 0);
  if (operation.path === "") {
    let returnValue = { newDocument: document2 };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document2;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document2, operation.from);
      if (operation.op === "move")
        returnValue.removed = document2;
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document2, operation.value);
      if (returnValue.test === false)
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
      returnValue.newDocument = document2;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document2;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document2;
      return returnValue;
    } else if (validateOperation)
      throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document2);
    else
      return returnValue;
  } else {
    if (!mutateDocument)
      document2 = _deepClone(document2);
    const path = operation.path || "";
    const keys = path.split("/");
    let obj = document2;
    let t = 1;
    let len = keys.length;
    let existingPathFragment = undefined;
    let key;
    let validateFunction;
    if (typeof validateOperation == "function")
      validateFunction = validateOperation;
    else
      validateFunction = validator;
    while (true) {
      key = keys[t];
      if (key && key.indexOf("~") != -1)
        key = unescapePathComponent(key);
      if (banPrototypeModifications && (key == "__proto__" || key == "prototype" && t > 0 && keys[t - 1] == "constructor"))
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      if (validateOperation) {
        if (existingPathFragment === undefined) {
          if (obj[key] === undefined)
            existingPathFragment = keys.slice(0, t).join("/");
          else if (t == len - 1)
            existingPathFragment = operation.path;
          if (existingPathFragment !== undefined)
            validateFunction(operation, 0, document2, existingPathFragment);
        }
      }
      t++;
      if (Array.isArray(obj)) {
        if (key === "-")
          key = obj.length;
        else if (validateOperation && !isInteger(key))
          throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document2);
        else if (isInteger(key))
          key = ~~key;
        if (t >= len) {
          if (validateOperation && operation.op === "add" && key > obj.length)
            throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document2);
          const returnValue = arrOps[operation.op].call(operation, obj, key, document2);
          if (returnValue.test === false)
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
          return returnValue;
        }
      } else if (t >= len) {
        const returnValue = objOps[operation.op].call(operation, obj, key, document2);
        if (returnValue.test === false)
          throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
        return returnValue;
      }
      obj = obj[key];
      if (validateOperation && t < len && (!obj || typeof obj !== "object"))
        throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index, operation, document2);
    }
  }
}
function applyPatch(document2, patch, validateOperation, mutateDocument = true, banPrototypeModifications = true) {
  if (validateOperation) {
    if (!Array.isArray(patch))
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
  }
  if (!mutateDocument)
    document2 = _deepClone(document2);
  const results = new Array(patch.length);
  for (let i = 0, length = patch.length;i < length; i++) {
    results[i] = applyOperation(document2, patch[i], validateOperation, true, banPrototypeModifications, i);
    document2 = results[i].newDocument;
  }
  results.newDocument = document2;
  return results;
}
function applyReducer(document2, operation, index) {
  const operationResult = applyOperation(document2, operation);
  if (operationResult.test === false)
    throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
  return operationResult.newDocument;
}
function validator(operation, index, document2, existingPathFragment) {
  if (typeof operation !== "object" || operation === null || Array.isArray(operation))
    throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index, operation, document2);
  else if (!objOps[operation.op])
    throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document2);
  else if (typeof operation.path !== "string")
    throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index, operation, document2);
  else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0)
    throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index, operation, document2);
  else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string")
    throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index, operation, document2);
  else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === undefined)
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index, operation, document2);
  else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value))
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index, operation, document2);
  else if (document2) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen)
        throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index, operation, document2);
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment)
        throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index, operation, document2);
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = {
        op: "_get",
        path: operation.from,
        value: undefined
      };
      var error = validate2([existingValue], document2);
      if (error && error.name === "OPERATION_PATH_UNRESOLVABLE")
        throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index, operation, document2);
    }
  }
}
function validate2(sequence, document2, externalValidator) {
  try {
    if (!Array.isArray(sequence))
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    if (document2)
      applyPatch(_deepClone(document2), _deepClone(sequence), externalValidator || true);
    else {
      externalValidator = externalValidator || validator;
      for (var i = 0;i < sequence.length; i++)
        externalValidator(sequence[i], i, document2, undefined);
    }
  } catch (e) {
    if (e instanceof JsonPatchError)
      return e;
    else
      throw e;
  }
}
function _areEquals(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
    if (arrA && arrB) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length;i-- !== 0; )
        if (!_areEquals(a[i], b[i]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length;i-- !== 0; )
      if (!b.hasOwnProperty(keys[i]))
        return false;
    for (i = length;i-- !== 0; ) {
      key = keys[i];
      if (!_areEquals(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
}

// node_modules/@langchain/core/dist/utils/fast-json-patch/index.js
var fast_json_patch_default = {
  ...core_exports,
  JsonPatchError: PatchError,
  deepClone: _deepClone,
  escapePathComponent,
  unescapePathComponent
};

// node_modules/@langchain/core/dist/tracers/log_stream.js
var log_stream_exports = {};
__export2(log_stream_exports, {
  LogStreamCallbackHandler: () => LogStreamCallbackHandler,
  RunLog: () => RunLog,
  RunLogPatch: () => RunLogPatch,
  isLogStreamHandler: () => isLogStreamHandler
});
var RunLogPatch = class {
  ops;
  constructor(fields) {
    this.ops = fields.ops ?? [];
  }
  concat(other) {
    const ops = this.ops.concat(other.ops);
    const states = applyPatch({}, ops);
    return new RunLog({
      ops,
      state: states[states.length - 1].newDocument
    });
  }
};
var RunLog = class RunLog2 extends RunLogPatch {
  state;
  constructor(fields) {
    super(fields);
    this.state = fields.state;
  }
  concat(other) {
    const ops = this.ops.concat(other.ops);
    const states = applyPatch(this.state, other.ops);
    return new RunLog2({
      ops,
      state: states[states.length - 1].newDocument
    });
  }
  static fromRunLogPatch(patch) {
    const states = applyPatch({}, patch.ops);
    return new RunLog2({
      ops: patch.ops,
      state: states[states.length - 1].newDocument
    });
  }
};
var isLogStreamHandler = (handler) => handler.name === "log_stream_tracer";
async function _getStandardizedInputs(run, schemaFormat) {
  if (schemaFormat === "original")
    throw new Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
  const { inputs } = run;
  if ([
    "retriever",
    "llm",
    "prompt"
  ].includes(run.run_type))
    return inputs;
  if (Object.keys(inputs).length === 1 && inputs?.input === "")
    return;
  return inputs.input;
}
async function _getStandardizedOutputs(run, schemaFormat) {
  const { outputs } = run;
  if (schemaFormat === "original")
    return outputs;
  if ([
    "retriever",
    "llm",
    "prompt"
  ].includes(run.run_type))
    return outputs;
  if (outputs !== undefined && Object.keys(outputs).length === 1 && outputs?.output !== undefined)
    return outputs.output;
  return outputs;
}
function isChatGenerationChunk(x) {
  return x !== undefined && x.message !== undefined;
}
var LogStreamCallbackHandler = class extends BaseTracer {
  autoClose = true;
  includeNames;
  includeTypes;
  includeTags;
  excludeNames;
  excludeTypes;
  excludeTags;
  _schemaFormat = "original";
  rootId;
  keyMapByRunId = {};
  counterMapByRunName = {};
  transformStream;
  writer;
  receiveStream;
  name = "log_stream_tracer";
  lc_prefer_streaming = true;
  constructor(fields) {
    super({
      _awaitHandler: true,
      ...fields
    });
    this.autoClose = fields?.autoClose ?? true;
    this.includeNames = fields?.includeNames;
    this.includeTypes = fields?.includeTypes;
    this.includeTags = fields?.includeTags;
    this.excludeNames = fields?.excludeNames;
    this.excludeTypes = fields?.excludeTypes;
    this.excludeTags = fields?.excludeTags;
    this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;
    this.transformStream = new TransformStream;
    this.writer = this.transformStream.writable.getWriter();
    this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(_run) {}
  _includeRun(run) {
    if (run.id === this.rootId)
      return false;
    const runTags = run.tags ?? [];
    let include = this.includeNames === undefined && this.includeTags === undefined && this.includeTypes === undefined;
    if (this.includeNames !== undefined)
      include = include || this.includeNames.includes(run.name);
    if (this.includeTypes !== undefined)
      include = include || this.includeTypes.includes(run.run_type);
    if (this.includeTags !== undefined)
      include = include || runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;
    if (this.excludeNames !== undefined)
      include = include && !this.excludeNames.includes(run.name);
    if (this.excludeTypes !== undefined)
      include = include && !this.excludeTypes.includes(run.run_type);
    if (this.excludeTags !== undefined)
      include = include && runTags.every((tag) => !this.excludeTags?.includes(tag));
    return include;
  }
  async* tapOutputIterable(runId, output) {
    for await (const chunk of output) {
      if (runId !== this.rootId) {
        const key = this.keyMapByRunId[runId];
        if (key)
          await this.writer.write(new RunLogPatch({ ops: [{
            op: "add",
            path: `/logs/${key}/streamed_output/-`,
            value: chunk
          }] }));
      }
      yield chunk;
    }
  }
  async onRunCreate(run) {
    if (this.rootId === undefined) {
      this.rootId = run.id;
      await this.writer.write(new RunLogPatch({ ops: [{
        op: "replace",
        path: "",
        value: {
          id: run.id,
          name: run.name,
          type: run.run_type,
          streamed_output: [],
          final_output: undefined,
          logs: {}
        }
      }] }));
    }
    if (!this._includeRun(run))
      return;
    if (this.counterMapByRunName[run.name] === undefined)
      this.counterMapByRunName[run.name] = 0;
    this.counterMapByRunName[run.name] += 1;
    const count = this.counterMapByRunName[run.name];
    this.keyMapByRunId[run.id] = count === 1 ? run.name : `${run.name}:${count}`;
    const logEntry = {
      id: run.id,
      name: run.name,
      type: run.run_type,
      tags: run.tags ?? [],
      metadata: run.extra?.metadata ?? {},
      start_time: new Date(run.start_time).toISOString(),
      streamed_output: [],
      streamed_output_str: [],
      final_output: undefined,
      end_time: undefined
    };
    if (this._schemaFormat === "streaming_events")
      logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);
    await this.writer.write(new RunLogPatch({ ops: [{
      op: "add",
      path: `/logs/${this.keyMapByRunId[run.id]}`,
      value: logEntry
    }] }));
  }
  async onRunUpdate(run) {
    try {
      const runName = this.keyMapByRunId[run.id];
      if (runName === undefined)
        return;
      const ops = [];
      if (this._schemaFormat === "streaming_events")
        ops.push({
          op: "replace",
          path: `/logs/${runName}/inputs`,
          value: await _getStandardizedInputs(run, this._schemaFormat)
        });
      ops.push({
        op: "add",
        path: `/logs/${runName}/final_output`,
        value: await _getStandardizedOutputs(run, this._schemaFormat)
      });
      if (run.end_time !== undefined)
        ops.push({
          op: "add",
          path: `/logs/${runName}/end_time`,
          value: new Date(run.end_time).toISOString()
        });
      const patch = new RunLogPatch({ ops });
      await this.writer.write(patch);
    } finally {
      if (run.id === this.rootId) {
        const patch = new RunLogPatch({ ops: [{
          op: "replace",
          path: "/final_output",
          value: await _getStandardizedOutputs(run, this._schemaFormat)
        }] });
        await this.writer.write(patch);
        if (this.autoClose)
          await this.writer.close();
      }
    }
  }
  async onLLMNewToken(run, token, kwargs) {
    const runName = this.keyMapByRunId[run.id];
    if (runName === undefined)
      return;
    const isChatModel = run.inputs.messages !== undefined;
    let streamedOutputValue;
    if (isChatModel)
      if (isChatGenerationChunk(kwargs?.chunk))
        streamedOutputValue = kwargs?.chunk;
      else
        streamedOutputValue = new AIMessageChunk({
          id: `run-${run.id}`,
          content: token
        });
    else
      streamedOutputValue = token;
    const patch = new RunLogPatch({ ops: [{
      op: "add",
      path: `/logs/${runName}/streamed_output_str/-`,
      value: token
    }, {
      op: "add",
      path: `/logs/${runName}/streamed_output/-`,
      value: streamedOutputValue
    }] });
    await this.writer.write(patch);
  }
};

// node_modules/@langchain/core/dist/outputs.js
var outputs_exports = {};
__export2(outputs_exports, {
  ChatGenerationChunk: () => ChatGenerationChunk,
  GenerationChunk: () => GenerationChunk,
  RUN_KEY: () => RUN_KEY
});
var RUN_KEY = "__run";
var GenerationChunk = class GenerationChunk2 {
  text;
  generationInfo;
  constructor(fields) {
    this.text = fields.text;
    this.generationInfo = fields.generationInfo;
  }
  concat(chunk) {
    return new GenerationChunk2({
      text: this.text + chunk.text,
      generationInfo: {
        ...this.generationInfo,
        ...chunk.generationInfo
      }
    });
  }
};
var ChatGenerationChunk = class ChatGenerationChunk2 extends GenerationChunk {
  message;
  constructor(fields) {
    super(fields);
    this.message = fields.message;
  }
  concat(chunk) {
    return new ChatGenerationChunk2({
      text: this.text + chunk.text,
      generationInfo: {
        ...this.generationInfo,
        ...chunk.generationInfo
      },
      message: this.message.concat(chunk.message)
    });
  }
};

// node_modules/@langchain/core/dist/tracers/event_stream.js
function assignName({ name, serialized }) {
  if (name !== undefined)
    return name;
  if (serialized?.name !== undefined)
    return serialized.name;
  else if (serialized?.id !== undefined && Array.isArray(serialized?.id))
    return serialized.id[serialized.id.length - 1];
  return "Unnamed";
}
var isStreamEventsHandler = (handler) => handler.name === "event_stream_tracer";
var EventStreamCallbackHandler = class extends BaseTracer {
  autoClose = true;
  includeNames;
  includeTypes;
  includeTags;
  excludeNames;
  excludeTypes;
  excludeTags;
  runInfoMap = /* @__PURE__ */ new Map;
  tappedPromises = /* @__PURE__ */ new Map;
  transformStream;
  writer;
  receiveStream;
  name = "event_stream_tracer";
  lc_prefer_streaming = true;
  constructor(fields) {
    super({
      _awaitHandler: true,
      ...fields
    });
    this.autoClose = fields?.autoClose ?? true;
    this.includeNames = fields?.includeNames;
    this.includeTypes = fields?.includeTypes;
    this.includeTags = fields?.includeTags;
    this.excludeNames = fields?.excludeNames;
    this.excludeTypes = fields?.excludeTypes;
    this.excludeTags = fields?.excludeTags;
    this.transformStream = new TransformStream;
    this.writer = this.transformStream.writable.getWriter();
    this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(_run) {}
  _includeRun(run) {
    const runTags = run.tags ?? [];
    let include = this.includeNames === undefined && this.includeTags === undefined && this.includeTypes === undefined;
    if (this.includeNames !== undefined)
      include = include || this.includeNames.includes(run.name);
    if (this.includeTypes !== undefined)
      include = include || this.includeTypes.includes(run.runType);
    if (this.includeTags !== undefined)
      include = include || runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;
    if (this.excludeNames !== undefined)
      include = include && !this.excludeNames.includes(run.name);
    if (this.excludeTypes !== undefined)
      include = include && !this.excludeTypes.includes(run.runType);
    if (this.excludeTags !== undefined)
      include = include && runTags.every((tag) => !this.excludeTags?.includes(tag));
    return include;
  }
  async* tapOutputIterable(runId, outputStream) {
    const firstChunk = await outputStream.next();
    if (firstChunk.done)
      return;
    const runInfo = this.runInfoMap.get(runId);
    if (runInfo === undefined) {
      yield firstChunk.value;
      return;
    }
    function _formatOutputChunk(eventType, data) {
      if (eventType === "llm" && typeof data === "string")
        return new GenerationChunk({ text: data });
      return data;
    }
    let tappedPromise = this.tappedPromises.get(runId);
    if (tappedPromise === undefined) {
      let tappedPromiseResolver;
      tappedPromise = new Promise((resolve) => {
        tappedPromiseResolver = resolve;
      });
      this.tappedPromises.set(runId, tappedPromise);
      try {
        const event = {
          event: `on_${runInfo.runType}_stream`,
          run_id: runId,
          name: runInfo.name,
          tags: runInfo.tags,
          metadata: runInfo.metadata,
          data: {}
        };
        await this.send({
          ...event,
          data: { chunk: _formatOutputChunk(runInfo.runType, firstChunk.value) }
        }, runInfo);
        yield firstChunk.value;
        for await (const chunk of outputStream) {
          if (runInfo.runType !== "tool" && runInfo.runType !== "retriever")
            await this.send({
              ...event,
              data: { chunk: _formatOutputChunk(runInfo.runType, chunk) }
            }, runInfo);
          yield chunk;
        }
      } finally {
        tappedPromiseResolver?.();
      }
    } else {
      yield firstChunk.value;
      for await (const chunk of outputStream)
        yield chunk;
    }
  }
  async send(payload, run) {
    if (this._includeRun(run))
      await this.writer.write(payload);
  }
  async sendEndEvent(payload, run) {
    const tappedPromise = this.tappedPromises.get(payload.run_id);
    if (tappedPromise !== undefined)
      tappedPromise.then(() => {
        this.send(payload, run);
      });
    else
      await this.send(payload, run);
  }
  async onLLMStart(run) {
    const runName = assignName(run);
    const runType = run.inputs.messages !== undefined ? "chat_model" : "llm";
    const runInfo = {
      tags: run.tags ?? [],
      metadata: run.extra?.metadata ?? {},
      name: runName,
      runType,
      inputs: run.inputs
    };
    this.runInfoMap.set(run.id, runInfo);
    const eventName = `on_${runType}_start`;
    await this.send({
      event: eventName,
      data: { input: run.inputs },
      name: runName,
      tags: run.tags ?? [],
      run_id: run.id,
      metadata: run.extra?.metadata ?? {}
    }, runInfo);
  }
  async onLLMNewToken(run, token, kwargs) {
    const runInfo = this.runInfoMap.get(run.id);
    let chunk;
    let eventName;
    if (runInfo === undefined)
      throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);
    if (this.runInfoMap.size === 1)
      return;
    if (runInfo.runType === "chat_model") {
      eventName = "on_chat_model_stream";
      if (kwargs?.chunk === undefined)
        chunk = new AIMessageChunk({
          content: token,
          id: `run-${run.id}`
        });
      else
        chunk = kwargs.chunk.message;
    } else if (runInfo.runType === "llm") {
      eventName = "on_llm_stream";
      if (kwargs?.chunk === undefined)
        chunk = new GenerationChunk({ text: token });
      else
        chunk = kwargs.chunk;
    } else
      throw new Error(`Unexpected run type ${runInfo.runType}`);
    await this.send({
      event: eventName,
      data: { chunk },
      run_id: run.id,
      name: runInfo.name,
      tags: runInfo.tags,
      metadata: runInfo.metadata
    }, runInfo);
  }
  async onLLMEnd(run) {
    const runInfo = this.runInfoMap.get(run.id);
    this.runInfoMap.delete(run.id);
    let eventName;
    if (runInfo === undefined)
      throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);
    const generations = run.outputs?.generations;
    let output;
    if (runInfo.runType === "chat_model") {
      for (const generation of generations ?? []) {
        if (output !== undefined)
          break;
        output = generation[0]?.message;
      }
      eventName = "on_chat_model_end";
    } else if (runInfo.runType === "llm") {
      output = {
        generations: generations?.map((generation) => {
          return generation.map((chunk) => {
            return {
              text: chunk.text,
              generationInfo: chunk.generationInfo
            };
          });
        }),
        llmOutput: run.outputs?.llmOutput ?? {}
      };
      eventName = "on_llm_end";
    } else
      throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);
    await this.sendEndEvent({
      event: eventName,
      data: {
        output,
        input: runInfo.inputs
      },
      run_id: run.id,
      name: runInfo.name,
      tags: runInfo.tags,
      metadata: runInfo.metadata
    }, runInfo);
  }
  async onChainStart(run) {
    const runName = assignName(run);
    const runType = run.run_type ?? "chain";
    const runInfo = {
      tags: run.tags ?? [],
      metadata: run.extra?.metadata ?? {},
      name: runName,
      runType: run.run_type
    };
    let eventData = {};
    if (run.inputs.input === "" && Object.keys(run.inputs).length === 1) {
      eventData = {};
      runInfo.inputs = {};
    } else if (run.inputs.input !== undefined) {
      eventData.input = run.inputs.input;
      runInfo.inputs = run.inputs.input;
    } else {
      eventData.input = run.inputs;
      runInfo.inputs = run.inputs;
    }
    this.runInfoMap.set(run.id, runInfo);
    await this.send({
      event: `on_${runType}_start`,
      data: eventData,
      name: runName,
      tags: run.tags ?? [],
      run_id: run.id,
      metadata: run.extra?.metadata ?? {}
    }, runInfo);
  }
  async onChainEnd(run) {
    const runInfo = this.runInfoMap.get(run.id);
    this.runInfoMap.delete(run.id);
    if (runInfo === undefined)
      throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);
    const eventName = `on_${run.run_type}_end`;
    const inputs = run.inputs ?? runInfo.inputs ?? {};
    const outputs = run.outputs?.output ?? run.outputs;
    const data = {
      output: outputs,
      input: inputs
    };
    if (inputs.input && Object.keys(inputs).length === 1) {
      data.input = inputs.input;
      runInfo.inputs = inputs.input;
    }
    await this.sendEndEvent({
      event: eventName,
      data,
      run_id: run.id,
      name: runInfo.name,
      tags: runInfo.tags,
      metadata: runInfo.metadata ?? {}
    }, runInfo);
  }
  async onToolStart(run) {
    const runName = assignName(run);
    const runInfo = {
      tags: run.tags ?? [],
      metadata: run.extra?.metadata ?? {},
      name: runName,
      runType: "tool",
      inputs: run.inputs ?? {}
    };
    this.runInfoMap.set(run.id, runInfo);
    await this.send({
      event: "on_tool_start",
      data: { input: run.inputs ?? {} },
      name: runName,
      run_id: run.id,
      tags: run.tags ?? [],
      metadata: run.extra?.metadata ?? {}
    }, runInfo);
  }
  async onToolEnd(run) {
    const runInfo = this.runInfoMap.get(run.id);
    this.runInfoMap.delete(run.id);
    if (runInfo === undefined)
      throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);
    if (runInfo.inputs === undefined)
      throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);
    const output = run.outputs?.output === undefined ? run.outputs : run.outputs.output;
    await this.sendEndEvent({
      event: "on_tool_end",
      data: {
        output,
        input: runInfo.inputs
      },
      run_id: run.id,
      name: runInfo.name,
      tags: runInfo.tags,
      metadata: runInfo.metadata
    }, runInfo);
  }
  async onRetrieverStart(run) {
    const runName = assignName(run);
    const runType = "retriever";
    const runInfo = {
      tags: run.tags ?? [],
      metadata: run.extra?.metadata ?? {},
      name: runName,
      runType,
      inputs: { query: run.inputs.query }
    };
    this.runInfoMap.set(run.id, runInfo);
    await this.send({
      event: "on_retriever_start",
      data: { input: { query: run.inputs.query } },
      name: runName,
      tags: run.tags ?? [],
      run_id: run.id,
      metadata: run.extra?.metadata ?? {}
    }, runInfo);
  }
  async onRetrieverEnd(run) {
    const runInfo = this.runInfoMap.get(run.id);
    this.runInfoMap.delete(run.id);
    if (runInfo === undefined)
      throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);
    await this.sendEndEvent({
      event: "on_retriever_end",
      data: {
        output: run.outputs?.documents ?? run.outputs,
        input: runInfo.inputs
      },
      run_id: run.id,
      name: runInfo.name,
      tags: runInfo.tags,
      metadata: runInfo.metadata
    }, runInfo);
  }
  async handleCustomEvent(eventName, data, runId) {
    const runInfo = this.runInfoMap.get(runId);
    if (runInfo === undefined)
      throw new Error(`handleCustomEvent: Run ID ${runId} not found in run map.`);
    await this.send({
      event: "on_custom_event",
      run_id: runId,
      name: eventName,
      tags: runInfo.tags,
      metadata: runInfo.metadata,
      data
    }, runInfo);
  }
  async finish() {
    const pendingPromises = [...this.tappedPromises.values()];
    Promise.all(pendingPromises).finally(() => {
      this.writer.close();
    });
  }
};

// node_modules/@langchain/core/dist/utils/is-network-error/index.js
var objectToString2 = Object.prototype.toString;
var isError2 = (value) => objectToString2.call(value) === "[object Error]";
var errorMessages2 = new Set([
  "network error",
  "Failed to fetch",
  "NetworkError when attempting to fetch resource.",
  "The Internet connection appears to be offline.",
  "Network request failed",
  "fetch failed",
  "terminated",
  " A network error occurred.",
  "Network connection lost"
]);
function isNetworkError2(error) {
  const isValid = error && isError2(error) && error.name === "TypeError" && typeof error.message === "string";
  if (!isValid)
    return false;
  const { message, stack } = error;
  if (message === "Load failed")
    return stack === undefined || "__sentry_captured__" in error;
  if (message.startsWith("error sending request for url"))
    return true;
  return errorMessages2.has(message);
}

// node_modules/@langchain/core/dist/utils/p-retry/index.js
function validateRetries2(retries) {
  if (typeof retries === "number") {
    if (retries < 0)
      throw new TypeError("Expected `retries` to be a non-negative number.");
    if (Number.isNaN(retries))
      throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
  } else if (retries !== undefined)
    throw new TypeError("Expected `retries` to be a number or Infinity.");
}
function validateNumberOption2(name, value, { min = 0, allowInfinity = false } = {}) {
  if (value === undefined)
    return;
  if (typeof value !== "number" || Number.isNaN(value))
    throw new TypeError(`Expected \`${name}\` to be a number${allowInfinity ? " or Infinity" : ""}.`);
  if (!allowInfinity && !Number.isFinite(value))
    throw new TypeError(`Expected \`${name}\` to be a finite number.`);
  if (value < min)
    throw new TypeError(`Expected \`${name}\` to be \u2265 ${min}.`);
}
var AbortError2 = class extends Error {
  constructor(message) {
    super();
    if (message instanceof Error) {
      this.originalError = message;
      ({ message } = message);
    } else {
      this.originalError = new Error(message);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message;
  }
};
function calculateDelay2(retriesConsumed, options) {
  const attempt = Math.max(1, retriesConsumed + 1);
  const random = options.randomize ? Math.random() + 1 : 1;
  let timeout = Math.round(random * options.minTimeout * options.factor ** (attempt - 1));
  timeout = Math.min(timeout, options.maxTimeout);
  return timeout;
}
function calculateRemainingTime2(start, max) {
  if (!Number.isFinite(max))
    return max;
  return max - (performance.now() - start);
}
async function onAttemptFailure2({ error, attemptNumber, retriesConsumed, startTime, options }) {
  const normalizedError = error instanceof Error ? error : /* @__PURE__ */ new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
  if (normalizedError instanceof AbortError2)
    throw normalizedError.originalError;
  const retriesLeft = Number.isFinite(options.retries) ? Math.max(0, options.retries - retriesConsumed) : options.retries;
  const maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;
  const context = Object.freeze({
    error: normalizedError,
    attemptNumber,
    retriesLeft,
    retriesConsumed
  });
  await options.onFailedAttempt(context);
  if (calculateRemainingTime2(startTime, maxRetryTime) <= 0)
    throw normalizedError;
  const consumeRetry = await options.shouldConsumeRetry(context);
  const remainingTime = calculateRemainingTime2(startTime, maxRetryTime);
  if (remainingTime <= 0 || retriesLeft <= 0)
    throw normalizedError;
  if (normalizedError instanceof TypeError && !isNetworkError2(normalizedError)) {
    if (consumeRetry)
      throw normalizedError;
    options.signal?.throwIfAborted();
    return false;
  }
  if (!await options.shouldRetry(context))
    throw normalizedError;
  if (!consumeRetry) {
    options.signal?.throwIfAborted();
    return false;
  }
  const delayTime = calculateDelay2(retriesConsumed, options);
  const finalDelay = Math.min(delayTime, remainingTime);
  if (finalDelay > 0)
    await new Promise((resolve, reject) => {
      const onAbort = () => {
        clearTimeout(timeoutToken);
        options.signal?.removeEventListener("abort", onAbort);
        reject(options.signal.reason);
      };
      const timeoutToken = setTimeout(() => {
        options.signal?.removeEventListener("abort", onAbort);
        resolve();
      }, finalDelay);
      if (options.unref)
        timeoutToken.unref?.();
      options.signal?.addEventListener("abort", onAbort, { once: true });
    });
  options.signal?.throwIfAborted();
  return true;
}
async function pRetry2(input, options = {}) {
  options = { ...options };
  validateRetries2(options.retries);
  if (Object.hasOwn(options, "forever"))
    throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  options.retries ??= 10;
  options.factor ??= 2;
  options.minTimeout ??= 1000;
  options.maxTimeout ??= Number.POSITIVE_INFINITY;
  options.maxRetryTime ??= Number.POSITIVE_INFINITY;
  options.randomize ??= false;
  options.onFailedAttempt ??= () => {};
  options.shouldRetry ??= () => true;
  options.shouldConsumeRetry ??= () => true;
  validateNumberOption2("factor", options.factor, {
    min: 0,
    allowInfinity: false
  });
  validateNumberOption2("minTimeout", options.minTimeout, {
    min: 0,
    allowInfinity: false
  });
  validateNumberOption2("maxTimeout", options.maxTimeout, {
    min: 0,
    allowInfinity: true
  });
  validateNumberOption2("maxRetryTime", options.maxRetryTime, {
    min: 0,
    allowInfinity: true
  });
  if (!(options.factor > 0))
    options.factor = 1;
  options.signal?.throwIfAborted();
  let attemptNumber = 0;
  let retriesConsumed = 0;
  const startTime = performance.now();
  while (Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true) {
    attemptNumber++;
    try {
      options.signal?.throwIfAborted();
      const result = await input(attemptNumber);
      options.signal?.throwIfAborted();
      return result;
    } catch (error) {
      if (await onAttemptFailure2({
        error,
        attemptNumber,
        retriesConsumed,
        startTime,
        options
      }))
        retriesConsumed++;
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}

// node_modules/@langchain/core/dist/utils/async_caller.js
var import_p_queue3 = __toESM(require_dist2(), 1);
var async_caller_exports = {};
__export2(async_caller_exports, { AsyncCaller: () => AsyncCaller2 });
var STATUS_NO_RETRY = [
  400,
  401,
  402,
  403,
  404,
  405,
  406,
  407,
  409
];
var defaultFailedAttemptHandler = (error) => {
  if (error.message.startsWith("Cancel") || error.message.startsWith("AbortError") || error.name === "AbortError")
    throw error;
  if (error?.code === "ECONNABORTED")
    throw error;
  const status = error?.response?.status ?? error?.status;
  if (status && STATUS_NO_RETRY.includes(+status))
    throw error;
  if (error?.error?.code === "insufficient_quota") {
    const err = new Error(error?.message);
    err.name = "InsufficientQuotaError";
    throw err;
  }
};
var AsyncCaller2 = class {
  maxConcurrency;
  maxRetries;
  onFailedAttempt;
  queue;
  constructor(params) {
    this.maxConcurrency = params.maxConcurrency ?? Infinity;
    this.maxRetries = params.maxRetries ?? 6;
    this.onFailedAttempt = params.onFailedAttempt ?? defaultFailedAttemptHandler;
    const PQueue = "default" in import_p_queue3.default ? import_p_queue3.default.default : import_p_queue3.default;
    this.queue = new PQueue({ concurrency: this.maxConcurrency });
  }
  async call(callable, ...args) {
    return this.queue.add(() => pRetry2(() => callable(...args).catch((error) => {
      if (error instanceof Error)
        throw error;
      else
        throw new Error(error);
    }), {
      onFailedAttempt: ({ error }) => this.onFailedAttempt?.(error),
      retries: this.maxRetries,
      randomize: true
    }), { throwOnTimeout: true });
  }
  callWithOptions(options, callable, ...args) {
    if (options.signal) {
      let listener;
      return Promise.race([this.call(callable, ...args), new Promise((_, reject) => {
        listener = () => {
          reject(getAbortSignalError(options.signal));
        };
        options.signal?.addEventListener("abort", listener);
      })]).finally(() => {
        if (options.signal && listener)
          options.signal.removeEventListener("abort", listener);
      });
    }
    return this.call(callable, ...args);
  }
  fetch(...args) {
    return this.call(() => fetch(...args).then((res) => res.ok ? res : Promise.reject(res)));
  }
};

// node_modules/@langchain/core/dist/tracers/root_listener.js
var RootListenersTracer = class extends BaseTracer {
  name = "RootListenersTracer";
  rootId;
  config;
  argOnStart;
  argOnEnd;
  argOnError;
  constructor({ config, onStart, onEnd, onError }) {
    super({ _awaitHandler: true });
    this.config = config;
    this.argOnStart = onStart;
    this.argOnEnd = onEnd;
    this.argOnError = onError;
  }
  persistRun(_) {
    return Promise.resolve();
  }
  async onRunCreate(run) {
    if (this.rootId)
      return;
    this.rootId = run.id;
    if (this.argOnStart)
      await this.argOnStart(run, this.config);
  }
  async onRunUpdate(run) {
    if (run.id !== this.rootId)
      return;
    if (!run.error) {
      if (this.argOnEnd)
        await this.argOnEnd(run, this.config);
    } else if (this.argOnError)
      await this.argOnError(run, this.config);
  }
};

// node_modules/@langchain/core/dist/runnables/utils.js
function isRunnableInterface(thing) {
  return thing ? thing.lc_runnable : false;
}
var _RootEventFilter = class {
  includeNames;
  includeTypes;
  includeTags;
  excludeNames;
  excludeTypes;
  excludeTags;
  constructor(fields) {
    this.includeNames = fields.includeNames;
    this.includeTypes = fields.includeTypes;
    this.includeTags = fields.includeTags;
    this.excludeNames = fields.excludeNames;
    this.excludeTypes = fields.excludeTypes;
    this.excludeTags = fields.excludeTags;
  }
  includeEvent(event, rootType) {
    let include = this.includeNames === undefined && this.includeTypes === undefined && this.includeTags === undefined;
    const eventTags = event.tags ?? [];
    if (this.includeNames !== undefined)
      include = include || this.includeNames.includes(event.name);
    if (this.includeTypes !== undefined)
      include = include || this.includeTypes.includes(rootType);
    if (this.includeTags !== undefined)
      include = include || eventTags.some((tag) => this.includeTags?.includes(tag));
    if (this.excludeNames !== undefined)
      include = include && !this.excludeNames.includes(event.name);
    if (this.excludeTypes !== undefined)
      include = include && !this.excludeTypes.includes(rootType);
    if (this.excludeTags !== undefined)
      include = include && eventTags.every((tag) => !this.excludeTags?.includes(tag));
    return include;
  }
};
var toBase64Url = (str) => {
  const encoded = btoa(str);
  return encoded.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
};

// node_modules/@langchain/core/dist/utils/types/zod.js
init_core2();
function isZodSchemaV4(schema) {
  if (typeof schema !== "object" || schema === null)
    return false;
  const obj = schema;
  if (!("_zod" in obj))
    return false;
  const zod = obj._zod;
  return typeof zod === "object" && zod !== null && "def" in zod;
}
function isZodSchemaV3(schema) {
  if (typeof schema !== "object" || schema === null)
    return false;
  const obj = schema;
  if (!("_def" in obj) || "_zod" in obj)
    return false;
  const def = obj._def;
  return typeof def === "object" && def != null && "typeName" in def;
}
function isInteropZodSchema(input) {
  if (!input)
    return false;
  if (typeof input !== "object")
    return false;
  if (Array.isArray(input))
    return false;
  if (isZodSchemaV4(input) || isZodSchemaV3(input))
    return true;
  return false;
}
async function interopParseAsync(schema, input) {
  if (isZodSchemaV4(schema))
    return await parseAsync(schema, input);
  if (isZodSchemaV3(schema))
    return await schema.parseAsync(input);
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function getSchemaDescription(schema) {
  if (isZodSchemaV4(schema))
    return globalRegistry.get(schema)?.description;
  if (isZodSchemaV3(schema))
    return schema.description;
  if ("description" in schema && typeof schema.description === "string")
    return schema.description;
  return;
}
function isSimpleStringZodSchema(schema) {
  if (!isInteropZodSchema(schema))
    return false;
  if (isZodSchemaV3(schema)) {
    const def = schema._def;
    return def.typeName === "ZodString";
  }
  if (isZodSchemaV4(schema)) {
    const def = schema._zod.def;
    return def.type === "string";
  }
  return false;
}
function isZodObjectV4(obj) {
  if (!isZodSchemaV4(obj))
    return false;
  if (typeof obj === "object" && obj !== null && "_zod" in obj && typeof obj._zod === "object" && obj._zod !== null && "def" in obj._zod && typeof obj._zod.def === "object" && obj._zod.def !== null && "type" in obj._zod.def && obj._zod.def.type === "object")
    return true;
  return false;
}
function isZodArrayV4(obj) {
  if (!isZodSchemaV4(obj))
    return false;
  if (typeof obj === "object" && obj !== null && "_zod" in obj && typeof obj._zod === "object" && obj._zod !== null && "def" in obj._zod && typeof obj._zod.def === "object" && obj._zod.def !== null && "type" in obj._zod.def && obj._zod.def.type === "array")
    return true;
  return false;
}
function isZodOptionalV4(obj) {
  if (!isZodSchemaV4(obj))
    return false;
  if (typeof obj === "object" && obj !== null && "_zod" in obj && typeof obj._zod === "object" && obj._zod !== null && "def" in obj._zod && typeof obj._zod.def === "object" && obj._zod.def !== null && "type" in obj._zod.def && obj._zod.def.type === "optional")
    return true;
  return false;
}
function isZodNullableV4(obj) {
  if (!isZodSchemaV4(obj))
    return false;
  if (typeof obj === "object" && obj !== null && "_zod" in obj && typeof obj._zod === "object" && obj._zod !== null && "def" in obj._zod && typeof obj._zod.def === "object" && obj._zod.def !== null && "type" in obj._zod.def && obj._zod.def.type === "nullable")
    return true;
  return false;
}
function interopZodObjectStrict(schema, recursive = false) {
  if (isZodSchemaV3(schema))
    return schema.strict();
  if (isZodObjectV4(schema)) {
    const outputShape = schema._zod.def.shape;
    if (recursive)
      for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {
        if (isZodObjectV4(keySchema)) {
          const outputSchema = interopZodObjectStrict(keySchema, recursive);
          outputShape[key] = outputSchema;
        } else if (isZodArrayV4(keySchema)) {
          let elementSchema = keySchema._zod.def.element;
          if (isZodObjectV4(elementSchema))
            elementSchema = interopZodObjectStrict(elementSchema, recursive);
          outputShape[key] = clone(keySchema, {
            ...keySchema._zod.def,
            element: elementSchema
          });
        } else
          outputShape[key] = keySchema;
        const meta$1 = globalRegistry.get(keySchema);
        if (meta$1)
          globalRegistry.add(outputShape[key], meta$1);
      }
    const modifiedSchema = clone(schema, {
      ...schema._zod.def,
      shape: outputShape,
      catchall: _never($ZodNever)
    });
    const meta2 = globalRegistry.get(schema);
    if (meta2)
      globalRegistry.add(modifiedSchema, meta2);
    return modifiedSchema;
  }
  throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject");
}
function isZodTransformV3(schema) {
  return isZodSchemaV3(schema) && "typeName" in schema._def && schema._def.typeName === "ZodEffects";
}
function isZodTransformV4(schema) {
  return isZodSchemaV4(schema) && schema._zod.def.type === "pipe";
}
function interopZodTransformInputSchemaImpl(schema, recursive, cache) {
  const cached2 = cache.get(schema);
  if (cached2 !== undefined)
    return cached2;
  if (isZodSchemaV3(schema)) {
    if (isZodTransformV3(schema))
      return interopZodTransformInputSchemaImpl(schema._def.schema, recursive, cache);
    return schema;
  }
  if (isZodSchemaV4(schema)) {
    let outputSchema = schema;
    if (isZodTransformV4(schema))
      outputSchema = interopZodTransformInputSchemaImpl(schema._zod.def.in, recursive, cache);
    if (recursive) {
      if (isZodObjectV4(outputSchema)) {
        const outputShape = {};
        for (const [key, keySchema] of Object.entries(outputSchema._zod.def.shape))
          outputShape[key] = interopZodTransformInputSchemaImpl(keySchema, recursive, cache);
        outputSchema = clone(outputSchema, {
          ...outputSchema._zod.def,
          shape: outputShape
        });
      } else if (isZodArrayV4(outputSchema)) {
        const elementSchema = interopZodTransformInputSchemaImpl(outputSchema._zod.def.element, recursive, cache);
        outputSchema = clone(outputSchema, {
          ...outputSchema._zod.def,
          element: elementSchema
        });
      } else if (isZodOptionalV4(outputSchema)) {
        const innerSchema = interopZodTransformInputSchemaImpl(outputSchema._zod.def.innerType, recursive, cache);
        outputSchema = clone(outputSchema, {
          ...outputSchema._zod.def,
          innerType: innerSchema
        });
      } else if (isZodNullableV4(outputSchema)) {
        const innerSchema = interopZodTransformInputSchemaImpl(outputSchema._zod.def.innerType, recursive, cache);
        outputSchema = clone(outputSchema, {
          ...outputSchema._zod.def,
          innerType: innerSchema
        });
      }
    }
    const meta2 = globalRegistry.get(schema);
    if (meta2)
      globalRegistry.add(outputSchema, meta2);
    cache.set(schema, outputSchema);
    return outputSchema;
  }
  throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType");
}
function interopZodTransformInputSchema(schema, recursive = false) {
  const cache = /* @__PURE__ */ new WeakMap;
  return interopZodTransformInputSchemaImpl(schema, recursive, cache);
}

// node_modules/@langchain/core/dist/runnables/graph_mermaid.js
function _escapeNodeLabel(nodeLabel) {
  return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, "_");
}
var MARKDOWN_SPECIAL_CHARS = [
  "*",
  "_",
  "`"
];
function _generateMermaidGraphStyles(nodeColors) {
  let styles2 = "";
  for (const [className, color2] of Object.entries(nodeColors))
    styles2 += `	classDef ${className} ${color2};
`;
  return styles2;
}
function drawMermaid(nodes, edges, config2) {
  const { firstNode, lastNode, nodeColors, withStyles = true, curveStyle = "linear", wrapLabelNWords = 9 } = config2 ?? {};
  let mermaidGraph = withStyles ? `%%{init: {'flowchart': {'curve': '${curveStyle}'}}}%%
graph TD;
` : `graph TD;
`;
  if (withStyles) {
    const defaultClassLabel = "default";
    const formatDict = { [defaultClassLabel]: "{0}({1})" };
    if (firstNode !== undefined)
      formatDict[firstNode] = "{0}([{1}]):::first";
    if (lastNode !== undefined)
      formatDict[lastNode] = "{0}([{1}]):::last";
    for (const [key, node] of Object.entries(nodes)) {
      const nodeName = node.name.split(":").pop() ?? "";
      const label = MARKDOWN_SPECIAL_CHARS.some((char) => nodeName.startsWith(char) && nodeName.endsWith(char)) ? `<p>${nodeName}</p>` : nodeName;
      let finalLabel = label;
      if (Object.keys(node.metadata ?? {}).length)
        finalLabel += `<hr/><small><em>${Object.entries(node.metadata ?? {}).map(([k, v]) => `${k} = ${v}`).join(`
`)}</em></small>`;
      const nodeLabel = (formatDict[key] ?? formatDict[defaultClassLabel]).replace("{0}", _escapeNodeLabel(key)).replace("{1}", finalLabel);
      mermaidGraph += `	${nodeLabel}
`;
    }
  }
  const edgeGroups = {};
  for (const edge of edges) {
    const srcParts = edge.source.split(":");
    const tgtParts = edge.target.split(":");
    const commonPrefix = srcParts.filter((src, i) => src === tgtParts[i]).join(":");
    if (!edgeGroups[commonPrefix])
      edgeGroups[commonPrefix] = [];
    edgeGroups[commonPrefix].push(edge);
  }
  const seenSubgraphs = /* @__PURE__ */ new Set;
  function sortPrefixesByDepth(prefixes) {
    return [...prefixes].sort((a, b) => {
      return a.split(":").length - b.split(":").length;
    });
  }
  function addSubgraph(edges$1, prefix) {
    const selfLoop = edges$1.length === 1 && edges$1[0].source === edges$1[0].target;
    if (prefix && !selfLoop) {
      const subgraph = prefix.split(":").pop();
      if (seenSubgraphs.has(prefix))
        throw new Error(`Found duplicate subgraph '${subgraph}' at '${prefix} -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);
      seenSubgraphs.add(prefix);
      mermaidGraph += `	subgraph ${subgraph}
`;
    }
    const nestedPrefixes = sortPrefixesByDepth(Object.keys(edgeGroups).filter((nestedPrefix) => nestedPrefix.startsWith(`${prefix}:`) && nestedPrefix !== prefix && nestedPrefix.split(":").length === prefix.split(":").length + 1));
    for (const nestedPrefix of nestedPrefixes)
      addSubgraph(edgeGroups[nestedPrefix], nestedPrefix);
    for (const edge of edges$1) {
      const { source, target, data, conditional } = edge;
      let edgeLabel = "";
      if (data !== undefined) {
        let edgeData = data;
        const words = edgeData.split(" ");
        if (words.length > wrapLabelNWords)
          edgeData = Array.from({ length: Math.ceil(words.length / wrapLabelNWords) }, (_, i) => words.slice(i * wrapLabelNWords, (i + 1) * wrapLabelNWords).join(" ")).join("&nbsp;<br>&nbsp;");
        edgeLabel = conditional ? ` -. &nbsp;${edgeData}&nbsp; .-> ` : ` -- &nbsp;${edgeData}&nbsp; --> `;
      } else
        edgeLabel = conditional ? " -.-> " : " --> ";
      mermaidGraph += `	${_escapeNodeLabel(source)}${edgeLabel}${_escapeNodeLabel(target)};
`;
    }
    if (prefix && !selfLoop)
      mermaidGraph += `	end
`;
  }
  addSubgraph(edgeGroups[""] ?? [], "");
  for (const prefix in edgeGroups)
    if (!prefix.includes(":") && prefix !== "")
      addSubgraph(edgeGroups[prefix], prefix);
  if (withStyles)
    mermaidGraph += _generateMermaidGraphStyles(nodeColors ?? {});
  return mermaidGraph;
}
async function drawMermaidImage(mermaidSyntax, config2) {
  let backgroundColor = config2?.backgroundColor ?? "white";
  const imageType = config2?.imageType ?? "png";
  const mermaidSyntaxEncoded = toBase64Url(mermaidSyntax);
  if (backgroundColor !== undefined) {
    const hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;
    if (!hexColorPattern.test(backgroundColor))
      backgroundColor = `!${backgroundColor}`;
  }
  const imageUrl = `https://mermaid.ink/img/${mermaidSyntaxEncoded}?bgColor=${backgroundColor}&type=${imageType}`;
  const res = await fetch(imageUrl);
  if (!res.ok)
    throw new Error([
      `Failed to render the graph using the Mermaid.INK API.`,
      `Status code: ${res.status}`,
      `Status text: ${res.statusText}`
    ].join(`
`));
  const content = await res.blob();
  return content;
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/Options.js
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions2 = {
  name: undefined,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
};
var getDefaultOptions = (options) => typeof options === "string" ? {
  ...defaultOptions2,
  name: options
} : {
  ...defaultOptions2,
  ...options
};

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/Refs.js
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== undefined ? [
    ..._options.basePath,
    _options.definitionPath,
    _options.name
  ] : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: undefined,
    seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [def._def, {
      def: def._def,
      path: [
        ..._options.basePath,
        _options.definitionPath,
        name
      ],
      jsonSchema: undefined
    }]))
  };
};

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/getRelativePath.js
var getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (;i < pathA.length && i < pathB.length; i++)
    if (pathA[i] !== pathB[i])
      break;
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/any.js
function parseAnyDef(refs) {
  if (refs.target !== "openAi")
    return {};
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return { $ref: refs.$refStrategy === "relative" ? getRelativePath(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/") };
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage)
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/array.js
init_v3();
function parseArrayDef(def, refs) {
  const res = { type: "array" };
  if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny)
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  if (def.minLength)
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  if (def.maxLength)
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/bigint.js
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks)
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7")
          if (check.inclusive)
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          else
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
        else {
          if (!check.inclusive)
            res.exclusiveMinimum = true;
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7")
          if (check.inclusive)
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          else
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
        else {
          if (!check.inclusive)
            res.exclusiveMaximum = true;
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  return res;
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/boolean.js
function parseBooleanDef() {
  return { type: "boolean" };
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/branded.js
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/catch.js
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/date.js
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy))
    return { anyOf: strategy.map((item) => parseDateDef(def, refs, item)) };
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
var integerDateParser = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3")
    return res;
  for (const check of def.checks)
    switch (check.kind) {
      case "min":
        setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        break;
      case "max":
        setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        break;
    }
  return res;
};

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/default.js
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/effects.js
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef(refs);
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/enum.js
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/intersection.js
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [parseDef(def.left._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "allOf",
      "0"
    ]
  }), parseDef(def.right._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "allOf",
      "1"
    ]
  })].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : undefined;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === undefined)
        unevaluatedProperties = undefined;
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else
        unevaluatedProperties = undefined;
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : undefined;
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/literal.js
function parseLiteralDef(def, refs) {
  const parsedType8 = typeof def.value;
  if (parsedType8 !== "bigint" && parsedType8 !== "number" && parsedType8 !== "boolean" && parsedType8 !== "string")
    return { type: Array.isArray(def.value) ? "array" : "object" };
  if (refs.target === "openApi3")
    return {
      type: parsedType8 === "bigint" ? "integer" : parsedType8,
      enum: [def.value]
    };
  return {
    type: parsedType8 === "bigint" ? "integer" : parsedType8,
    const: def.value
  };
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/string.js
var emojiRegex2 = undefined;
var zodPatterns = {
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  emoji: () => {
    if (emojiRegex2 === undefined)
      emojiRegex2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    return emojiRegex2;
  },
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = { type: "string" };
  if (def.checks)
    for (const check of def.checks)
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes":
          addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
          break;
        case "ip":
          if (check.version !== "v6")
            addFormat(res, "ipv4", check.message, refs);
          if (check.version !== "v4")
            addFormat(res, "ipv6", check.message, refs);
          break;
        case "base64url":
          addPattern(res, zodPatterns.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check.message, refs);
          break;
        case "cidr":
          if (check.version !== "v6")
            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
          if (check.version !== "v4")
            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
          break;
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check.message, refs);
          break;
        case "ulid":
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        case "base64":
          switch (refs.base64Strategy) {
            case "format:binary":
              addFormat(res, "binary", check.message, refs);
              break;
            case "contentEncoding:base64":
              setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
          }
          break;
        case "nanoid":
          addPattern(res, zodPatterns.nanoid, check.message, refs);
          break;
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          ((_) => {})(check);
      }
  return res;
}
function escapeLiteralCheckValue(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
}
var ALPHA_NUMERIC = /* @__PURE__ */ new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i = 0;i < source.length; i++) {
    if (!ALPHA_NUMERIC.has(source[i]))
      result += "\\";
    result += source[i];
  }
  return result;
}
function addFormat(schema, value, message, refs) {
  if (schema.format || schema.anyOf?.some((x) => x.format)) {
    if (!schema.anyOf)
      schema.anyOf = [];
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && { errorMessage: { format: schema.errorMessage.format } }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0)
          delete schema.errorMessage;
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else
    setResponseValueAndErrors(schema, "format", value, message, refs);
}
function addPattern(schema, regex, message, refs) {
  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
    if (!schema.allOf)
      schema.allOf = [];
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && { errorMessage: { pattern: schema.errorMessage.pattern } }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0)
          delete schema.errorMessage;
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else
    setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
}
function stringifyRegExpWithFlags(regex, refs) {
  if (!refs.applyRegexFlags || !regex.flags)
    return regex.source;
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0;i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
            pattern += source[i];
            inCharRange = true;
          } else
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\")
      isEscaped = true;
    else if (inCharGroup && source[i] === "]")
      inCharGroup = false;
    else if (!inCharGroup && source[i] === "[")
      inCharGroup = true;
  }
  try {
    new RegExp(pattern);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex.source;
  }
  return pattern;
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/record.js
init_v3();
function parseRecordDef(def, refs) {
  if (refs.target === "openAi")
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum)
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [
            ...refs.currentPath,
            "properties",
            key
          ]
        }) ?? parseAnyDef(refs)
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3")
    return schema;
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum)
    return {
      ...schema,
      propertyNames: { enum: def.keyType._def.values }
    };
  else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/map.js
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record")
    return parseRecordDef(def, refs);
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "items",
      "items",
      "0"
    ]
  }) || parseAnyDef(refs);
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "items",
      "items",
      "1"
    ]
  }) || parseAnyDef(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/never.js
function parseNeverDef(refs) {
  return refs.target === "openAi" ? undefined : { not: parseAnyDef({
    ...refs,
    currentPath: [...refs.currentPath, "not"]
  }) };
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/null.js
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : { type: "null" };
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/union.js
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => (x._def.typeName in primitiveMappings) && (!x._def.checks || !x._def.checks.length))) {
    const types2 = options.reduce((types$1, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types$1.includes(type) ? [...types$1, type] : types$1;
    }, []);
    return { type: types2.length > 1 ? types2 : types2[0] };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types2 = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
          return acc;
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types2.length === options.length) {
      const uniqueTypes = types2.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: options.reduce((acc, x) => [...acc, ...x._def.values.filter((x$1) => !acc.includes(x$1))], [])
    };
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "anyOf",
      `${i}`
    ]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : undefined;
};

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/nullable.js
function parseNullableDef(def, refs) {
  if ([
    "ZodString",
    "ZodNumber",
    "ZodBigInt",
    "ZodBoolean",
    "ZodNull"
  ].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3")
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    return { type: [primitiveMappings[def.innerType._def.typeName], "null"] };
  }
  if (refs.target === "openApi3") {
    const base$1 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base$1 && "$ref" in base$1)
      return {
        allOf: [base$1],
        nullable: true
      };
    return base$1 && {
      ...base$1,
      nullable: true
    };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "anyOf",
      "0"
    ]
  });
  return base && { anyOf: [base, { type: "null" }] };
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/number.js
function parseNumberDef(def, refs) {
  const res = { type: "number" };
  if (!def.checks)
    return res;
  for (const check of def.checks)
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7")
          if (check.inclusive)
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          else
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
        else {
          if (!check.inclusive)
            res.exclusiveMinimum = true;
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7")
          if (check.inclusive)
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          else
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
        else {
          if (!check.inclusive)
            res.exclusiveMaximum = true;
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  return res;
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/object.js
function parseObjectDef(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required2 = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === undefined || propDef._def === undefined)
      continue;
    let propOptional = safeIsOptional(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional")
        propDef = propDef._def.innerType;
      if (!propDef.isNullable())
        propDef = propDef.nullable();
      propOptional = false;
    }
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [
        ...refs.currentPath,
        "properties",
        propName
      ],
      propertyPath: [
        ...refs.currentPath,
        "properties",
        propName
      ]
    });
    if (parsedDef === undefined)
      continue;
    result.properties[propName] = parsedDef;
    if (!propOptional)
      required2.push(propName);
  }
  if (required2.length)
    result.required = required2;
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== undefined)
    result.additionalProperties = additionalProperties;
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever")
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/optional.js
var parseOptionalDef = (def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString())
    return parseDef(def.innerType._def, refs);
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "anyOf",
      "1"
    ]
  });
  return innerSchema ? { anyOf: [{ not: parseAnyDef(refs) }, innerSchema] } : parseAnyDef(refs);
};

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/pipeline.js
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input")
    return parseDef(def.in._def, refs);
  else if (refs.pipeStrategy === "output")
    return parseDef(def.out._def, refs);
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "allOf",
      "0"
    ]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [
      ...refs.currentPath,
      "allOf",
      a ? "1" : "0"
    ]
  });
  return { allOf: [a, b].filter((x) => x !== undefined) };
};

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/promise.js
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/set.js
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize)
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  if (def.maxSize)
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  return schema;
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/tuple.js
function parseTupleDef(def, refs) {
  if (def.rest)
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "items",
          `${i}`
        ]
      })).reduce((acc, x) => x === undefined ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  else
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "items",
          `${i}`
        ]
      })).reduce((acc, x) => x === undefined ? acc : [...acc, x], [])
    };
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/undefined.js
function parseUndefinedDef(refs) {
  return { not: parseAnyDef(refs) };
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/unknown.js
function parseUnknownDef(refs) {
  return parseAnyDef(refs);
}

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parsers/readonly.js
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/selectParser.js
init_v3();
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef(refs);
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef(refs);
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef(refs);
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef(refs);
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return;
    default:
      return ((_) => {
        return;
      })(typeName);
  }
};

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/parseDef.js
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride)
      return overrideResult;
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== undefined)
      return seenSchema;
  }
  const newItem = {
    def,
    path: refs.currentPath,
    jsonSchema: undefined
  };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema)
    addMeta(def, refs, jsonSchema);
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema, def, refs);
    newItem.jsonSchema = jsonSchema;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen":
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef(refs) : undefined;
  }
};
var addMeta = (def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription)
      jsonSchema.markdownDescription = def.description;
  }
  return jsonSchema;
};

// node_modules/@langchain/core/dist/utils/zod-to-json-schema/zodToJsonSchema.js
var zodToJsonSchema = (schema, options) => {
  const refs = getRefs(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name$1, schema$1]) => ({
    ...acc,
    [name$1]: parseDef(schema$1._def, {
      ...refs,
      currentPath: [
        ...refs.basePath,
        refs.definitionPath,
        name$1
      ]
    }, true) ?? parseAnyDef(refs)
  }), {}) : undefined;
  const name = typeof options === "string" ? options : options?.nameStrategy === "title" ? undefined : options?.name;
  const main = parseDef(schema._def, name === undefined ? refs : {
    ...refs,
    currentPath: [
      ...refs.basePath,
      refs.definitionPath,
      name
    ]
  }, false) ?? parseAnyDef(refs);
  const title = typeof options === "object" && options.name !== undefined && options.nameStrategy === "title" ? options.name : undefined;
  if (title !== undefined)
    main.title = title;
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions)
      definitions = {};
    if (!definitions[refs.openAiAnyTypeName])
      definitions[refs.openAiAnyTypeName] = {
        type: [
          "string",
          "number",
          "integer",
          "boolean",
          "array",
          "null"
        ],
        items: { $ref: refs.$refStrategy === "relative" ? "1" : [
          ...refs.basePath,
          refs.definitionPath,
          refs.openAiAnyTypeName
        ].join("/") }
      };
  }
  const combined = name === undefined ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name]: main
    }
  };
  if (refs.target === "jsonSchema7")
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi")
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  if (refs.target === "openAi" && (("anyOf" in combined) || ("oneOf" in combined) || ("allOf" in combined) || ("type" in combined) && Array.isArray(combined.type)))
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  return combined;
};

// node_modules/@langchain/core/dist/utils/json_schema.js
init_core2();

// node_modules/@cfworker/json-schema/dist/esm/deep-compare-strict.js
function deepCompareStrict(a, b) {
  const typeofa = typeof a;
  if (typeofa !== typeof b) {
    return false;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }
    const length = a.length;
    if (length !== b.length) {
      return false;
    }
    for (let i = 0;i < length; i++) {
      if (!deepCompareStrict(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  if (typeofa === "object") {
    if (!a || !b) {
      return a === b;
    }
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    const length = aKeys.length;
    if (length !== bKeys.length) {
      return false;
    }
    for (const k of aKeys) {
      if (!deepCompareStrict(a[k], b[k])) {
        return false;
      }
    }
    return true;
  }
  return a === b;
}

// node_modules/@cfworker/json-schema/dist/esm/pointer.js
function encodePointer(p) {
  return encodeURI(escapePointer(p));
}
function escapePointer(p) {
  return p.replace(/~/g, "~0").replace(/\//g, "~1");
}

// node_modules/@cfworker/json-schema/dist/esm/dereference.js
var schemaArrayKeyword = {
  prefixItems: true,
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
var schemaMapKeyword = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependentSchemas: true
};
var ignoredKeyword = {
  id: true,
  $id: true,
  $ref: true,
  $schema: true,
  $anchor: true,
  $vocabulary: true,
  $comment: true,
  default: true,
  enum: true,
  const: true,
  required: true,
  type: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
var initialBaseURI = typeof self !== "undefined" && self.location && self.location.origin !== "null" ? new URL(self.location.origin + self.location.pathname + location.search) : new URL("https://github.com/cfworker");
function dereference(schema, lookup = Object.create(null), baseURI = initialBaseURI, basePointer = "") {
  if (schema && typeof schema === "object" && !Array.isArray(schema)) {
    const id = schema.$id || schema.id;
    if (id) {
      const url = new URL(id, baseURI.href);
      if (url.hash.length > 1) {
        lookup[url.href] = schema;
      } else {
        url.hash = "";
        if (basePointer === "") {
          baseURI = url;
        } else {
          dereference(schema, lookup, baseURI);
        }
      }
    }
  } else if (schema !== true && schema !== false) {
    return lookup;
  }
  const schemaURI = baseURI.href + (basePointer ? "#" + basePointer : "");
  if (lookup[schemaURI] !== undefined) {
    throw new Error(`Duplicate schema URI "${schemaURI}".`);
  }
  lookup[schemaURI] = schema;
  if (schema === true || schema === false) {
    return lookup;
  }
  if (schema.__absolute_uri__ === undefined) {
    Object.defineProperty(schema, "__absolute_uri__", {
      enumerable: false,
      value: schemaURI
    });
  }
  if (schema.$ref && schema.__absolute_ref__ === undefined) {
    const url = new URL(schema.$ref, baseURI.href);
    url.hash = url.hash;
    Object.defineProperty(schema, "__absolute_ref__", {
      enumerable: false,
      value: url.href
    });
  }
  if (schema.$recursiveRef && schema.__absolute_recursive_ref__ === undefined) {
    const url = new URL(schema.$recursiveRef, baseURI.href);
    url.hash = url.hash;
    Object.defineProperty(schema, "__absolute_recursive_ref__", {
      enumerable: false,
      value: url.href
    });
  }
  if (schema.$anchor) {
    const url = new URL("#" + schema.$anchor, baseURI.href);
    lookup[url.href] = schema;
  }
  for (let key in schema) {
    if (ignoredKeyword[key]) {
      continue;
    }
    const keyBase = `${basePointer}/${encodePointer(key)}`;
    const subSchema = schema[key];
    if (Array.isArray(subSchema)) {
      if (schemaArrayKeyword[key]) {
        const length = subSchema.length;
        for (let i = 0;i < length; i++) {
          dereference(subSchema[i], lookup, baseURI, `${keyBase}/${i}`);
        }
      }
    } else if (schemaMapKeyword[key]) {
      for (let subKey in subSchema) {
        dereference(subSchema[subKey], lookup, baseURI, `${keyBase}/${encodePointer(subKey)}`);
      }
    } else {
      dereference(subSchema, lookup, baseURI, keyBase);
    }
  }
  return lookup;
}

// node_modules/@cfworker/json-schema/dist/esm/format.js
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
var URL_ = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
var EMAIL = (input) => {
  if (input[0] === '"')
    return false;
  const [name, host, ...rest] = input.split("@");
  if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253)
    return false;
  if (name[0] === "." || name.endsWith(".") || name.includes(".."))
    return false;
  if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name))
    return false;
  return host.split(".").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part));
};
var IPV4 = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
var IPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i;
var DURATION = (input) => input.length > 1 && input.length < 80 && (/^P\d+([.,]\d+)?W$/.test(input) || /^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(input) && /^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(input));
function bind(r) {
  return r.test.bind(r);
}
var format = {
  date: date2,
  time: time2.bind(undefined, false),
  "date-time": date_time,
  duration: DURATION,
  uri,
  "uri-reference": bind(URIREF),
  "uri-template": bind(URITEMPLATE),
  url: bind(URL_),
  email: EMAIL,
  hostname: bind(HOSTNAME),
  ipv4: bind(IPV4),
  ipv6: bind(IPV6),
  regex,
  uuid: bind(UUID),
  "json-pointer": bind(JSON_POINTER),
  "json-pointer-uri-fragment": bind(JSON_POINTER_URI_FRAGMENT),
  "relative-json-pointer": bind(RELATIVE_JSON_POINTER)
};
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function date2(str) {
  const matches = str.match(DATE);
  if (!matches)
    return false;
  const year = +matches[1];
  const month = +matches[2];
  const day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
function time2(full, str) {
  const matches = str.match(TIME);
  if (!matches)
    return false;
  const hour = +matches[1];
  const minute = +matches[2];
  const second = +matches[3];
  const timeZone = !!matches[5];
  return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
}
var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  const dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date2(dateTime[0]) && time2(true, dateTime[1]);
}
var NOT_URI_FRAGMENT = /\/|:/;
var URI_PATTERN = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str) {
  return NOT_URI_FRAGMENT.test(str) && URI_PATTERN.test(str);
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    new RegExp(str, "u");
    return true;
  } catch (e) {
    return false;
  }
}

// node_modules/@cfworker/json-schema/dist/esm/ucs2-length.js
function ucs2length(s) {
  let result = 0;
  let length = s.length;
  let index = 0;
  let charCode;
  while (index < length) {
    result++;
    charCode = s.charCodeAt(index++);
    if (charCode >= 55296 && charCode <= 56319 && index < length) {
      charCode = s.charCodeAt(index);
      if ((charCode & 64512) == 56320) {
        index++;
      }
    }
  }
  return result;
}

// node_modules/@cfworker/json-schema/dist/esm/validate.js
function validate3(instance, schema, draft = "2019-09", lookup = dereference(schema), shortCircuit = true, recursiveAnchor = null, instanceLocation = "#", schemaLocation = "#", evaluated = Object.create(null)) {
  if (schema === true) {
    return { valid: true, errors: [] };
  }
  if (schema === false) {
    return {
      valid: false,
      errors: [
        {
          instanceLocation,
          keyword: "false",
          keywordLocation: instanceLocation,
          error: "False boolean schema."
        }
      ]
    };
  }
  const rawInstanceType = typeof instance;
  let instanceType;
  switch (rawInstanceType) {
    case "boolean":
    case "number":
    case "string":
      instanceType = rawInstanceType;
      break;
    case "object":
      if (instance === null) {
        instanceType = "null";
      } else if (Array.isArray(instance)) {
        instanceType = "array";
      } else {
        instanceType = "object";
      }
      break;
    default:
      throw new Error(`Instances of "${rawInstanceType}" type are not supported.`);
  }
  const { $ref, $recursiveRef, $recursiveAnchor, type: $type, const: $const, enum: $enum, required: $required, not: $not, anyOf: $anyOf, allOf: $allOf, oneOf: $oneOf, if: $if, then: $then, else: $else, format: $format, properties: $properties, patternProperties: $patternProperties, additionalProperties: $additionalProperties, unevaluatedProperties: $unevaluatedProperties, minProperties: $minProperties, maxProperties: $maxProperties, propertyNames: $propertyNames, dependentRequired: $dependentRequired, dependentSchemas: $dependentSchemas, dependencies: $dependencies, prefixItems: $prefixItems, items: $items, additionalItems: $additionalItems, unevaluatedItems: $unevaluatedItems, contains: $contains, minContains: $minContains, maxContains: $maxContains, minItems: $minItems, maxItems: $maxItems, uniqueItems: $uniqueItems, minimum: $minimum, maximum: $maximum, exclusiveMinimum: $exclusiveMinimum, exclusiveMaximum: $exclusiveMaximum, multipleOf: $multipleOf, minLength: $minLength, maxLength: $maxLength, pattern: $pattern, __absolute_ref__, __absolute_recursive_ref__ } = schema;
  const errors3 = [];
  if ($recursiveAnchor === true && recursiveAnchor === null) {
    recursiveAnchor = schema;
  }
  if ($recursiveRef === "#") {
    const refSchema = recursiveAnchor === null ? lookup[__absolute_recursive_ref__] : recursiveAnchor;
    const keywordLocation = `${schemaLocation}/$recursiveRef`;
    const result = validate3(instance, recursiveAnchor === null ? schema : recursiveAnchor, draft, lookup, shortCircuit, refSchema, instanceLocation, keywordLocation, evaluated);
    if (!result.valid) {
      errors3.push({
        instanceLocation,
        keyword: "$recursiveRef",
        keywordLocation,
        error: "A subschema had errors."
      }, ...result.errors);
    }
  }
  if ($ref !== undefined) {
    const uri2 = __absolute_ref__ || $ref;
    const refSchema = lookup[uri2];
    if (refSchema === undefined) {
      let message = `Unresolved $ref "${$ref}".`;
      if (__absolute_ref__ && __absolute_ref__ !== $ref) {
        message += `  Absolute URI "${__absolute_ref__}".`;
      }
      message += `
Known schemas:
- ${Object.keys(lookup).join(`
- `)}`;
      throw new Error(message);
    }
    const keywordLocation = `${schemaLocation}/$ref`;
    const result = validate3(instance, refSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated);
    if (!result.valid) {
      errors3.push({
        instanceLocation,
        keyword: "$ref",
        keywordLocation,
        error: "A subschema had errors."
      }, ...result.errors);
    }
    if (draft === "4" || draft === "7") {
      return { valid: errors3.length === 0, errors: errors3 };
    }
  }
  if (Array.isArray($type)) {
    let length = $type.length;
    let valid = false;
    for (let i = 0;i < length; i++) {
      if (instanceType === $type[i] || $type[i] === "integer" && instanceType === "number" && instance % 1 === 0 && instance === instance) {
        valid = true;
        break;
      }
    }
    if (!valid) {
      errors3.push({
        instanceLocation,
        keyword: "type",
        keywordLocation: `${schemaLocation}/type`,
        error: `Instance type "${instanceType}" is invalid. Expected "${$type.join('", "')}".`
      });
    }
  } else if ($type === "integer") {
    if (instanceType !== "number" || instance % 1 || instance !== instance) {
      errors3.push({
        instanceLocation,
        keyword: "type",
        keywordLocation: `${schemaLocation}/type`,
        error: `Instance type "${instanceType}" is invalid. Expected "${$type}".`
      });
    }
  } else if ($type !== undefined && instanceType !== $type) {
    errors3.push({
      instanceLocation,
      keyword: "type",
      keywordLocation: `${schemaLocation}/type`,
      error: `Instance type "${instanceType}" is invalid. Expected "${$type}".`
    });
  }
  if ($const !== undefined) {
    if (instanceType === "object" || instanceType === "array") {
      if (!deepCompareStrict(instance, $const)) {
        errors3.push({
          instanceLocation,
          keyword: "const",
          keywordLocation: `${schemaLocation}/const`,
          error: `Instance does not match ${JSON.stringify($const)}.`
        });
      }
    } else if (instance !== $const) {
      errors3.push({
        instanceLocation,
        keyword: "const",
        keywordLocation: `${schemaLocation}/const`,
        error: `Instance does not match ${JSON.stringify($const)}.`
      });
    }
  }
  if ($enum !== undefined) {
    if (instanceType === "object" || instanceType === "array") {
      if (!$enum.some((value) => deepCompareStrict(instance, value))) {
        errors3.push({
          instanceLocation,
          keyword: "enum",
          keywordLocation: `${schemaLocation}/enum`,
          error: `Instance does not match any of ${JSON.stringify($enum)}.`
        });
      }
    } else if (!$enum.some((value) => instance === value)) {
      errors3.push({
        instanceLocation,
        keyword: "enum",
        keywordLocation: `${schemaLocation}/enum`,
        error: `Instance does not match any of ${JSON.stringify($enum)}.`
      });
    }
  }
  if ($not !== undefined) {
    const keywordLocation = `${schemaLocation}/not`;
    const result = validate3(instance, $not, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation);
    if (result.valid) {
      errors3.push({
        instanceLocation,
        keyword: "not",
        keywordLocation,
        error: 'Instance matched "not" schema.'
      });
    }
  }
  let subEvaluateds = [];
  if ($anyOf !== undefined) {
    const keywordLocation = `${schemaLocation}/anyOf`;
    const errorsLength = errors3.length;
    let anyValid = false;
    for (let i = 0;i < $anyOf.length; i++) {
      const subSchema = $anyOf[i];
      const subEvaluated = Object.create(evaluated);
      const result = validate3(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);
      errors3.push(...result.errors);
      anyValid = anyValid || result.valid;
      if (result.valid) {
        subEvaluateds.push(subEvaluated);
      }
    }
    if (anyValid) {
      errors3.length = errorsLength;
    } else {
      errors3.splice(errorsLength, 0, {
        instanceLocation,
        keyword: "anyOf",
        keywordLocation,
        error: "Instance does not match any subschemas."
      });
    }
  }
  if ($allOf !== undefined) {
    const keywordLocation = `${schemaLocation}/allOf`;
    const errorsLength = errors3.length;
    let allValid = true;
    for (let i = 0;i < $allOf.length; i++) {
      const subSchema = $allOf[i];
      const subEvaluated = Object.create(evaluated);
      const result = validate3(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);
      errors3.push(...result.errors);
      allValid = allValid && result.valid;
      if (result.valid) {
        subEvaluateds.push(subEvaluated);
      }
    }
    if (allValid) {
      errors3.length = errorsLength;
    } else {
      errors3.splice(errorsLength, 0, {
        instanceLocation,
        keyword: "allOf",
        keywordLocation,
        error: `Instance does not match every subschema.`
      });
    }
  }
  if ($oneOf !== undefined) {
    const keywordLocation = `${schemaLocation}/oneOf`;
    const errorsLength = errors3.length;
    const matches = $oneOf.filter((subSchema, i) => {
      const subEvaluated = Object.create(evaluated);
      const result = validate3(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);
      errors3.push(...result.errors);
      if (result.valid) {
        subEvaluateds.push(subEvaluated);
      }
      return result.valid;
    }).length;
    if (matches === 1) {
      errors3.length = errorsLength;
    } else {
      errors3.splice(errorsLength, 0, {
        instanceLocation,
        keyword: "oneOf",
        keywordLocation,
        error: `Instance does not match exactly one subschema (${matches} matches).`
      });
    }
  }
  if (instanceType === "object" || instanceType === "array") {
    Object.assign(evaluated, ...subEvaluateds);
  }
  if ($if !== undefined) {
    const keywordLocation = `${schemaLocation}/if`;
    const conditionResult = validate3(instance, $if, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated).valid;
    if (conditionResult) {
      if ($then !== undefined) {
        const thenResult = validate3(instance, $then, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/then`, evaluated);
        if (!thenResult.valid) {
          errors3.push({
            instanceLocation,
            keyword: "if",
            keywordLocation,
            error: `Instance does not match "then" schema.`
          }, ...thenResult.errors);
        }
      }
    } else if ($else !== undefined) {
      const elseResult = validate3(instance, $else, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/else`, evaluated);
      if (!elseResult.valid) {
        errors3.push({
          instanceLocation,
          keyword: "if",
          keywordLocation,
          error: `Instance does not match "else" schema.`
        }, ...elseResult.errors);
      }
    }
  }
  if (instanceType === "object") {
    if ($required !== undefined) {
      for (const key of $required) {
        if (!(key in instance)) {
          errors3.push({
            instanceLocation,
            keyword: "required",
            keywordLocation: `${schemaLocation}/required`,
            error: `Instance does not have required property "${key}".`
          });
        }
      }
    }
    const keys = Object.keys(instance);
    if ($minProperties !== undefined && keys.length < $minProperties) {
      errors3.push({
        instanceLocation,
        keyword: "minProperties",
        keywordLocation: `${schemaLocation}/minProperties`,
        error: `Instance does not have at least ${$minProperties} properties.`
      });
    }
    if ($maxProperties !== undefined && keys.length > $maxProperties) {
      errors3.push({
        instanceLocation,
        keyword: "maxProperties",
        keywordLocation: `${schemaLocation}/maxProperties`,
        error: `Instance does not have at least ${$maxProperties} properties.`
      });
    }
    if ($propertyNames !== undefined) {
      const keywordLocation = `${schemaLocation}/propertyNames`;
      for (const key in instance) {
        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
        const result = validate3(key, $propertyNames, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);
        if (!result.valid) {
          errors3.push({
            instanceLocation,
            keyword: "propertyNames",
            keywordLocation,
            error: `Property name "${key}" does not match schema.`
          }, ...result.errors);
        }
      }
    }
    if ($dependentRequired !== undefined) {
      const keywordLocation = `${schemaLocation}/dependantRequired`;
      for (const key in $dependentRequired) {
        if (key in instance) {
          const required2 = $dependentRequired[key];
          for (const dependantKey of required2) {
            if (!(dependantKey in instance)) {
              errors3.push({
                instanceLocation,
                keyword: "dependentRequired",
                keywordLocation,
                error: `Instance has "${key}" but does not have "${dependantKey}".`
              });
            }
          }
        }
      }
    }
    if ($dependentSchemas !== undefined) {
      for (const key in $dependentSchemas) {
        const keywordLocation = `${schemaLocation}/dependentSchemas`;
        if (key in instance) {
          const result = validate3(instance, $dependentSchemas[key], draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`, evaluated);
          if (!result.valid) {
            errors3.push({
              instanceLocation,
              keyword: "dependentSchemas",
              keywordLocation,
              error: `Instance has "${key}" but does not match dependant schema.`
            }, ...result.errors);
          }
        }
      }
    }
    if ($dependencies !== undefined) {
      const keywordLocation = `${schemaLocation}/dependencies`;
      for (const key in $dependencies) {
        if (key in instance) {
          const propsOrSchema = $dependencies[key];
          if (Array.isArray(propsOrSchema)) {
            for (const dependantKey of propsOrSchema) {
              if (!(dependantKey in instance)) {
                errors3.push({
                  instanceLocation,
                  keyword: "dependencies",
                  keywordLocation,
                  error: `Instance has "${key}" but does not have "${dependantKey}".`
                });
              }
            }
          } else {
            const result = validate3(instance, propsOrSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`);
            if (!result.valid) {
              errors3.push({
                instanceLocation,
                keyword: "dependencies",
                keywordLocation,
                error: `Instance has "${key}" but does not match dependant schema.`
              }, ...result.errors);
            }
          }
        }
      }
    }
    const thisEvaluated = Object.create(null);
    let stop = false;
    if ($properties !== undefined) {
      const keywordLocation = `${schemaLocation}/properties`;
      for (const key in $properties) {
        if (!(key in instance)) {
          continue;
        }
        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
        const result = validate3(instance[key], $properties[key], draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(key)}`);
        if (result.valid) {
          evaluated[key] = thisEvaluated[key] = true;
        } else {
          stop = shortCircuit;
          errors3.push({
            instanceLocation,
            keyword: "properties",
            keywordLocation,
            error: `Property "${key}" does not match schema.`
          }, ...result.errors);
          if (stop)
            break;
        }
      }
    }
    if (!stop && $patternProperties !== undefined) {
      const keywordLocation = `${schemaLocation}/patternProperties`;
      for (const pattern in $patternProperties) {
        const regex2 = new RegExp(pattern, "u");
        const subSchema = $patternProperties[pattern];
        for (const key in instance) {
          if (!regex2.test(key)) {
            continue;
          }
          const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
          const result = validate3(instance[key], subSchema, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(pattern)}`);
          if (result.valid) {
            evaluated[key] = thisEvaluated[key] = true;
          } else {
            stop = shortCircuit;
            errors3.push({
              instanceLocation,
              keyword: "patternProperties",
              keywordLocation,
              error: `Property "${key}" matches pattern "${pattern}" but does not match associated schema.`
            }, ...result.errors);
          }
        }
      }
    }
    if (!stop && $additionalProperties !== undefined) {
      const keywordLocation = `${schemaLocation}/additionalProperties`;
      for (const key in instance) {
        if (thisEvaluated[key]) {
          continue;
        }
        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
        const result = validate3(instance[key], $additionalProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);
        if (result.valid) {
          evaluated[key] = true;
        } else {
          stop = shortCircuit;
          errors3.push({
            instanceLocation,
            keyword: "additionalProperties",
            keywordLocation,
            error: `Property "${key}" does not match additional properties schema.`
          }, ...result.errors);
        }
      }
    } else if (!stop && $unevaluatedProperties !== undefined) {
      const keywordLocation = `${schemaLocation}/unevaluatedProperties`;
      for (const key in instance) {
        if (!evaluated[key]) {
          const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;
          const result = validate3(instance[key], $unevaluatedProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);
          if (result.valid) {
            evaluated[key] = true;
          } else {
            errors3.push({
              instanceLocation,
              keyword: "unevaluatedProperties",
              keywordLocation,
              error: `Property "${key}" does not match unevaluated properties schema.`
            }, ...result.errors);
          }
        }
      }
    }
  } else if (instanceType === "array") {
    if ($maxItems !== undefined && instance.length > $maxItems) {
      errors3.push({
        instanceLocation,
        keyword: "maxItems",
        keywordLocation: `${schemaLocation}/maxItems`,
        error: `Array has too many items (${instance.length} > ${$maxItems}).`
      });
    }
    if ($minItems !== undefined && instance.length < $minItems) {
      errors3.push({
        instanceLocation,
        keyword: "minItems",
        keywordLocation: `${schemaLocation}/minItems`,
        error: `Array has too few items (${instance.length} < ${$minItems}).`
      });
    }
    const length = instance.length;
    let i = 0;
    let stop = false;
    if ($prefixItems !== undefined) {
      const keywordLocation = `${schemaLocation}/prefixItems`;
      const length2 = Math.min($prefixItems.length, length);
      for (;i < length2; i++) {
        const result = validate3(instance[i], $prefixItems[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);
        evaluated[i] = true;
        if (!result.valid) {
          stop = shortCircuit;
          errors3.push({
            instanceLocation,
            keyword: "prefixItems",
            keywordLocation,
            error: `Items did not match schema.`
          }, ...result.errors);
          if (stop)
            break;
        }
      }
    }
    if ($items !== undefined) {
      const keywordLocation = `${schemaLocation}/items`;
      if (Array.isArray($items)) {
        const length2 = Math.min($items.length, length);
        for (;i < length2; i++) {
          const result = validate3(instance[i], $items[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);
          evaluated[i] = true;
          if (!result.valid) {
            stop = shortCircuit;
            errors3.push({
              instanceLocation,
              keyword: "items",
              keywordLocation,
              error: `Items did not match schema.`
            }, ...result.errors);
            if (stop)
              break;
          }
        }
      } else {
        for (;i < length; i++) {
          const result = validate3(instance[i], $items, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);
          evaluated[i] = true;
          if (!result.valid) {
            stop = shortCircuit;
            errors3.push({
              instanceLocation,
              keyword: "items",
              keywordLocation,
              error: `Items did not match schema.`
            }, ...result.errors);
            if (stop)
              break;
          }
        }
      }
      if (!stop && $additionalItems !== undefined) {
        const keywordLocation2 = `${schemaLocation}/additionalItems`;
        for (;i < length; i++) {
          const result = validate3(instance[i], $additionalItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation2);
          evaluated[i] = true;
          if (!result.valid) {
            stop = shortCircuit;
            errors3.push({
              instanceLocation,
              keyword: "additionalItems",
              keywordLocation: keywordLocation2,
              error: `Items did not match additional items schema.`
            }, ...result.errors);
          }
        }
      }
    }
    if ($contains !== undefined) {
      if (length === 0 && $minContains === undefined) {
        errors3.push({
          instanceLocation,
          keyword: "contains",
          keywordLocation: `${schemaLocation}/contains`,
          error: `Array is empty. It must contain at least one item matching the schema.`
        });
      } else if ($minContains !== undefined && length < $minContains) {
        errors3.push({
          instanceLocation,
          keyword: "minContains",
          keywordLocation: `${schemaLocation}/minContains`,
          error: `Array has less items (${length}) than minContains (${$minContains}).`
        });
      } else {
        const keywordLocation = `${schemaLocation}/contains`;
        const errorsLength = errors3.length;
        let contained = 0;
        for (let j = 0;j < length; j++) {
          const result = validate3(instance[j], $contains, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${j}`, keywordLocation);
          if (result.valid) {
            evaluated[j] = true;
            contained++;
          } else {
            errors3.push(...result.errors);
          }
        }
        if (contained >= ($minContains || 0)) {
          errors3.length = errorsLength;
        }
        if ($minContains === undefined && $maxContains === undefined && contained === 0) {
          errors3.splice(errorsLength, 0, {
            instanceLocation,
            keyword: "contains",
            keywordLocation,
            error: `Array does not contain item matching schema.`
          });
        } else if ($minContains !== undefined && contained < $minContains) {
          errors3.push({
            instanceLocation,
            keyword: "minContains",
            keywordLocation: `${schemaLocation}/minContains`,
            error: `Array must contain at least ${$minContains} items matching schema. Only ${contained} items were found.`
          });
        } else if ($maxContains !== undefined && contained > $maxContains) {
          errors3.push({
            instanceLocation,
            keyword: "maxContains",
            keywordLocation: `${schemaLocation}/maxContains`,
            error: `Array may contain at most ${$maxContains} items matching schema. ${contained} items were found.`
          });
        }
      }
    }
    if (!stop && $unevaluatedItems !== undefined) {
      const keywordLocation = `${schemaLocation}/unevaluatedItems`;
      for (i;i < length; i++) {
        if (evaluated[i]) {
          continue;
        }
        const result = validate3(instance[i], $unevaluatedItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);
        evaluated[i] = true;
        if (!result.valid) {
          errors3.push({
            instanceLocation,
            keyword: "unevaluatedItems",
            keywordLocation,
            error: `Items did not match unevaluated items schema.`
          }, ...result.errors);
        }
      }
    }
    if ($uniqueItems) {
      for (let j = 0;j < length; j++) {
        const a = instance[j];
        const ao = typeof a === "object" && a !== null;
        for (let k = 0;k < length; k++) {
          if (j === k) {
            continue;
          }
          const b = instance[k];
          const bo = typeof b === "object" && b !== null;
          if (a === b || ao && bo && deepCompareStrict(a, b)) {
            errors3.push({
              instanceLocation,
              keyword: "uniqueItems",
              keywordLocation: `${schemaLocation}/uniqueItems`,
              error: `Duplicate items at indexes ${j} and ${k}.`
            });
            j = Number.MAX_SAFE_INTEGER;
            k = Number.MAX_SAFE_INTEGER;
          }
        }
      }
    }
  } else if (instanceType === "number") {
    if (draft === "4") {
      if ($minimum !== undefined && ($exclusiveMinimum === true && instance <= $minimum || instance < $minimum)) {
        errors3.push({
          instanceLocation,
          keyword: "minimum",
          keywordLocation: `${schemaLocation}/minimum`,
          error: `${instance} is less than ${$exclusiveMinimum ? "or equal to " : ""} ${$minimum}.`
        });
      }
      if ($maximum !== undefined && ($exclusiveMaximum === true && instance >= $maximum || instance > $maximum)) {
        errors3.push({
          instanceLocation,
          keyword: "maximum",
          keywordLocation: `${schemaLocation}/maximum`,
          error: `${instance} is greater than ${$exclusiveMaximum ? "or equal to " : ""} ${$maximum}.`
        });
      }
    } else {
      if ($minimum !== undefined && instance < $minimum) {
        errors3.push({
          instanceLocation,
          keyword: "minimum",
          keywordLocation: `${schemaLocation}/minimum`,
          error: `${instance} is less than ${$minimum}.`
        });
      }
      if ($maximum !== undefined && instance > $maximum) {
        errors3.push({
          instanceLocation,
          keyword: "maximum",
          keywordLocation: `${schemaLocation}/maximum`,
          error: `${instance} is greater than ${$maximum}.`
        });
      }
      if ($exclusiveMinimum !== undefined && instance <= $exclusiveMinimum) {
        errors3.push({
          instanceLocation,
          keyword: "exclusiveMinimum",
          keywordLocation: `${schemaLocation}/exclusiveMinimum`,
          error: `${instance} is less than ${$exclusiveMinimum}.`
        });
      }
      if ($exclusiveMaximum !== undefined && instance >= $exclusiveMaximum) {
        errors3.push({
          instanceLocation,
          keyword: "exclusiveMaximum",
          keywordLocation: `${schemaLocation}/exclusiveMaximum`,
          error: `${instance} is greater than or equal to ${$exclusiveMaximum}.`
        });
      }
    }
    if ($multipleOf !== undefined) {
      const remainder = instance % $multipleOf;
      if (Math.abs(0 - remainder) >= 0.00000011920929 && Math.abs($multipleOf - remainder) >= 0.00000011920929) {
        errors3.push({
          instanceLocation,
          keyword: "multipleOf",
          keywordLocation: `${schemaLocation}/multipleOf`,
          error: `${instance} is not a multiple of ${$multipleOf}.`
        });
      }
    }
  } else if (instanceType === "string") {
    const length = $minLength === undefined && $maxLength === undefined ? 0 : ucs2length(instance);
    if ($minLength !== undefined && length < $minLength) {
      errors3.push({
        instanceLocation,
        keyword: "minLength",
        keywordLocation: `${schemaLocation}/minLength`,
        error: `String is too short (${length} < ${$minLength}).`
      });
    }
    if ($maxLength !== undefined && length > $maxLength) {
      errors3.push({
        instanceLocation,
        keyword: "maxLength",
        keywordLocation: `${schemaLocation}/maxLength`,
        error: `String is too long (${length} > ${$maxLength}).`
      });
    }
    if ($pattern !== undefined && !new RegExp($pattern, "u").test(instance)) {
      errors3.push({
        instanceLocation,
        keyword: "pattern",
        keywordLocation: `${schemaLocation}/pattern`,
        error: `String does not match pattern.`
      });
    }
    if ($format !== undefined && format[$format] && !format[$format](instance)) {
      errors3.push({
        instanceLocation,
        keyword: "format",
        keywordLocation: `${schemaLocation}/format`,
        error: `String does not match format "${$format}".`
      });
    }
  }
  return { valid: errors3.length === 0, errors: errors3 };
}

// node_modules/@cfworker/json-schema/dist/esm/validator.js
class Validator {
  schema;
  draft;
  shortCircuit;
  lookup;
  constructor(schema, draft = "2019-09", shortCircuit = true) {
    this.schema = schema;
    this.draft = draft;
    this.shortCircuit = shortCircuit;
    this.lookup = dereference(schema);
  }
  validate(instance) {
    return validate3(instance, this.schema, this.draft, this.lookup, this.shortCircuit);
  }
  addSchema(schema, id) {
    if (id) {
      schema = { ...schema, $id: id };
    }
    dereference(schema, this.lookup);
  }
}

// node_modules/@langchain/core/dist/utils/json_schema.js
var json_schema_exports = {};
__export2(json_schema_exports, {
  Validator: () => Validator,
  deepCompareStrict: () => deepCompareStrict,
  toJsonSchema: () => toJsonSchema,
  validatesOnlyStrings: () => validatesOnlyStrings
});
function toJsonSchema(schema, params) {
  if (isZodSchemaV4(schema)) {
    const inputSchema = interopZodTransformInputSchema(schema, true);
    if (isZodObjectV4(inputSchema)) {
      const strictSchema = interopZodObjectStrict(inputSchema, true);
      return toJSONSchema(strictSchema, params);
    } else
      return toJSONSchema(schema, params);
  }
  if (isZodSchemaV3(schema))
    return zodToJsonSchema(schema);
  return schema;
}
function validatesOnlyStrings(schema) {
  if (!schema || typeof schema !== "object" || Object.keys(schema).length === 0 || Array.isArray(schema))
    return false;
  if ("type" in schema) {
    if (typeof schema.type === "string")
      return schema.type === "string";
    if (Array.isArray(schema.type))
      return schema.type.every((t) => t === "string");
    return false;
  }
  if ("enum" in schema)
    return Array.isArray(schema.enum) && schema.enum.length > 0 && schema.enum.every((val) => typeof val === "string");
  if ("const" in schema)
    return typeof schema.const === "string";
  if ("allOf" in schema && Array.isArray(schema.allOf))
    return schema.allOf.some((subschema) => validatesOnlyStrings(subschema));
  if ("anyOf" in schema && Array.isArray(schema.anyOf) || "oneOf" in schema && Array.isArray(schema.oneOf)) {
    const subschemas = "anyOf" in schema ? schema.anyOf : schema.oneOf;
    return subschemas.length > 0 && subschemas.every((subschema) => validatesOnlyStrings(subschema));
  }
  if ("not" in schema)
    return false;
  if ("$ref" in schema && typeof schema.$ref === "string") {
    const ref = schema.$ref;
    const resolved = dereference(schema);
    if (resolved[ref])
      return validatesOnlyStrings(resolved[ref]);
    return false;
  }
  return false;
}

// node_modules/@langchain/core/dist/runnables/graph.js
var graph_exports = {};
__export2(graph_exports, { Graph: () => Graph });
function nodeDataStr(id, data) {
  if (id !== undefined && !validate(id))
    return id;
  else if (isRunnableInterface(data))
    try {
      let dataStr = data.getName();
      dataStr = dataStr.startsWith("Runnable") ? dataStr.slice(8) : dataStr;
      return dataStr;
    } catch {
      return data.getName();
    }
  else
    return data.name ?? "UnknownSchema";
}
function nodeDataJson(node) {
  if (isRunnableInterface(node.data))
    return {
      type: "runnable",
      data: {
        id: node.data.lc_id,
        name: node.data.getName()
      }
    };
  else
    return {
      type: "schema",
      data: {
        ...toJsonSchema(node.data.schema),
        title: node.data.name
      }
    };
}
var Graph = class Graph2 {
  nodes = {};
  edges = [];
  constructor(params) {
    this.nodes = params?.nodes ?? this.nodes;
    this.edges = params?.edges ?? this.edges;
  }
  toJSON() {
    const stableNodeIds = {};
    Object.values(this.nodes).forEach((node, i) => {
      stableNodeIds[node.id] = validate(node.id) ? i : node.id;
    });
    return {
      nodes: Object.values(this.nodes).map((node) => ({
        id: stableNodeIds[node.id],
        ...nodeDataJson(node)
      })),
      edges: this.edges.map((edge) => {
        const item = {
          source: stableNodeIds[edge.source],
          target: stableNodeIds[edge.target]
        };
        if (typeof edge.data !== "undefined")
          item.data = edge.data;
        if (typeof edge.conditional !== "undefined")
          item.conditional = edge.conditional;
        return item;
      })
    };
  }
  addNode(data, id, metadata) {
    if (id !== undefined && this.nodes[id] !== undefined)
      throw new Error(`Node with id ${id} already exists`);
    const nodeId = id ?? v4();
    const node = {
      id: nodeId,
      data,
      name: nodeDataStr(id, data),
      metadata
    };
    this.nodes[nodeId] = node;
    return node;
  }
  removeNode(node) {
    delete this.nodes[node.id];
    this.edges = this.edges.filter((edge) => edge.source !== node.id && edge.target !== node.id);
  }
  addEdge(source, target, data, conditional) {
    if (this.nodes[source.id] === undefined)
      throw new Error(`Source node ${source.id} not in graph`);
    if (this.nodes[target.id] === undefined)
      throw new Error(`Target node ${target.id} not in graph`);
    const edge = {
      source: source.id,
      target: target.id,
      data,
      conditional
    };
    this.edges.push(edge);
    return edge;
  }
  firstNode() {
    return _firstNode(this);
  }
  lastNode() {
    return _lastNode(this);
  }
  extend(graph, prefix = "") {
    let finalPrefix = prefix;
    const nodeIds = Object.values(graph.nodes).map((node) => node.id);
    if (nodeIds.every(validate))
      finalPrefix = "";
    const prefixed = (id) => {
      return finalPrefix ? `${finalPrefix}:${id}` : id;
    };
    Object.entries(graph.nodes).forEach(([key, value]) => {
      this.nodes[prefixed(key)] = {
        ...value,
        id: prefixed(key)
      };
    });
    const newEdges = graph.edges.map((edge) => {
      return {
        ...edge,
        source: prefixed(edge.source),
        target: prefixed(edge.target)
      };
    });
    this.edges = [...this.edges, ...newEdges];
    const first = graph.firstNode();
    const last = graph.lastNode();
    return [first ? {
      id: prefixed(first.id),
      data: first.data
    } : undefined, last ? {
      id: prefixed(last.id),
      data: last.data
    } : undefined];
  }
  trimFirstNode() {
    const firstNode = this.firstNode();
    if (firstNode && _firstNode(this, [firstNode.id]))
      this.removeNode(firstNode);
  }
  trimLastNode() {
    const lastNode = this.lastNode();
    if (lastNode && _lastNode(this, [lastNode.id]))
      this.removeNode(lastNode);
  }
  reid() {
    const nodeLabels = Object.fromEntries(Object.values(this.nodes).map((node) => [node.id, node.name]));
    const nodeLabelCounts = /* @__PURE__ */ new Map;
    Object.values(nodeLabels).forEach((label) => {
      nodeLabelCounts.set(label, (nodeLabelCounts.get(label) || 0) + 1);
    });
    const getNodeId = (nodeId) => {
      const label = nodeLabels[nodeId];
      if (validate(nodeId) && nodeLabelCounts.get(label) === 1)
        return label;
      else
        return nodeId;
    };
    return new Graph2({
      nodes: Object.fromEntries(Object.entries(this.nodes).map(([id, node]) => [getNodeId(id), {
        ...node,
        id: getNodeId(id)
      }])),
      edges: this.edges.map((edge) => ({
        ...edge,
        source: getNodeId(edge.source),
        target: getNodeId(edge.target)
      }))
    });
  }
  drawMermaid(params) {
    const { withStyles, curveStyle, nodeColors = {
      default: "fill:#f2f0ff,line-height:1.2",
      first: "fill-opacity:0",
      last: "fill:#bfb6fc"
    }, wrapLabelNWords } = params ?? {};
    const graph = this.reid();
    const firstNode = graph.firstNode();
    const lastNode = graph.lastNode();
    return drawMermaid(graph.nodes, graph.edges, {
      firstNode: firstNode?.id,
      lastNode: lastNode?.id,
      withStyles,
      curveStyle,
      nodeColors,
      wrapLabelNWords
    });
  }
  async drawMermaidPng(params) {
    const mermaidSyntax = this.drawMermaid(params);
    return drawMermaidImage(mermaidSyntax, { backgroundColor: params?.backgroundColor });
  }
};
function _firstNode(graph, exclude = []) {
  const targets = new Set(graph.edges.filter((edge) => !exclude.includes(edge.source)).map((edge) => edge.target));
  const found = [];
  for (const node of Object.values(graph.nodes))
    if (!exclude.includes(node.id) && !targets.has(node.id))
      found.push(node);
  return found.length === 1 ? found[0] : undefined;
}
function _lastNode(graph, exclude = []) {
  const sources = new Set(graph.edges.filter((edge) => !exclude.includes(edge.target)).map((edge) => edge.source));
  const found = [];
  for (const node of Object.values(graph.nodes))
    if (!exclude.includes(node.id) && !sources.has(node.id))
      found.push(node);
  return found.length === 1 ? found[0] : undefined;
}

// node_modules/@langchain/core/dist/runnables/wrappers.js
function convertToHttpEventStream(stream) {
  const encoder2 = new TextEncoder;
  const finalStream = new ReadableStream({ async start(controller) {
    for await (const chunk of stream)
      controller.enqueue(encoder2.encode(`event: data
data: ${JSON.stringify(chunk)}

`));
    controller.enqueue(encoder2.encode(`event: end

`));
    controller.close();
  } });
  return IterableReadableStream.fromReadableStream(finalStream);
}

// node_modules/@langchain/core/dist/runnables/iter.js
function isIterableIterator(thing) {
  return typeof thing === "object" && thing !== null && typeof thing[Symbol.iterator] === "function" && typeof thing.next === "function";
}
var isIterator = (x) => x != null && typeof x === "object" && ("next" in x) && typeof x.next === "function";
function isAsyncIterable(thing) {
  return typeof thing === "object" && thing !== null && typeof thing[Symbol.asyncIterator] === "function";
}
function* consumeIteratorInContext(context, iter) {
  while (true) {
    const { value, done } = AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(context), iter.next.bind(iter), true);
    if (done)
      break;
    else
      yield value;
  }
}
async function* consumeAsyncIterableInContext(context, iter) {
  const iterator = iter[Symbol.asyncIterator]();
  while (true) {
    const { value, done } = await AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(context), iterator.next.bind(iter), true);
    if (done)
      break;
    else
      yield value;
  }
}

// node_modules/@langchain/core/dist/runnables/base.js
init_v3();
function _coerceToDict2(value, defaultKey) {
  return value && !Array.isArray(value) && !(value instanceof Date) && typeof value === "object" ? value : { [defaultKey]: value };
}
var Runnable = class extends Serializable {
  lc_runnable = true;
  name;
  getName(suffix) {
    const name = this.name ?? this.constructor.lc_name() ?? this.constructor.name;
    return suffix ? `${name}${suffix}` : name;
  }
  withRetry(fields) {
    return new RunnableRetry({
      bound: this,
      kwargs: {},
      config: {},
      maxAttemptNumber: fields?.stopAfterAttempt,
      ...fields
    });
  }
  withConfig(config2) {
    return new RunnableBinding({
      bound: this,
      config: config2,
      kwargs: {}
    });
  }
  withFallbacks(fields) {
    const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;
    return new RunnableWithFallbacks({
      runnable: this,
      fallbacks
    });
  }
  _getOptionsList(options, length = 0) {
    if (Array.isArray(options) && options.length !== length)
      throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);
    if (Array.isArray(options))
      return options.map(ensureConfig);
    if (length > 1 && !Array.isArray(options) && options.runId) {
      console.warn("Provided runId will be used only for the first element of the batch.");
      const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== "runId"));
      return Array.from({ length }, (_, i) => ensureConfig(i === 0 ? options : subsequent));
    }
    return Array.from({ length }, () => ensureConfig(options));
  }
  async batch(inputs, options, batchOptions) {
    const configList = this._getOptionsList(options ?? {}, inputs.length);
    const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;
    const caller = new AsyncCaller2({
      maxConcurrency,
      onFailedAttempt: (e) => {
        throw e;
      }
    });
    const batchCalls = inputs.map((input, i) => caller.call(async () => {
      try {
        const result = await this.invoke(input, configList[i]);
        return result;
      } catch (e) {
        if (batchOptions?.returnExceptions)
          return e;
        throw e;
      }
    }));
    return Promise.all(batchCalls);
  }
  async* _streamIterator(input, options) {
    yield this.invoke(input, options);
  }
  async stream(input, options) {
    const config2 = ensureConfig(options);
    const wrappedGenerator = new AsyncGeneratorWithSetup({
      generator: this._streamIterator(input, config2),
      config: config2
    });
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
  _separateRunnableConfigFromCallOptions(options) {
    let runnableConfig;
    if (options === undefined)
      runnableConfig = ensureConfig(options);
    else
      runnableConfig = ensureConfig({
        callbacks: options.callbacks,
        tags: options.tags,
        metadata: options.metadata,
        runName: options.runName,
        configurable: options.configurable,
        recursionLimit: options.recursionLimit,
        maxConcurrency: options.maxConcurrency,
        runId: options.runId,
        timeout: options.timeout,
        signal: options.signal
      });
    const callOptions = { ...options };
    delete callOptions.callbacks;
    delete callOptions.tags;
    delete callOptions.metadata;
    delete callOptions.runName;
    delete callOptions.configurable;
    delete callOptions.recursionLimit;
    delete callOptions.maxConcurrency;
    delete callOptions.runId;
    delete callOptions.timeout;
    delete callOptions.signal;
    return [runnableConfig, callOptions];
  }
  async _callWithConfig(func, input, options) {
    const config2 = ensureConfig(options);
    const callbackManager_ = await getCallbackManagerForConfig(config2);
    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), config2.runId, config2?.runType, undefined, undefined, config2?.runName ?? this.getName());
    delete config2.runId;
    let output;
    try {
      const promise = func.call(this, input, config2, runManager);
      output = await raceWithSignal(promise, options?.signal);
    } catch (e) {
      await runManager?.handleChainError(e);
      throw e;
    }
    await runManager?.handleChainEnd(_coerceToDict2(output, "output"));
    return output;
  }
  async _batchWithConfig(func, inputs, options, batchOptions) {
    const optionsList = this._getOptionsList(options ?? {}, inputs.length);
    const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));
    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {
      const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict2(inputs[i], "input"), optionsList[i].runId, optionsList[i].runType, undefined, undefined, optionsList[i].runName ?? this.getName());
      delete optionsList[i].runId;
      return handleStartRes;
    }));
    let outputs;
    try {
      const promise = func.call(this, inputs, optionsList, runManagers, batchOptions);
      outputs = await raceWithSignal(promise, optionsList?.[0]?.signal);
    } catch (e) {
      await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));
      throw e;
    }
    await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict2(outputs, "output"))));
    return outputs;
  }
  _concatOutputChunks(first, second) {
    return concat(first, second);
  }
  async* _transformStreamWithConfig(inputGenerator, transformer, options) {
    let finalInput;
    let finalInputSupported = true;
    let finalOutput;
    let finalOutputSupported = true;
    const config2 = ensureConfig(options);
    const callbackManager_ = await getCallbackManagerForConfig(config2);
    const outerThis = this;
    async function* wrapInputForTracing() {
      for await (const chunk of inputGenerator) {
        if (finalInputSupported)
          if (finalInput === undefined)
            finalInput = chunk;
          else
            try {
              finalInput = outerThis._concatOutputChunks(finalInput, chunk);
            } catch {
              finalInput = undefined;
              finalInputSupported = false;
            }
        yield chunk;
      }
    }
    let runManager;
    try {
      const pipe = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), { input: "" }, config2.runId, config2.runType, undefined, undefined, config2.runName ?? this.getName()), options?.signal, config2);
      delete config2.runId;
      runManager = pipe.setup;
      const streamEventsHandler = runManager?.handlers.find(isStreamEventsHandler);
      let iterator = pipe.output;
      if (streamEventsHandler !== undefined && runManager !== undefined)
        iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);
      const streamLogHandler = runManager?.handlers.find(isLogStreamHandler);
      if (streamLogHandler !== undefined && runManager !== undefined)
        iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);
      for await (const chunk of iterator) {
        yield chunk;
        if (finalOutputSupported)
          if (finalOutput === undefined)
            finalOutput = chunk;
          else
            try {
              finalOutput = this._concatOutputChunks(finalOutput, chunk);
            } catch {
              finalOutput = undefined;
              finalOutputSupported = false;
            }
      }
    } catch (e) {
      await runManager?.handleChainError(e, undefined, undefined, undefined, { inputs: _coerceToDict2(finalInput, "input") });
      throw e;
    }
    await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, { inputs: _coerceToDict2(finalInput, "input") });
  }
  getGraph(_) {
    const graph = new Graph;
    const inputNode = graph.addNode({
      name: `${this.getName()}Input`,
      schema: exports_external.any()
    });
    const runnableNode = graph.addNode(this);
    const outputNode = graph.addNode({
      name: `${this.getName()}Output`,
      schema: exports_external.any()
    });
    graph.addEdge(inputNode, runnableNode);
    graph.addEdge(runnableNode, outputNode);
    return graph;
  }
  pipe(coerceable) {
    return new RunnableSequence({
      first: this,
      last: _coerceToRunnable(coerceable)
    });
  }
  pick(keys) {
    return this.pipe(new RunnablePick(keys));
  }
  assign(mapping) {
    return this.pipe(new RunnableAssign(new RunnableMap({ steps: mapping })));
  }
  async* transform(generator, options) {
    let finalChunk;
    for await (const chunk of generator)
      if (finalChunk === undefined)
        finalChunk = chunk;
      else
        finalChunk = this._concatOutputChunks(finalChunk, chunk);
    yield* this._streamIterator(finalChunk, ensureConfig(options));
  }
  async* streamLog(input, options, streamOptions) {
    const logStreamCallbackHandler = new LogStreamCallbackHandler({
      ...streamOptions,
      autoClose: false,
      _schemaFormat: "original"
    });
    const config2 = ensureConfig(options);
    yield* this._streamLog(input, logStreamCallbackHandler, config2);
  }
  async* _streamLog(input, logStreamCallbackHandler, config2) {
    const { callbacks } = config2;
    if (callbacks === undefined)
      config2.callbacks = [logStreamCallbackHandler];
    else if (Array.isArray(callbacks))
      config2.callbacks = callbacks.concat([logStreamCallbackHandler]);
    else {
      const copiedCallbacks = callbacks.copy();
      copiedCallbacks.addHandler(logStreamCallbackHandler, true);
      config2.callbacks = copiedCallbacks;
    }
    const runnableStreamPromise = this.stream(input, config2);
    async function consumeRunnableStream() {
      try {
        const runnableStream = await runnableStreamPromise;
        for await (const chunk of runnableStream) {
          const patch = new RunLogPatch({ ops: [{
            op: "add",
            path: "/streamed_output/-",
            value: chunk
          }] });
          await logStreamCallbackHandler.writer.write(patch);
        }
      } finally {
        await logStreamCallbackHandler.writer.close();
      }
    }
    const runnableStreamConsumePromise = consumeRunnableStream();
    try {
      for await (const log of logStreamCallbackHandler)
        yield log;
    } finally {
      await runnableStreamConsumePromise;
    }
  }
  streamEvents(input, options, streamOptions) {
    let stream;
    if (options.version === "v1")
      stream = this._streamEventsV1(input, options, streamOptions);
    else if (options.version === "v2")
      stream = this._streamEventsV2(input, options, streamOptions);
    else
      throw new Error(`Only versions "v1" and "v2" of the schema are currently supported.`);
    if (options.encoding === "text/event-stream")
      return convertToHttpEventStream(stream);
    else
      return IterableReadableStream.fromAsyncGenerator(stream);
  }
  async* _streamEventsV2(input, options, streamOptions) {
    const eventStreamer = new EventStreamCallbackHandler({
      ...streamOptions,
      autoClose: false
    });
    const config2 = ensureConfig(options);
    const runId = config2.runId ?? v4();
    config2.runId = runId;
    const callbacks = config2.callbacks;
    if (callbacks === undefined)
      config2.callbacks = [eventStreamer];
    else if (Array.isArray(callbacks))
      config2.callbacks = callbacks.concat(eventStreamer);
    else {
      const copiedCallbacks = callbacks.copy();
      copiedCallbacks.addHandler(eventStreamer, true);
      config2.callbacks = copiedCallbacks;
    }
    const abortController = new AbortController;
    const outerThis = this;
    async function consumeRunnableStream() {
      let signal;
      let listener = null;
      try {
        if (options?.signal)
          if ("any" in AbortSignal)
            signal = AbortSignal.any([abortController.signal, options.signal]);
          else {
            signal = options.signal;
            listener = () => {
              abortController.abort();
            };
            options.signal.addEventListener("abort", listener, { once: true });
          }
        else
          signal = abortController.signal;
        const runnableStream = await outerThis.stream(input, {
          ...config2,
          signal
        });
        const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);
        for await (const _ of tappedStream)
          if (abortController.signal.aborted)
            break;
      } finally {
        await eventStreamer.finish();
        if (signal && listener)
          signal.removeEventListener("abort", listener);
      }
    }
    const runnableStreamConsumePromise = consumeRunnableStream();
    let firstEventSent = false;
    let firstEventRunId;
    try {
      for await (const event of eventStreamer) {
        if (!firstEventSent) {
          event.data.input = input;
          firstEventSent = true;
          firstEventRunId = event.run_id;
          yield event;
          continue;
        }
        if (event.run_id === firstEventRunId && event.event.endsWith("_end")) {
          if (event.data?.input)
            delete event.data.input;
        }
        yield event;
      }
    } finally {
      abortController.abort();
      await runnableStreamConsumePromise;
    }
  }
  async* _streamEventsV1(input, options, streamOptions) {
    let runLog;
    let hasEncounteredStartEvent = false;
    const config2 = ensureConfig(options);
    const rootTags = config2.tags ?? [];
    const rootMetadata = config2.metadata ?? {};
    const rootName = config2.runName ?? this.getName();
    const logStreamCallbackHandler = new LogStreamCallbackHandler({
      ...streamOptions,
      autoClose: false,
      _schemaFormat: "streaming_events"
    });
    const rootEventFilter = new _RootEventFilter({ ...streamOptions });
    const logStream = this._streamLog(input, logStreamCallbackHandler, config2);
    for await (const log of logStream) {
      if (!runLog)
        runLog = RunLog.fromRunLogPatch(log);
      else
        runLog = runLog.concat(log);
      if (runLog.state === undefined)
        throw new Error(`Internal error: "streamEvents" state is missing. Please open a bug report.`);
      if (!hasEncounteredStartEvent) {
        hasEncounteredStartEvent = true;
        const state$2 = { ...runLog.state };
        const event = {
          run_id: state$2.id,
          event: `on_${state$2.type}_start`,
          name: rootName,
          tags: rootTags,
          metadata: rootMetadata,
          data: { input }
        };
        if (rootEventFilter.includeEvent(event, state$2.type))
          yield event;
      }
      const paths = log.ops.filter((op) => op.path.startsWith("/logs/")).map((op) => op.path.split("/")[2]);
      const dedupedPaths = [...new Set(paths)];
      for (const path of dedupedPaths) {
        let eventType;
        let data = {};
        const logEntry = runLog.state.logs[path];
        if (logEntry.end_time === undefined)
          if (logEntry.streamed_output.length > 0)
            eventType = "stream";
          else
            eventType = "start";
        else
          eventType = "end";
        if (eventType === "start") {
          if (logEntry.inputs !== undefined)
            data.input = logEntry.inputs;
        } else if (eventType === "end") {
          if (logEntry.inputs !== undefined)
            data.input = logEntry.inputs;
          data.output = logEntry.final_output;
        } else if (eventType === "stream") {
          const chunkCount = logEntry.streamed_output.length;
          if (chunkCount !== 1)
            throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${logEntry.name}"`);
          data = { chunk: logEntry.streamed_output[0] };
          logEntry.streamed_output = [];
        }
        yield {
          event: `on_${logEntry.type}_${eventType}`,
          name: logEntry.name,
          run_id: logEntry.id,
          tags: logEntry.tags,
          metadata: logEntry.metadata,
          data
        };
      }
      const { state: state$1 } = runLog;
      if (state$1.streamed_output.length > 0) {
        const chunkCount = state$1.streamed_output.length;
        if (chunkCount !== 1)
          throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${state$1.name}"`);
        const data = { chunk: state$1.streamed_output[0] };
        state$1.streamed_output = [];
        const event = {
          event: `on_${state$1.type}_stream`,
          run_id: state$1.id,
          tags: rootTags,
          metadata: rootMetadata,
          name: rootName,
          data
        };
        if (rootEventFilter.includeEvent(event, state$1.type))
          yield event;
      }
    }
    const state = runLog?.state;
    if (state !== undefined) {
      const event = {
        event: `on_${state.type}_end`,
        name: rootName,
        run_id: state.id,
        tags: rootTags,
        metadata: rootMetadata,
        data: { output: state.final_output }
      };
      if (rootEventFilter.includeEvent(event, state.type))
        yield event;
    }
  }
  static isRunnable(thing) {
    return isRunnableInterface(thing);
  }
  withListeners({ onStart, onEnd, onError }) {
    return new RunnableBinding({
      bound: this,
      config: {},
      configFactories: [(config2) => ({ callbacks: [new RootListenersTracer({
        config: config2,
        onStart,
        onEnd,
        onError
      })] })]
    });
  }
  asTool(fields) {
    return convertRunnableToTool(this, fields);
  }
};
var RunnableBinding = class RunnableBinding2 extends Runnable {
  static lc_name() {
    return "RunnableBinding";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = true;
  bound;
  config;
  kwargs;
  configFactories;
  constructor(fields) {
    super(fields);
    this.bound = fields.bound;
    this.kwargs = fields.kwargs;
    this.config = fields.config;
    this.configFactories = fields.configFactories;
  }
  getName(suffix) {
    return this.bound.getName(suffix);
  }
  async _mergeConfig(...options) {
    const config2 = mergeConfigs(this.config, ...options);
    return mergeConfigs(config2, ...this.configFactories ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config2))) : []);
  }
  withConfig(config2) {
    return new this.constructor({
      bound: this.bound,
      kwargs: this.kwargs,
      config: {
        ...this.config,
        ...config2
      }
    });
  }
  withRetry(fields) {
    return new RunnableRetry({
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      maxAttemptNumber: fields?.stopAfterAttempt,
      ...fields
    });
  }
  async invoke(input, options) {
    return this.bound.invoke(input, await this._mergeConfig(options, this.kwargs));
  }
  async batch(inputs, options, batchOptions) {
    const mergedOptions = Array.isArray(options) ? await Promise.all(options.map(async (individualOption) => this._mergeConfig(ensureConfig(individualOption), this.kwargs))) : await this._mergeConfig(ensureConfig(options), this.kwargs);
    return this.bound.batch(inputs, mergedOptions, batchOptions);
  }
  _concatOutputChunks(first, second) {
    return this.bound._concatOutputChunks(first, second);
  }
  async* _streamIterator(input, options) {
    yield* this.bound._streamIterator(input, await this._mergeConfig(ensureConfig(options), this.kwargs));
  }
  async stream(input, options) {
    return this.bound.stream(input, await this._mergeConfig(ensureConfig(options), this.kwargs));
  }
  async* transform(generator, options) {
    yield* this.bound.transform(generator, await this._mergeConfig(ensureConfig(options), this.kwargs));
  }
  streamEvents(input, options, streamOptions) {
    const outerThis = this;
    const generator = async function* () {
      yield* outerThis.bound.streamEvents(input, {
        ...await outerThis._mergeConfig(ensureConfig(options), outerThis.kwargs),
        version: options.version
      }, streamOptions);
    };
    return IterableReadableStream.fromAsyncGenerator(generator());
  }
  static isRunnableBinding(thing) {
    return thing.bound && Runnable.isRunnable(thing.bound);
  }
  withListeners({ onStart, onEnd, onError }) {
    return new RunnableBinding2({
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      configFactories: [(config2) => ({ callbacks: [new RootListenersTracer({
        config: config2,
        onStart,
        onEnd,
        onError
      })] })]
    });
  }
};
var RunnableRetry = class extends RunnableBinding {
  static lc_name() {
    return "RunnableRetry";
  }
  lc_namespace = ["langchain_core", "runnables"];
  maxAttemptNumber = 3;
  onFailedAttempt = () => {};
  constructor(fields) {
    super(fields);
    this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;
    this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;
  }
  _patchConfigForRetry(attempt, config2, runManager) {
    const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;
    return patchConfig(config2, { callbacks: runManager?.getChild(tag) });
  }
  async _invoke(input, config2, runManager) {
    return pRetry2((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config2, runManager)), {
      onFailedAttempt: ({ error: error46 }) => this.onFailedAttempt(error46, input),
      retries: Math.max(this.maxAttemptNumber - 1, 0),
      randomize: true
    });
  }
  async invoke(input, config2) {
    return this._callWithConfig(this._invoke.bind(this), input, config2);
  }
  async _batch(inputs, configs, runManagers, batchOptions) {
    const resultsMap = {};
    try {
      await pRetry2(async (attemptNumber) => {
        const remainingIndexes = inputs.map((_, i) => i).filter((i) => resultsMap[i.toString()] === undefined || resultsMap[i.toString()] instanceof Error);
        const remainingInputs = remainingIndexes.map((i) => inputs[i]);
        const patchedConfigs = remainingIndexes.map((i) => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));
        const results = await super.batch(remainingInputs, patchedConfigs, {
          ...batchOptions,
          returnExceptions: true
        });
        let firstException;
        for (let i = 0;i < results.length; i += 1) {
          const result = results[i];
          const resultMapIndex = remainingIndexes[i];
          if (result instanceof Error) {
            if (firstException === undefined) {
              firstException = result;
              firstException.input = remainingInputs[i];
            }
          }
          resultsMap[resultMapIndex.toString()] = result;
        }
        if (firstException)
          throw firstException;
        return results;
      }, {
        onFailedAttempt: ({ error: error46 }) => this.onFailedAttempt(error46, error46.input),
        retries: Math.max(this.maxAttemptNumber - 1, 0),
        randomize: true
      });
    } catch (e) {
      if (batchOptions?.returnExceptions !== true)
        throw e;
    }
    return Object.keys(resultsMap).sort((a, b) => parseInt(a, 10) - parseInt(b, 10)).map((key) => resultsMap[parseInt(key, 10)]);
  }
  async batch(inputs, options, batchOptions) {
    return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);
  }
};
var RunnableSequence = class RunnableSequence2 extends Runnable {
  static lc_name() {
    return "RunnableSequence";
  }
  first;
  middle = [];
  last;
  omitSequenceTags = false;
  lc_serializable = true;
  lc_namespace = ["langchain_core", "runnables"];
  constructor(fields) {
    super(fields);
    this.first = fields.first;
    this.middle = fields.middle ?? this.middle;
    this.last = fields.last;
    this.name = fields.name;
    this.omitSequenceTags = fields.omitSequenceTags ?? this.omitSequenceTags;
  }
  get steps() {
    return [
      this.first,
      ...this.middle,
      this.last
    ];
  }
  async invoke(input, options) {
    const config2 = ensureConfig(options);
    const callbackManager_ = await getCallbackManagerForConfig(config2);
    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), config2.runId, undefined, undefined, undefined, config2?.runName);
    delete config2.runId;
    let nextStepInput = input;
    let finalOutput;
    try {
      const initialSteps = [this.first, ...this.middle];
      for (let i = 0;i < initialSteps.length; i += 1) {
        const step = initialSteps[i];
        const promise = step.invoke(nextStepInput, patchConfig(config2, { callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`) }));
        nextStepInput = await raceWithSignal(promise, options?.signal);
      }
      if (options?.signal?.aborted)
        throw getAbortSignalError(options.signal);
      finalOutput = await this.last.invoke(nextStepInput, patchConfig(config2, { callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${this.steps.length}`) }));
    } catch (e) {
      await runManager?.handleChainError(e);
      throw e;
    }
    await runManager?.handleChainEnd(_coerceToDict2(finalOutput, "output"));
    return finalOutput;
  }
  async batch(inputs, options, batchOptions) {
    const configList = this._getOptionsList(options ?? {}, inputs.length);
    const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));
    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {
      const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict2(inputs[i], "input"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);
      delete configList[i].runId;
      return handleStartRes;
    }));
    let nextStepInputs = inputs;
    try {
      for (let i = 0;i < this.steps.length; i += 1) {
        const step = this.steps[i];
        const promise = step.batch(nextStepInputs, runManagers.map((runManager, j) => {
          const childRunManager = runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`);
          return patchConfig(configList[j], { callbacks: childRunManager });
        }), batchOptions);
        nextStepInputs = await raceWithSignal(promise, configList[0]?.signal);
      }
    } catch (e) {
      await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));
      throw e;
    }
    await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict2(nextStepInputs, "output"))));
    return nextStepInputs;
  }
  _concatOutputChunks(first, second) {
    return this.last._concatOutputChunks(first, second);
  }
  async* _streamIterator(input, options) {
    const callbackManager_ = await getCallbackManagerForConfig(options);
    const { runId, ...otherOptions } = options ?? {};
    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), runId, undefined, undefined, undefined, otherOptions?.runName);
    const steps = [
      this.first,
      ...this.middle,
      this.last
    ];
    let concatSupported = true;
    let finalOutput;
    async function* inputGenerator() {
      yield input;
    }
    try {
      let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(otherOptions, { callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:1`) }));
      for (let i = 1;i < steps.length; i += 1) {
        const step = steps[i];
        finalGenerator = await step.transform(finalGenerator, patchConfig(otherOptions, { callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`) }));
      }
      for await (const chunk of finalGenerator) {
        options?.signal?.throwIfAborted();
        yield chunk;
        if (concatSupported)
          if (finalOutput === undefined)
            finalOutput = chunk;
          else
            try {
              finalOutput = this._concatOutputChunks(finalOutput, chunk);
            } catch {
              finalOutput = undefined;
              concatSupported = false;
            }
      }
    } catch (e) {
      await runManager?.handleChainError(e);
      throw e;
    }
    await runManager?.handleChainEnd(_coerceToDict2(finalOutput, "output"));
  }
  getGraph(config2) {
    const graph = new Graph;
    let currentLastNode = null;
    this.steps.forEach((step, index) => {
      const stepGraph = step.getGraph(config2);
      if (index !== 0)
        stepGraph.trimFirstNode();
      if (index !== this.steps.length - 1)
        stepGraph.trimLastNode();
      graph.extend(stepGraph);
      const stepFirstNode = stepGraph.firstNode();
      if (!stepFirstNode)
        throw new Error(`Runnable ${step} has no first node`);
      if (currentLastNode)
        graph.addEdge(currentLastNode, stepFirstNode);
      currentLastNode = stepGraph.lastNode();
    });
    return graph;
  }
  pipe(coerceable) {
    if (RunnableSequence2.isRunnableSequence(coerceable))
      return new RunnableSequence2({
        first: this.first,
        middle: this.middle.concat([
          this.last,
          coerceable.first,
          ...coerceable.middle
        ]),
        last: coerceable.last,
        name: this.name ?? coerceable.name
      });
    else
      return new RunnableSequence2({
        first: this.first,
        middle: [...this.middle, this.last],
        last: _coerceToRunnable(coerceable),
        name: this.name
      });
  }
  static isRunnableSequence(thing) {
    return Array.isArray(thing.middle) && Runnable.isRunnable(thing);
  }
  static from([first, ...runnables], nameOrFields) {
    let extra = {};
    if (typeof nameOrFields === "string")
      extra.name = nameOrFields;
    else if (nameOrFields !== undefined)
      extra = nameOrFields;
    return new RunnableSequence2({
      ...extra,
      first: _coerceToRunnable(first),
      middle: runnables.slice(0, -1).map(_coerceToRunnable),
      last: _coerceToRunnable(runnables[runnables.length - 1])
    });
  }
};
var RunnableMap = class RunnableMap2 extends Runnable {
  static lc_name() {
    return "RunnableMap";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = true;
  steps;
  getStepsKeys() {
    return Object.keys(this.steps);
  }
  constructor(fields) {
    super(fields);
    this.steps = {};
    for (const [key, value] of Object.entries(fields.steps))
      this.steps[key] = _coerceToRunnable(value);
  }
  static from(steps) {
    return new RunnableMap2({ steps });
  }
  async invoke(input, options) {
    const config2 = ensureConfig(options);
    const callbackManager_ = await getCallbackManagerForConfig(config2);
    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), { input }, config2.runId, undefined, undefined, undefined, config2?.runName);
    delete config2.runId;
    const output = {};
    try {
      const promises = Object.entries(this.steps).map(async ([key, runnable]) => {
        output[key] = await runnable.invoke(input, patchConfig(config2, { callbacks: runManager?.getChild(`map:key:${key}`) }));
      });
      await raceWithSignal(Promise.all(promises), options?.signal);
    } catch (e) {
      await runManager?.handleChainError(e);
      throw e;
    }
    await runManager?.handleChainEnd(output);
    return output;
  }
  async* _transform(generator, runManager, options) {
    const steps = { ...this.steps };
    const inputCopies = atee(generator, Object.keys(steps).length);
    const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {
      const gen = runnable.transform(inputCopies[i], patchConfig(options, { callbacks: runManager?.getChild(`map:key:${key}`) }));
      return [key, gen.next().then((result) => ({
        key,
        gen,
        result
      }))];
    }));
    while (tasks.size) {
      const promise = Promise.race(tasks.values());
      const { key, result, gen } = await raceWithSignal(promise, options?.signal);
      tasks.delete(key);
      if (!result.done) {
        yield { [key]: result.value };
        tasks.set(key, gen.next().then((result$1) => ({
          key,
          gen,
          result: result$1
        })));
      }
    }
  }
  transform(generator, options) {
    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
  }
  async stream(input, options) {
    async function* generator() {
      yield input;
    }
    const config2 = ensureConfig(options);
    const wrappedGenerator = new AsyncGeneratorWithSetup({
      generator: this.transform(generator(), config2),
      config: config2
    });
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
};
var RunnableTraceable = class RunnableTraceable2 extends Runnable {
  lc_serializable = false;
  lc_namespace = ["langchain_core", "runnables"];
  func;
  constructor(fields) {
    super(fields);
    if (!isTraceableFunction(fields.func))
      throw new Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
    this.func = fields.func;
  }
  async invoke(input, options) {
    const [config2] = this._getOptionsList(options ?? {}, 1);
    const callbacks = await getCallbackManagerForConfig(config2);
    const promise = this.func(patchConfig(config2, { callbacks }), input);
    return raceWithSignal(promise, config2?.signal);
  }
  async* _streamIterator(input, options) {
    const [config2] = this._getOptionsList(options ?? {}, 1);
    const result = await this.invoke(input, options);
    if (isAsyncIterable(result)) {
      for await (const item of result) {
        config2?.signal?.throwIfAborted();
        yield item;
      }
      return;
    }
    if (isIterator(result)) {
      while (true) {
        config2?.signal?.throwIfAborted();
        const state = result.next();
        if (state.done)
          break;
        yield state.value;
      }
      return;
    }
    yield result;
  }
  static from(func) {
    return new RunnableTraceable2({ func });
  }
};
function assertNonTraceableFunction(func) {
  if (isTraceableFunction(func))
    throw new Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
}
var RunnableLambda = class RunnableLambda2 extends Runnable {
  static lc_name() {
    return "RunnableLambda";
  }
  lc_namespace = ["langchain_core", "runnables"];
  func;
  constructor(fields) {
    if (isTraceableFunction(fields.func))
      return RunnableTraceable.from(fields.func);
    super(fields);
    assertNonTraceableFunction(fields.func);
    this.func = fields.func;
  }
  static from(func) {
    return new RunnableLambda2({ func });
  }
  async _invoke(input, config2, runManager) {
    return new Promise((resolve, reject) => {
      const childConfig = patchConfig(config2, {
        callbacks: runManager?.getChild(),
        recursionLimit: (config2?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1
      });
      AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {
        try {
          let output = await this.func(input, { ...childConfig });
          if (output && Runnable.isRunnable(output)) {
            if (config2?.recursionLimit === 0)
              throw new Error("Recursion limit reached.");
            output = await output.invoke(input, {
              ...childConfig,
              recursionLimit: (childConfig.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1
            });
          } else if (isAsyncIterable(output)) {
            let finalOutput;
            for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {
              config2?.signal?.throwIfAborted();
              if (finalOutput === undefined)
                finalOutput = chunk;
              else
                try {
                  finalOutput = this._concatOutputChunks(finalOutput, chunk);
                } catch {
                  finalOutput = chunk;
                }
            }
            output = finalOutput;
          } else if (isIterableIterator(output)) {
            let finalOutput;
            for (const chunk of consumeIteratorInContext(childConfig, output)) {
              config2?.signal?.throwIfAborted();
              if (finalOutput === undefined)
                finalOutput = chunk;
              else
                try {
                  finalOutput = this._concatOutputChunks(finalOutput, chunk);
                } catch {
                  finalOutput = chunk;
                }
            }
            output = finalOutput;
          }
          resolve(output);
        } catch (e) {
          reject(e);
        }
      });
    });
  }
  async invoke(input, options) {
    return this._callWithConfig(this._invoke.bind(this), input, options);
  }
  async* _transform(generator, runManager, config2) {
    let finalChunk;
    for await (const chunk of generator)
      if (finalChunk === undefined)
        finalChunk = chunk;
      else
        try {
          finalChunk = this._concatOutputChunks(finalChunk, chunk);
        } catch {
          finalChunk = chunk;
        }
    const childConfig = patchConfig(config2, {
      callbacks: runManager?.getChild(),
      recursionLimit: (config2?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1
    });
    const output = await new Promise((resolve, reject) => {
      AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {
        try {
          const res = await this.func(finalChunk, {
            ...childConfig,
            config: childConfig
          });
          resolve(res);
        } catch (e) {
          reject(e);
        }
      });
    });
    if (output && Runnable.isRunnable(output)) {
      if (config2?.recursionLimit === 0)
        throw new Error("Recursion limit reached.");
      const stream = await output.stream(finalChunk, childConfig);
      for await (const chunk of stream)
        yield chunk;
    } else if (isAsyncIterable(output))
      for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {
        config2?.signal?.throwIfAborted();
        yield chunk;
      }
    else if (isIterableIterator(output))
      for (const chunk of consumeIteratorInContext(childConfig, output)) {
        config2?.signal?.throwIfAborted();
        yield chunk;
      }
    else
      yield output;
  }
  transform(generator, options) {
    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
  }
  async stream(input, options) {
    async function* generator() {
      yield input;
    }
    const config2 = ensureConfig(options);
    const wrappedGenerator = new AsyncGeneratorWithSetup({
      generator: this.transform(generator(), config2),
      config: config2
    });
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
};
var RunnableWithFallbacks = class extends Runnable {
  static lc_name() {
    return "RunnableWithFallbacks";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = true;
  runnable;
  fallbacks;
  constructor(fields) {
    super(fields);
    this.runnable = fields.runnable;
    this.fallbacks = fields.fallbacks;
  }
  *runnables() {
    yield this.runnable;
    for (const fallback of this.fallbacks)
      yield fallback;
  }
  async invoke(input, options) {
    const config2 = ensureConfig(options);
    const callbackManager_ = await getCallbackManagerForConfig(config2);
    const { runId, ...otherConfigFields } = config2;
    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), runId, undefined, undefined, undefined, otherConfigFields?.runName);
    const childConfig = patchConfig(otherConfigFields, { callbacks: runManager?.getChild() });
    const res = await AsyncLocalStorageProviderSingleton2.runWithConfig(childConfig, async () => {
      let firstError;
      for (const runnable of this.runnables()) {
        config2?.signal?.throwIfAborted();
        try {
          const output = await runnable.invoke(input, childConfig);
          await runManager?.handleChainEnd(_coerceToDict2(output, "output"));
          return output;
        } catch (e) {
          if (firstError === undefined)
            firstError = e;
        }
      }
      if (firstError === undefined)
        throw new Error("No error stored at end of fallback.");
      await runManager?.handleChainError(firstError);
      throw firstError;
    });
    return res;
  }
  async* _streamIterator(input, options) {
    const config2 = ensureConfig(options);
    const callbackManager_ = await getCallbackManagerForConfig(config2);
    const { runId, ...otherConfigFields } = config2;
    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), runId, undefined, undefined, undefined, otherConfigFields?.runName);
    let firstError;
    let stream;
    for (const runnable of this.runnables()) {
      config2?.signal?.throwIfAborted();
      const childConfig = patchConfig(otherConfigFields, { callbacks: runManager?.getChild() });
      try {
        const originalStream = await runnable.stream(input, childConfig);
        stream = consumeAsyncIterableInContext(childConfig, originalStream);
        break;
      } catch (e) {
        if (firstError === undefined)
          firstError = e;
      }
    }
    if (stream === undefined) {
      const error46 = firstError ?? /* @__PURE__ */ new Error("No error stored at end of fallback.");
      await runManager?.handleChainError(error46);
      throw error46;
    }
    let output;
    try {
      for await (const chunk of stream) {
        yield chunk;
        try {
          output = output === undefined ? output : this._concatOutputChunks(output, chunk);
        } catch {
          output = undefined;
        }
      }
    } catch (e) {
      await runManager?.handleChainError(e);
      throw e;
    }
    await runManager?.handleChainEnd(_coerceToDict2(output, "output"));
  }
  async batch(inputs, options, batchOptions) {
    if (batchOptions?.returnExceptions)
      throw new Error("Not implemented.");
    const configList = this._getOptionsList(options ?? {}, inputs.length);
    const callbackManagers = await Promise.all(configList.map((config2) => getCallbackManagerForConfig(config2)));
    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {
      const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict2(inputs[i], "input"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);
      delete configList[i].runId;
      return handleStartRes;
    }));
    let firstError;
    for (const runnable of this.runnables()) {
      configList[0].signal?.throwIfAborted();
      try {
        const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => patchConfig(configList[j], { callbacks: runManager?.getChild() })), batchOptions);
        await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict2(outputs[i], "output"))));
        return outputs;
      } catch (e) {
        if (firstError === undefined)
          firstError = e;
      }
    }
    if (!firstError)
      throw new Error("No error stored at end of fallbacks.");
    await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(firstError)));
    throw firstError;
  }
};
function _coerceToRunnable(coerceable) {
  if (typeof coerceable === "function")
    return new RunnableLambda({ func: coerceable });
  else if (Runnable.isRunnable(coerceable))
    return coerceable;
  else if (!Array.isArray(coerceable) && typeof coerceable === "object") {
    const runnables = {};
    for (const [key, value] of Object.entries(coerceable))
      runnables[key] = _coerceToRunnable(value);
    return new RunnableMap({ steps: runnables });
  } else
    throw new Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
}
var RunnableAssign = class extends Runnable {
  static lc_name() {
    return "RunnableAssign";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = true;
  mapper;
  constructor(fields) {
    if (fields instanceof RunnableMap)
      fields = { mapper: fields };
    super(fields);
    this.mapper = fields.mapper;
  }
  async invoke(input, options) {
    const mapperResult = await this.mapper.invoke(input, options);
    return {
      ...input,
      ...mapperResult
    };
  }
  async* _transform(generator, runManager, options) {
    const mapperKeys = this.mapper.getStepsKeys();
    const [forPassthrough, forMapper] = atee(generator);
    const mapperOutput = this.mapper.transform(forMapper, patchConfig(options, { callbacks: runManager?.getChild() }));
    const firstMapperChunkPromise = mapperOutput.next();
    for await (const chunk of forPassthrough) {
      if (typeof chunk !== "object" || Array.isArray(chunk))
        throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);
      const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));
      if (Object.keys(filtered).length > 0)
        yield filtered;
    }
    yield (await firstMapperChunkPromise).value;
    for await (const chunk of mapperOutput)
      yield chunk;
  }
  transform(generator, options) {
    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
  }
  async stream(input, options) {
    async function* generator() {
      yield input;
    }
    const config2 = ensureConfig(options);
    const wrappedGenerator = new AsyncGeneratorWithSetup({
      generator: this.transform(generator(), config2),
      config: config2
    });
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
};
var RunnablePick = class extends Runnable {
  static lc_name() {
    return "RunnablePick";
  }
  lc_namespace = ["langchain_core", "runnables"];
  lc_serializable = true;
  keys;
  constructor(fields) {
    if (typeof fields === "string" || Array.isArray(fields))
      fields = { keys: fields };
    super(fields);
    this.keys = fields.keys;
  }
  async _pick(input) {
    if (typeof this.keys === "string")
      return input[this.keys];
    else {
      const picked = this.keys.map((key) => [key, input[key]]).filter((v) => v[1] !== undefined);
      return picked.length === 0 ? undefined : Object.fromEntries(picked);
    }
  }
  async invoke(input, options) {
    return this._callWithConfig(this._pick.bind(this), input, options);
  }
  async* _transform(generator) {
    for await (const chunk of generator) {
      const picked = await this._pick(chunk);
      if (picked !== undefined)
        yield picked;
    }
  }
  transform(generator, options) {
    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
  }
  async stream(input, options) {
    async function* generator() {
      yield input;
    }
    const config2 = ensureConfig(options);
    const wrappedGenerator = new AsyncGeneratorWithSetup({
      generator: this.transform(generator(), config2),
      config: config2
    });
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
};
var RunnableToolLike = class extends RunnableBinding {
  name;
  description;
  schema;
  constructor(fields) {
    const sequence = RunnableSequence.from([RunnableLambda.from(async (input) => {
      let toolInput;
      if (_isToolCall(input))
        try {
          toolInput = await interopParseAsync(this.schema, input.args);
        } catch {
          throw new ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(input.args));
        }
      else
        toolInput = input;
      return toolInput;
    }).withConfig({ runName: `${fields.name}:parse_input` }), fields.bound]).withConfig({ runName: fields.name });
    super({
      bound: sequence,
      config: fields.config ?? {}
    });
    this.name = fields.name;
    this.description = fields.description;
    this.schema = fields.schema;
  }
  static lc_name() {
    return "RunnableToolLike";
  }
};
function convertRunnableToTool(runnable, fields) {
  const name = fields.name ?? runnable.getName();
  const description = fields.description ?? getSchemaDescription(fields.schema);
  if (isSimpleStringZodSchema(fields.schema))
    return new RunnableToolLike({
      name,
      description,
      schema: exports_external.object({ input: exports_external.string() }).transform((input) => input.input),
      bound: runnable
    });
  return new RunnableToolLike({
    name,
    description,
    schema: fields.schema,
    bound: runnable
  });
}

// node_modules/@langchain/core/dist/documents/transformers.js
var BaseDocumentTransformer = class extends Runnable {
  lc_namespace = [
    "langchain_core",
    "documents",
    "transformers"
  ];
  invoke(input, _options) {
    return this.transformDocuments(input);
  }
};
var MappingDocumentTransformer = class extends BaseDocumentTransformer {
  async transformDocuments(documents) {
    const newDocuments = [];
    for (const document2 of documents) {
      const transformedDocument = await this._transformDocument(document2);
      newDocuments.push(transformedDocument);
    }
    return newDocuments;
  }
};

// node_modules/@langchain/core/dist/documents/index.js
var documents_exports = {};
__export2(documents_exports, {
  BaseDocumentTransformer: () => BaseDocumentTransformer,
  Document: () => Document,
  MappingDocumentTransformer: () => MappingDocumentTransformer
});

// node_modules/js-tiktoken/dist/chunk-VL2OQCWN.js
var import_base64_js = __toESM(require_base64_js(), 1);
var __defProp3 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function bytePairMerge(piece, ranks) {
  let parts = Array.from({ length: piece.length }, (_, i) => ({ start: i, end: i + 1 }));
  while (parts.length > 1) {
    let minRank = null;
    for (let i = 0;i < parts.length - 1; i++) {
      const slice = piece.slice(parts[i].start, parts[i + 1].end);
      const rank = ranks.get(slice.join(","));
      if (rank == null)
        continue;
      if (minRank == null || rank < minRank[0]) {
        minRank = [rank, i];
      }
    }
    if (minRank != null) {
      const i = minRank[1];
      parts[i] = { start: parts[i].start, end: parts[i + 1].end };
      parts.splice(i + 1, 1);
    } else {
      break;
    }
  }
  return parts;
}
function bytePairEncode(piece, ranks) {
  if (piece.length === 1)
    return [ranks.get(piece.join(","))];
  return bytePairMerge(piece, ranks).map((p) => ranks.get(piece.slice(p.start, p.end).join(","))).filter((x) => x != null);
}
function escapeRegex2(str) {
  return str.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
var _Tiktoken = class {
  specialTokens;
  inverseSpecialTokens;
  patStr;
  textEncoder = new TextEncoder;
  textDecoder = new TextDecoder("utf-8");
  rankMap = /* @__PURE__ */ new Map;
  textMap = /* @__PURE__ */ new Map;
  constructor(ranks, extendedSpecialTokens) {
    this.patStr = ranks.pat_str;
    const uncompressed = ranks.bpe_ranks.split(`
`).filter(Boolean).reduce((memo, x) => {
      const [_, offsetStr, ...tokens] = x.split(" ");
      const offset = Number.parseInt(offsetStr, 10);
      tokens.forEach((token, i) => memo[token] = offset + i);
      return memo;
    }, {});
    for (const [token, rank] of Object.entries(uncompressed)) {
      const bytes = import_base64_js.default.toByteArray(token);
      this.rankMap.set(bytes.join(","), rank);
      this.textMap.set(rank, bytes);
    }
    this.specialTokens = { ...ranks.special_tokens, ...extendedSpecialTokens };
    this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((memo, [text, rank]) => {
      memo[rank] = this.textEncoder.encode(text);
      return memo;
    }, {});
  }
  encode(text, allowedSpecial = [], disallowedSpecial = "all") {
    const regexes = new RegExp(this.patStr, "ug");
    const specialRegex = _Tiktoken.specialTokenRegex(Object.keys(this.specialTokens));
    const ret = [];
    const allowedSpecialSet = new Set(allowedSpecial === "all" ? Object.keys(this.specialTokens) : allowedSpecial);
    const disallowedSpecialSet = new Set(disallowedSpecial === "all" ? Object.keys(this.specialTokens).filter((x) => !allowedSpecialSet.has(x)) : disallowedSpecial);
    if (disallowedSpecialSet.size > 0) {
      const disallowedSpecialRegex = _Tiktoken.specialTokenRegex([
        ...disallowedSpecialSet
      ]);
      const specialMatch = text.match(disallowedSpecialRegex);
      if (specialMatch != null) {
        throw new Error(`The text contains a special token that is not allowed: ${specialMatch[0]}`);
      }
    }
    let start = 0;
    while (true) {
      let nextSpecial = null;
      let startFind = start;
      while (true) {
        specialRegex.lastIndex = startFind;
        nextSpecial = specialRegex.exec(text);
        if (nextSpecial == null || allowedSpecialSet.has(nextSpecial[0]))
          break;
        startFind = nextSpecial.index + 1;
      }
      const end = nextSpecial?.index ?? text.length;
      for (const match of text.substring(start, end).matchAll(regexes)) {
        const piece = this.textEncoder.encode(match[0]);
        const token2 = this.rankMap.get(piece.join(","));
        if (token2 != null) {
          ret.push(token2);
          continue;
        }
        ret.push(...bytePairEncode(piece, this.rankMap));
      }
      if (nextSpecial == null)
        break;
      let token = this.specialTokens[nextSpecial[0]];
      ret.push(token);
      start = nextSpecial.index + nextSpecial[0].length;
    }
    return ret;
  }
  decode(tokens) {
    const res = [];
    let length = 0;
    for (let i2 = 0;i2 < tokens.length; ++i2) {
      const token = tokens[i2];
      const bytes = this.textMap.get(token) ?? this.inverseSpecialTokens[token];
      if (bytes != null) {
        res.push(bytes);
        length += bytes.length;
      }
    }
    const mergedArray = new Uint8Array(length);
    let i = 0;
    for (const bytes of res) {
      mergedArray.set(bytes, i);
      i += bytes.length;
    }
    return this.textDecoder.decode(mergedArray);
  }
};
var Tiktoken = _Tiktoken;
__publicField(Tiktoken, "specialTokenRegex", (tokens) => {
  return new RegExp(tokens.map((i) => escapeRegex2(i)).join("|"), "g");
});
function getEncodingNameForModel(model) {
  switch (model) {
    case "gpt2": {
      return "gpt2";
    }
    case "code-cushman-001":
    case "code-cushman-002":
    case "code-davinci-001":
    case "code-davinci-002":
    case "cushman-codex":
    case "davinci-codex":
    case "davinci-002":
    case "text-davinci-002":
    case "text-davinci-003": {
      return "p50k_base";
    }
    case "code-davinci-edit-001":
    case "text-davinci-edit-001": {
      return "p50k_edit";
    }
    case "ada":
    case "babbage":
    case "babbage-002":
    case "code-search-ada-code-001":
    case "code-search-babbage-code-001":
    case "curie":
    case "davinci":
    case "text-ada-001":
    case "text-babbage-001":
    case "text-curie-001":
    case "text-davinci-001":
    case "text-search-ada-doc-001":
    case "text-search-babbage-doc-001":
    case "text-search-curie-doc-001":
    case "text-search-davinci-doc-001":
    case "text-similarity-ada-001":
    case "text-similarity-babbage-001":
    case "text-similarity-curie-001":
    case "text-similarity-davinci-001": {
      return "r50k_base";
    }
    case "gpt-3.5-turbo-instruct-0914":
    case "gpt-3.5-turbo-instruct":
    case "gpt-3.5-turbo-16k-0613":
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo":
    case "gpt-4-32k-0613":
    case "gpt-4-32k-0314":
    case "gpt-4-32k":
    case "gpt-4-0613":
    case "gpt-4-0314":
    case "gpt-4":
    case "gpt-3.5-turbo-1106":
    case "gpt-35-turbo":
    case "gpt-4-1106-preview":
    case "gpt-4-vision-preview":
    case "gpt-3.5-turbo-0125":
    case "gpt-4-turbo":
    case "gpt-4-turbo-2024-04-09":
    case "gpt-4-turbo-preview":
    case "gpt-4-0125-preview":
    case "text-embedding-ada-002":
    case "text-embedding-3-small":
    case "text-embedding-3-large": {
      return "cl100k_base";
    }
    case "gpt-4o":
    case "gpt-4o-2024-05-13":
    case "gpt-4o-2024-08-06":
    case "gpt-4o-2024-11-20":
    case "gpt-4o-mini-2024-07-18":
    case "gpt-4o-mini":
    case "gpt-4o-search-preview":
    case "gpt-4o-search-preview-2025-03-11":
    case "gpt-4o-mini-search-preview":
    case "gpt-4o-mini-search-preview-2025-03-11":
    case "gpt-4o-audio-preview":
    case "gpt-4o-audio-preview-2024-12-17":
    case "gpt-4o-audio-preview-2024-10-01":
    case "gpt-4o-mini-audio-preview":
    case "gpt-4o-mini-audio-preview-2024-12-17":
    case "o1":
    case "o1-2024-12-17":
    case "o1-mini":
    case "o1-mini-2024-09-12":
    case "o1-preview":
    case "o1-preview-2024-09-12":
    case "o1-pro":
    case "o1-pro-2025-03-19":
    case "o3":
    case "o3-2025-04-16":
    case "o3-mini":
    case "o3-mini-2025-01-31":
    case "o4-mini":
    case "o4-mini-2025-04-16":
    case "chatgpt-4o-latest":
    case "gpt-4o-realtime":
    case "gpt-4o-realtime-preview-2024-10-01":
    case "gpt-4o-realtime-preview-2024-12-17":
    case "gpt-4o-mini-realtime-preview":
    case "gpt-4o-mini-realtime-preview-2024-12-17":
    case "gpt-4.1":
    case "gpt-4.1-2025-04-14":
    case "gpt-4.1-mini":
    case "gpt-4.1-mini-2025-04-14":
    case "gpt-4.1-nano":
    case "gpt-4.1-nano-2025-04-14":
    case "gpt-4.5-preview":
    case "gpt-4.5-preview-2025-02-27":
    case "gpt-5":
    case "gpt-5-2025-08-07":
    case "gpt-5-nano":
    case "gpt-5-nano-2025-08-07":
    case "gpt-5-mini":
    case "gpt-5-mini-2025-08-07":
    case "gpt-5-chat-latest": {
      return "o200k_base";
    }
    default:
      throw new Error("Unknown model");
  }
}
// node_modules/@langchain/core/dist/utils/tiktoken.js
var tiktoken_exports = {};
__export2(tiktoken_exports, {
  encodingForModel: () => encodingForModel,
  getEncoding: () => getEncoding
});
var cache = {};
var caller = /* @__PURE__ */ new AsyncCaller2({});
async function getEncoding(encoding) {
  if (!(encoding in cache))
    cache[encoding] = caller.fetch(`https://tiktoken.pages.dev/js/${encoding}.json`).then((res) => res.json()).then((data) => new Tiktoken(data)).catch((e) => {
      delete cache[encoding];
      throw e;
    });
  return await cache[encoding];
}
async function encodingForModel(model) {
  return getEncoding(getEncodingNameForModel(model));
}

// node_modules/@langchain/textsplitters/dist/text_splitter.js
var TextSplitter = class extends BaseDocumentTransformer {
  lc_namespace = [
    "langchain",
    "document_transformers",
    "text_splitters"
  ];
  chunkSize = 1000;
  chunkOverlap = 200;
  keepSeparator = false;
  lengthFunction;
  constructor(fields) {
    super(fields);
    this.chunkSize = fields?.chunkSize ?? this.chunkSize;
    this.chunkOverlap = fields?.chunkOverlap ?? this.chunkOverlap;
    this.keepSeparator = fields?.keepSeparator ?? this.keepSeparator;
    this.lengthFunction = fields?.lengthFunction ?? ((text) => text.length);
    if (this.chunkOverlap >= this.chunkSize)
      throw new Error("Cannot have chunkOverlap >= chunkSize");
  }
  async transformDocuments(documents, chunkHeaderOptions = {}) {
    return this.splitDocuments(documents, chunkHeaderOptions);
  }
  splitOnSeparator(text, separator) {
    let splits;
    if (separator)
      if (this.keepSeparator) {
        const regexEscapedSeparator = separator.replace(/[/\-\\^$*+?.()|[\]{}]/g, "\\$&");
        splits = text.split(/* @__PURE__ */ new RegExp(`(?=${regexEscapedSeparator})`));
      } else
        splits = text.split(separator);
    else
      splits = text.split("");
    return splits.filter((s) => s !== "");
  }
  async createDocuments(texts, metadatas = [], chunkHeaderOptions = {}) {
    const _metadatas = metadatas.length > 0 ? metadatas : [...Array(texts.length)].map(() => ({}));
    const { chunkHeader = "", chunkOverlapHeader = "(cont'd) ", appendChunkOverlapHeader = false } = chunkHeaderOptions;
    const documents = new Array;
    for (let i = 0;i < texts.length; i += 1) {
      const text = texts[i];
      let lineCounterIndex = 1;
      let prevChunk = null;
      let indexPrevChunk = -1;
      for (const chunk of await this.splitText(text)) {
        let pageContent = chunkHeader;
        const indexChunk = text.indexOf(chunk, indexPrevChunk + 1);
        if (prevChunk === null) {
          const newLinesBeforeFirstChunk = this.numberOfNewLines(text, 0, indexChunk);
          lineCounterIndex += newLinesBeforeFirstChunk;
        } else {
          const indexEndPrevChunk = indexPrevChunk + await this.lengthFunction(prevChunk);
          if (indexEndPrevChunk < indexChunk) {
            const numberOfIntermediateNewLines = this.numberOfNewLines(text, indexEndPrevChunk, indexChunk);
            lineCounterIndex += numberOfIntermediateNewLines;
          } else if (indexEndPrevChunk > indexChunk) {
            const numberOfIntermediateNewLines = this.numberOfNewLines(text, indexChunk, indexEndPrevChunk);
            lineCounterIndex -= numberOfIntermediateNewLines;
          }
          if (appendChunkOverlapHeader)
            pageContent += chunkOverlapHeader;
        }
        const newLinesCount = this.numberOfNewLines(chunk);
        const loc = _metadatas[i].loc && typeof _metadatas[i].loc === "object" ? { ..._metadatas[i].loc } : {};
        loc.lines = {
          from: lineCounterIndex,
          to: lineCounterIndex + newLinesCount
        };
        const metadataWithLinesNumber = {
          ..._metadatas[i],
          loc
        };
        pageContent += chunk;
        documents.push(new Document({
          pageContent,
          metadata: metadataWithLinesNumber
        }));
        lineCounterIndex += newLinesCount;
        prevChunk = chunk;
        indexPrevChunk = indexChunk;
      }
    }
    return documents;
  }
  numberOfNewLines(text, start, end) {
    const textSection = text.slice(start, end);
    return (textSection.match(/\n/g) || []).length;
  }
  async splitDocuments(documents, chunkHeaderOptions = {}) {
    const selectedDocuments = documents.filter((doc2) => doc2.pageContent !== undefined);
    const texts = selectedDocuments.map((doc2) => doc2.pageContent);
    const metadatas = selectedDocuments.map((doc2) => doc2.metadata);
    return this.createDocuments(texts, metadatas, chunkHeaderOptions);
  }
  joinDocs(docs, separator) {
    const text = docs.join(separator).trim();
    return text === "" ? null : text;
  }
  async mergeSplits(splits, separator) {
    const docs = [];
    const currentDoc = [];
    let total = 0;
    for (const d of splits) {
      const _len = await this.lengthFunction(d);
      if (total + _len + currentDoc.length * separator.length > this.chunkSize) {
        if (total > this.chunkSize)
          console.warn(`Created a chunk of size ${total}, +
which is longer than the specified ${this.chunkSize}`);
        if (currentDoc.length > 0) {
          const doc$1 = this.joinDocs(currentDoc, separator);
          if (doc$1 !== null)
            docs.push(doc$1);
          while (total > this.chunkOverlap || total + _len + currentDoc.length * separator.length > this.chunkSize && total > 0) {
            total -= await this.lengthFunction(currentDoc[0]);
            currentDoc.shift();
          }
        }
      }
      currentDoc.push(d);
      total += _len;
    }
    const doc2 = this.joinDocs(currentDoc, separator);
    if (doc2 !== null)
      docs.push(doc2);
    return docs;
  }
};
var RecursiveCharacterTextSplitter = class RecursiveCharacterTextSplitter2 extends TextSplitter {
  static lc_name() {
    return "RecursiveCharacterTextSplitter";
  }
  separators = [
    `

`,
    `
`,
    " ",
    ""
  ];
  constructor(fields) {
    super(fields);
    this.separators = fields?.separators ?? this.separators;
    this.keepSeparator = fields?.keepSeparator ?? true;
  }
  async _splitText(text, separators) {
    const finalChunks = [];
    let separator = separators[separators.length - 1];
    let newSeparators;
    for (let i = 0;i < separators.length; i += 1) {
      const s = separators[i];
      if (s === "") {
        separator = s;
        break;
      }
      if (text.includes(s)) {
        separator = s;
        newSeparators = separators.slice(i + 1);
        break;
      }
    }
    const splits = this.splitOnSeparator(text, separator);
    let goodSplits = [];
    const _separator = this.keepSeparator ? "" : separator;
    for (const s of splits)
      if (await this.lengthFunction(s) < this.chunkSize)
        goodSplits.push(s);
      else {
        if (goodSplits.length) {
          const mergedText = await this.mergeSplits(goodSplits, _separator);
          finalChunks.push(...mergedText);
          goodSplits = [];
        }
        if (!newSeparators)
          finalChunks.push(s);
        else {
          const otherInfo = await this._splitText(s, newSeparators);
          finalChunks.push(...otherInfo);
        }
      }
    if (goodSplits.length) {
      const mergedText = await this.mergeSplits(goodSplits, _separator);
      finalChunks.push(...mergedText);
    }
    return finalChunks;
  }
  async splitText(text) {
    return this._splitText(text, this.separators);
  }
  static fromLanguage(language, options) {
    return new RecursiveCharacterTextSplitter2({
      ...options,
      separators: RecursiveCharacterTextSplitter2.getSeparatorsForLanguage(language)
    });
  }
  static getSeparatorsForLanguage(language) {
    if (language === "cpp")
      return [
        `
class `,
        `
void `,
        `
int `,
        `
float `,
        `
double `,
        `
if `,
        `
for `,
        `
while `,
        `
switch `,
        `
case `,
        `

`,
        `
`,
        " ",
        ""
      ];
    else if (language === "go")
      return [
        `
func `,
        `
var `,
        `
const `,
        `
type `,
        `
if `,
        `
for `,
        `
switch `,
        `
case `,
        `

`,
        `
`,
        " ",
        ""
      ];
    else if (language === "java")
      return [
        `
class `,
        `
public `,
        `
protected `,
        `
private `,
        `
static `,
        `
if `,
        `
for `,
        `
while `,
        `
switch `,
        `
case `,
        `

`,
        `
`,
        " ",
        ""
      ];
    else if (language === "js")
      return [
        `
function `,
        `
const `,
        `
let `,
        `
var `,
        `
class `,
        `
if `,
        `
for `,
        `
while `,
        `
switch `,
        `
case `,
        `
default `,
        `

`,
        `
`,
        " ",
        ""
      ];
    else if (language === "php")
      return [
        `
function `,
        `
class `,
        `
if `,
        `
foreach `,
        `
while `,
        `
do `,
        `
switch `,
        `
case `,
        `

`,
        `
`,
        " ",
        ""
      ];
    else if (language === "proto")
      return [
        `
message `,
        `
service `,
        `
enum `,
        `
option `,
        `
import `,
        `
syntax `,
        `

`,
        `
`,
        " ",
        ""
      ];
    else if (language === "python")
      return [
        `
class `,
        `
def `,
        `
	def `,
        `

`,
        `
`,
        " ",
        ""
      ];
    else if (language === "rst")
      return [
        `
===
`,
        `
---
`,
        `
***
`,
        `
.. `,
        `

`,
        `
`,
        " ",
        ""
      ];
    else if (language === "ruby")
      return [
        `
def `,
        `
class `,
        `
if `,
        `
unless `,
        `
while `,
        `
for `,
        `
do `,
        `
begin `,
        `
rescue `,
        `

`,
        `
`,
        " ",
        ""
      ];
    else if (language === "rust")
      return [
        `
fn `,
        `
const `,
        `
let `,
        `
if `,
        `
while `,
        `
for `,
        `
loop `,
        `
match `,
        `
const `,
        `

`,
        `
`,
        " ",
        ""
      ];
    else if (language === "scala")
      return [
        `
class `,
        `
object `,
        `
def `,
        `
val `,
        `
var `,
        `
if `,
        `
for `,
        `
while `,
        `
match `,
        `
case `,
        `

`,
        `
`,
        " ",
        ""
      ];
    else if (language === "swift")
      return [
        `
func `,
        `
class `,
        `
struct `,
        `
enum `,
        `
if `,
        `
for `,
        `
while `,
        `
do `,
        `
switch `,
        `
case `,
        `

`,
        `
`,
        " ",
        ""
      ];
    else if (language === "markdown")
      return [
        `
## `,
        `
### `,
        `
#### `,
        `
##### `,
        `
###### `,
        "```\n\n",
        `

***

`,
        `

---

`,
        `

___

`,
        `

`,
        `
`,
        " ",
        ""
      ];
    else if (language === "latex")
      return [
        `
\\chapter{`,
        `
\\section{`,
        `
\\subsection{`,
        `
\\subsubsection{`,
        `
\\begin{enumerate}`,
        `
\\begin{itemize}`,
        `
\\begin{description}`,
        `
\\begin{list}`,
        `
\\begin{quote}`,
        `
\\begin{quotation}`,
        `
\\begin{verse}`,
        `
\\begin{verbatim}`,
        `
\\begin{align}`,
        "$$",
        "$",
        `

`,
        `
`,
        " ",
        ""
      ];
    else if (language === "html")
      return [
        "<body>",
        "<div>",
        "<p>",
        "<br>",
        "<li>",
        "<h1>",
        "<h2>",
        "<h3>",
        "<h4>",
        "<h5>",
        "<h6>",
        "<span>",
        "<table>",
        "<tr>",
        "<td>",
        "<th>",
        "<ul>",
        "<ol>",
        "<header>",
        "<footer>",
        "<nav>",
        "<head>",
        "<style>",
        "<script>",
        "<meta>",
        "<title>",
        " ",
        ""
      ];
    else if (language === "sol")
      return [
        `
pragma `,
        `
using `,
        `
contract `,
        `
interface `,
        `
library `,
        `
constructor `,
        `
type `,
        `
function `,
        `
event `,
        `
modifier `,
        `
error `,
        `
struct `,
        `
enum `,
        `
if `,
        `
for `,
        `
while `,
        `
do while `,
        `
assembly `,
        `

`,
        `
`,
        " ",
        ""
      ];
    else
      throw new Error(`Language ${language} is not supported.`);
  }
};

// src/service/index.ts
var import_telegramify_markdown = __toESM(require_convert4(), 1);

class Service {
  bot;
  agentGroup;
  constructor(bot, agentGroup) {
    this.bot = bot;
    this.agentGroup = agentGroup;
  }
  async setup() {
    const ag = this.agentGroup;
    this.bot.setup(function(telegraf) {
      telegraf.command(["start", "help"], (ctx) => {
        console.log(ctx.message);
        return ctx.reply([
          "Send `/analyse <TICKER> [horizon]` to generate a research report.",
          "",
          "Examples:",
          "- `/analyse AAPL`",
          "- `/analyse BRK.B`"
        ].join(`
`));
      });
      telegraf.command("analyse", async (ctx) => {
        if (!ctx.text)
          return ctx.reply("Please send a code to analyze");
        const [_, code] = ctx.text?.split(" ");
        if (!code)
          return ctx.reply("Please send a code to analyze");
        try {
          await ctx.reply(`Generating ${code} report...`);
          const report = await ag.run(`Analyze **${code}** to produce the "Short/Mid/Long-term Investment Analysis Report". Synthesize market sentiment and technical indicators to provide actionable strategies in Traditional Chinese.`, {
            stockCode: code
          });
          await ctx.reply(report.short_summary, { link_preview_options: { is_disabled: true } });
          const recursiveCharacterTextSplitter = new RecursiveCharacterTextSplitter({
            chunkSize: 4000,
            chunkOverlap: 0,
            separators: [
              `
## `,
              `
### `,
              `

`,
              `
`,
              " "
            ]
          });
          const outputDocs = await recursiveCharacterTextSplitter.createDocuments([report.markdown_report.replace(/^[\s\t]*[-*_]{3,}[\s\t]*$/gm, "")]);
          for (const doc2 of outputDocs) {
            await ctx.reply(import_telegramify_markdown.default(doc2.pageContent, "escape"), {
              parse_mode: "MarkdownV2",
              link_preview_options: { is_disabled: true }
            });
            await new Promise((resolve) => setTimeout(resolve, 500));
          }
        } catch (e) {
          console.error(e);
          if (e instanceof Error) {
            return ctx.reply(`got some error: ${e.message}`);
          }
          return ctx.reply(`got some error: ${e}`);
        }
      });
    });
  }
  async start() {
    await this.setup();
    console.log("Starting background worker...");
    await this.bot.start();
  }
  async stop(signal) {
    console.log(`[${signal}]Stopping background worker...`);
    await this.bot.stop();
    console.log("background worker stopped");
  }
}

// src/bot/index.ts
var import_telegraf = __toESM(require_lib3(), 1);

class TelegramBot {
  telegraf;
  constructor() {
    this.telegraf = new import_telegraf.Telegraf("8404879341:AAH7SfnKUkED5RopkcbSfQi_P-yKYCTen4s", {
      handlerTimeout: 60 * 60 * 1000
    });
  }
  async start() {
    await this.telegraf.launch(() => console.log("Bot started!"));
  }
  async send(chatId, message) {
    await this.telegraf.telegram.sendMessage(chatId, message, {
      parse_mode: "Markdown",
      link_preview_options: { is_disabled: true }
    });
  }
  stop() {
    return new Promise((resolve, reject) => {
      try {
        this.telegraf.stop();
        resolve(undefined);
      } catch (e) {
        reject(e);
      }
    });
  }
  setup(setupFunc) {
    setupFunc(this.telegraf);
  }
}

// node_modules/@openai/agents-core/dist/shims/shims-node.mjs
import * as process3 from "process";
import { EventEmitter } from "events";
import { randomUUID } from "crypto";
import { Readable } from "stream";
import { ReadableStream as ReadableStream2, TransformStream as TransformStream2 } from "stream/web";
import { AsyncLocalStorage } from "async_hooks";

// node_modules/@openai/agents-core/dist/shims/mcp-server/node.mjs
init_protocol();

// node_modules/@openai/agents-core/dist/utils/safeExecute.mjs
async function safeExecute(fn) {
  try {
    return [null, await fn()];
  } catch (error46) {
    return [error46, null];
  }
}

// node_modules/openai/helpers/zod.mjs
init_v4();

// node_modules/openai/internal/errors.mjs
function isAbortError(err) {
  return typeof err === "object" && err !== null && (("name" in err) && err.name === "AbortError" || ("message" in err) && String(err.message).includes("FetchRequestCanceledException"));
}
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      if (Object.prototype.toString.call(err) === "[object Error]") {
        const error46 = new Error(err.message, err.cause ? { cause: err.cause } : {});
        if (err.stack)
          error46.stack = err.stack;
        if (err.cause && !error46.cause)
          error46.cause = err.cause;
        if (err.name)
          error46.name = err.name;
        return error46;
      }
    } catch {}
    try {
      return new Error(JSON.stringify(err));
    } catch {}
  }
  return new Error(err);
};

// node_modules/openai/core/error.mjs
class OpenAIError extends Error {
}

class APIError extends OpenAIError {
  constructor(status, error46, message, headers) {
    super(`${APIError.makeMessage(status, error46, message)}`);
    this.status = status;
    this.headers = headers;
    this.requestID = headers?.get("x-request-id");
    this.error = error46;
    const data = error46;
    this.code = data?.["code"];
    this.param = data?.["param"];
    this.type = data?.["type"];
  }
  static makeMessage(status, error46, message) {
    const msg = error46?.message ? typeof error46.message === "string" ? error46.message : JSON.stringify(error46.message) : error46 ? JSON.stringify(error46) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error46 = errorResponse?.["error"];
    if (status === 400) {
      return new BadRequestError(status, error46, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error46, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error46, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error46, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error46, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error46, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error46, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error46, message, headers);
    }
    return new APIError(status, error46, message, headers);
  }
}

class APIUserAbortError extends APIError {
  constructor({ message } = {}) {
    super(undefined, undefined, message || "Request was aborted.", undefined);
  }
}

class APIConnectionError extends APIError {
  constructor({ message, cause }) {
    super(undefined, undefined, message || "Connection error.", undefined);
    if (cause)
      this.cause = cause;
  }
}

class APIConnectionTimeoutError extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
}

class BadRequestError extends APIError {
}

class AuthenticationError extends APIError {
}

class PermissionDeniedError extends APIError {
}

class NotFoundError extends APIError {
}

class ConflictError extends APIError {
}

class UnprocessableEntityError extends APIError {
}

class RateLimitError extends APIError {
}

class InternalServerError extends APIError {
}

class LengthFinishReasonError extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the length limit was reached`);
  }
}

class ContentFilterFinishReasonError extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the request was rejected by the content filter`);
  }
}

class InvalidWebhookSignatureError extends Error {
  constructor(message) {
    super(message);
  }
}
// node_modules/openai/lib/parser.mjs
function isChatCompletionFunctionTool(tool) {
  return tool !== undefined && "function" in tool && tool.function !== undefined;
}
function makeParseableTextFormat(response_format, parser) {
  const obj = { ...response_format };
  Object.defineProperties(obj, {
    $brand: {
      value: "auto-parseable-response-format",
      enumerable: false
    },
    $parseRaw: {
      value: parser,
      enumerable: false
    }
  });
  return obj;
}
function isAutoParsableResponseFormat(response_format) {
  return response_format?.["$brand"] === "auto-parseable-response-format";
}
function isAutoParsableTool(tool) {
  return tool?.["$brand"] === "auto-parseable-tool";
}
function maybeParseChatCompletion(completion, params) {
  if (!params || !hasAutoParseableInput(params)) {
    return {
      ...completion,
      choices: completion.choices.map((choice) => {
        assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
        return {
          ...choice,
          message: {
            ...choice.message,
            parsed: null,
            ...choice.message.tool_calls ? {
              tool_calls: choice.message.tool_calls
            } : undefined
          }
        };
      })
    };
  }
  return parseChatCompletion(completion, params);
}
function parseChatCompletion(completion, params) {
  const choices = completion.choices.map((choice) => {
    if (choice.finish_reason === "length") {
      throw new LengthFinishReasonError;
    }
    if (choice.finish_reason === "content_filter") {
      throw new ContentFilterFinishReasonError;
    }
    assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
    return {
      ...choice,
      message: {
        ...choice.message,
        ...choice.message.tool_calls ? {
          tool_calls: choice.message.tool_calls?.map((toolCall) => parseToolCall(params, toolCall)) ?? undefined
        } : undefined,
        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
      }
    };
  });
  return { ...completion, choices };
}
function parseResponseFormat(params, content) {
  if (params.response_format?.type !== "json_schema") {
    return null;
  }
  if (params.response_format?.type === "json_schema") {
    if ("$parseRaw" in params.response_format) {
      const response_format = params.response_format;
      return response_format.$parseRaw(content);
    }
    return JSON.parse(content);
  }
  return null;
}
function parseToolCall(params, toolCall) {
  const inputTool = params.tools?.find((inputTool2) => isChatCompletionFunctionTool(inputTool2) && inputTool2.function?.name === toolCall.function.name);
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments) : null
    }
  };
}
function shouldParseToolCall(params, toolCall) {
  if (!params || !("tools" in params) || !params.tools) {
    return false;
  }
  const inputTool = params.tools?.find((inputTool2) => isChatCompletionFunctionTool(inputTool2) && inputTool2.function?.name === toolCall.function.name);
  return isChatCompletionFunctionTool(inputTool) && (isAutoParsableTool(inputTool) || inputTool?.function.strict || false);
}
function hasAutoParseableInput(params) {
  if (isAutoParsableResponseFormat(params.response_format)) {
    return true;
  }
  return params.tools?.some((t) => isAutoParsableTool(t) || t.type === "function" && t.function.strict === true) ?? false;
}
function assertToolCallsAreChatCompletionFunctionToolCalls(toolCalls) {
  for (const toolCall of toolCalls || []) {
    if (toolCall.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool calls are supported; Received \`${toolCall.type}\``);
    }
  }
}
function validateInputTools(tools) {
  for (const tool of tools ?? []) {
    if (tool.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
    }
    if (tool.function.strict !== true) {
      throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
    }
  }
}

// node_modules/openai/_vendor/zod-to-json-schema/Options.mjs
var ignoreOverride3 = Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions3 = {
  name: undefined,
  $refStrategy: "root",
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  nullableStrategy: "from-target",
  removeAdditionalStrategy: "passthrough",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions3 = (options) => {
  return typeof options === "string" ? {
    ...defaultOptions3,
    basePath: ["#"],
    definitions: {},
    name: options
  } : {
    ...defaultOptions3,
    basePath: ["#"],
    definitions: {},
    ...options
  };
};
// node_modules/openai/_vendor/zod-to-json-schema/util.mjs
var zodDef = (zodSchema) => {
  return "_def" in zodSchema ? zodSchema._def : zodSchema;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}

// node_modules/openai/_vendor/zod-to-json-schema/Refs.mjs
var getRefs3 = (options) => {
  const _options = getDefaultOptions3(options);
  const currentPath = _options.name !== undefined ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: undefined,
    seenRefs: new Set,
    seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
      zodDef(def),
      {
        def: zodDef(def),
        path: [..._options.basePath, _options.definitionPath, name],
        jsonSchema: undefined
      }
    ]))
  };
};
// node_modules/openai/_vendor/zod-to-json-schema/errorMessages.mjs
function addErrorMessage3(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors3(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage3(res, key, errorMessage, refs);
}
// node_modules/openai/_vendor/zod-to-json-schema/parseDef.mjs
init_v3();

// node_modules/openai/_vendor/zod-to-json-schema/parsers/any.mjs
function parseAnyDef3() {
  return {};
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/array.mjs
init_v3();
function parseArrayDef3(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef4(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors3(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors3(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors3(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors3(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/bigint.mjs
function parseBigintDef3(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors3(res, "minimum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors3(res, "exclusiveMinimum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors3(res, "minimum", check2.value, check2.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors3(res, "maximum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors3(res, "exclusiveMaximum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors3(res, "maximum", check2.value, check2.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors3(res, "multipleOf", check2.value, check2.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/boolean.mjs
function parseBooleanDef3() {
  return {
    type: "boolean"
  };
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/branded.mjs
function parseBrandedDef3(_def, refs) {
  return parseDef4(_def.type._def, refs);
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/catch.mjs
var parseCatchDef3 = (def, refs) => {
  return parseDef4(def.innerType._def, refs);
};

// node_modules/openai/_vendor/zod-to-json-schema/parsers/date.mjs
function parseDateDef3(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef3(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser2(def, refs);
  }
}
var integerDateParser2 = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "min":
        setResponseValueAndErrors3(res, "minimum", check2.value, check2.message, refs);
        break;
      case "max":
        setResponseValueAndErrors3(res, "maximum", check2.value, check2.message, refs);
        break;
    }
  }
  return res;
};

// node_modules/openai/_vendor/zod-to-json-schema/parsers/default.mjs
function parseDefaultDef3(_def, refs) {
  return {
    ...parseDef4(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/effects.mjs
function parseEffectsDef3(_def, refs, forceResolution) {
  return refs.effectStrategy === "input" ? parseDef4(_def.schema._def, refs, forceResolution) : {};
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/enum.mjs
function parseEnumDef3(def) {
  return {
    type: "string",
    enum: [...def.values]
  };
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/intersection.mjs
var isJsonSchema7AllOfType2 = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef3(def, refs) {
  const allOf = [
    parseDef4(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef4(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : undefined;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType2(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === undefined) {
        unevaluatedProperties = undefined;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = undefined;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : undefined;
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/literal.mjs
function parseLiteralDef3(def, refs) {
  const parsedType8 = typeof def.value;
  if (parsedType8 !== "bigint" && parsedType8 !== "number" && parsedType8 !== "boolean" && parsedType8 !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType8 === "bigint" ? "integer" : parsedType8,
      enum: [def.value]
    };
  }
  return {
    type: parsedType8 === "bigint" ? "integer" : parsedType8,
    const: def.value
  };
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/record.mjs
init_v3();

// node_modules/openai/_vendor/zod-to-json-schema/parsers/string.mjs
var emojiRegex3;
var zodPatterns2 = {
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  emoji: () => {
    if (emojiRegex3 === undefined) {
      emojiRegex3 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex3;
  },
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/
};
function parseStringDef3(def, refs) {
  const res = {
    type: "string"
  };
  function processPattern(value) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric2(value) : value;
  }
  if (def.checks) {
    for (const check2 of def.checks) {
      switch (check2.kind) {
        case "min":
          setResponseValueAndErrors3(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value, check2.message, refs);
          break;
        case "max":
          setResponseValueAndErrors3(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value, check2.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat2(res, "email", check2.message, refs);
              break;
            case "format:idn-email":
              addFormat2(res, "idn-email", check2.message, refs);
              break;
            case "pattern:zod":
              addPattern2(res, zodPatterns2.email, check2.message, refs);
              break;
          }
          break;
        case "url":
          addFormat2(res, "uri", check2.message, refs);
          break;
        case "uuid":
          addFormat2(res, "uuid", check2.message, refs);
          break;
        case "regex":
          addPattern2(res, check2.regex, check2.message, refs);
          break;
        case "cuid":
          addPattern2(res, zodPatterns2.cuid, check2.message, refs);
          break;
        case "cuid2":
          addPattern2(res, zodPatterns2.cuid2, check2.message, refs);
          break;
        case "startsWith":
          addPattern2(res, RegExp(`^${processPattern(check2.value)}`), check2.message, refs);
          break;
        case "endsWith":
          addPattern2(res, RegExp(`${processPattern(check2.value)}$`), check2.message, refs);
          break;
        case "datetime":
          addFormat2(res, "date-time", check2.message, refs);
          break;
        case "date":
          addFormat2(res, "date", check2.message, refs);
          break;
        case "time":
          addFormat2(res, "time", check2.message, refs);
          break;
        case "duration":
          addFormat2(res, "duration", check2.message, refs);
          break;
        case "length":
          setResponseValueAndErrors3(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value, check2.message, refs);
          setResponseValueAndErrors3(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value, check2.message, refs);
          break;
        case "includes": {
          addPattern2(res, RegExp(processPattern(check2.value)), check2.message, refs);
          break;
        }
        case "ip": {
          if (check2.version !== "v6") {
            addFormat2(res, "ipv4", check2.message, refs);
          }
          if (check2.version !== "v4") {
            addFormat2(res, "ipv6", check2.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern2(res, zodPatterns2.emoji, check2.message, refs);
          break;
        case "ulid": {
          addPattern2(res, zodPatterns2.ulid, check2.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat2(res, "binary", check2.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors3(res, "contentEncoding", "base64", check2.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern2(res, zodPatterns2.base64, check2.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern2(res, zodPatterns2.nanoid, check2.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          ((_) => {})(check2);
      }
    }
  }
  return res;
}
var escapeNonAlphaNumeric2 = (value) => Array.from(value).map((c) => /[a-zA-Z0-9]/.test(c) ? c : `\\${c}`).join("");
var addFormat2 = (schema, value, message, refs) => {
  if (schema.format || schema.anyOf?.some((x) => x.format)) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors3(schema, "format", value, message, refs);
  }
};
var addPattern2 = (schema, regex2, message, refs) => {
  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: processRegExp(regex2, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors3(schema, "pattern", processRegExp(regex2, refs), message, refs);
  }
};
var processRegExp = (regexOrFunction, refs) => {
  const regex2 = typeof regexOrFunction === "function" ? regexOrFunction() : regexOrFunction;
  if (!refs.applyRegexFlags || !regex2.flags)
    return regex2.source;
  const flags = {
    i: regex2.flags.includes("i"),
    m: regex2.flags.includes("m"),
    s: regex2.flags.includes("s")
  };
  const source = flags.i ? regex2.source.toLowerCase() : regex2.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0;i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    const regexTest = new RegExp(pattern);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex2.source;
  }
  return pattern;
};

// node_modules/openai/_vendor/zod-to-json-schema/parsers/record.mjs
function parseRecordDef3(def, refs) {
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef4(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? {}
      }), {}),
      additionalProperties: false
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef4(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const keyType = Object.entries(parseStringDef3(def.keyType._def, refs)).reduce((acc, [key, value]) => key === "type" ? acc : { ...acc, [key]: value }, {});
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  }
  return schema;
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/map.mjs
function parseMapDef3(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef3(def, refs);
  }
  const keys = parseDef4(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || {};
  const values = parseDef4(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/nativeEnum.mjs
function parseNativeEnumDef3(def) {
  const object4 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object4[object4[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object4[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/never.mjs
function parseNeverDef3() {
  return {
    not: {}
  };
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/null.mjs
function parseNullDef3(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/union.mjs
var primitiveMappings3 = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef3(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf2(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => (x._def.typeName in primitiveMappings3) && (!x._def.checks || !x._def.checks.length))) {
    const types2 = options.reduce((types3, x) => {
      const type = primitiveMappings3[x._def.typeName];
      return type && !types3.includes(type) ? [...types3, type] : types3;
    }, []);
    return {
      type: types2.length > 1 ? types2 : types2[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types2 = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types2.length === options.length) {
      const uniqueTypes = types2.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [...acc, ...x._def.values.filter((x2) => !acc.includes(x2))], [])
    };
  }
  return asAnyOf2(def, refs);
}
var asAnyOf2 = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef4(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : undefined;
};

// node_modules/openai/_vendor/zod-to-json-schema/parsers/nullable.mjs
function parseNullableDef3(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3" || refs.nullableStrategy === "property") {
      return {
        type: primitiveMappings3[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [primitiveMappings3[def.innerType._def.typeName], "null"]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef4(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef4(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/number.mjs
function parseNumberDef3(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage3(res, "type", check2.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors3(res, "minimum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors3(res, "exclusiveMinimum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors3(res, "minimum", check2.value, check2.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors3(res, "maximum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors3(res, "exclusiveMaximum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors3(res, "maximum", check2.value, check2.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors3(res, "multipleOf", check2.value, check2.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/object.mjs
function decideAdditionalProperties2(def, refs) {
  if (refs.removeAdditionalStrategy === "strict") {
    return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys !== "strict" : parseDef4(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? true;
  } else {
    return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : parseDef4(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? true;
  }
}
function parseObjectDef3(def, refs) {
  const result = {
    type: "object",
    ...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {
      if (propDef === undefined || propDef._def === undefined)
        return acc;
      const propertyPath = [...refs.currentPath, "properties", propName];
      const parsedDef = parseDef4(propDef._def, {
        ...refs,
        currentPath: propertyPath,
        propertyPath
      });
      if (parsedDef === undefined)
        return acc;
      if (refs.openaiStrictMode && propDef.isOptional() && !propDef.isNullable() && typeof propDef._def?.defaultValue === "undefined") {
        throw new Error(`Zod field at \`${propertyPath.join("/")}\` uses \`.optional()\` without \`.nullable()\` which is not supported by the API. See: https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses#all-fields-must-be-required`);
      }
      return {
        properties: {
          ...acc.properties,
          [propName]: parsedDef
        },
        required: propDef.isOptional() && !refs.openaiStrictMode ? acc.required : [...acc.required, propName]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: decideAdditionalProperties2(def, refs)
  };
  if (!result.required.length)
    delete result.required;
  return result;
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/optional.mjs
var parseOptionalDef3 = (def, refs) => {
  if (refs.propertyPath && refs.currentPath.slice(0, refs.propertyPath.length).toString() === refs.propertyPath.toString()) {
    return parseDef4(def.innerType._def, { ...refs, currentPath: refs.currentPath });
  }
  const innerSchema = parseDef4(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: {}
      },
      innerSchema
    ]
  } : {};
};

// node_modules/openai/_vendor/zod-to-json-schema/parsers/pipeline.mjs
var parsePipelineDef3 = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef4(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef4(def.out._def, refs);
  }
  const a = parseDef4(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef4(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== undefined)
  };
};

// node_modules/openai/_vendor/zod-to-json-schema/parsers/promise.mjs
function parsePromiseDef3(def, refs) {
  return parseDef4(def.type._def, refs);
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/set.mjs
function parseSetDef3(def, refs) {
  const items = parseDef4(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors3(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors3(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/tuple.mjs
function parseTupleDef3(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef4(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === undefined ? acc : [...acc, x], []),
      additionalItems: parseDef4(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef4(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === undefined ? acc : [...acc, x], [])
    };
  }
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/undefined.mjs
function parseUndefinedDef3() {
  return {
    not: {}
  };
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/unknown.mjs
function parseUnknownDef3() {
  return {};
}

// node_modules/openai/_vendor/zod-to-json-schema/parsers/readonly.mjs
var parseReadonlyDef3 = (def, refs) => {
  return parseDef4(def.innerType._def, refs);
};

// node_modules/openai/_vendor/zod-to-json-schema/parseDef.mjs
function parseDef4(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride3) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref2(seenItem, refs);
    if (seenSchema !== undefined) {
      if ("$ref" in seenSchema) {
        refs.seenRefs.add(seenSchema.$ref);
      }
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: undefined };
  refs.seen.set(def, newItem);
  const jsonSchema = selectParser4(def, def.typeName, refs, forceResolution);
  if (jsonSchema) {
    addMeta2(def, refs, jsonSchema);
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
var get$ref2 = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "extract-to-root":
      const name = item.path.slice(refs.basePath.length + 1).join("_");
      if (name !== refs.name && refs.nameStrategy === "duplicate-ref") {
        refs.definitions[name] = item.def;
      }
      return { $ref: [...refs.basePath, refs.definitionPath, name].join("/") };
    case "relative":
      return { $ref: getRelativePath4(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return {};
      }
      return refs.$refStrategy === "seen" ? {} : undefined;
    }
  }
};
var getRelativePath4 = (pathA, pathB) => {
  let i = 0;
  for (;i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
var selectParser4 = (def, typeName, refs, forceResolution) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef3();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef3();
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef3(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef3(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef3(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return parseDef4(def.getter()._def, refs);
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef3();
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef3(def, refs, forceResolution);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef3();
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef3();
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef3(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return;
    default:
      return ((_) => {
        return;
      })(typeName);
  }
};
var addMeta2 = (def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  return jsonSchema;
};
// node_modules/openai/_vendor/zod-to-json-schema/zodToJsonSchema.mjs
var zodToJsonSchema4 = (schema, options) => {
  const refs = getRefs3(options);
  const name = typeof options === "string" ? options : options?.nameStrategy === "title" ? undefined : options?.name;
  const main = parseDef4(schema._def, name === undefined ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name]
  }, false) ?? {};
  const title = typeof options === "object" && options.name !== undefined && options.nameStrategy === "title" ? options.name : undefined;
  if (title !== undefined) {
    main.title = title;
  }
  const definitions = (() => {
    if (isEmptyObj(refs.definitions)) {
      return;
    }
    const definitions2 = {};
    const processedDefinitions = new Set;
    for (let i = 0;i < 500; i++) {
      const newDefinitions = Object.entries(refs.definitions).filter(([key]) => !processedDefinitions.has(key));
      if (newDefinitions.length === 0)
        break;
      for (const [key, schema2] of newDefinitions) {
        definitions2[key] = parseDef4(zodDef(schema2), { ...refs, currentPath: [...refs.basePath, refs.definitionPath, key] }, true) ?? {};
        processedDefinitions.add(key);
      }
    }
    return definitions2;
  })();
  const combined = name === undefined ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : refs.nameStrategy === "duplicate-ref" ? {
    ...main,
    ...definitions || refs.seenRefs.size ? {
      [refs.definitionPath]: {
        ...definitions,
        ...refs.seenRefs.size ? { [name]: main } : undefined
      }
    } : undefined
  } : {
    $ref: [...refs.$refStrategy === "relative" ? [] : refs.basePath, refs.definitionPath, name].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  return combined;
};
// node_modules/openai/lib/ResponsesParser.mjs
function maybeParseResponse(response, params) {
  if (!params || !hasAutoParseableInput2(params)) {
    return {
      ...response,
      output_parsed: null,
      output: response.output.map((item) => {
        if (item.type === "function_call") {
          return {
            ...item,
            parsed_arguments: null
          };
        }
        if (item.type === "message") {
          return {
            ...item,
            content: item.content.map((content) => ({
              ...content,
              parsed: null
            }))
          };
        } else {
          return item;
        }
      })
    };
  }
  return parseResponse(response, params);
}
function parseResponse(response, params) {
  const output = response.output.map((item) => {
    if (item.type === "function_call") {
      return {
        ...item,
        parsed_arguments: parseToolCall2(params, item)
      };
    }
    if (item.type === "message") {
      const content = item.content.map((content2) => {
        if (content2.type === "output_text") {
          return {
            ...content2,
            parsed: parseTextFormat(params, content2.text)
          };
        }
        return content2;
      });
      return {
        ...item,
        content
      };
    }
    return item;
  });
  const parsed = Object.assign({}, response, { output });
  if (!Object.getOwnPropertyDescriptor(response, "output_text")) {
    addOutputText(parsed);
  }
  Object.defineProperty(parsed, "output_parsed", {
    enumerable: true,
    get() {
      for (const output2 of parsed.output) {
        if (output2.type !== "message") {
          continue;
        }
        for (const content of output2.content) {
          if (content.type === "output_text" && content.parsed !== null) {
            return content.parsed;
          }
        }
      }
      return null;
    }
  });
  return parsed;
}
function parseTextFormat(params, content) {
  if (params.text?.format?.type !== "json_schema") {
    return null;
  }
  if ("$parseRaw" in params.text?.format) {
    const text_format = params.text?.format;
    return text_format.$parseRaw(content);
  }
  return JSON.parse(content);
}
function hasAutoParseableInput2(params) {
  if (isAutoParsableResponseFormat(params.text?.format)) {
    return true;
  }
  return false;
}
function makeParseableResponseTool(tool, { parser, callback }) {
  const obj = { ...tool };
  Object.defineProperties(obj, {
    $brand: {
      value: "auto-parseable-tool",
      enumerable: false
    },
    $parseRaw: {
      value: parser,
      enumerable: false
    },
    $callback: {
      value: callback,
      enumerable: false
    }
  });
  return obj;
}
function isAutoParsableTool2(tool) {
  return tool?.["$brand"] === "auto-parseable-tool";
}
function getInputToolByName(input_tools, name) {
  return input_tools.find((tool) => tool.type === "function" && tool.name === name);
}
function parseToolCall2(params, toolCall) {
  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);
  return {
    ...toolCall,
    ...toolCall,
    parsed_arguments: isAutoParsableTool2(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : inputTool?.strict ? JSON.parse(toolCall.arguments) : null
  };
}
function addOutputText(rsp) {
  const texts = [];
  for (const output of rsp.output) {
    if (output.type !== "message") {
      continue;
    }
    for (const content of output.content) {
      if (content.type === "output_text") {
        texts.push(content.text);
      }
    }
  }
  rsp.output_text = texts.join("");
}

// node_modules/openai/lib/transform.mjs
function toStrictJsonSchema(schema) {
  if (schema.type !== "object") {
    throw new Error(`Root schema must have type: 'object' but got type: ${schema.type ? `'${schema.type}'` : "undefined"}`);
  }
  const schemaCopy = structuredClone(schema);
  return ensureStrictJsonSchema(schemaCopy, [], schemaCopy);
}
function isNullable(schema) {
  if (typeof schema === "boolean") {
    return false;
  }
  if (schema.type === "null") {
    return true;
  }
  for (const oneOfVariant of schema.oneOf ?? []) {
    if (isNullable(oneOfVariant)) {
      return true;
    }
  }
  for (const allOfVariant of schema.anyOf ?? []) {
    if (isNullable(allOfVariant)) {
      return true;
    }
  }
  return false;
}
function ensureStrictJsonSchema(jsonSchema, path, root) {
  if (typeof jsonSchema === "boolean") {
    throw new TypeError(`Expected object schema but got boolean; path=${path.join("/")}`);
  }
  if (!isObject2(jsonSchema)) {
    throw new TypeError(`Expected ${JSON.stringify(jsonSchema)} to be an object; path=${path.join("/")}`);
  }
  const defs = jsonSchema.$defs;
  if (isObject2(defs)) {
    for (const [defName, defSchema] of Object.entries(defs)) {
      ensureStrictJsonSchema(defSchema, [...path, "$defs", defName], root);
    }
  }
  const definitions = jsonSchema.definitions;
  if (isObject2(definitions)) {
    for (const [definitionName, definitionSchema] of Object.entries(definitions)) {
      ensureStrictJsonSchema(definitionSchema, [...path, "definitions", definitionName], root);
    }
  }
  const typ = jsonSchema.type;
  if (typ === "object" && !("additionalProperties" in jsonSchema)) {
    jsonSchema.additionalProperties = false;
  }
  const required2 = jsonSchema.required ?? [];
  const properties = jsonSchema.properties;
  if (isObject2(properties)) {
    for (const [key, value] of Object.entries(properties)) {
      if (!isNullable(value) && !required2.includes(key)) {
        throw new Error(`Zod field at \`${[...path, "properties", key].join("/")}\` uses \`.optional()\` without \`.nullable()\` which is not supported by the API. See: https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses#all-fields-must-be-required`);
      }
    }
    jsonSchema.required = Object.keys(properties);
    jsonSchema.properties = Object.fromEntries(Object.entries(properties).map(([key, propSchema]) => [
      key,
      ensureStrictJsonSchema(propSchema, [...path, "properties", key], root)
    ]));
  }
  const items = jsonSchema.items;
  if (isObject2(items)) {
    jsonSchema.items = ensureStrictJsonSchema(items, [...path, "items"], root);
  }
  const anyOf = jsonSchema.anyOf;
  if (Array.isArray(anyOf)) {
    jsonSchema.anyOf = anyOf.map((variant, i) => ensureStrictJsonSchema(variant, [...path, "anyOf", String(i)], root));
  }
  const allOf = jsonSchema.allOf;
  if (Array.isArray(allOf)) {
    if (allOf.length === 1) {
      const resolved = ensureStrictJsonSchema(allOf[0], [...path, "allOf", "0"], root);
      Object.assign(jsonSchema, resolved);
      delete jsonSchema.allOf;
    } else {
      jsonSchema.allOf = allOf.map((entry, i) => ensureStrictJsonSchema(entry, [...path, "allOf", String(i)], root));
    }
  }
  if (jsonSchema.default === null) {
    delete jsonSchema.default;
  }
  const ref = jsonSchema.$ref;
  if (ref && hasMoreThanNKeys(jsonSchema, 1)) {
    if (typeof ref !== "string") {
      throw new TypeError(`Received non-string $ref - ${ref}; path=${path.join("/")}`);
    }
    const resolved = resolveRef(root, ref);
    if (typeof resolved === "boolean") {
      throw new Error(`Expected \`$ref: ${ref}\` to resolve to an object schema but got boolean`);
    }
    if (!isObject2(resolved)) {
      throw new Error(`Expected \`$ref: ${ref}\` to resolve to an object but got ${JSON.stringify(resolved)}`);
    }
    Object.assign(jsonSchema, { ...resolved, ...jsonSchema });
    delete jsonSchema.$ref;
    return ensureStrictJsonSchema(jsonSchema, path, root);
  }
  return jsonSchema;
}
function resolveRef(root, ref) {
  if (!ref.startsWith("#/")) {
    throw new Error(`Unexpected $ref format ${JSON.stringify(ref)}; Does not start with #/`);
  }
  const pathParts = ref.slice(2).split("/");
  let resolved = root;
  for (const key of pathParts) {
    if (!isObject2(resolved)) {
      throw new Error(`encountered non-object entry while resolving ${ref} - ${JSON.stringify(resolved)}`);
    }
    const value = resolved[key];
    if (value === undefined) {
      throw new Error(`Key ${key} not found while resolving ${ref}`);
    }
    resolved = value;
  }
  return resolved;
}
function isObject2(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
}
function hasMoreThanNKeys(obj, n) {
  let i = 0;
  for (const _ in obj) {
    i++;
    if (i > n) {
      return true;
    }
  }
  return false;
}

// node_modules/openai/helpers/zod.mjs
function zodV3ToJsonSchema(schema, options) {
  return zodToJsonSchema4(schema, {
    openaiStrictMode: true,
    name: options.name,
    nameStrategy: "duplicate-ref",
    $refStrategy: "extract-to-root",
    nullableStrategy: "property"
  });
}
function zodV4ToJsonSchema(schema) {
  return toStrictJsonSchema(toJSONSchema(schema, {
    target: "draft-7"
  }));
}
function isZodV4(zodObject) {
  return "_zod" in zodObject;
}
function zodTextFormat(zodObject, name, props) {
  return makeParseableTextFormat({
    type: "json_schema",
    ...props,
    name,
    strict: true,
    schema: isZodV4(zodObject) ? zodV4ToJsonSchema(zodObject) : zodV3ToJsonSchema(zodObject, { name })
  }, (content) => zodObject.parse(JSON.parse(content)));
}
function zodResponsesFunction(options) {
  return makeParseableResponseTool({
    type: "function",
    name: options.name,
    parameters: isZodV4(options.parameters) ? zodV4ToJsonSchema(options.parameters) : zodV3ToJsonSchema(options.parameters, { name: options.name }),
    strict: true,
    ...options.description ? { description: options.description } : undefined
  }, {
    callback: options.function,
    parser: (args) => options.parameters.parse(JSON.parse(args))
  });
}

// node_modules/@openai/agents-core/dist/errors.mjs
class AgentsError extends Error {
  state;
  constructor(message, state) {
    super(message);
    this.state = state;
  }
}

class SystemError extends AgentsError {
}

class MaxTurnsExceededError extends AgentsError {
}

class ModelBehaviorError extends AgentsError {
}

class UserError extends AgentsError {
}

class GuardrailExecutionError extends AgentsError {
  error;
  constructor(message, error47, state) {
    super(message, state);
    this.error = error47;
  }
}

class ToolCallError extends AgentsError {
  error;
  constructor(message, error47, state) {
    super(message, state);
    this.error = error47;
  }
}

class InputGuardrailTripwireTriggered extends AgentsError {
  result;
  constructor(message, result, state) {
    super(message, state);
    this.result = result;
  }
}

class OutputGuardrailTripwireTriggered extends AgentsError {
  result;
  constructor(message, result, state) {
    super(message, state);
    this.result = result;
  }
}

// node_modules/@openai/agents-core/dist/utils/zodCompat.mjs
function asZodType(schema) {
  return schema;
}
function readZodDefinition(input) {
  if (typeof input !== "object" || input === null) {
    return;
  }
  const candidate = input;
  return candidate._zod?.def || candidate._def || candidate.def;
}
function readZodType(input) {
  const def = readZodDefinition(input);
  if (!def) {
    return;
  }
  const rawType = typeof def.typeName === "string" && def.typeName || typeof def.type === "string" && def.type;
  if (typeof rawType !== "string") {
    return;
  }
  const lower = rawType.toLowerCase();
  return lower.startsWith("zod") ? lower.slice(3) : lower;
}

// node_modules/@openai/agents-core/dist/utils/typeGuards.mjs
function isZodObject(input) {
  const definition = readZodDefinition(input);
  if (!definition) {
    return false;
  }
  const type = readZodType(input);
  return type === "object";
}
function isAgentToolInput(input) {
  return typeof input === "object" && input !== null && "input" in input && typeof input.input === "string";
}

// node_modules/@openai/agents-core/dist/utils/zodJsonSchemaCompat.mjs
var JSON_SCHEMA_DRAFT_07 = "http://json-schema.org/draft-07/schema#";
var OPTIONAL_WRAPPERS = new Set(["optional"]);
var DECORATOR_WRAPPERS = new Set([
  "brand",
  "branded",
  "catch",
  "default",
  "effects",
  "pipeline",
  "pipe",
  "prefault",
  "readonly",
  "refinement",
  "transform"
]);
var SIMPLE_TYPE_MAPPING = {
  string: { type: "string" },
  number: { type: "number" },
  bigint: { type: "integer" },
  boolean: { type: "boolean" },
  date: { type: "string", format: "date-time" }
};
function hasJsonSchemaObjectShape(value) {
  return typeof value === "object" && value !== null && value.type === "object" && "properties" in value && "additionalProperties" in value;
}
function zodJsonSchemaCompat(input) {
  const schema = buildObjectSchema(input);
  if (!schema) {
    return;
  }
  if (!Array.isArray(schema.required)) {
    schema.required = [];
  }
  if (typeof schema.additionalProperties === "undefined") {
    schema.additionalProperties = false;
  }
  if (typeof schema.$schema !== "string") {
    schema.$schema = JSON_SCHEMA_DRAFT_07;
  }
  return schema;
}
function buildObjectSchema(value) {
  const shape = readShape(value);
  if (!shape) {
    return;
  }
  const properties = {};
  const required2 = [];
  for (const [key, field] of Object.entries(shape)) {
    const { schema, optional: optional4 } = convertProperty(field);
    if (!schema) {
      return;
    }
    properties[key] = schema;
    if (!optional4) {
      required2.push(key);
    }
  }
  return { type: "object", properties, required: required2, additionalProperties: false };
}
function convertProperty(value) {
  let current = unwrapDecorators(value);
  let optional4 = false;
  while (OPTIONAL_WRAPPERS.has(readZodType(current) ?? "")) {
    optional4 = true;
    const def = readZodDefinition(current);
    const next = unwrapDecorators(def?.innerType);
    if (!next || next === current) {
      break;
    }
    current = next;
  }
  return { schema: convertSchema(current), optional: optional4 };
}
function convertSchema(value) {
  if (value === undefined) {
    return;
  }
  const unwrapped = unwrapDecorators(value);
  const type = readZodType(unwrapped);
  const def = readZodDefinition(unwrapped);
  if (!type) {
    return;
  }
  if (type in SIMPLE_TYPE_MAPPING) {
    return SIMPLE_TYPE_MAPPING[type];
  }
  switch (type) {
    case "object":
      return buildObjectSchema(unwrapped);
    case "array":
      return buildArraySchema(def);
    case "tuple":
      return buildTupleSchema(def);
    case "union":
      return buildUnionSchema(def);
    case "intersection":
      return buildIntersectionSchema(def);
    case "literal":
      return buildLiteral(def);
    case "enum":
    case "nativeenum":
      return buildEnum(def);
    case "record":
      return buildRecordSchema(def);
    case "map":
      return buildMapSchema(def);
    case "set":
      return buildSetSchema(def);
    case "nullable":
      return buildNullableSchema(def);
    default:
      return;
  }
}
function buildArraySchema(def) {
  const items = convertSchema(extractFirst(def, "element", "items", "type"));
  return items ? { type: "array", items } : undefined;
}
function buildTupleSchema(def) {
  const items = coerceArray(def?.items).map((item) => convertSchema(item)).filter(Boolean);
  if (!items.length) {
    return;
  }
  const schema = {
    type: "array",
    items,
    minItems: items.length
  };
  if (!def?.rest) {
    schema.maxItems = items.length;
  }
  return schema;
}
function buildUnionSchema(def) {
  const options = coerceArray(def?.options ?? def?.schemas).map((option) => convertSchema(option)).filter(Boolean);
  return options.length ? { anyOf: options } : undefined;
}
function buildIntersectionSchema(def) {
  const left = convertSchema(def?.left);
  const right = convertSchema(def?.right);
  return left && right ? { allOf: [left, right] } : undefined;
}
function buildRecordSchema(def) {
  const valueSchema = convertSchema(def?.valueType ?? def?.values);
  return valueSchema ? { type: "object", additionalProperties: valueSchema } : undefined;
}
function buildMapSchema(def) {
  const valueSchema = convertSchema(def?.valueType ?? def?.values);
  return valueSchema ? { type: "array", items: valueSchema } : undefined;
}
function buildSetSchema(def) {
  const valueSchema = convertSchema(def?.valueType);
  return valueSchema ? { type: "array", items: valueSchema, uniqueItems: true } : undefined;
}
function buildNullableSchema(def) {
  const inner = convertSchema(def?.innerType ?? def?.type);
  return inner ? { anyOf: [inner, { type: "null" }] } : undefined;
}
function unwrapDecorators(value) {
  let current = value;
  while (DECORATOR_WRAPPERS.has(readZodType(current) ?? "")) {
    const def = readZodDefinition(current);
    const next = def?.innerType ?? def?.schema ?? def?.base ?? def?.type ?? def?.wrapped ?? def?.underlying;
    if (!next || next === current) {
      return current;
    }
    current = next;
  }
  return current;
}
function extractFirst(def, ...keys) {
  if (!def) {
    return;
  }
  for (const key of keys) {
    if (key in def && def[key] !== undefined) {
      return def[key];
    }
  }
  return;
}
function coerceArray(value) {
  if (Array.isArray(value)) {
    return value;
  }
  return value === undefined ? [] : [value];
}
function buildLiteral(def) {
  if (!def) {
    return;
  }
  const literal4 = extractFirst(def, "value", "literal");
  if (literal4 === undefined) {
    return;
  }
  return {
    const: literal4,
    type: literal4 === null ? "null" : typeof literal4
  };
}
function buildEnum(def) {
  if (!def) {
    return;
  }
  if (Array.isArray(def.values)) {
    return { enum: def.values };
  }
  if (Array.isArray(def.options)) {
    return { enum: def.options };
  }
  if (def.values && typeof def.values === "object") {
    return { enum: Object.values(def.values) };
  }
  if (def.enum && typeof def.enum === "object") {
    return { enum: Object.values(def.enum) };
  }
  return;
}
function readShape(input) {
  if (typeof input !== "object" || input === null) {
    return;
  }
  const candidate = input;
  if (candidate.shape && typeof candidate.shape === "object") {
    return candidate.shape;
  }
  if (typeof candidate.shape === "function") {
    try {
      return candidate.shape();
    } catch (_error) {
      return;
    }
  }
  const def = readZodDefinition(candidate);
  const shape = def?.shape;
  if (shape && typeof shape === "object") {
    return shape;
  }
  if (typeof shape === "function") {
    try {
      return shape();
    } catch (_error) {
      return;
    }
  }
  return;
}

// node_modules/@openai/agents-core/dist/utils/tools.mjs
var zodResponsesFunctionCompat = zodResponsesFunction;
var zodTextFormatCompat = zodTextFormat;
function buildJsonSchemaFromZod(inputType) {
  return zodJsonSchemaCompat(inputType);
}
function toFunctionToolName(name) {
  name = name.replace(/\s/g, "_");
  name = name.replace(/[^a-zA-Z0-9]/g, "_");
  if (name.length === 0) {
    throw new Error("Tool name cannot be empty");
  }
  return name;
}
function getSchemaAndParserFromInputType(inputType, name) {
  const parser = (input) => JSON.parse(input);
  if (isZodObject(inputType)) {
    const useFallback = (originalError) => {
      const fallbackSchema = buildJsonSchemaFromZod(inputType);
      if (fallbackSchema) {
        return {
          schema: fallbackSchema,
          parser: (rawInput) => inputType.parse(JSON.parse(rawInput))
        };
      }
      const errorMessage = originalError instanceof Error ? ` Upstream helper error: ${originalError.message}` : "";
      throw new UserError(`Unable to convert the provided Zod schema to JSON Schema. Ensure that the \`zod\` package is available at runtime or provide a JSON schema object instead.${errorMessage}`);
    };
    let formattedFunction;
    try {
      formattedFunction = zodResponsesFunctionCompat({
        name,
        parameters: asZodType(inputType),
        function: () => {},
        description: ""
      });
    } catch (error47) {
      return useFallback(error47);
    }
    if (hasJsonSchemaObjectShape(formattedFunction.parameters)) {
      return {
        schema: formattedFunction.parameters,
        parser: formattedFunction.$parseRaw
      };
    }
    return useFallback();
  } else if (typeof inputType === "object" && inputType !== null) {
    return {
      schema: inputType,
      parser
    };
  }
  throw new UserError("Input type is not a ZodObject or a valid JSON schema");
}
function convertAgentOutputTypeToSerializable(outputType) {
  if (outputType === "text") {
    return "text";
  }
  if (isZodObject(outputType)) {
    const useFallback = (existing, originalError) => {
      const fallbackSchema = buildJsonSchemaFromZod(outputType);
      if (fallbackSchema) {
        return {
          type: existing?.type ?? "json_schema",
          name: existing?.name ?? "output",
          strict: existing?.strict ?? false,
          schema: fallbackSchema
        };
      }
      const errorMessage = originalError instanceof Error ? ` Upstream helper error: ${originalError.message}` : "";
      throw new UserError(`Unable to convert the provided Zod schema to JSON Schema. Ensure that the \`zod\` package is available at runtime or provide a JSON schema object instead.${errorMessage}`);
    };
    let output;
    try {
      output = zodTextFormatCompat(asZodType(outputType), "output");
    } catch (error47) {
      return useFallback(undefined, error47);
    }
    if (hasJsonSchemaObjectShape(output.schema)) {
      return {
        type: output.type,
        name: output.name,
        strict: output.strict || false,
        schema: output.schema
      };
    }
    return useFallback(output);
  }
  return outputType;
}

// node_modules/@openai/agents-core/dist/logger.mjs
var import_debug = __toESM(require_src(), 1);

// node_modules/@openai/agents-core/dist/config.mjs
function loadEnv2() {
  return loadEnv();
}
function isEnabled(flagName) {
  const env = loadEnv2();
  return typeof env !== "undefined" && (env[flagName] === "true" || env[flagName] === "1");
}
var tracing = {
  get disabled() {
    if (isBrowserEnvironment()) {
      return true;
    } else if (loadEnv2().NODE_ENV === "test") {
      return true;
    }
    return isEnabled("OPENAI_AGENTS_DISABLE_TRACING");
  }
};
var logging = {
  get dontLogModelData() {
    return isEnabled("OPENAI_AGENTS_DONT_LOG_MODEL_DATA");
  },
  get dontLogToolData() {
    return isEnabled("OPENAI_AGENTS_DONT_LOG_TOOL_DATA");
  }
};

// node_modules/@openai/agents-core/dist/logger.mjs
var dontLogModelData = logging.dontLogModelData;
var dontLogToolData = logging.dontLogToolData;
function getLogger(namespace = "openai-agents") {
  return {
    namespace,
    debug: import_debug.default(namespace),
    error: console.error,
    warn: console.warn,
    dontLogModelData,
    dontLogToolData
  };
}
var logger = getLogger("openai-agents:core");
var logger_default = logger;

// node_modules/@openai/agents-core/dist/utils/smartString.mjs
var BYTE_PREVIEW_LIMIT = 20;
function toSmartString(value) {
  if (value === null || value === undefined) {
    return String(value);
  }
  if (isArrayBufferLike(value)) {
    return formatByteArray(new Uint8Array(value));
  }
  if (isArrayBufferView(value)) {
    const view = value;
    return formatByteArray(new Uint8Array(view.buffer, view.byteOffset, view.byteLength));
  }
  if (typeof value === "string") {
    return value;
  }
  if (typeof value === "object") {
    try {
      return JSON.stringify(value, smartStringReplacer);
    } catch (_e) {
      return "[object with circular references]";
    }
  }
  return String(value);
}
function isArrayBufferLike(value) {
  if (value instanceof ArrayBuffer) {
    return true;
  }
  const sharedArrayBufferCtor = globalThis.SharedArrayBuffer;
  return Boolean(sharedArrayBufferCtor && value instanceof sharedArrayBufferCtor);
}
function isArrayBufferView(value) {
  return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(value);
}
function isSerializedBufferSnapshot(value) {
  return typeof value === "object" && value !== null && value.type === "Buffer" && Array.isArray(value.data);
}
function isNodeBuffer(value) {
  const bufferCtor = globalThis.Buffer;
  return Boolean(bufferCtor && typeof bufferCtor.isBuffer === "function" && bufferCtor.isBuffer(value));
}
function formatByteArray(bytes) {
  if (bytes.length === 0) {
    return "[byte array (0 bytes)]";
  }
  const previewLength = Math.min(bytes.length, BYTE_PREVIEW_LIMIT);
  const previewParts = [];
  for (let i = 0;i < previewLength; i++) {
    previewParts.push(formatByte(bytes[i]));
  }
  const ellipsis = bytes.length > BYTE_PREVIEW_LIMIT ? " \u2026" : "";
  const preview = previewParts.join(" ");
  return `[byte array ${preview}${ellipsis} (${bytes.length} bytes)]`;
}
function formatByte(byte) {
  return `0x${byte.toString(16).padStart(2, "0")}`;
}
function smartStringReplacer(_key, nestedValue) {
  if (isArrayBufferLike(nestedValue)) {
    return formatByteArray(new Uint8Array(nestedValue));
  }
  if (isArrayBufferView(nestedValue)) {
    const view = nestedValue;
    return formatByteArray(new Uint8Array(view.buffer, view.byteOffset, view.byteLength));
  }
  if (isSerializedBufferSnapshot(nestedValue)) {
    return formatByteArray(Uint8Array.from(nestedValue.data));
  }
  return nestedValue;
}

// node_modules/@openai/agents-core/dist/tool.mjs
function defaultToolErrorFunction(context, error47) {
  const details = error47 instanceof Error ? error47.toString() : String(error47);
  return `An error occurred while running the tool. Please try again. Error: ${details}`;
}
function tool(options) {
  const name = options.name ? toFunctionToolName(options.name) : toFunctionToolName(options.execute.name);
  const toolErrorFunction = typeof options.errorFunction === "undefined" ? defaultToolErrorFunction : options.errorFunction;
  if (!name) {
    throw new Error("Tool name cannot be empty. Either name your function or provide a name in the options.");
  }
  const strictMode = options.strict ?? true;
  if (!strictMode && isZodObject(options.parameters)) {
    throw new UserError("Strict mode is required for Zod parameters");
  }
  const { parser, schema: parameters } = getSchemaAndParserFromInputType(options.parameters, name);
  async function _invoke(runContext, input, details) {
    const [error47, parsed] = await safeExecute(() => parser(input));
    if (error47 !== null) {
      if (logger_default.dontLogToolData) {
        logger_default.debug(`Invalid JSON input for tool ${name}`);
      } else {
        logger_default.debug(`Invalid JSON input for tool ${name}: ${input}`);
      }
      throw new ModelBehaviorError("Invalid JSON input for tool");
    }
    if (logger_default.dontLogToolData) {
      logger_default.debug(`Invoking tool ${name}`);
    } else {
      logger_default.debug(`Invoking tool ${name} with input ${input}`);
    }
    const result = await options.execute(parsed, runContext, details);
    const stringResult = toSmartString(result);
    if (logger_default.dontLogToolData) {
      logger_default.debug(`Tool ${name} completed`);
    } else {
      logger_default.debug(`Tool ${name} returned: ${stringResult}`);
    }
    return result;
  }
  async function invoke(runContext, input, details) {
    return _invoke(runContext, input, details).catch((error47) => {
      if (toolErrorFunction) {
        const currentSpan = getCurrentSpan();
        currentSpan?.setError({
          message: "Error running tool (non-fatal)",
          data: {
            tool_name: name,
            error: error47.toString()
          }
        });
        return toolErrorFunction(runContext, error47);
      }
      throw error47;
    });
  }
  const needsApproval = typeof options.needsApproval === "function" ? options.needsApproval : async () => typeof options.needsApproval === "boolean" ? options.needsApproval : false;
  const isEnabled2 = typeof options.isEnabled === "function" ? async (runContext, agent) => {
    const predicate = options.isEnabled;
    const result = await predicate({ runContext, agent });
    return Boolean(result);
  } : async () => typeof options.isEnabled === "boolean" ? options.isEnabled : true;
  return {
    type: "function",
    name,
    description: options.description,
    parameters,
    strict: strictMode,
    invoke,
    needsApproval,
    isEnabled: isEnabled2
  };
}

// node_modules/@openai/agents-core/dist/mcp.mjs
var import_debug2 = __toESM(require_src(), 1);

// node_modules/zod/index.js
init_external3();
init_external3();

// node_modules/@openai/agents-core/dist/mcp.mjs
var DEFAULT_STDIO_MCP_CLIENT_LOGGER_NAME = "openai-agents:stdio-mcp-client";
class BaseMCPServerStdio {
  cacheToolsList;
  _cachedTools = undefined;
  toolFilter;
  logger;
  constructor(options) {
    this.logger = options.logger ?? getLogger(DEFAULT_STDIO_MCP_CLIENT_LOGGER_NAME);
    this.cacheToolsList = options.cacheToolsList ?? false;
    this.toolFilter = options.toolFilter;
  }
  debugLog(buildMessage) {
    if (import_debug2.default.enabled(this.logger.namespace)) {
      this.logger.debug(buildMessage());
    }
  }
}
var MCPTool = exports_external2.object({
  name: exports_external2.string(),
  description: exports_external2.string().optional(),
  inputSchema: exports_external2.object({
    type: exports_external2.literal("object"),
    properties: exports_external2.record(exports_external2.string(), exports_external2.any()),
    required: exports_external2.array(exports_external2.string()),
    additionalProperties: exports_external2.boolean()
  })
});

class MCPServerStdio extends BaseMCPServerStdio {
  underlying;
  constructor(options) {
    super(options);
    this.underlying = new NodeMCPServerStdio(options);
  }
  get name() {
    return this.underlying.name;
  }
  connect() {
    return this.underlying.connect();
  }
  close() {
    return this.underlying.close();
  }
  async listTools() {
    if (this.cacheToolsList && this._cachedTools) {
      return this._cachedTools;
    }
    const tools = await this.underlying.listTools();
    if (this.cacheToolsList) {
      this._cachedTools = tools;
    }
    return tools;
  }
  callTool(toolName, args) {
    return this.underlying.callTool(toolName, args);
  }
  invalidateToolsCache() {
    return this.underlying.invalidateToolsCache();
  }
}
var _cachedTools = {};
var _cachedToolKeysByServer = {};
async function invalidateServerToolsCache(serverName) {
  const cachedKeys = _cachedToolKeysByServer[serverName];
  if (cachedKeys) {
    for (const cacheKey of cachedKeys) {
      delete _cachedTools[cacheKey];
    }
    delete _cachedToolKeysByServer[serverName];
    return;
  }
  delete _cachedTools[serverName];
  for (const cacheKey of Object.keys(_cachedTools)) {
    if (cacheKey.startsWith(`${serverName}:`)) {
      delete _cachedTools[cacheKey];
    }
  }
}
var defaultMCPToolCacheKey = ({ server, agent }) => {
  if (server.toolFilter && typeof server.toolFilter === "function" && agent) {
    return `${server.name}:${agent.name}`;
  }
  return server.name;
};
async function getFunctionToolsFromServer({ server, convertSchemasToStrict, runContext, agent, generateMCPToolCacheKey }) {
  const cacheKey = (generateMCPToolCacheKey || defaultMCPToolCacheKey)({
    server,
    agent,
    runContext
  });
  if (server.cacheToolsList && _cachedTools[cacheKey]) {
    return _cachedTools[cacheKey].map((t) => mcpToFunctionTool(t, server, convertSchemasToStrict));
  }
  const listToolsForServer = async (span) => {
    const fetchedMcpTools = await server.listTools();
    let mcpTools = fetchedMcpTools;
    if (runContext && agent) {
      const context = { runContext, agent, serverName: server.name };
      const filteredTools = [];
      for (const tool2 of fetchedMcpTools) {
        const filter = server.toolFilter;
        if (filter) {
          if (typeof filter === "function") {
            const filtered = await filter(context, tool2);
            if (!filtered) {
              logger.debug(`MCP Tool (server: ${server.name}, tool: ${tool2.name}) is blocked by the callable filter.`);
              continue;
            }
          } else {
            const allowedToolNames = filter.allowedToolNames ?? [];
            const blockedToolNames = filter.blockedToolNames ?? [];
            if (allowedToolNames.length > 0 || blockedToolNames.length > 0) {
              const allowed = allowedToolNames.length > 0 ? allowedToolNames.includes(tool2.name) : true;
              const blocked = blockedToolNames.length > 0 ? blockedToolNames.includes(tool2.name) : false;
              if (!allowed || blocked) {
                if (blocked) {
                  logger.debug(`MCP Tool (server: ${server.name}, tool: ${tool2.name}) is blocked by the static filter.`);
                } else if (!allowed) {
                  logger.debug(`MCP Tool (server: ${server.name}, tool: ${tool2.name}) is not allowed by the static filter.`);
                }
                continue;
              }
            }
          }
        }
        filteredTools.push(tool2);
      }
      mcpTools = filteredTools;
    }
    if (span) {
      span.spanData.result = mcpTools.map((t) => t.name);
    }
    const tools = mcpTools.map((t) => mcpToFunctionTool(t, server, convertSchemasToStrict));
    if (server.cacheToolsList) {
      _cachedTools[cacheKey] = mcpTools;
      if (!_cachedToolKeysByServer[server.name]) {
        _cachedToolKeysByServer[server.name] = new Set;
      }
      _cachedToolKeysByServer[server.name].add(cacheKey);
    }
    return tools;
  };
  if (!getCurrentTrace()) {
    return listToolsForServer();
  }
  return withMCPListToolsSpan(listToolsForServer, {
    data: { server: server.name }
  });
}
async function getAllMcpTools(mcpServersOrOpts, runContext, agent, convertSchemasToStrict = false) {
  const opts = Array.isArray(mcpServersOrOpts) ? {
    mcpServers: mcpServersOrOpts,
    runContext,
    agent,
    convertSchemasToStrict
  } : mcpServersOrOpts;
  const { mcpServers, convertSchemasToStrict: convertSchemasToStrictFromOpts = false, runContext: runContextFromOpts, agent: agentFromOpts, generateMCPToolCacheKey } = opts;
  const allTools = [];
  const toolNames = new Set;
  for (const server of mcpServers) {
    const serverTools = await getFunctionToolsFromServer({
      server,
      convertSchemasToStrict: convertSchemasToStrictFromOpts,
      runContext: runContextFromOpts,
      agent: agentFromOpts,
      generateMCPToolCacheKey
    });
    const serverToolNames = new Set(serverTools.map((t) => t.name));
    const intersection4 = [...serverToolNames].filter((n) => toolNames.has(n));
    if (intersection4.length > 0) {
      throw new UserError(`Duplicate tool names found across MCP servers: ${intersection4.join(", ")}`);
    }
    for (const t of serverTools) {
      toolNames.add(t.name);
      allTools.push(t);
    }
  }
  return allTools;
}
function mcpToFunctionTool(mcpTool, server, convertSchemasToStrict) {
  async function invoke(input, _context) {
    let args = {};
    if (typeof input === "string" && input) {
      args = JSON.parse(input);
    } else if (typeof input === "object" && input != null) {
      args = input;
    }
    const currentSpan = getCurrentSpan();
    if (currentSpan) {
      currentSpan.spanData["mcp_data"] = { server: server.name };
    }
    const content = await server.callTool(mcpTool.name, args);
    return content.length === 1 ? content[0] : content;
  }
  const schema = {
    ...mcpTool.inputSchema,
    type: mcpTool.inputSchema?.type ?? "object",
    properties: mcpTool.inputSchema?.properties ?? {},
    required: mcpTool.inputSchema?.required ?? [],
    additionalProperties: mcpTool.inputSchema?.additionalProperties ?? false
  };
  if (convertSchemasToStrict || schema.additionalProperties === true) {
    try {
      const strictSchema = ensureStrictJsonSchema2(schema);
      return tool({
        name: mcpTool.name,
        description: mcpTool.description || "",
        parameters: strictSchema,
        strict: true,
        execute: invoke
      });
    } catch (e) {
      logger.warn(`Error converting MCP schema to strict mode: ${e}`);
    }
  }
  const nonStrictSchema = {
    ...schema,
    additionalProperties: true
  };
  return tool({
    name: mcpTool.name,
    description: mcpTool.description || "",
    parameters: nonStrictSchema,
    strict: false,
    execute: invoke
  });
}
function ensureStrictJsonSchema2(schema) {
  const out = {
    ...schema,
    additionalProperties: false
  };
  if (!out.required)
    out.required = [];
  return out;
}

// node_modules/@openai/agents-core/dist/shims/mcp-server/node.mjs
function failedToImport(error47) {
  logger_default.error(`
Failed to load the MCP SDK. Please install the @modelcontextprotocol/sdk package.

npm install @modelcontextprotocol/sdk
    `.trim());
  throw error47;
}

class NodeMCPServerStdio extends BaseMCPServerStdio {
  session = null;
  _cacheDirty = true;
  _toolsList = [];
  serverInitializeResult = null;
  clientSessionTimeoutSeconds;
  timeout;
  params;
  _name;
  transport = null;
  constructor(params) {
    super(params);
    this.clientSessionTimeoutSeconds = params.clientSessionTimeoutSeconds ?? 5;
    this.timeout = params.timeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC;
    if ("fullCommand" in params) {
      const elements = params.fullCommand.split(" ");
      const command = elements.shift();
      if (!command) {
        throw new Error("Invalid fullCommand: " + params.fullCommand);
      }
      this.params = {
        ...params,
        command,
        args: elements,
        encoding: params.encoding || "utf-8",
        encodingErrorHandler: params.encodingErrorHandler || "strict"
      };
    } else {
      this.params = params;
    }
    this._name = params.name || `stdio: ${this.params.command}`;
  }
  async connect() {
    try {
      const { StdioClientTransport: StdioClientTransport2 } = await Promise.resolve().then(() => (init_stdio2(), exports_stdio)).catch(failedToImport);
      const { Client: Client3 } = await Promise.resolve().then(() => (init_client2(), exports_client)).catch(failedToImport);
      this.transport = new StdioClientTransport2({
        command: this.params.command,
        args: this.params.args,
        env: this.params.env,
        cwd: this.params.cwd
      });
      this.session = new Client3({
        name: this._name,
        version: "1.0.0"
      });
      await this.session.connect(this.transport);
      this.serverInitializeResult = {
        serverInfo: { name: this._name, version: "1.0.0" }
      };
    } catch (e) {
      this.logger.error("Error initializing MCP server:", e);
      await this.close();
      throw e;
    }
    this.debugLog(() => `Connected to MCP server: ${this._name}`);
  }
  async invalidateToolsCache() {
    await invalidateServerToolsCache(this.name);
    this._cacheDirty = true;
  }
  async listTools() {
    const { ListToolsResultSchema: ListToolsResultSchema2 } = await Promise.resolve().then(() => (init_types2(), exports_types)).catch(failedToImport);
    if (!this.session) {
      throw new Error("Server not initialized. Make sure you call connect() first.");
    }
    if (this.cacheToolsList && !this._cacheDirty && this._toolsList) {
      return this._toolsList;
    }
    this._cacheDirty = false;
    const response = await this.session.listTools();
    this.debugLog(() => `Listed tools: ${JSON.stringify(response)}`);
    this._toolsList = ListToolsResultSchema2.parse(response).tools;
    return this._toolsList;
  }
  async callTool(toolName, args) {
    const { CallToolResultSchema: CallToolResultSchema2 } = await Promise.resolve().then(() => (init_types2(), exports_types)).catch(failedToImport);
    if (!this.session) {
      throw new Error("Server not initialized. Make sure you call connect() first.");
    }
    const response = await this.session.callTool({
      name: toolName,
      arguments: args ?? {}
    }, undefined, {
      timeout: this.timeout
    });
    const parsed = CallToolResultSchema2.parse(response);
    const result = parsed.content;
    this.debugLog(() => `Called tool ${toolName} (args: ${JSON.stringify(args)}, result: ${JSON.stringify(result)})`);
    return result;
  }
  get name() {
    return this._name;
  }
  async close() {
    if (this.transport) {
      await this.transport.close();
      this.transport = null;
    }
    if (this.session) {
      await this.session.close();
      this.session = null;
    }
  }
}
// node_modules/@openai/agents-core/dist/shims/shims-node.mjs
function loadEnv() {
  if (typeof process3 === "undefined" || typeof process3.env === "undefined") {
    try {
      const importMeta = (0, eval)("import.meta");
      if (typeof importMeta === "object" && typeof importMeta.env === "object") {
        return importMeta.env;
      }
    } catch {}
    return {};
  }
  return process3.env;
}
function isTracingLoopRunningByDefault() {
  return true;
}
function isBrowserEnvironment() {
  return false;
}

class NodeTimer {
  constructor() {}
  setTimeout(callback, ms) {
    return setTimeout(callback, ms);
  }
  clearTimeout(timeoutId) {
    clearTimeout(timeoutId);
  }
}
var timer = new NodeTimer;

// node_modules/@openai/agents-core/dist/lifecycle.mjs
class EventEmitterDelegate {
  on(type, listener) {
    this.eventEmitter.on(type, listener);
    return this.eventEmitter;
  }
  off(type, listener) {
    this.eventEmitter.off(type, listener);
    return this.eventEmitter;
  }
  emit(type, ...args) {
    return this.eventEmitter.emit(type, ...args);
  }
  once(type, listener) {
    this.eventEmitter.once(type, listener);
    return this.eventEmitter;
  }
}

class AgentHooks extends EventEmitterDelegate {
  eventEmitter = new EventEmitter;
}

class RunHooks extends EventEmitterDelegate {
  eventEmitter = new EventEmitter;
}

// node_modules/@openai/agents-core/dist/defaultModel.mjs
var OPENAI_DEFAULT_MODEL_ENV_VARIABLE_NAME = "OPENAI_DEFAULT_MODEL";
function gpt5ReasoningSettingsRequired(modelName) {
  if (modelName.startsWith("gpt-5-chat")) {
    return false;
  }
  return modelName.startsWith("gpt-5");
}
function isGpt5Default() {
  return gpt5ReasoningSettingsRequired(getDefaultModel());
}
function getDefaultModel() {
  const env2 = loadEnv2();
  return env2[OPENAI_DEFAULT_MODEL_ENV_VARIABLE_NAME]?.toLowerCase() ?? "gpt-4.1";
}
function getDefaultModelSettings(model) {
  const _model = model ?? getDefaultModel();
  if (gpt5ReasoningSettingsRequired(_model)) {
    return {
      reasoning: { effort: "low" },
      text: { verbosity: "low" }
    };
  }
  return {};
}

// node_modules/@openai/agents-core/dist/handoff.mjs
function getTransferMessage(agent) {
  return JSON.stringify({ assistant: agent.name });
}
function defaultHandoffToolName(agent) {
  return `transfer_to_${toFunctionToolName(agent.name)}`;
}
function defaultHandoffToolDescription(agent) {
  return `Handoff to the ${agent.name} agent to handle the request. ${agent.handoffDescription ?? ""}`;
}

class Handoff {
  toolName;
  toolDescription;
  inputJsonSchema = {
    type: "object",
    properties: {},
    required: [],
    additionalProperties: false
  };
  strictJsonSchema = true;
  onInvokeHandoff;
  agentName;
  inputFilter;
  agent;
  getHandoffAsFunctionTool() {
    return {
      type: "function",
      name: this.toolName,
      description: this.toolDescription,
      parameters: this.inputJsonSchema,
      strict: this.strictJsonSchema
    };
  }
  isEnabled = async () => true;
  constructor(agent, onInvokeHandoff) {
    this.agentName = agent.name;
    this.onInvokeHandoff = onInvokeHandoff;
    this.toolName = defaultHandoffToolName(agent);
    this.toolDescription = defaultHandoffToolDescription(agent);
    this.agent = agent;
  }
}
function handoff(agent, config2 = {}) {
  let parser = undefined;
  const hasOnHandoff = !!config2.onHandoff;
  const hasInputType = !!config2.inputType;
  const hasBothOrNeitherHandoffAndInputType = hasOnHandoff === hasInputType;
  if (!hasBothOrNeitherHandoffAndInputType) {
    throw new UserError("You must provide either both `onHandoff` and `inputType` or neither.");
  }
  async function onInvokeHandoff(context, inputJsonString) {
    if (parser) {
      if (!inputJsonString) {
        addErrorToCurrentSpan({
          message: `Handoff function expected non empty input but got: ${inputJsonString}`,
          data: {
            details: `input is empty`
          }
        });
        throw new ModelBehaviorError("Handoff function expected non empty input");
      }
      try {
        const parsed = await parser(inputJsonString);
        if (config2.onHandoff) {
          await config2.onHandoff(context, parsed);
        }
      } catch (error47) {
        addErrorToCurrentSpan({
          message: `Invalid JSON provided`,
          data: {}
        });
        if (!logger_default.dontLogToolData) {
          logger_default.error(`Invalid JSON when parsing: ${inputJsonString}. Error: ${error47}`);
        }
        throw new ModelBehaviorError("Invalid JSON provided");
      }
    } else {
      await config2.onHandoff?.(context);
    }
    return agent;
  }
  const handoff2 = new Handoff(agent, onInvokeHandoff);
  if (typeof config2.isEnabled === "function") {
    const predicate = config2.isEnabled;
    handoff2.isEnabled = async ({ runContext, agent: agent2 }) => {
      const result = await predicate({ runContext, agent: agent2 });
      return Boolean(result);
    };
  } else if (typeof config2.isEnabled === "boolean") {
    handoff2.isEnabled = async () => config2.isEnabled;
  }
  if (config2.inputType) {
    const result = getSchemaAndParserFromInputType(config2.inputType, handoff2.toolName);
    handoff2.inputJsonSchema = result.schema;
    handoff2.strictJsonSchema = true;
    parser = result.parser;
  }
  if (config2.toolNameOverride) {
    handoff2.toolName = config2.toolNameOverride;
  }
  if (config2.toolDescriptionOverride) {
    handoff2.toolDescription = config2.toolDescriptionOverride;
  }
  if (config2.inputFilter) {
    handoff2.inputFilter = config2.inputFilter;
  }
  return handoff2;
}
function getHandoff(agent) {
  if (agent instanceof Handoff) {
    return agent;
  }
  return handoff(agent);
}

// node_modules/@openai/agents-core/dist/utils/messages.mjs
function getLastTextFromOutputMessage(outputMessage) {
  if (outputMessage.type !== "message") {
    return;
  }
  if (outputMessage.role !== "assistant") {
    return;
  }
  const lastItem = outputMessage.content[outputMessage.content.length - 1];
  if (lastItem.type !== "output_text") {
    return;
  }
  return lastItem.text;
}
function getOutputText(output) {
  if (output.output.length === 0) {
    return "";
  }
  return getLastTextFromOutputMessage(output.output[output.output.length - 1]) || "";
}

// node_modules/@openai/agents-core/dist/agent.mjs
var agentToolRunResults = new WeakMap;
function saveAgentToolRunResult(toolCall, runResult) {
  if (toolCall) {
    agentToolRunResults.set(toolCall, runResult);
  }
}
function consumeAgentToolRunResult(toolCall) {
  const runResult = agentToolRunResults.get(toolCall);
  if (runResult) {
    agentToolRunResults.delete(toolCall);
  }
  return runResult;
}
var AgentAsToolNeedApprovalSchame = exports_external2.object({ input: exports_external2.string() });

class Agent extends AgentHooks {
  static create(config2) {
    return new Agent({
      ...config2,
      handoffs: config2.handoffs,
      outputType: config2.outputType,
      handoffOutputTypeWarningEnabled: false
    });
  }
  static DEFAULT_MODEL_PLACEHOLDER = "";
  name;
  instructions;
  prompt;
  handoffDescription;
  handoffs;
  model;
  modelSettings;
  tools;
  mcpServers;
  inputGuardrails;
  outputGuardrails;
  outputType = "text";
  toolUseBehavior;
  resetToolChoice;
  _toolsExplicitlyConfigured;
  constructor(config2) {
    super();
    if (typeof config2.name !== "string" || config2.name.trim() === "") {
      throw new UserError("Agent must have a name.");
    }
    this.name = config2.name;
    this.instructions = config2.instructions ?? Agent.DEFAULT_MODEL_PLACEHOLDER;
    this.prompt = config2.prompt;
    this.handoffDescription = config2.handoffDescription ?? "";
    this.handoffs = config2.handoffs ?? [];
    this.model = config2.model ?? "";
    this.modelSettings = config2.modelSettings ?? getDefaultModelSettings();
    this.tools = config2.tools ?? [];
    this._toolsExplicitlyConfigured = config2.tools !== undefined;
    this.mcpServers = config2.mcpServers ?? [];
    this.inputGuardrails = config2.inputGuardrails ?? [];
    this.outputGuardrails = config2.outputGuardrails ?? [];
    if (config2.outputType) {
      this.outputType = config2.outputType;
    }
    this.toolUseBehavior = config2.toolUseBehavior ?? "run_llm_again";
    this.resetToolChoice = config2.resetToolChoice ?? true;
    if (config2.model !== undefined && isGpt5Default() && (typeof config2.model !== "string" || !gpt5ReasoningSettingsRequired(config2.model)) && config2.modelSettings === undefined) {
      this.modelSettings = {};
    }
    if (config2.handoffOutputTypeWarningEnabled === undefined || config2.handoffOutputTypeWarningEnabled) {
      if (this.handoffs && this.outputType) {
        const outputTypes = new Set([JSON.stringify(this.outputType)]);
        for (const h of this.handoffs) {
          if ("outputType" in h && h.outputType) {
            outputTypes.add(JSON.stringify(h.outputType));
          } else if ("agent" in h && h.agent.outputType) {
            outputTypes.add(JSON.stringify(h.agent.outputType));
          }
        }
        if (outputTypes.size > 1) {
          logger_default.warn(`[Agent] Warning: Handoff agents have different output types: ${Array.from(outputTypes).join(", ")}. You can make it type-safe by using Agent.create({ ... }) method instead.`);
        }
      }
    }
  }
  get outputSchemaName() {
    if (this.outputType === "text") {
      return "text";
    } else if (isZodObject(this.outputType)) {
      return "ZodOutput";
    } else if (typeof this.outputType === "object") {
      return this.outputType.name;
    }
    throw new Error(`Unknown output type: ${this.outputType}`);
  }
  clone(config2) {
    return new Agent({
      ...this,
      ...config2
    });
  }
  asTool(options) {
    const { toolName, toolDescription, customOutputExtractor, needsApproval, runConfig, runOptions, isEnabled: isEnabled2 } = options;
    return tool({
      name: toolName ?? toFunctionToolName(this.name),
      description: toolDescription ?? "",
      parameters: AgentAsToolNeedApprovalSchame,
      strict: true,
      needsApproval,
      isEnabled: isEnabled2,
      execute: async (data, context, details) => {
        if (!isAgentToolInput(data)) {
          throw new ModelBehaviorError("Agent tool called with invalid input");
        }
        const runner = new Runner(runConfig ?? {});
        const result = await runner.run(this, data.input, {
          context,
          ...runOptions ?? {}
        });
        const completedResult = result;
        const usesStopAtToolNames = typeof this.toolUseBehavior === "object" && this.toolUseBehavior !== null && "stopAtToolNames" in this.toolUseBehavior;
        if (typeof customOutputExtractor !== "function" && usesStopAtToolNames) {
          logger_default.debug(`You're passing the agent (name: ${this.name}) with toolUseBehavior.stopAtToolNames configured as a tool to a different agent; this may not work as you expect. You may want to have a wrapper function tool to consistently return the final output.`);
        }
        const outputText = typeof customOutputExtractor === "function" ? await customOutputExtractor(completedResult) : getOutputText(completedResult.rawResponses[completedResult.rawResponses.length - 1]);
        if (details?.toolCall) {
          saveAgentToolRunResult(details.toolCall, completedResult);
        }
        return outputText;
      }
    });
  }
  async getSystemPrompt(runContext) {
    if (typeof this.instructions === "function") {
      return await this.instructions(runContext, this);
    }
    return this.instructions;
  }
  async getPrompt(runContext) {
    if (typeof this.prompt === "function") {
      return await this.prompt(runContext, this);
    }
    return this.prompt;
  }
  async getMcpTools(runContext) {
    if (this.mcpServers.length > 0) {
      return getAllMcpTools({
        mcpServers: this.mcpServers,
        runContext,
        agent: this,
        convertSchemasToStrict: false
      });
    }
    return [];
  }
  async getAllTools(runContext) {
    const mcpTools = await this.getMcpTools(runContext);
    const enabledTools = [];
    for (const candidate of this.tools) {
      if (candidate.type === "function") {
        const maybeIsEnabled = candidate.isEnabled;
        const enabled = typeof maybeIsEnabled === "function" ? await maybeIsEnabled(runContext, this) : typeof maybeIsEnabled === "boolean" ? maybeIsEnabled : true;
        if (!enabled) {
          continue;
        }
      }
      enabledTools.push(candidate);
    }
    return [...mcpTools, ...enabledTools];
  }
  hasExplicitToolConfig() {
    return this._toolsExplicitlyConfigured;
  }
  async getEnabledHandoffs(runContext) {
    const handoffs = this.handoffs?.map((h) => getHandoff(h)) ?? [];
    const enabled = [];
    for (const handoff2 of handoffs) {
      if (await handoff2.isEnabled({ runContext, agent: this })) {
        enabled.push(handoff2);
      }
    }
    return enabled;
  }
  processFinalOutput(output) {
    if (this.outputType === "text") {
      return output;
    }
    if (typeof this.outputType === "object") {
      const parsed = JSON.parse(output);
      if (isZodObject(this.outputType)) {
        return this.outputType.parse(parsed);
      }
      return parsed;
    }
    throw new Error(`Unknown output type: ${this.outputType}`);
  }
  toJSON() {
    return {
      name: this.name
    };
  }
}

// node_modules/@openai/agents-core/dist/guardrail.mjs
function defineInputGuardrail({ name, execute, runInParallel = true }) {
  return {
    type: "input",
    name,
    runInParallel,
    guardrailFunction: execute,
    async run(args) {
      return {
        guardrail: { type: "input", name },
        output: await execute(args)
      };
    }
  };
}
function defineOutputGuardrail({ name, execute }) {
  return {
    type: "output",
    name,
    guardrailFunction: execute,
    async run(args) {
      return {
        guardrail: { type: "output", name },
        agent: args.agent,
        agentOutput: args.agentOutput,
        output: await execute(args)
      };
    }
  };
}

// node_modules/@openai/agents-core/dist/providers.mjs
var DEFAULT_PROVIDER;
function setDefaultModelProvider(provider) {
  DEFAULT_PROVIDER = provider;
}
function getDefaultModelProvider() {
  if (typeof DEFAULT_PROVIDER === "undefined") {
    throw new Error("No default model provider set. Make sure to set a provider using setDefaultModelProvider before calling getDefaultModelProvider or pass an explicit provider.");
  }
  return DEFAULT_PROVIDER;
}

// node_modules/@openai/agents-core/dist/types/protocol.mjs
var SharedBase = exports_external2.object({
  providerData: exports_external2.record(exports_external2.string(), exports_external2.any()).optional()
});
var ItemBase = SharedBase.extend({
  id: exports_external2.string().optional()
});
var Refusal = SharedBase.extend({
  type: exports_external2.literal("refusal"),
  refusal: exports_external2.string()
});
var OutputText = SharedBase.extend({
  type: exports_external2.literal("output_text"),
  text: exports_external2.string()
});
var InputText = SharedBase.extend({
  type: exports_external2.literal("input_text"),
  text: exports_external2.string()
});
var ReasoningText = SharedBase.extend({
  type: exports_external2.literal("reasoning_text"),
  text: exports_external2.string()
});
var InputImage = SharedBase.extend({
  type: exports_external2.literal("input_image"),
  image: exports_external2.string().or(exports_external2.object({ id: exports_external2.string().describe("OpenAI file ID") })).describe("Either base64 encoded image data, a data URL, or an object with a file ID.").optional(),
  detail: exports_external2.string().optional()
});
var InputFile = SharedBase.extend({
  type: exports_external2.literal("input_file"),
  file: exports_external2.string().describe("Either base64 encoded file data or a publicly accessible file URL").or(exports_external2.object({ id: exports_external2.string().describe("OpenAI file ID") })).or(exports_external2.object({ url: exports_external2.string().describe("Publicly accessible file URL") })).describe("Contents of the file or an object with a file ID.").optional(),
  filename: exports_external2.string().optional()
});
var AudioContent = SharedBase.extend({
  type: exports_external2.literal("audio"),
  audio: exports_external2.string().or(exports_external2.object({
    id: exports_external2.string()
  })).describe("Base64 encoded audio data or file id"),
  format: exports_external2.string().nullable().optional(),
  transcript: exports_external2.string().nullable().optional()
});
var ImageContent = SharedBase.extend({
  type: exports_external2.literal("image"),
  image: exports_external2.string().describe("Base64 encoded image data")
});
var ToolOutputText = SharedBase.extend({
  type: exports_external2.literal("text"),
  text: exports_external2.string()
});
var ImageDataObjectSchema = exports_external2.object({
  data: exports_external2.union([exports_external2.string(), exports_external2.instanceof(Uint8Array)]).describe("Base64 image data, or raw bytes that will be base64 encoded automatically."),
  mediaType: exports_external2.string().optional()
});
var ImageUrlObjectSchema = exports_external2.object({
  url: exports_external2.string().describe("Publicly accessible URL pointing to the image content")
});
var ImageFileIdObjectSchema = exports_external2.object({
  fileId: exports_external2.string().describe("OpenAI file ID referencing uploaded image content")
});
var ImageObjectSchema = exports_external2.union([ImageDataObjectSchema, ImageUrlObjectSchema, ImageFileIdObjectSchema]).describe("Inline image data or references to uploaded content.");
var FileDataObjectSchema = exports_external2.object({
  data: exports_external2.union([exports_external2.string(), exports_external2.instanceof(Uint8Array)]).describe("Base64 encoded file data, or raw bytes that will be encoded automatically."),
  mediaType: exports_external2.string().describe("IANA media type describing the file contents"),
  filename: exports_external2.string().describe("Filename associated with the inline data")
});
var FileUrlObjectSchema = exports_external2.object({
  url: exports_external2.string().describe("Publicly accessible URL for the file content"),
  filename: exports_external2.string().optional()
});
var FileIdObjectSchema = exports_external2.object({
  id: exports_external2.string().describe("OpenAI file ID referencing uploaded content"),
  filename: exports_external2.string().optional()
});
var FileReferenceSchema = exports_external2.union([
  exports_external2.string().describe("Existing data URL or base64 string"),
  FileDataObjectSchema,
  FileUrlObjectSchema,
  FileIdObjectSchema
]).describe("Inline data (with metadata) or references pointing to file contents.");
var zStringWithHints = (..._hints) => exports_external2.string();
var ToolOutputImage = SharedBase.extend({
  type: exports_external2.literal("image"),
  image: exports_external2.string().or(ImageObjectSchema).optional(),
  detail: zStringWithHints("low", "high", "auto").optional()
});
var ToolOutputFileContent = SharedBase.extend({
  type: exports_external2.literal("file"),
  file: FileReferenceSchema
});
var ComputerToolOutput = SharedBase.extend({
  type: exports_external2.literal("computer_screenshot"),
  data: exports_external2.string().describe("Base64 encoded image data or URL")
});
var computerActions = exports_external2.discriminatedUnion("type", [
  exports_external2.object({ type: exports_external2.literal("screenshot") }),
  exports_external2.object({
    type: exports_external2.literal("click"),
    x: exports_external2.number(),
    y: exports_external2.number(),
    button: exports_external2.enum(["left", "right", "wheel", "back", "forward"])
  }),
  exports_external2.object({
    type: exports_external2.literal("double_click"),
    x: exports_external2.number(),
    y: exports_external2.number()
  }),
  exports_external2.object({
    type: exports_external2.literal("scroll"),
    x: exports_external2.number(),
    y: exports_external2.number(),
    scroll_x: exports_external2.number(),
    scroll_y: exports_external2.number()
  }),
  exports_external2.object({
    type: exports_external2.literal("type"),
    text: exports_external2.string()
  }),
  exports_external2.object({ type: exports_external2.literal("wait") }),
  exports_external2.object({
    type: exports_external2.literal("move"),
    x: exports_external2.number(),
    y: exports_external2.number()
  }),
  exports_external2.object({
    type: exports_external2.literal("keypress"),
    keys: exports_external2.array(exports_external2.string())
  }),
  exports_external2.object({
    type: exports_external2.literal("drag"),
    path: exports_external2.array(exports_external2.object({ x: exports_external2.number(), y: exports_external2.number() }))
  })
]);
var AssistantContent = exports_external2.discriminatedUnion("type", [
  OutputText,
  Refusal,
  AudioContent,
  ImageContent
]);
var MessageBase = ItemBase.extend({
  type: exports_external2.literal("message").optional()
});
var AssistantMessageItem = MessageBase.extend({
  role: exports_external2.literal("assistant"),
  status: exports_external2.enum(["in_progress", "completed", "incomplete"]),
  content: exports_external2.array(AssistantContent)
});
var UserContent = exports_external2.discriminatedUnion("type", [
  InputText,
  InputImage,
  InputFile,
  AudioContent
]);
var UserMessageItem = MessageBase.extend({
  role: exports_external2.literal("user"),
  content: exports_external2.array(UserContent).or(exports_external2.string())
});
var SystemMessageItem = MessageBase.extend({
  role: exports_external2.literal("system"),
  content: exports_external2.string()
});
var MessageItem = exports_external2.discriminatedUnion("role", [
  SystemMessageItem,
  AssistantMessageItem,
  UserMessageItem
]);
var HostedToolCallItem = ItemBase.extend({
  type: exports_external2.literal("hosted_tool_call"),
  name: exports_external2.string().describe("The name of the hosted tool"),
  arguments: exports_external2.string().describe("The arguments of the hosted tool call").optional(),
  status: exports_external2.string().optional(),
  output: exports_external2.string().optional()
});
var FunctionCallItem = ItemBase.extend({
  type: exports_external2.literal("function_call"),
  callId: exports_external2.string().describe("The ID of the tool call"),
  name: exports_external2.string().describe("The name of the function"),
  status: exports_external2.enum(["in_progress", "completed", "incomplete"]).optional(),
  arguments: exports_external2.string()
});
var ToolCallOutputContent = exports_external2.discriminatedUnion("type", [
  ToolOutputText,
  ToolOutputImage,
  ToolOutputFileContent
]);
var ToolCallStructuredOutput = exports_external2.discriminatedUnion("type", [
  InputText,
  InputImage,
  InputFile
]);
var FunctionCallResultItem = ItemBase.extend({
  type: exports_external2.literal("function_call_result"),
  name: exports_external2.string().describe("The name of the tool"),
  callId: exports_external2.string().describe("The ID of the tool call"),
  status: exports_external2.enum(["in_progress", "completed", "incomplete"]),
  output: exports_external2.union([
    exports_external2.string(),
    ToolCallOutputContent,
    exports_external2.array(ToolCallStructuredOutput)
  ]).describe("Output returned by the tool call. Supports plain strings, legacy ToolOutput items, or structured input_* items.")
});
var ComputerUseCallItem = ItemBase.extend({
  type: exports_external2.literal("computer_call"),
  callId: exports_external2.string().describe("The ID of the computer call"),
  status: exports_external2.enum(["in_progress", "completed", "incomplete"]),
  action: computerActions
});
var ComputerCallResultItem = ItemBase.extend({
  type: exports_external2.literal("computer_call_result"),
  callId: exports_external2.string().describe("The ID of the computer call"),
  output: ComputerToolOutput
});
var ShellAction = exports_external2.object({
  commands: exports_external2.array(exports_external2.string()),
  timeoutMs: exports_external2.number().int().min(0).optional(),
  maxOutputLength: exports_external2.number().int().min(0).optional()
});
var ShellCallItem = ItemBase.extend({
  type: exports_external2.literal("shell_call"),
  callId: exports_external2.string(),
  status: exports_external2.enum(["in_progress", "completed", "incomplete"]).optional(),
  action: ShellAction
});
var ShellCallOutcome = exports_external2.discriminatedUnion("type", [
  exports_external2.object({ type: exports_external2.literal("timeout") }),
  exports_external2.object({
    type: exports_external2.literal("exit"),
    exitCode: exports_external2.number().int().nullable()
  })
]);
var ShellCallOutputContent = exports_external2.object({
  stdout: exports_external2.string(),
  stderr: exports_external2.string(),
  outcome: ShellCallOutcome
}).passthrough();
var ShellCallResultItem = ItemBase.extend({
  type: exports_external2.literal("shell_call_output"),
  callId: exports_external2.string(),
  maxOutputLength: exports_external2.number().optional(),
  output: exports_external2.array(ShellCallOutputContent)
});
var ApplyPatchOperationCreateFile = exports_external2.object({
  type: exports_external2.literal("create_file"),
  path: exports_external2.string(),
  diff: exports_external2.string()
});
var ApplyPatchOperationUpdateFile = exports_external2.object({
  type: exports_external2.literal("update_file"),
  path: exports_external2.string(),
  diff: exports_external2.string()
});
var ApplyPatchOperationDeleteFile = exports_external2.object({
  type: exports_external2.literal("delete_file"),
  path: exports_external2.string()
});
var ApplyPatchOperation = exports_external2.discriminatedUnion("type", [
  ApplyPatchOperationCreateFile,
  ApplyPatchOperationUpdateFile,
  ApplyPatchOperationDeleteFile
]);
var ApplyPatchCallItem = ItemBase.extend({
  type: exports_external2.literal("apply_patch_call"),
  callId: exports_external2.string(),
  status: exports_external2.enum(["in_progress", "completed"]),
  operation: ApplyPatchOperation
});
var ApplyPatchCallResultItem = ItemBase.extend({
  type: exports_external2.literal("apply_patch_call_output"),
  callId: exports_external2.string(),
  status: exports_external2.enum(["completed", "failed"]),
  output: exports_external2.string().optional()
});
var ToolCallItem = exports_external2.discriminatedUnion("type", [
  ComputerUseCallItem,
  ShellCallItem,
  ApplyPatchCallItem,
  FunctionCallItem,
  HostedToolCallItem
]);
var ReasoningItem = SharedBase.extend({
  id: exports_external2.string().optional(),
  type: exports_external2.literal("reasoning"),
  content: exports_external2.array(InputText),
  rawContent: exports_external2.array(ReasoningText).optional()
});
var UnknownItem = ItemBase.extend({
  type: exports_external2.literal("unknown")
});
var OutputModelItem = exports_external2.discriminatedUnion("type", [
  AssistantMessageItem,
  HostedToolCallItem,
  FunctionCallItem,
  ComputerUseCallItem,
  ShellCallItem,
  ApplyPatchCallItem,
  FunctionCallResultItem,
  ShellCallResultItem,
  ApplyPatchCallResultItem,
  ReasoningItem,
  UnknownItem
]);
var ModelItem = exports_external2.union([
  UserMessageItem,
  AssistantMessageItem,
  SystemMessageItem,
  HostedToolCallItem,
  FunctionCallItem,
  ComputerUseCallItem,
  ShellCallItem,
  ApplyPatchCallItem,
  FunctionCallResultItem,
  ComputerCallResultItem,
  ShellCallResultItem,
  ApplyPatchCallResultItem,
  ReasoningItem,
  UnknownItem
]);
var RequestUsageData = exports_external2.object({
  inputTokens: exports_external2.number(),
  outputTokens: exports_external2.number(),
  totalTokens: exports_external2.number(),
  inputTokensDetails: exports_external2.record(exports_external2.string(), exports_external2.number()).optional(),
  outputTokensDetails: exports_external2.record(exports_external2.string(), exports_external2.number()).optional()
});
var UsageData = exports_external2.object({
  requests: exports_external2.number().optional(),
  inputTokens: exports_external2.number(),
  outputTokens: exports_external2.number(),
  totalTokens: exports_external2.number(),
  inputTokensDetails: exports_external2.union([
    exports_external2.record(exports_external2.string(), exports_external2.number()),
    exports_external2.array(exports_external2.record(exports_external2.string(), exports_external2.number()))
  ]).optional(),
  outputTokensDetails: exports_external2.union([
    exports_external2.record(exports_external2.string(), exports_external2.number()),
    exports_external2.array(exports_external2.record(exports_external2.string(), exports_external2.number()))
  ]).optional(),
  requestUsageEntries: exports_external2.array(RequestUsageData).optional()
});
var StreamEventTextStream = SharedBase.extend({
  type: exports_external2.literal("output_text_delta"),
  delta: exports_external2.string()
});
var StreamEventResponseStarted = SharedBase.extend({
  type: exports_external2.literal("response_started")
});
var StreamEventResponseCompleted = SharedBase.extend({
  type: exports_external2.literal("response_done"),
  response: SharedBase.extend({
    id: exports_external2.string(),
    usage: UsageData,
    output: exports_external2.array(OutputModelItem)
  })
});
var StreamEventGenericItem = SharedBase.extend({
  type: exports_external2.literal("model"),
  event: exports_external2.any().describe("The event from the model")
});
var StreamEvent = exports_external2.discriminatedUnion("type", [
  StreamEventTextStream,
  StreamEventResponseCompleted,
  StreamEventResponseStarted,
  StreamEventGenericItem
]);

// node_modules/@openai/agents-core/dist/usage.mjs
class RequestUsage {
  inputTokens;
  outputTokens;
  totalTokens;
  inputTokensDetails;
  outputTokensDetails;
  constructor(input) {
    this.inputTokens = input?.inputTokens ?? input?.input_tokens ?? 0;
    this.outputTokens = input?.outputTokens ?? input?.output_tokens ?? 0;
    this.totalTokens = input?.totalTokens ?? input?.total_tokens ?? this.inputTokens + this.outputTokens;
    const inputTokensDetails = input?.inputTokensDetails ?? input?.input_tokens_details;
    this.inputTokensDetails = inputTokensDetails ? inputTokensDetails : {};
    const outputTokensDetails = input?.outputTokensDetails ?? input?.output_tokens_details;
    this.outputTokensDetails = outputTokensDetails ? outputTokensDetails : {};
  }
}

class Usage {
  requests;
  inputTokens;
  outputTokens;
  totalTokens;
  inputTokensDetails = [];
  outputTokensDetails = [];
  requestUsageEntries;
  constructor(input) {
    if (typeof input === "undefined") {
      this.requests = 0;
      this.inputTokens = 0;
      this.outputTokens = 0;
      this.totalTokens = 0;
      this.inputTokensDetails = [];
      this.outputTokensDetails = [];
      this.requestUsageEntries = undefined;
    } else {
      this.requests = input?.requests ?? 1;
      this.inputTokens = input?.inputTokens ?? input?.input_tokens ?? 0;
      this.outputTokens = input?.outputTokens ?? input?.output_tokens ?? 0;
      this.totalTokens = input?.totalTokens ?? input?.total_tokens ?? this.inputTokens + this.outputTokens;
      const inputTokensDetails = input?.inputTokensDetails ?? input?.input_tokens_details;
      if (Array.isArray(inputTokensDetails)) {
        this.inputTokensDetails = inputTokensDetails;
      } else {
        this.inputTokensDetails = inputTokensDetails ? [inputTokensDetails] : [];
      }
      const outputTokensDetails = input?.outputTokensDetails ?? input?.output_tokens_details;
      if (Array.isArray(outputTokensDetails)) {
        this.outputTokensDetails = outputTokensDetails;
      } else {
        this.outputTokensDetails = outputTokensDetails ? [outputTokensDetails] : [];
      }
      const requestUsageEntries = input?.requestUsageEntries ?? input?.request_usage_entries;
      const normalizedRequestUsageEntries = Array.isArray(requestUsageEntries) ? requestUsageEntries.map((entry) => entry instanceof RequestUsage ? entry : new RequestUsage(entry)) : undefined;
      this.requestUsageEntries = normalizedRequestUsageEntries && normalizedRequestUsageEntries.length > 0 ? normalizedRequestUsageEntries : undefined;
    }
  }
  add(newUsage) {
    this.requests += newUsage.requests ?? 0;
    this.inputTokens += newUsage.inputTokens ?? 0;
    this.outputTokens += newUsage.outputTokens ?? 0;
    this.totalTokens += newUsage.totalTokens ?? 0;
    if (newUsage.inputTokensDetails) {
      this.inputTokensDetails.push(...newUsage.inputTokensDetails);
    }
    if (newUsage.outputTokensDetails) {
      this.outputTokensDetails.push(...newUsage.outputTokensDetails);
    }
    if (Array.isArray(newUsage.requestUsageEntries) && newUsage.requestUsageEntries.length > 0) {
      this.requestUsageEntries ??= [];
      this.requestUsageEntries.push(...newUsage.requestUsageEntries.map((entry) => entry instanceof RequestUsage ? entry : new RequestUsage(entry)));
    } else if (newUsage.requests === 1 && newUsage.totalTokens > 0) {
      this.requestUsageEntries ??= [];
      this.requestUsageEntries.push(new RequestUsage({
        inputTokens: newUsage.inputTokens,
        outputTokens: newUsage.outputTokens,
        totalTokens: newUsage.totalTokens,
        inputTokensDetails: newUsage.inputTokensDetails?.[0],
        outputTokensDetails: newUsage.outputTokensDetails?.[0]
      }));
    }
  }
}

// node_modules/@openai/agents-core/dist/runContext.mjs
class RunContext {
  context;
  usage;
  #approvals;
  constructor(context = {}) {
    this.context = context;
    this.usage = new Usage;
    this.#approvals = new Map;
  }
  _rebuildApprovals(approvals) {
    this.#approvals = new Map(Object.entries(approvals));
  }
  isToolApproved(approval) {
    const { toolName, callId } = approval;
    const approvalEntry = this.#approvals.get(toolName);
    if (approvalEntry?.approved === true && approvalEntry.rejected === true) {
      logger_default.warn("Tool is permanently approved and rejected at the same time. Approval takes precedence");
      return true;
    }
    if (approvalEntry?.approved === true) {
      return true;
    }
    if (approvalEntry?.rejected === true) {
      return false;
    }
    const individualCallApproval = Array.isArray(approvalEntry?.approved) ? approvalEntry.approved.includes(callId) : false;
    const individualCallRejection = Array.isArray(approvalEntry?.rejected) ? approvalEntry.rejected.includes(callId) : false;
    if (individualCallApproval && individualCallRejection) {
      logger_default.warn(`Tool call ${callId} is both approved and rejected at the same time. Approval takes precedence`);
      return true;
    }
    if (individualCallApproval) {
      return true;
    }
    if (individualCallRejection) {
      return false;
    }
    return;
  }
  approveTool(approvalItem, { alwaysApprove = false } = {}) {
    const toolName = approvalItem.toolName ?? approvalItem.rawItem.name;
    if (alwaysApprove) {
      this.#approvals.set(toolName, {
        approved: true,
        rejected: []
      });
      return;
    }
    const approvalEntry = this.#approvals.get(toolName) ?? {
      approved: [],
      rejected: []
    };
    if (Array.isArray(approvalEntry.approved)) {
      const callId = "callId" in approvalItem.rawItem ? approvalItem.rawItem.callId : approvalItem.rawItem.id;
      approvalEntry.approved.push(callId);
    }
    this.#approvals.set(toolName, approvalEntry);
  }
  rejectTool(approvalItem, { alwaysReject = false } = {}) {
    const toolName = approvalItem.toolName ?? approvalItem.rawItem.name;
    if (alwaysReject) {
      this.#approvals.set(toolName, {
        approved: false,
        rejected: true
      });
      return;
    }
    const approvalEntry = this.#approvals.get(toolName) ?? {
      approved: [],
      rejected: []
    };
    if (Array.isArray(approvalEntry.rejected)) {
      const callId = "callId" in approvalItem.rawItem ? approvalItem.rawItem.callId : approvalItem.rawItem.id;
      approvalEntry.rejected.push(callId);
    }
    this.#approvals.set(toolName, approvalEntry);
  }
  toJSON() {
    return {
      context: this.context,
      usage: this.usage,
      approvals: Object.fromEntries(this.#approvals.entries())
    };
  }
}

// node_modules/@openai/agents-core/dist/utils/serialize.mjs
function serializeTool(tool2) {
  if (tool2.type === "function") {
    return {
      type: "function",
      name: tool2.name,
      description: tool2.description,
      parameters: tool2.parameters,
      strict: tool2.strict
    };
  }
  if (tool2.type === "computer") {
    return {
      type: "computer",
      name: tool2.name,
      environment: tool2.computer.environment,
      dimensions: tool2.computer.dimensions
    };
  }
  if (tool2.type === "shell") {
    return {
      type: "shell",
      name: tool2.name
    };
  }
  if (tool2.type === "apply_patch") {
    return {
      type: "apply_patch",
      name: tool2.name
    };
  }
  return {
    type: "hosted_tool",
    name: tool2.name,
    providerData: tool2.providerData
  };
}
function serializeHandoff(h) {
  return {
    toolName: h.toolName,
    toolDescription: h.toolDescription,
    inputJsonSchema: h.inputJsonSchema,
    strictJsonSchema: h.strictJsonSchema
  };
}

// node_modules/@openai/agents-core/dist/items.mjs
class RunItemBase {
  type = "base_item";
  rawItem;
  toJSON() {
    return {
      type: this.type,
      rawItem: this.rawItem
    };
  }
}

class RunMessageOutputItem extends RunItemBase {
  rawItem;
  agent;
  type = "message_output_item";
  constructor(rawItem, agent) {
    super();
    this.rawItem = rawItem;
    this.agent = agent;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      agent: this.agent.toJSON()
    };
  }
  get content() {
    let content = "";
    for (const part of this.rawItem.content) {
      if (part.type === "output_text") {
        content += part.text;
      }
    }
    return content;
  }
}

class RunToolCallItem extends RunItemBase {
  rawItem;
  agent;
  type = "tool_call_item";
  constructor(rawItem, agent) {
    super();
    this.rawItem = rawItem;
    this.agent = agent;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      agent: this.agent.toJSON()
    };
  }
}

class RunToolCallOutputItem extends RunItemBase {
  rawItem;
  agent;
  output;
  type = "tool_call_output_item";
  constructor(rawItem, agent, output) {
    super();
    this.rawItem = rawItem;
    this.agent = agent;
    this.output = output;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      agent: this.agent.toJSON(),
      output: toSmartString(this.output)
    };
  }
}

class RunReasoningItem extends RunItemBase {
  rawItem;
  agent;
  type = "reasoning_item";
  constructor(rawItem, agent) {
    super();
    this.rawItem = rawItem;
    this.agent = agent;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      agent: this.agent.toJSON()
    };
  }
}

class RunHandoffCallItem extends RunItemBase {
  rawItem;
  agent;
  type = "handoff_call_item";
  constructor(rawItem, agent) {
    super();
    this.rawItem = rawItem;
    this.agent = agent;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      agent: this.agent.toJSON()
    };
  }
}

class RunHandoffOutputItem extends RunItemBase {
  rawItem;
  sourceAgent;
  targetAgent;
  type = "handoff_output_item";
  constructor(rawItem, sourceAgent, targetAgent) {
    super();
    this.rawItem = rawItem;
    this.sourceAgent = sourceAgent;
    this.targetAgent = targetAgent;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      sourceAgent: this.sourceAgent.toJSON(),
      targetAgent: this.targetAgent.toJSON()
    };
  }
}

class RunToolApprovalItem extends RunItemBase {
  rawItem;
  agent;
  toolName;
  type = "tool_approval_item";
  constructor(rawItem, agent, toolName) {
    super();
    this.rawItem = rawItem;
    this.agent = agent;
    this.toolName = toolName;
    this.toolName = toolName ?? rawItem.name;
  }
  get name() {
    return this.toolName ?? this.rawItem.name;
  }
  get arguments() {
    return "arguments" in this.rawItem ? this.rawItem.arguments : undefined;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      agent: this.agent.toJSON(),
      toolName: this.toolName
    };
  }
}

// node_modules/@openai/agents-core/dist/tracing/createSpans.mjs
function _withSpanFactory(createSpan) {
  return async (fn, ...args) => {
    return withNewSpanContext(async () => {
      const span = createSpan(...args);
      setCurrentSpan(span);
      try {
        span.start();
        return await fn(span);
      } catch (error47) {
        span.setError({
          message: error47.message,
          data: error47.data
        });
        throw error47;
      } finally {
        span.end();
        resetCurrentSpan();
      }
    });
  };
}
function createResponseSpan(options, parent) {
  options = {};
  return getGlobalTraceProvider().createSpan({
    ...options,
    data: {
      type: "response",
      ...options.data
    }
  }, parent);
}
var withResponseSpan = _withSpanFactory(createResponseSpan);
function createAgentSpan(options, parent) {
  return getGlobalTraceProvider().createSpan({
    ...options,
    data: {
      type: "agent",
      name: options?.data?.name ?? "Agent",
      ...options?.data
    }
  }, parent);
}
var withAgentSpan = _withSpanFactory(createAgentSpan);
function createFunctionSpan(options, parent) {
  return getGlobalTraceProvider().createSpan({
    ...options,
    data: {
      type: "function",
      input: options?.data?.input ?? "",
      output: options?.data?.output ?? "",
      ...options?.data
    }
  }, parent);
}
var withFunctionSpan = _withSpanFactory(createFunctionSpan);
function createHandoffSpan(options, parent) {
  return getGlobalTraceProvider().createSpan({
    ...options,
    data: { type: "handoff", ...options?.data }
  }, parent);
}
var withHandoffSpan = _withSpanFactory(createHandoffSpan);
function createGenerationSpan(options, parent) {
  return getGlobalTraceProvider().createSpan({
    ...options,
    data: {
      type: "generation",
      ...options?.data
    }
  }, parent);
}
var withGenerationSpan = _withSpanFactory(createGenerationSpan);
function createCustomSpan(options, parent) {
  return getGlobalTraceProvider().createSpan({
    ...options,
    data: {
      type: "custom",
      data: {},
      ...options?.data
    }
  }, parent);
}
var withCustomSpan = _withSpanFactory(createCustomSpan);
function createGuardrailSpan(options, parent) {
  return getGlobalTraceProvider().createSpan({
    ...options,
    data: {
      type: "guardrail",
      triggered: false,
      ...options?.data
    }
  }, parent);
}
var withGuardrailSpan = _withSpanFactory(createGuardrailSpan);
function createTranscriptionSpan(options, parent) {
  return getGlobalTraceProvider().createSpan({
    ...options,
    data: {
      type: "transcription",
      ...options.data
    }
  }, parent);
}
var withTranscriptionSpan = _withSpanFactory(createTranscriptionSpan);
function createSpeechSpan(options, parent) {
  return getGlobalTraceProvider().createSpan({
    ...options,
    data: {
      type: "speech",
      ...options.data
    }
  }, parent);
}
var withSpeechSpan = _withSpanFactory(createSpeechSpan);
function createSpeechGroupSpan(options, parent) {
  return getGlobalTraceProvider().createSpan({
    ...options,
    data: {
      type: "speech_group",
      ...options?.data
    }
  }, parent);
}
var withSpeechGroupSpan = _withSpanFactory(createSpeechGroupSpan);
function createMCPListToolsSpan(options, parent) {
  return getGlobalTraceProvider().createSpan({
    ...options,
    data: {
      type: "mcp_tools",
      ...options?.data
    }
  }, parent);
}
var withMCPListToolsSpan = _withSpanFactory(createMCPListToolsSpan);

// node_modules/@openai/agents-core/dist/utils/base64.mjs
function encodeUint8ArrayToBase64(data) {
  if (data.length === 0) {
    return "";
  }
  const globalBuffer = typeof globalThis !== "undefined" && globalThis.Buffer ? globalThis.Buffer : undefined;
  if (globalBuffer) {
    return globalBuffer.from(data).toString("base64");
  }
  let binary = "";
  for (let i2 = 0;i2 < data.length; i2 += 1) {
    binary += String.fromCharCode(data[i2]);
  }
  if (typeof globalThis.btoa === "function") {
    return globalThis.btoa(binary);
  }
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  let result = "";
  let i = 0;
  while (i < binary.length) {
    const c1 = binary.charCodeAt(i++);
    const c2 = binary.charCodeAt(i++);
    const c3 = binary.charCodeAt(i++);
    const enc1 = c1 >> 2;
    const enc2 = (c1 & 3) << 4 | c2 >> 4;
    const enc3 = isNaN(c2) ? 64 : (c2 & 15) << 2 | c3 >> 6;
    const enc4 = isNaN(c3) ? 64 : c3 & 63;
    result += chars.charAt(enc1) + chars.charAt(enc2) + chars.charAt(enc3) + chars.charAt(enc4);
  }
  return result;
}

// node_modules/@openai/agents-core/dist/events.mjs
class RunRawModelStreamEvent {
  data;
  type = "raw_model_stream_event";
  constructor(data) {
    this.data = data;
  }
}

class RunItemStreamEvent {
  name;
  item;
  type = "run_item_stream_event";
  constructor(name, item) {
    this.name = name;
    this.item = item;
  }
}

class RunAgentUpdatedStreamEvent {
  agent;
  type = "agent_updated_stream_event";
  constructor(agent) {
    this.agent = agent;
  }
}
// node_modules/@openai/agents-core/dist/runImplementation.mjs
function isApprovalItemLike(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (!("rawItem" in value)) {
    return false;
  }
  const rawItem = value.rawItem;
  if (!rawItem || typeof rawItem !== "object") {
    return false;
  }
  const itemType = rawItem.type;
  return itemType === "function_call" || itemType === "hosted_tool_call";
}
function getApprovalIdentity(approval) {
  const rawItem = approval.rawItem;
  if (!rawItem) {
    return;
  }
  if (rawItem.type === "function_call" && rawItem.callId) {
    return `function_call:${rawItem.callId}`;
  }
  if ("callId" in rawItem && rawItem.callId) {
    return `${rawItem.type}:${rawItem.callId}`;
  }
  const id = "id" in rawItem ? rawItem.id : undefined;
  if (id) {
    return `${rawItem.type}:${id}`;
  }
  const providerData = typeof rawItem.providerData === "object" && rawItem.providerData ? rawItem.providerData : undefined;
  if (providerData?.id) {
    return `${rawItem.type}:provider:${providerData.id}`;
  }
  const agentName = "agent" in approval && approval.agent ? approval.agent.name : "";
  try {
    return `${agentName}:${rawItem.type}:${JSON.stringify(rawItem)}`;
  } catch {
    return `${agentName}:${rawItem.type}`;
  }
}
function formatFinalOutputTypeError(error47) {
  try {
    if (error47 instanceof exports_external2.ZodError) {
      const issue2 = error47.issues[0];
      if (issue2) {
        const issuePathParts = Array.isArray(issue2.path) ? issue2.path : [];
        const issuePath = issuePathParts.length > 0 ? issuePathParts.map((part) => String(part)).join(".") : "(root)";
        const message = truncateForDeveloper(issue2.message ?? "");
        return `Invalid output type: final assistant output failed schema validation at "${issuePath}" (${message}).`;
      }
      return "Invalid output type: final assistant output failed schema validation.";
    }
    if (error47 instanceof Error && error47.message) {
      return `Invalid output type: ${truncateForDeveloper(error47.message)}`;
    }
  } catch {}
  return "Invalid output type: final assistant output did not match the expected schema.";
}
function truncateForDeveloper(message, maxLength = 160) {
  const trimmed = message.trim();
  if (!trimmed) {
    return "Schema validation failed.";
  }
  if (trimmed.length <= maxLength) {
    return trimmed;
  }
  return `${trimmed.slice(0, maxLength - 3)}...`;
}
function processModelResponse(modelResponse, agent, tools, handoffs) {
  const items = [];
  const runHandoffs = [];
  const runFunctions = [];
  const runComputerActions = [];
  const runShellActions = [];
  const runApplyPatchActions = [];
  const runMCPApprovalRequests = [];
  const toolsUsed = [];
  const handoffMap = new Map(handoffs.map((h) => [h.toolName, h]));
  const functionMap = new Map(tools.filter((t) => t.type === "function").map((t) => [t.name, t]));
  const computerTool = tools.find((t) => t.type === "computer");
  const shellTool = tools.find((t) => t.type === "shell");
  const applyPatchTool = tools.find((t) => t.type === "apply_patch");
  const mcpToolMap = new Map(tools.filter((t) => t.type === "hosted_tool" && t.providerData?.type === "mcp").map((t) => t).map((t) => [t.providerData.server_label, t]));
  for (const output of modelResponse.output) {
    if (output.type === "message") {
      if (output.role === "assistant") {
        items.push(new RunMessageOutputItem(output, agent));
      }
    } else if (output.type === "hosted_tool_call") {
      items.push(new RunToolCallItem(output, agent));
      const toolName = output.name;
      toolsUsed.push(toolName);
      if (output.providerData?.type === "mcp_approval_request" || output.name === "mcp_approval_request") {
        const providerData = output.providerData;
        const mcpServerLabel = providerData.server_label;
        const mcpServerTool = mcpToolMap.get(mcpServerLabel);
        if (typeof mcpServerTool === "undefined") {
          const message = `MCP server (${mcpServerLabel}) not found in Agent (${agent.name})`;
          addErrorToCurrentSpan({
            message,
            data: { mcp_server_label: mcpServerLabel }
          });
          throw new ModelBehaviorError(message);
        }
        const approvalItem = new RunToolApprovalItem({
          type: "hosted_tool_call",
          name: providerData.name,
          id: providerData.id,
          status: "in_progress",
          providerData
        }, agent);
        runMCPApprovalRequests.push({
          requestItem: approvalItem,
          mcpTool: mcpServerTool
        });
        if (!mcpServerTool.providerData.on_approval) {
          items.push(approvalItem);
        }
      }
    } else if (output.type === "reasoning") {
      items.push(new RunReasoningItem(output, agent));
    } else if (output.type === "computer_call") {
      items.push(new RunToolCallItem(output, agent));
      toolsUsed.push("computer_use");
      if (!computerTool) {
        addErrorToCurrentSpan({
          message: "Model produced computer action without a computer tool.",
          data: {
            agent_name: agent.name
          }
        });
        throw new ModelBehaviorError("Model produced computer action without a computer tool.");
      }
      runComputerActions.push({
        toolCall: output,
        computer: computerTool
      });
    } else if (output.type === "shell_call") {
      items.push(new RunToolCallItem(output, agent));
      toolsUsed.push("shell");
      if (!shellTool) {
        addErrorToCurrentSpan({
          message: "Model produced shell action without a shell tool.",
          data: {
            agent_name: agent.name
          }
        });
        throw new ModelBehaviorError("Model produced shell action without a shell tool.");
      }
      runShellActions.push({
        toolCall: output,
        shell: shellTool
      });
    } else if (output.type === "apply_patch_call") {
      items.push(new RunToolCallItem(output, agent));
      toolsUsed.push("apply_patch");
      if (!applyPatchTool) {
        addErrorToCurrentSpan({
          message: "Model produced apply_patch action without an apply_patch tool.",
          data: {
            agent_name: agent.name
          }
        });
        throw new ModelBehaviorError("Model produced apply_patch action without an apply_patch tool.");
      }
      runApplyPatchActions.push({
        toolCall: output,
        applyPatch: applyPatchTool
      });
    }
    if (output.type !== "function_call") {
      continue;
    }
    toolsUsed.push(output.name);
    const handoff2 = handoffMap.get(output.name);
    if (handoff2) {
      items.push(new RunHandoffCallItem(output, agent));
      runHandoffs.push({
        toolCall: output,
        handoff: handoff2
      });
    } else {
      const functionTool = functionMap.get(output.name);
      if (!functionTool) {
        addErrorToCurrentSpan({
          message: `Tool ${output.name} not found in agent ${agent.name}.`,
          data: {
            tool_name: output.name,
            agent_name: agent.name
          }
        });
        throw new ModelBehaviorError(`Tool ${output.name} not found in agent ${agent.name}.`);
      }
      items.push(new RunToolCallItem(output, agent));
      runFunctions.push({
        toolCall: output,
        tool: functionTool
      });
    }
  }
  return {
    newItems: items,
    handoffs: runHandoffs,
    functions: runFunctions,
    computerActions: runComputerActions,
    shellActions: runShellActions,
    applyPatchActions: runApplyPatchActions,
    mcpApprovalRequests: runMCPApprovalRequests,
    toolsUsed,
    hasToolsOrApprovalsToRun() {
      return runHandoffs.length > 0 || runFunctions.length > 0 || runMCPApprovalRequests.length > 0 || runComputerActions.length > 0 || runShellActions.length > 0 || runApplyPatchActions.length > 0;
    }
  };
}
var nextStepSchema = exports_external2.discriminatedUnion("type", [
  exports_external2.object({
    type: exports_external2.literal("next_step_handoff"),
    newAgent: exports_external2.any()
  }),
  exports_external2.object({
    type: exports_external2.literal("next_step_final_output"),
    output: exports_external2.string()
  }),
  exports_external2.object({
    type: exports_external2.literal("next_step_run_again")
  }),
  exports_external2.object({
    type: exports_external2.literal("next_step_interruption"),
    data: exports_external2.record(exports_external2.string(), exports_external2.any())
  })
]);

class SingleStepResult {
  originalInput;
  modelResponse;
  preStepItems;
  newStepItems;
  nextStep;
  constructor(originalInput, modelResponse, preStepItems, newStepItems, nextStep) {
    this.originalInput = originalInput;
    this.modelResponse = modelResponse;
    this.preStepItems = preStepItems;
    this.newStepItems = newStepItems;
    this.nextStep = nextStep;
  }
  get generatedItems() {
    return this.preStepItems.concat(this.newStepItems);
  }
}
function maybeResetToolChoice(agent, toolUseTracker, modelSettings) {
  if (agent.resetToolChoice && toolUseTracker.hasUsedTools(agent)) {
    return { ...modelSettings, toolChoice: undefined };
  }
  return modelSettings;
}
async function resolveInterruptedTurn(agent, originalInput, originalPreStepItems, newResponse, processedResponse, runner, state) {
  const functionCallIds = originalPreStepItems.filter((item) => item instanceof RunToolApprovalItem && ("callId" in item.rawItem) && item.rawItem.type === "function_call").map((item) => item.rawItem.callId);
  const pendingApprovalItems = state.getInterruptions().filter(isApprovalItemLike);
  if (pendingApprovalItems.length > 0) {
    const pendingApprovalIdentities = new Set;
    for (const approval of pendingApprovalItems) {
      const identity = getApprovalIdentity(approval);
      if (identity) {
        pendingApprovalIdentities.add(identity);
      }
    }
    if (pendingApprovalIdentities.size > 0) {
      let rewindCount = 0;
      for (let index = originalPreStepItems.length - 1;index >= 0; index--) {
        const item = originalPreStepItems[index];
        if (!(item instanceof RunToolApprovalItem)) {
          continue;
        }
        const identity = getApprovalIdentity(item);
        if (!identity) {
          continue;
        }
        if (!pendingApprovalIdentities.has(identity)) {
          continue;
        }
        rewindCount++;
        pendingApprovalIdentities.delete(identity);
        if (pendingApprovalIdentities.size === 0) {
          break;
        }
      }
      if (rewindCount > 0) {
        state._currentTurnPersistedItemCount = Math.max(0, state._currentTurnPersistedItemCount - rewindCount);
      }
    }
  }
  const functionToolRuns = processedResponse.functions.filter((run) => {
    return functionCallIds.includes(run.toolCall.callId);
  });
  const functionResults = await executeFunctionToolCalls(agent, functionToolRuns, runner, state);
  const computerResults = processedResponse.computerActions.length > 0 ? await executeComputerActions(agent, processedResponse.computerActions, runner, state._context) : [];
  const originalPreStepItemSet = new Set(originalPreStepItems);
  const newItems = [];
  const newItemsSet = new Set;
  const appendIfNew = (item) => {
    if (originalPreStepItemSet.has(item) || newItemsSet.has(item)) {
      return;
    }
    newItems.push(item);
    newItemsSet.add(item);
  };
  for (const result of functionResults) {
    appendIfNew(result.runItem);
  }
  for (const result of computerResults) {
    appendIfNew(result);
  }
  const mcpApprovalRuns = processedResponse.mcpApprovalRequests.filter((run) => {
    return run.requestItem.type === "tool_approval_item" && run.requestItem.rawItem.type === "hosted_tool_call" && run.requestItem.rawItem.providerData?.type === "mcp_approval_request";
  });
  const pendingHostedMCPApprovals = new Set;
  const pendingHostedMCPApprovalIds = new Set;
  for (const run of mcpApprovalRuns) {
    const rawItem = run.requestItem.rawItem;
    if (rawItem.type !== "hosted_tool_call") {
      continue;
    }
    const approvalRequestId = rawItem.id;
    const approved = state._context.isToolApproved({
      toolName: rawItem.name,
      callId: approvalRequestId
    });
    if (typeof approved !== "undefined") {
      const providerData = {
        approve: approved,
        approval_request_id: approvalRequestId,
        reason: undefined
      };
      const responseItem = new RunToolCallItem({
        type: "hosted_tool_call",
        name: "mcp_approval_response",
        providerData
      }, agent);
      appendIfNew(responseItem);
    } else {
      pendingHostedMCPApprovals.add(run.requestItem);
      pendingHostedMCPApprovalIds.add(approvalRequestId);
      functionResults.push({
        type: "hosted_mcp_tool_approval",
        tool: run.mcpTool,
        runItem: run.requestItem
      });
      appendIfNew(run.requestItem);
    }
  }
  const preStepItems = originalPreStepItems.filter((item) => {
    if (!(item instanceof RunToolApprovalItem)) {
      return true;
    }
    if (item.rawItem.type === "hosted_tool_call" && item.rawItem.providerData?.type === "mcp_approval_request") {
      if (pendingHostedMCPApprovals.has(item)) {
        return true;
      }
      const approvalRequestId = item.rawItem.id;
      if (approvalRequestId) {
        return pendingHostedMCPApprovalIds.has(approvalRequestId);
      }
      return false;
    }
    return false;
  });
  const completedStep = await maybeCompleteTurnFromToolResults({
    agent,
    runner,
    state,
    functionResults,
    originalInput,
    newResponse,
    preStepItems,
    newItems
  });
  if (completedStep) {
    return completedStep;
  }
  return new SingleStepResult(originalInput, newResponse, preStepItems, newItems, { type: "next_step_run_again" });
}
async function resolveTurnAfterModelResponse(agent, originalInput, originalPreStepItems, newResponse, processedResponse, runner, state) {
  const preStepItems = originalPreStepItems;
  const seenItems = new Set(originalPreStepItems);
  const newItems = [];
  const appendIfNew = (item) => {
    if (seenItems.has(item)) {
      return;
    }
    newItems.push(item);
    seenItems.add(item);
  };
  for (const item of processedResponse.newItems) {
    appendIfNew(item);
  }
  const [functionResults, computerResults, shellResults, applyPatchResults] = await Promise.all([
    executeFunctionToolCalls(agent, processedResponse.functions, runner, state),
    executeComputerActions(agent, processedResponse.computerActions, runner, state._context),
    executeShellActions(agent, processedResponse.shellActions, runner, state._context),
    executeApplyPatchOperations(agent, processedResponse.applyPatchActions, runner, state._context)
  ]);
  for (const result of functionResults) {
    appendIfNew(result.runItem);
  }
  for (const item of computerResults) {
    appendIfNew(item);
  }
  for (const item of shellResults) {
    appendIfNew(item);
  }
  for (const item of applyPatchResults) {
    appendIfNew(item);
  }
  if (processedResponse.mcpApprovalRequests.length > 0) {
    for (const approvalRequest of processedResponse.mcpApprovalRequests) {
      const toolData = approvalRequest.mcpTool.providerData;
      const requestData = approvalRequest.requestItem.rawItem.providerData;
      if (toolData.on_approval) {
        const approvalResult = await toolData.on_approval(state._context, approvalRequest.requestItem);
        const approvalResponseData = {
          approve: approvalResult.approve,
          approval_request_id: requestData.id,
          reason: approvalResult.reason
        };
        newItems.push(new RunToolCallItem({
          type: "hosted_tool_call",
          name: "mcp_approval_response",
          providerData: approvalResponseData
        }, agent));
      } else {
        newItems.push(approvalRequest.requestItem);
        const approvalItem = {
          type: "hosted_mcp_tool_approval",
          tool: approvalRequest.mcpTool,
          runItem: new RunToolApprovalItem({
            type: "hosted_tool_call",
            name: requestData.name,
            id: requestData.id,
            arguments: requestData.arguments,
            status: "in_progress",
            providerData: requestData
          }, agent)
        };
        functionResults.push(approvalItem);
      }
    }
  }
  if (processedResponse.handoffs.length > 0) {
    return await executeHandoffCalls(agent, originalInput, preStepItems, newItems, newResponse, processedResponse.handoffs, runner, state._context);
  }
  const completedStep = await maybeCompleteTurnFromToolResults({
    agent,
    runner,
    state,
    functionResults,
    originalInput,
    newResponse,
    preStepItems,
    newItems
  });
  if (completedStep) {
    return completedStep;
  }
  const hadToolCallsOrActions = (processedResponse.functions?.length ?? 0) > 0 || (processedResponse.computerActions?.length ?? 0) > 0 || (processedResponse.shellActions?.length ?? 0) > 0 || (processedResponse.applyPatchActions?.length ?? 0) > 0 || (processedResponse.mcpApprovalRequests?.length ?? 0) > 0 || (processedResponse.handoffs?.length ?? 0) > 0;
  if (hadToolCallsOrActions) {
    return new SingleStepResult(originalInput, newResponse, preStepItems, newItems, { type: "next_step_run_again" });
  }
  const messageItems = newItems.filter((item) => item instanceof RunMessageOutputItem);
  const potentialFinalOutput = messageItems.length > 0 ? getLastTextFromOutputMessage(messageItems[messageItems.length - 1].rawItem) : undefined;
  if (typeof potentialFinalOutput === "undefined") {
    return new SingleStepResult(originalInput, newResponse, preStepItems, newItems, { type: "next_step_run_again" });
  }
  const hasPendingToolsOrApprovals = functionResults.some((result) => result.runItem instanceof RunToolApprovalItem);
  if (!hasPendingToolsOrApprovals) {
    if (agent.outputType === "text") {
      return new SingleStepResult(originalInput, newResponse, preStepItems, newItems, {
        type: "next_step_final_output",
        output: potentialFinalOutput
      });
    }
    if (agent.outputType !== "text" && potentialFinalOutput) {
      const { parser } = getSchemaAndParserFromInputType(agent.outputType, "final_output");
      const [error47] = await safeExecute(() => parser(potentialFinalOutput));
      if (error47) {
        const outputErrorMessage = formatFinalOutputTypeError(error47);
        addErrorToCurrentSpan({
          message: outputErrorMessage,
          data: {
            error: String(error47)
          }
        });
        throw new ModelBehaviorError(outputErrorMessage);
      }
      return new SingleStepResult(originalInput, newResponse, preStepItems, newItems, { type: "next_step_final_output", output: potentialFinalOutput });
    }
  }
  return new SingleStepResult(originalInput, newResponse, preStepItems, newItems, { type: "next_step_run_again" });
}
async function maybeCompleteTurnFromToolResults({ agent, runner, state, functionResults, originalInput, newResponse, preStepItems, newItems }) {
  const toolOutcome = await checkForFinalOutputFromTools(agent, functionResults, state);
  if (toolOutcome.isFinalOutput) {
    runner.emit("agent_end", state._context, agent, toolOutcome.finalOutput);
    agent.emit("agent_end", state._context, toolOutcome.finalOutput);
    return new SingleStepResult(originalInput, newResponse, preStepItems, newItems, {
      type: "next_step_final_output",
      output: toolOutcome.finalOutput
    });
  }
  if (toolOutcome.isInterrupted) {
    return new SingleStepResult(originalInput, newResponse, preStepItems, newItems, {
      type: "next_step_interruption",
      data: {
        interruptions: toolOutcome.interruptions
      }
    });
  }
  return null;
}
function getToolCallOutputItem(toolCall, output) {
  const maybeStructuredOutputs = normalizeStructuredToolOutputs(output);
  if (maybeStructuredOutputs) {
    const structuredItems = maybeStructuredOutputs.map(convertStructuredToolOutputToInputItem);
    return {
      type: "function_call_result",
      name: toolCall.name,
      callId: toolCall.callId,
      status: "completed",
      output: structuredItems
    };
  }
  return {
    type: "function_call_result",
    name: toolCall.name,
    callId: toolCall.callId,
    status: "completed",
    output: {
      type: "text",
      text: toSmartString(output)
    }
  };
}
function normalizeFileValue(value) {
  const directFile = value.file;
  if (typeof directFile === "string" && directFile.length > 0) {
    return directFile;
  }
  const normalizedObject = normalizeFileObjectCandidate(directFile);
  if (normalizedObject) {
    return normalizedObject;
  }
  const legacyValue = normalizeLegacyFileValue(value);
  if (legacyValue) {
    return legacyValue;
  }
  return null;
}
function normalizeFileObjectCandidate(value) {
  if (!isRecord(value)) {
    return null;
  }
  if ("data" in value && value.data !== undefined) {
    const dataValue = value.data;
    const hasStringData = typeof dataValue === "string" && dataValue.length > 0;
    const hasBinaryData = dataValue instanceof Uint8Array && dataValue.length > 0;
    if (!hasStringData && !hasBinaryData) {
      return null;
    }
    if (!isNonEmptyString(value.mediaType) || !isNonEmptyString(value.filename)) {
      return null;
    }
    return {
      data: typeof dataValue === "string" ? dataValue : new Uint8Array(dataValue),
      mediaType: value.mediaType,
      filename: value.filename
    };
  }
  if (isNonEmptyString(value.url)) {
    const result = { url: value.url };
    if (isNonEmptyString(value.filename)) {
      result.filename = value.filename;
    }
    return result;
  }
  const referencedId = isNonEmptyString(value.id) && value.id || isNonEmptyString(value.fileId) && value.fileId;
  if (referencedId) {
    const result = { id: referencedId };
    if (isNonEmptyString(value.filename)) {
      result.filename = value.filename;
    }
    return result;
  }
  return null;
}
function normalizeLegacyFileValue(value) {
  const filename = typeof value.filename === "string" && value.filename.length > 0 ? value.filename : undefined;
  const mediaType = typeof value.mediaType === "string" && value.mediaType.length > 0 ? value.mediaType : undefined;
  if (typeof value.fileData === "string" && value.fileData.length > 0) {
    if (!mediaType || !filename) {
      return null;
    }
    return { data: value.fileData, mediaType, filename };
  }
  if (value.fileData instanceof Uint8Array && value.fileData.length > 0) {
    if (!mediaType || !filename) {
      return null;
    }
    return { data: new Uint8Array(value.fileData), mediaType, filename };
  }
  if (typeof value.fileUrl === "string" && value.fileUrl.length > 0) {
    const result = { url: value.fileUrl };
    if (filename) {
      result.filename = filename;
    }
    return result;
  }
  if (typeof value.fileId === "string" && value.fileId.length > 0) {
    const result = { id: value.fileId };
    if (filename) {
      result.filename = filename;
    }
    return result;
  }
  return null;
}
function isRecord(value) {
  return typeof value === "object" && value !== null;
}
function isNonEmptyString(value) {
  return typeof value === "string" && value.length > 0;
}
function toInlineImageString(data, mediaType) {
  if (typeof data === "string") {
    if (mediaType && !data.startsWith("data:")) {
      return asDataUrl(data, mediaType);
    }
    return data;
  }
  const base644 = encodeUint8ArrayToBase64(data);
  return asDataUrl(base644, mediaType);
}
function asDataUrl(base644, mediaType) {
  return mediaType ? `data:${mediaType};base64,${base644}` : base644;
}
async function executeFunctionToolCalls(agent, toolRuns, runner, state) {
  async function runSingleTool(toolRun) {
    let parsedArgs = toolRun.toolCall.arguments;
    if (toolRun.tool.parameters) {
      if (isZodObject(toolRun.tool.parameters)) {
        parsedArgs = toolRun.tool.parameters.parse(parsedArgs);
      } else {
        parsedArgs = JSON.parse(parsedArgs);
      }
    }
    const needsApproval = await toolRun.tool.needsApproval(state._context, parsedArgs, toolRun.toolCall.callId);
    if (needsApproval) {
      const approval = state._context.isToolApproved({
        toolName: toolRun.tool.name,
        callId: toolRun.toolCall.callId
      });
      if (approval === false) {
        return withFunctionSpan(async (span) => {
          const response = "Tool execution was not approved.";
          span.setError({
            message: response,
            data: {
              tool_name: toolRun.tool.name,
              error: `Tool execution for ${toolRun.toolCall.callId} was manually rejected by user.`
            }
          });
          span.spanData.output = response;
          return {
            type: "function_output",
            tool: toolRun.tool,
            output: response,
            runItem: new RunToolCallOutputItem(getToolCallOutputItem(toolRun.toolCall, response), agent, response)
          };
        }, {
          data: {
            name: toolRun.tool.name
          }
        });
      }
      if (approval !== true) {
        return {
          type: "function_approval",
          tool: toolRun.tool,
          runItem: new RunToolApprovalItem(toolRun.toolCall, agent)
        };
      }
    }
    return withFunctionSpan(async (span) => {
      if (runner.config.traceIncludeSensitiveData) {
        span.spanData.input = toolRun.toolCall.arguments;
      }
      try {
        runner.emit("agent_tool_start", state._context, agent, toolRun.tool, {
          toolCall: toolRun.toolCall
        });
        agent.emit("agent_tool_start", state._context, toolRun.tool, {
          toolCall: toolRun.toolCall
        });
        const toolOutput = await toolRun.tool.invoke(state._context, toolRun.toolCall.arguments, { toolCall: toolRun.toolCall });
        const stringResult = toSmartString(toolOutput);
        runner.emit("agent_tool_end", state._context, agent, toolRun.tool, stringResult, { toolCall: toolRun.toolCall });
        agent.emit("agent_tool_end", state._context, toolRun.tool, stringResult, { toolCall: toolRun.toolCall });
        if (runner.config.traceIncludeSensitiveData) {
          span.spanData.output = stringResult;
        }
        const functionResult = {
          type: "function_output",
          tool: toolRun.tool,
          output: toolOutput,
          runItem: new RunToolCallOutputItem(getToolCallOutputItem(toolRun.toolCall, toolOutput), agent, toolOutput)
        };
        const nestedRunResult = consumeAgentToolRunResult(toolRun.toolCall);
        if (nestedRunResult) {
          functionResult.agentRunResult = nestedRunResult;
          const nestedInterruptions = nestedRunResult.interruptions;
          if (nestedInterruptions.length > 0) {
            functionResult.interruptions = nestedInterruptions;
          }
        }
        return functionResult;
      } catch (error47) {
        span.setError({
          message: "Error running tool",
          data: {
            tool_name: toolRun.tool.name,
            error: String(error47)
          }
        });
        throw error47;
      }
    }, {
      data: {
        name: toolRun.tool.name
      }
    });
  }
  try {
    const results = await Promise.all(toolRuns.map(runSingleTool));
    return results;
  } catch (e) {
    throw new ToolCallError(`Failed to run function tools: ${e}`, e, state);
  }
}
async function _runComputerActionAndScreenshot(computer, toolCall) {
  const action = toolCall.action;
  let screenshot;
  switch (action.type) {
    case "click":
      await computer.click(action.x, action.y, action.button);
      break;
    case "double_click":
      await computer.doubleClick(action.x, action.y);
      break;
    case "drag":
      await computer.drag(action.path.map((p) => [p.x, p.y]));
      break;
    case "keypress":
      await computer.keypress(action.keys);
      break;
    case "move":
      await computer.move(action.x, action.y);
      break;
    case "screenshot":
      screenshot = await computer.screenshot();
      break;
    case "scroll":
      await computer.scroll(action.x, action.y, action.scroll_x, action.scroll_y);
      break;
    case "type":
      await computer.type(action.text);
      break;
    case "wait":
      await computer.wait();
      break;
    default:
      break;
  }
  if (typeof screenshot !== "undefined") {
    return screenshot;
  }
  if (typeof computer.screenshot === "function") {
    screenshot = await computer.screenshot();
    if (typeof screenshot !== "undefined") {
      return screenshot;
    }
  }
  throw new Error("Computer does not implement screenshot()");
}
function toErrorMessage(error47) {
  if (error47 instanceof Error) {
    return error47.message || error47.toString();
  }
  try {
    return JSON.stringify(error47);
  } catch {
    return String(error47);
  }
}
async function executeShellActions(agent, actions, runner, runContext, customLogger = undefined) {
  const _logger = customLogger ?? logger_default;
  const results = [];
  for (const action of actions) {
    const shellTool = action.shell;
    const toolCall = action.toolCall;
    const approvalItem = new RunToolApprovalItem(toolCall, agent, shellTool.name);
    const requiresApproval = await shellTool.needsApproval(runContext, toolCall.action, toolCall.callId);
    if (requiresApproval) {
      if (shellTool.onApproval) {
        const decision = await shellTool.onApproval(runContext, approvalItem);
        if (decision.approve === true) {
          runContext.approveTool(approvalItem);
        } else if (decision.approve === false) {
          runContext.rejectTool(approvalItem);
        }
      }
      const approval = runContext.isToolApproved({
        toolName: shellTool.name,
        callId: toolCall.callId
      });
      if (approval === false) {
        const response = "Tool execution was not approved.";
        const rejectionOutput = {
          stdout: "",
          stderr: response,
          outcome: { type: "exit", exitCode: null }
        };
        results.push(new RunToolCallOutputItem({
          type: "shell_call_output",
          callId: toolCall.callId,
          output: [rejectionOutput]
        }, agent, response));
        continue;
      }
      if (approval !== true) {
        results.push(approvalItem);
        continue;
      }
    }
    runner.emit("agent_tool_start", runContext, agent, shellTool, {
      toolCall
    });
    if (typeof agent.emit === "function") {
      agent.emit("agent_tool_start", runContext, shellTool, { toolCall });
    }
    let shellOutputs;
    const providerMeta = {};
    let maxOutputLength;
    try {
      const shellResult = await shellTool.shell.run(toolCall.action);
      shellOutputs = shellResult.output ?? [];
      if (shellResult.providerData) {
        Object.assign(providerMeta, shellResult.providerData);
      }
      if (typeof shellResult.maxOutputLength === "number") {
        maxOutputLength = shellResult.maxOutputLength;
      }
    } catch (err) {
      const errorText = toErrorMessage(err);
      shellOutputs = [
        {
          stdout: "",
          stderr: errorText,
          outcome: { type: "exit", exitCode: null }
        }
      ];
      _logger.error("Failed to execute shell action:", err);
    }
    shellOutputs = shellOutputs ?? [];
    runner.emit("agent_tool_end", runContext, agent, shellTool, JSON.stringify(shellOutputs), {
      toolCall
    });
    if (typeof agent.emit === "function") {
      agent.emit("agent_tool_end", runContext, shellTool, JSON.stringify(shellOutputs), {
        toolCall
      });
    }
    const rawItem = {
      type: "shell_call_output",
      callId: toolCall.callId,
      output: shellOutputs ?? []
    };
    if (typeof maxOutputLength === "number") {
      rawItem.maxOutputLength = maxOutputLength;
    }
    if (Object.keys(providerMeta).length > 0) {
      rawItem.providerData = providerMeta;
    }
    results.push(new RunToolCallOutputItem(rawItem, agent, rawItem.output));
  }
  return results;
}
async function executeApplyPatchOperations(agent, actions, runner, runContext, customLogger = undefined) {
  const _logger = customLogger ?? logger_default;
  const results = [];
  for (const action of actions) {
    const applyPatchTool = action.applyPatch;
    const toolCall = action.toolCall;
    const approvalItem = new RunToolApprovalItem(toolCall, agent, applyPatchTool.name);
    const requiresApproval = await applyPatchTool.needsApproval(runContext, toolCall.operation, toolCall.callId);
    if (requiresApproval) {
      if (applyPatchTool.onApproval) {
        const decision = await applyPatchTool.onApproval(runContext, approvalItem);
        if (decision.approve === true) {
          runContext.approveTool(approvalItem);
        } else if (decision.approve === false) {
          runContext.rejectTool(approvalItem);
        }
      }
      const approval = runContext.isToolApproved({
        toolName: applyPatchTool.name,
        callId: toolCall.callId
      });
      if (approval === false) {
        const response = "Tool execution was not approved.";
        results.push(new RunToolCallOutputItem({
          type: "apply_patch_call_output",
          callId: toolCall.callId,
          status: "failed",
          output: response
        }, agent, response));
        continue;
      }
      if (approval !== true) {
        results.push(approvalItem);
        continue;
      }
    }
    runner.emit("agent_tool_start", runContext, agent, applyPatchTool, {
      toolCall
    });
    if (typeof agent.emit === "function") {
      agent.emit("agent_tool_start", runContext, applyPatchTool, {
        toolCall
      });
    }
    let status = "completed";
    let output = "";
    try {
      let result;
      switch (toolCall.operation.type) {
        case "create_file":
          result = await applyPatchTool.editor.createFile(toolCall.operation);
          break;
        case "update_file":
          result = await applyPatchTool.editor.updateFile(toolCall.operation);
          break;
        case "delete_file":
          result = await applyPatchTool.editor.deleteFile(toolCall.operation);
          break;
        default:
          throw new Error("Unsupported apply_patch operation");
      }
      if (result && typeof result.status === "string") {
        status = result.status;
      }
      if (result && typeof result.output === "string") {
        output = result.output;
      }
    } catch (err) {
      status = "failed";
      output = toErrorMessage(err);
      _logger.error("Failed to execute apply_patch operation:", err);
    }
    runner.emit("agent_tool_end", runContext, agent, applyPatchTool, output, {
      toolCall
    });
    if (typeof agent.emit === "function") {
      agent.emit("agent_tool_end", runContext, applyPatchTool, output, {
        toolCall
      });
    }
    const rawItem = {
      type: "apply_patch_call_output",
      callId: toolCall.callId,
      status
    };
    if (output) {
      rawItem.output = output;
    }
    results.push(new RunToolCallOutputItem(rawItem, agent, output));
  }
  return results;
}
async function executeComputerActions(agent, actions, runner, runContext, customLogger = undefined) {
  const _logger = customLogger ?? logger_default;
  const results = [];
  for (const action of actions) {
    const computer = action.computer.computer;
    const toolCall = action.toolCall;
    runner.emit("agent_tool_start", runContext, agent, action.computer, {
      toolCall
    });
    if (typeof agent.emit === "function") {
      agent.emit("agent_tool_start", runContext, action.computer, { toolCall });
    }
    let output;
    try {
      output = await _runComputerActionAndScreenshot(computer, toolCall);
    } catch (err) {
      _logger.error("Failed to execute computer action:", err);
      output = "";
    }
    runner.emit("agent_tool_end", runContext, agent, action.computer, output, {
      toolCall
    });
    if (typeof agent.emit === "function") {
      agent.emit("agent_tool_end", runContext, action.computer, output, {
        toolCall
      });
    }
    const imageUrl = output ? `data:image/png;base64,${output}` : "";
    const rawItem = {
      type: "computer_call_result",
      callId: toolCall.callId,
      output: { type: "computer_screenshot", data: imageUrl }
    };
    results.push(new RunToolCallOutputItem(rawItem, agent, imageUrl));
  }
  return results;
}
async function executeHandoffCalls(agent, originalInput, preStepItems, newStepItems, newResponse, runHandoffs, runner, runContext) {
  newStepItems = [...newStepItems];
  if (runHandoffs.length === 0) {
    logger_default.warn("Incorrectly called executeHandoffCalls with no handoffs. This should not happen. Moving on.");
    return new SingleStepResult(originalInput, newResponse, preStepItems, newStepItems, { type: "next_step_run_again" });
  }
  if (runHandoffs.length > 1) {
    const outputMessage = "Multiple handoffs detected, ignoring this one.";
    for (let i = 1;i < runHandoffs.length; i++) {
      newStepItems.push(new RunToolCallOutputItem(getToolCallOutputItem(runHandoffs[i].toolCall, outputMessage), agent, outputMessage));
    }
  }
  const actualHandoff = runHandoffs[0];
  return withHandoffSpan(async (handoffSpan) => {
    const handoff2 = actualHandoff.handoff;
    const newAgent = await handoff2.onInvokeHandoff(runContext, actualHandoff.toolCall.arguments);
    handoffSpan.spanData.to_agent = newAgent.name;
    if (runHandoffs.length > 1) {
      const requestedAgents = runHandoffs.map((h) => h.handoff.agentName);
      handoffSpan.setError({
        message: "Multiple handoffs requested",
        data: {
          requested_agents: requestedAgents
        }
      });
    }
    newStepItems.push(new RunHandoffOutputItem(getToolCallOutputItem(actualHandoff.toolCall, getTransferMessage(newAgent)), agent, newAgent));
    runner.emit("agent_handoff", runContext, agent, newAgent);
    agent.emit("agent_handoff", runContext, newAgent);
    const inputFilter = handoff2.inputFilter ?? runner.config.handoffInputFilter;
    if (inputFilter) {
      logger_default.debug("Filtering inputs for handoff");
      if (typeof inputFilter !== "function") {
        handoffSpan.setError({
          message: "Invalid input filter",
          data: {
            details: "not callable"
          }
        });
      }
      const handoffInputData = {
        inputHistory: Array.isArray(originalInput) ? [...originalInput] : originalInput,
        preHandoffItems: [...preStepItems],
        newItems: [...newStepItems],
        runContext
      };
      const filtered = inputFilter(handoffInputData);
      originalInput = filtered.inputHistory;
      preStepItems = filtered.preHandoffItems;
      newStepItems = filtered.newItems;
    }
    return new SingleStepResult(originalInput, newResponse, preStepItems, newStepItems, { type: "next_step_handoff", newAgent });
  }, {
    data: {
      from_agent: agent.name
    }
  });
}
var NOT_FINAL_OUTPUT = {
  isFinalOutput: false,
  isInterrupted: undefined
};
async function checkForFinalOutputFromTools(agent, toolResults, state) {
  if (toolResults.length === 0) {
    return NOT_FINAL_OUTPUT;
  }
  const interruptions = [];
  for (const result of toolResults) {
    if (result.runItem instanceof RunToolApprovalItem) {
      interruptions.push(result.runItem);
    }
    if (result.type === "function_output") {
      if (Array.isArray(result.interruptions)) {
        interruptions.push(...result.interruptions);
      } else if (result.agentRunResult) {
        const nestedInterruptions = result.agentRunResult.interruptions;
        if (nestedInterruptions.length > 0) {
          interruptions.push(...nestedInterruptions);
        }
      }
    }
  }
  if (interruptions.length > 0) {
    return {
      isFinalOutput: false,
      isInterrupted: true,
      interruptions
    };
  }
  if (agent.toolUseBehavior === "run_llm_again") {
    return NOT_FINAL_OUTPUT;
  }
  const firstToolResult = toolResults[0];
  if (agent.toolUseBehavior === "stop_on_first_tool") {
    if (firstToolResult?.type === "function_output") {
      const stringOutput = toSmartString(firstToolResult.output);
      return {
        isFinalOutput: true,
        isInterrupted: undefined,
        finalOutput: stringOutput
      };
    }
    return NOT_FINAL_OUTPUT;
  }
  const toolUseBehavior = agent.toolUseBehavior;
  if (typeof toolUseBehavior === "object") {
    const stoppingTool = toolResults.find((r) => toolUseBehavior.stopAtToolNames.includes(r.tool.name));
    if (stoppingTool?.type === "function_output") {
      const stringOutput = toSmartString(stoppingTool.output);
      return {
        isFinalOutput: true,
        isInterrupted: undefined,
        finalOutput: stringOutput
      };
    }
    return NOT_FINAL_OUTPUT;
  }
  if (typeof toolUseBehavior === "function") {
    return toolUseBehavior(state._context, toolResults);
  }
  throw new UserError(`Invalid toolUseBehavior: ${toolUseBehavior}`, state);
}
function getRunItemStreamEventName(item) {
  if (item instanceof RunMessageOutputItem) {
    return "message_output_created";
  }
  if (item instanceof RunHandoffCallItem) {
    return "handoff_requested";
  }
  if (item instanceof RunHandoffOutputItem) {
    return "handoff_occurred";
  }
  if (item instanceof RunToolCallItem) {
    return "tool_called";
  }
  if (item instanceof RunToolCallOutputItem) {
    return "tool_output";
  }
  if (item instanceof RunReasoningItem) {
    return "reasoning_item_created";
  }
  if (item instanceof RunToolApprovalItem) {
    return "tool_approval_requested";
  }
  return;
}
function enqueueRunItemStreamEvent(result, item) {
  const itemName = getRunItemStreamEventName(item);
  if (!itemName) {
    logger_default.warn("Unknown item type: ", item);
    return;
  }
  result._addItem(new RunItemStreamEvent(itemName, item));
}
function streamStepItemsToRunResult(result, items) {
  for (const item of items) {
    enqueueRunItemStreamEvent(result, item);
  }
}
function addStepToRunResult(result, step, options) {
  const skippedItems = options?.skipItems;
  for (const item of step.newStepItems) {
    if (skippedItems?.has(item)) {
      continue;
    }
    enqueueRunItemStreamEvent(result, item);
  }
}

class AgentToolUseTracker {
  #agentToTools = new Map;
  addToolUse(agent, toolNames) {
    this.#agentToTools.set(agent, toolNames);
  }
  hasUsedTools(agent) {
    return this.#agentToTools.has(agent);
  }
  toJSON() {
    return Object.fromEntries(Array.from(this.#agentToTools.entries()).map(([agent, toolNames]) => {
      return [agent.name, toolNames];
    }));
  }
}
function toInputItemList(input) {
  if (typeof input === "string") {
    return [
      {
        type: "message",
        role: "user",
        content: input
      }
    ];
  }
  return [...input];
}
function extractOutputItemsFromRunItems(items) {
  return items.filter((item) => item.type !== "tool_approval_item").map((item) => item.rawItem);
}
function normalizeItemsForSessionPersistence(items) {
  return items.map((item) => sanitizeValueForSession(stripTransientCallIds(item)));
}
function sanitizeValueForSession(value, context = {}) {
  if (value === null || value === undefined) {
    return value;
  }
  const binary = toUint8ArrayIfBinary(value);
  if (binary) {
    return toDataUrlFromBytes(binary, context.mediaType);
  }
  if (Array.isArray(value)) {
    return value.map((entry) => sanitizeValueForSession(entry, context));
  }
  if (!isPlainObject3(value)) {
    return value;
  }
  const record4 = value;
  const result = {};
  const mediaType = typeof record4.mediaType === "string" && record4.mediaType.length > 0 ? record4.mediaType : context.mediaType;
  for (const [key, entry] of Object.entries(record4)) {
    const nextContext = key === "data" || key === "fileData" ? { mediaType } : context;
    result[key] = sanitizeValueForSession(entry, nextContext);
  }
  return result;
}
function toUint8ArrayIfBinary(value) {
  if (value instanceof ArrayBuffer) {
    return new Uint8Array(value);
  }
  if (isArrayBufferView(value)) {
    const view = value;
    return new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
  }
  if (isNodeBuffer(value)) {
    const view = value;
    return new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
  }
  if (isSerializedBufferSnapshot(value)) {
    const snapshot = value;
    return Uint8Array.from(snapshot.data);
  }
  return;
}
function toDataUrlFromBytes(bytes, mediaType) {
  const base644 = encodeUint8ArrayToBase64(bytes);
  const type = mediaType && !mediaType.startsWith("data:") ? mediaType : "text/plain";
  return `data:${type};base64,${base644}`;
}
function isPlainObject3(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const proto = Object.getPrototypeOf(value);
  return proto === Object.prototype || proto === null;
}
function stripTransientCallIds(value) {
  if (value === null || value === undefined) {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map((entry) => stripTransientCallIds(entry));
  }
  if (!isPlainObject3(value)) {
    return value;
  }
  const record4 = value;
  const result = {};
  const isProtocolItem = typeof record4.type === "string" && record4.type.length > 0;
  const shouldStripId = isProtocolItem && shouldStripIdForType(record4.type);
  for (const [key, entry] of Object.entries(record4)) {
    if (shouldStripId && key === "id") {
      continue;
    }
    result[key] = stripTransientCallIds(entry);
  }
  return result;
}
function shouldStripIdForType(type) {
  switch (type) {
    case "function_call":
    case "function_call_result":
      return true;
    default:
      return false;
  }
}
async function saveToSession(session, sessionInputItems, result) {
  if (!session) {
    return;
  }
  const inputItems = sessionInputItems ?? [];
  const state = result.state;
  const alreadyPersisted = state._currentTurnPersistedItemCount ?? 0;
  const newRunItems = result.newItems.slice(alreadyPersisted);
  if (process.env.OPENAI_AGENTS__DEBUG_SAVE_SESSION) {
    console.debug("saveToSession:newRunItems", newRunItems.map((item) => item.type));
  }
  const outputItems = extractOutputItemsFromRunItems(newRunItems);
  const itemsToSave = [...inputItems, ...outputItems];
  if (itemsToSave.length === 0) {
    state._currentTurnPersistedItemCount = alreadyPersisted + newRunItems.length;
    return;
  }
  const sanitizedItems = normalizeItemsForSessionPersistence(itemsToSave);
  await session.addItems(sanitizedItems);
  state._currentTurnPersistedItemCount = alreadyPersisted + newRunItems.length;
}
async function saveStreamInputToSession(session, sessionInputItems) {
  if (!session) {
    return;
  }
  if (!sessionInputItems || sessionInputItems.length === 0) {
    return;
  }
  const sanitizedInput = normalizeItemsForSessionPersistence(sessionInputItems);
  await session.addItems(sanitizedInput);
}
async function saveStreamResultToSession(session, result) {
  if (!session) {
    return;
  }
  const state = result.state;
  const alreadyPersisted = state._currentTurnPersistedItemCount ?? 0;
  const newRunItems = result.newItems.slice(alreadyPersisted);
  const itemsToSave = extractOutputItemsFromRunItems(newRunItems);
  if (itemsToSave.length === 0) {
    state._currentTurnPersistedItemCount = alreadyPersisted + newRunItems.length;
    return;
  }
  const sanitizedItems = normalizeItemsForSessionPersistence(itemsToSave);
  await session.addItems(sanitizedItems);
  state._currentTurnPersistedItemCount = alreadyPersisted + newRunItems.length;
}
async function prepareInputItemsWithSession(input, session, sessionInputCallback, options) {
  if (!session) {
    return {
      preparedInput: input,
      sessionItems: undefined
    };
  }
  const includeHistoryInPreparedInput = options?.includeHistoryInPreparedInput ?? true;
  const preserveDroppedNewItems = options?.preserveDroppedNewItems ?? false;
  const history = await session.getItems();
  const newInputItems = Array.isArray(input) ? [...input] : toInputItemList(input);
  if (!sessionInputCallback) {
    return {
      preparedInput: includeHistoryInPreparedInput ? [...history, ...newInputItems] : newInputItems,
      sessionItems: newInputItems
    };
  }
  const historySnapshot = history.slice();
  const newInputSnapshot = newInputItems.slice();
  const combined = await sessionInputCallback(history, newInputItems);
  if (!Array.isArray(combined)) {
    throw new UserError("Session input callback must return an array of AgentInputItem objects.");
  }
  const historyCounts = buildItemFrequencyMap(historySnapshot);
  const newInputCounts = buildItemFrequencyMap(newInputSnapshot);
  const historyRefs = buildItemReferenceMap(historySnapshot);
  const newInputRefs = buildItemReferenceMap(newInputSnapshot);
  const appended = [];
  for (const item of combined) {
    const key = sessionItemKey(item);
    if (consumeReference(newInputRefs, key, item)) {
      decrementCount(newInputCounts, key);
      appended.push(item);
      continue;
    }
    if (consumeReference(historyRefs, key, item)) {
      decrementCount(historyCounts, key);
      continue;
    }
    const historyRemaining = historyCounts.get(key) ?? 0;
    if (historyRemaining > 0) {
      historyCounts.set(key, historyRemaining - 1);
      continue;
    }
    const newRemaining = newInputCounts.get(key) ?? 0;
    if (newRemaining > 0) {
      newInputCounts.set(key, newRemaining - 1);
      appended.push(item);
      continue;
    }
    appended.push(item);
  }
  const preparedItems = includeHistoryInPreparedInput ? combined : appended.length > 0 ? appended : preserveDroppedNewItems ? newInputSnapshot : [];
  return {
    preparedInput: preparedItems,
    sessionItems: appended
  };
}
function normalizeStructuredToolOutputs(output) {
  if (Array.isArray(output)) {
    const structured = [];
    for (const item of output) {
      const normalized2 = normalizeStructuredToolOutput(item);
      if (!normalized2) {
        return null;
      }
      structured.push(normalized2);
    }
    return structured;
  }
  const normalized = normalizeStructuredToolOutput(output);
  return normalized ? [normalized] : null;
}
function normalizeStructuredToolOutput(value) {
  if (!isRecord(value)) {
    return null;
  }
  const type = value.type;
  if (type === "text" && typeof value.text === "string") {
    const output = { type: "text", text: value.text };
    if (isRecord(value.providerData)) {
      output.providerData = value.providerData;
    }
    return output;
  }
  if (type === "image") {
    const output = { type: "image" };
    let imageString;
    let imageFileId;
    const fallbackImageMediaType = isNonEmptyString(value.mediaType) ? value.mediaType : undefined;
    const imageField = value.image;
    if (typeof imageField === "string" && imageField.length > 0) {
      imageString = imageField;
    } else if (isRecord(imageField)) {
      const imageObj = imageField;
      const inlineMediaType = isNonEmptyString(imageObj.mediaType) ? imageObj.mediaType : fallbackImageMediaType;
      if (isNonEmptyString(imageObj.url)) {
        imageString = imageObj.url;
      } else if (isNonEmptyString(imageObj.data)) {
        imageString = toInlineImageString(imageObj.data, inlineMediaType);
      } else if (imageObj.data instanceof Uint8Array && imageObj.data.length > 0) {
        imageString = toInlineImageString(imageObj.data, inlineMediaType);
      }
      if (!imageString) {
        const candidateId = isNonEmptyString(imageObj.fileId) && imageObj.fileId || isNonEmptyString(imageObj.id) && imageObj.id || undefined;
        if (candidateId) {
          imageFileId = candidateId;
        }
      }
    }
    if (!imageString && typeof value.imageUrl === "string" && value.imageUrl.length > 0) {
      imageString = value.imageUrl;
    }
    if (!imageFileId && typeof value.fileId === "string" && value.fileId.length > 0) {
      imageFileId = value.fileId;
    }
    if (!imageString && typeof value.data === "string" && value.data.length > 0) {
      imageString = fallbackImageMediaType ? toInlineImageString(value.data, fallbackImageMediaType) : value.data;
    } else if (!imageString && value.data instanceof Uint8Array && value.data.length > 0) {
      imageString = toInlineImageString(value.data, fallbackImageMediaType);
    }
    if (typeof value.detail === "string" && value.detail.length > 0) {
      output.detail = value.detail;
    }
    if (imageString) {
      output.image = imageString;
    } else if (imageFileId) {
      output.image = { fileId: imageFileId };
    } else {
      return null;
    }
    if (isRecord(value.providerData)) {
      output.providerData = value.providerData;
    }
    return output;
  }
  if (type === "file") {
    const fileValue = normalizeFileValue(value);
    if (!fileValue) {
      return null;
    }
    const output = { type: "file", file: fileValue };
    if (isRecord(value.providerData)) {
      output.providerData = value.providerData;
    }
    return output;
  }
  return null;
}
function convertStructuredToolOutputToInputItem(output) {
  if (output.type === "text") {
    const result = {
      type: "input_text",
      text: output.text
    };
    if (output.providerData) {
      result.providerData = output.providerData;
    }
    return result;
  }
  if (output.type === "image") {
    const result = { type: "input_image" };
    if (typeof output.detail === "string" && output.detail.length > 0) {
      result.detail = output.detail;
    }
    if (typeof output.image === "string" && output.image.length > 0) {
      result.image = output.image;
    } else if (isRecord(output.image)) {
      const imageObj = output.image;
      const inlineMediaType = isNonEmptyString(imageObj.mediaType) ? imageObj.mediaType : undefined;
      if (isNonEmptyString(imageObj.url)) {
        result.image = imageObj.url;
      } else if (isNonEmptyString(imageObj.data)) {
        result.image = inlineMediaType && !imageObj.data.startsWith("data:") ? asDataUrl(imageObj.data, inlineMediaType) : imageObj.data;
      } else if (imageObj.data instanceof Uint8Array && imageObj.data.length > 0) {
        const base644 = encodeUint8ArrayToBase64(imageObj.data);
        result.image = asDataUrl(base644, inlineMediaType);
      } else {
        const referencedId = isNonEmptyString(imageObj.fileId) && imageObj.fileId || isNonEmptyString(imageObj.id) && imageObj.id || undefined;
        if (referencedId) {
          result.image = { id: referencedId };
        }
      }
    }
    if (output.providerData) {
      result.providerData = output.providerData;
    }
    return result;
  }
  if (output.type === "file") {
    const result = { type: "input_file" };
    const fileValue = output.file;
    if (typeof fileValue === "string") {
      result.file = fileValue;
    } else if (fileValue && typeof fileValue === "object") {
      const record4 = fileValue;
      if ("data" in record4 && record4.data) {
        const mediaType = record4.mediaType ?? "text/plain";
        if (typeof record4.data === "string") {
          result.file = asDataUrl(record4.data, mediaType);
        } else {
          const base644 = encodeUint8ArrayToBase64(record4.data);
          result.file = asDataUrl(base644, mediaType);
        }
      } else if (typeof record4.url === "string" && record4.url.length > 0) {
        result.file = { url: record4.url };
      } else {
        const referencedId = typeof record4.id === "string" && record4.id.length > 0 && record4.id || (typeof record4.fileId === "string" && record4.fileId.length > 0 ? record4.fileId : undefined);
        if (referencedId) {
          result.file = { id: referencedId };
        }
      }
      if (typeof record4.filename === "string" && record4.filename.length > 0) {
        result.filename = record4.filename;
      }
    }
    if (output.providerData) {
      result.providerData = output.providerData;
    }
    return result;
  }
  const exhaustiveCheck = output;
  return exhaustiveCheck;
}
function buildItemFrequencyMap(items) {
  const counts = new Map;
  for (const item of items) {
    const key = sessionItemKey(item);
    counts.set(key, (counts.get(key) ?? 0) + 1);
  }
  return counts;
}
function buildItemReferenceMap(items) {
  const refs = new Map;
  for (const item of items) {
    const key = sessionItemKey(item);
    const list = refs.get(key);
    if (list) {
      list.push(item);
    } else {
      refs.set(key, [item]);
    }
  }
  return refs;
}
function consumeReference(refs, key, target) {
  const candidates = refs.get(key);
  if (!candidates || candidates.length === 0) {
    return false;
  }
  const index = candidates.findIndex((candidate) => candidate === target);
  if (index === -1) {
    return false;
  }
  candidates.splice(index, 1);
  if (candidates.length === 0) {
    refs.delete(key);
  }
  return true;
}
function decrementCount(map4, key) {
  const remaining = (map4.get(key) ?? 0) - 1;
  if (remaining <= 0) {
    map4.delete(key);
  } else {
    map4.set(key, remaining);
  }
}
function sessionItemKey(item) {
  return JSON.stringify(item, sessionSerializationReplacer);
}
function sessionSerializationReplacer(_key, value) {
  if (value instanceof ArrayBuffer) {
    return {
      __type: "ArrayBuffer",
      data: encodeUint8ArrayToBase64(new Uint8Array(value))
    };
  }
  if (isArrayBufferView(value)) {
    const view = value;
    return {
      __type: view.constructor.name,
      data: encodeUint8ArrayToBase64(new Uint8Array(view.buffer, view.byteOffset, view.byteLength))
    };
  }
  if (isNodeBuffer(value)) {
    const view = value;
    return {
      __type: "Buffer",
      data: encodeUint8ArrayToBase64(new Uint8Array(view.buffer, view.byteOffset, view.byteLength))
    };
  }
  if (isSerializedBufferSnapshot(value)) {
    return {
      __type: "Buffer",
      data: encodeUint8ArrayToBase64(Uint8Array.from(value.data))
    };
  }
  return value;
}

// node_modules/@openai/agents-core/dist/runState.mjs
var CURRENT_SCHEMA_VERSION = "1.0";
var $schemaVersion = exports_external2.literal(CURRENT_SCHEMA_VERSION);
var serializedAgentSchema = exports_external2.object({
  name: exports_external2.string()
});
var serializedSpanBase = exports_external2.object({
  object: exports_external2.literal("trace.span"),
  id: exports_external2.string(),
  trace_id: exports_external2.string(),
  parent_id: exports_external2.string().nullable(),
  started_at: exports_external2.string().nullable(),
  ended_at: exports_external2.string().nullable(),
  error: exports_external2.object({
    message: exports_external2.string(),
    data: exports_external2.record(exports_external2.string(), exports_external2.any()).optional()
  }).nullable(),
  span_data: exports_external2.record(exports_external2.string(), exports_external2.any())
});
var SerializedSpan = serializedSpanBase.extend({
  previous_span: exports_external2.lazy(() => SerializedSpan).optional()
});
var requestUsageSchema = exports_external2.object({
  inputTokens: exports_external2.number(),
  outputTokens: exports_external2.number(),
  totalTokens: exports_external2.number(),
  inputTokensDetails: exports_external2.record(exports_external2.string(), exports_external2.number()).optional(),
  outputTokensDetails: exports_external2.record(exports_external2.string(), exports_external2.number()).optional()
});
var usageSchema = exports_external2.object({
  requests: exports_external2.number(),
  inputTokens: exports_external2.number(),
  outputTokens: exports_external2.number(),
  totalTokens: exports_external2.number(),
  inputTokensDetails: exports_external2.array(exports_external2.record(exports_external2.string(), exports_external2.number())).optional(),
  outputTokensDetails: exports_external2.array(exports_external2.record(exports_external2.string(), exports_external2.number())).optional(),
  requestUsageEntries: exports_external2.array(requestUsageSchema).optional()
});
var modelResponseSchema = exports_external2.object({
  usage: usageSchema,
  output: exports_external2.array(OutputModelItem),
  responseId: exports_external2.string().optional(),
  providerData: exports_external2.record(exports_external2.string(), exports_external2.any()).optional()
});
var itemSchema = exports_external2.discriminatedUnion("type", [
  exports_external2.object({
    type: exports_external2.literal("message_output_item"),
    rawItem: AssistantMessageItem,
    agent: serializedAgentSchema
  }),
  exports_external2.object({
    type: exports_external2.literal("tool_call_item"),
    rawItem: ToolCallItem.or(HostedToolCallItem),
    agent: serializedAgentSchema
  }),
  exports_external2.object({
    type: exports_external2.literal("tool_call_output_item"),
    rawItem: FunctionCallResultItem,
    agent: serializedAgentSchema,
    output: exports_external2.string()
  }),
  exports_external2.object({
    type: exports_external2.literal("reasoning_item"),
    rawItem: ReasoningItem,
    agent: serializedAgentSchema
  }),
  exports_external2.object({
    type: exports_external2.literal("handoff_call_item"),
    rawItem: FunctionCallItem,
    agent: serializedAgentSchema
  }),
  exports_external2.object({
    type: exports_external2.literal("handoff_output_item"),
    rawItem: FunctionCallResultItem,
    sourceAgent: serializedAgentSchema,
    targetAgent: serializedAgentSchema
  }),
  exports_external2.object({
    type: exports_external2.literal("tool_approval_item"),
    rawItem: FunctionCallItem.or(HostedToolCallItem).or(ShellCallItem).or(ApplyPatchCallItem),
    agent: serializedAgentSchema,
    toolName: exports_external2.string().optional()
  })
]);
var serializedTraceSchema = exports_external2.object({
  object: exports_external2.literal("trace"),
  id: exports_external2.string(),
  workflow_name: exports_external2.string(),
  group_id: exports_external2.string().nullable(),
  metadata: exports_external2.record(exports_external2.string(), exports_external2.any())
});
var serializedProcessedResponseSchema = exports_external2.object({
  newItems: exports_external2.array(itemSchema),
  toolsUsed: exports_external2.array(exports_external2.string()),
  handoffs: exports_external2.array(exports_external2.object({
    toolCall: exports_external2.any(),
    handoff: exports_external2.any()
  })),
  functions: exports_external2.array(exports_external2.object({
    toolCall: exports_external2.any(),
    tool: exports_external2.any()
  })),
  computerActions: exports_external2.array(exports_external2.object({
    toolCall: exports_external2.any(),
    computer: exports_external2.any()
  })),
  shellActions: exports_external2.array(exports_external2.object({
    toolCall: exports_external2.any(),
    shell: exports_external2.any()
  })).optional(),
  applyPatchActions: exports_external2.array(exports_external2.object({
    toolCall: exports_external2.any(),
    applyPatch: exports_external2.any()
  })).optional(),
  mcpApprovalRequests: exports_external2.array(exports_external2.object({
    requestItem: exports_external2.object({
      rawItem: exports_external2.object({
        type: exports_external2.literal("hosted_tool_call"),
        name: exports_external2.string(),
        arguments: exports_external2.string().optional(),
        status: exports_external2.string().optional(),
        output: exports_external2.string().optional(),
        providerData: exports_external2.record(exports_external2.string(), exports_external2.any()).nullable().optional()
      })
    }),
    mcpTool: exports_external2.object({
      type: exports_external2.literal("hosted_tool"),
      name: exports_external2.literal("hosted_mcp"),
      providerData: exports_external2.record(exports_external2.string(), exports_external2.any())
    })
  })).optional()
});
var guardrailFunctionOutputSchema = exports_external2.object({
  tripwireTriggered: exports_external2.boolean(),
  outputInfo: exports_external2.any()
});
var inputGuardrailResultSchema = exports_external2.object({
  guardrail: exports_external2.object({
    type: exports_external2.literal("input"),
    name: exports_external2.string()
  }),
  output: guardrailFunctionOutputSchema
});
var outputGuardrailResultSchema = exports_external2.object({
  guardrail: exports_external2.object({
    type: exports_external2.literal("output"),
    name: exports_external2.string()
  }),
  agentOutput: exports_external2.any(),
  agent: serializedAgentSchema,
  output: guardrailFunctionOutputSchema
});
var SerializedRunState = exports_external2.object({
  $schemaVersion,
  currentTurn: exports_external2.number(),
  currentAgent: serializedAgentSchema,
  originalInput: exports_external2.string().or(exports_external2.array(ModelItem)),
  modelResponses: exports_external2.array(modelResponseSchema),
  context: exports_external2.object({
    usage: usageSchema,
    approvals: exports_external2.record(exports_external2.string(), exports_external2.object({
      approved: exports_external2.array(exports_external2.string()).or(exports_external2.boolean()),
      rejected: exports_external2.array(exports_external2.string()).or(exports_external2.boolean())
    })),
    context: exports_external2.record(exports_external2.string(), exports_external2.any())
  }),
  toolUseTracker: exports_external2.record(exports_external2.string(), exports_external2.array(exports_external2.string())),
  maxTurns: exports_external2.number(),
  currentAgentSpan: SerializedSpan.nullable().optional(),
  noActiveAgentRun: exports_external2.boolean(),
  inputGuardrailResults: exports_external2.array(inputGuardrailResultSchema),
  outputGuardrailResults: exports_external2.array(outputGuardrailResultSchema),
  currentStep: nextStepSchema.optional(),
  lastModelResponse: modelResponseSchema.optional(),
  generatedItems: exports_external2.array(itemSchema),
  lastProcessedResponse: serializedProcessedResponseSchema.optional(),
  currentTurnPersistedItemCount: exports_external2.number().int().min(0).optional(),
  trace: serializedTraceSchema.nullable()
});

class RunState {
  _currentTurn = 0;
  _currentAgent;
  _originalInput;
  _modelResponses;
  _currentAgentSpan;
  _context;
  get usage() {
    return this._context.usage;
  }
  _toolUseTracker;
  _generatedItems;
  _currentTurnPersistedItemCount;
  _maxTurns;
  _noActiveAgentRun = true;
  _lastTurnResponse;
  _inputGuardrailResults;
  _outputGuardrailResults;
  _currentStep = undefined;
  _lastProcessedResponse = undefined;
  _trace = null;
  constructor(context, originalInput, startingAgent, maxTurns) {
    this._context = context;
    this._originalInput = structuredClone(originalInput);
    this._modelResponses = [];
    this._currentAgentSpan = undefined;
    this._currentAgent = startingAgent;
    this._toolUseTracker = new AgentToolUseTracker;
    this._generatedItems = [];
    this._currentTurnPersistedItemCount = 0;
    this._maxTurns = maxTurns;
    this._inputGuardrailResults = [];
    this._outputGuardrailResults = [];
    this._trace = getCurrentTrace();
  }
  get history() {
    return getTurnInput(this._originalInput, this._generatedItems);
  }
  getInterruptions() {
    if (this._currentStep?.type !== "next_step_interruption") {
      return [];
    }
    return this._currentStep.data.interruptions;
  }
  approve(approvalItem, options = { alwaysApprove: false }) {
    this._context.approveTool(approvalItem, options);
  }
  reject(approvalItem, options = { alwaysReject: false }) {
    this._context.rejectTool(approvalItem, options);
  }
  toJSON() {
    const output = {
      $schemaVersion: CURRENT_SCHEMA_VERSION,
      currentTurn: this._currentTurn,
      currentAgent: {
        name: this._currentAgent.name
      },
      originalInput: this._originalInput,
      modelResponses: this._modelResponses.map((response) => {
        return {
          usage: {
            requests: response.usage.requests,
            inputTokens: response.usage.inputTokens,
            outputTokens: response.usage.outputTokens,
            totalTokens: response.usage.totalTokens,
            inputTokensDetails: response.usage.inputTokensDetails,
            outputTokensDetails: response.usage.outputTokensDetails,
            ...response.usage.requestUsageEntries && response.usage.requestUsageEntries.length > 0 ? {
              requestUsageEntries: response.usage.requestUsageEntries.map((entry) => ({
                inputTokens: entry.inputTokens,
                outputTokens: entry.outputTokens,
                totalTokens: entry.totalTokens,
                inputTokensDetails: entry.inputTokensDetails,
                outputTokensDetails: entry.outputTokensDetails
              }))
            } : {}
          },
          output: response.output,
          responseId: response.responseId,
          providerData: response.providerData
        };
      }),
      context: this._context.toJSON(),
      toolUseTracker: this._toolUseTracker.toJSON(),
      maxTurns: this._maxTurns,
      currentAgentSpan: this._currentAgentSpan?.toJSON(),
      noActiveAgentRun: this._noActiveAgentRun,
      inputGuardrailResults: this._inputGuardrailResults,
      outputGuardrailResults: this._outputGuardrailResults.map((r) => ({
        ...r,
        agent: r.agent.toJSON()
      })),
      currentStep: this._currentStep,
      lastModelResponse: this._lastTurnResponse,
      generatedItems: this._generatedItems.map((item) => item.toJSON()),
      currentTurnPersistedItemCount: this._currentTurnPersistedItemCount,
      lastProcessedResponse: this._lastProcessedResponse,
      trace: this._trace ? this._trace.toJSON() : null
    };
    const parsed = SerializedRunState.safeParse(output);
    if (!parsed.success) {
      throw new SystemError(`Failed to serialize run state. ${parsed.error.message}`);
    }
    return parsed.data;
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  static async fromString(initialAgent, str) {
    const [parsingError, jsonResult] = await safeExecute(() => JSON.parse(str));
    if (parsingError) {
      throw new UserError(`Failed to parse run state. ${parsingError instanceof Error ? parsingError.message : String(parsingError)}`);
    }
    const currentSchemaVersion = jsonResult.$schemaVersion;
    if (!currentSchemaVersion) {
      throw new UserError("Run state is missing schema version");
    }
    if (currentSchemaVersion !== CURRENT_SCHEMA_VERSION) {
      throw new UserError(`Run state schema version ${currentSchemaVersion} is not supported. Please use version ${CURRENT_SCHEMA_VERSION}`);
    }
    const stateJson = SerializedRunState.parse(JSON.parse(str));
    const agentMap = buildAgentMap(initialAgent);
    const context = new RunContext(stateJson.context.context);
    context._rebuildApprovals(stateJson.context.approvals);
    const currentAgent = agentMap.get(stateJson.currentAgent.name);
    if (!currentAgent) {
      throw new UserError(`Agent ${stateJson.currentAgent.name} not found`);
    }
    const state = new RunState(context, "", currentAgent, stateJson.maxTurns);
    state._currentTurn = stateJson.currentTurn;
    state._toolUseTracker = new AgentToolUseTracker;
    for (const [agentName, toolNames] of Object.entries(stateJson.toolUseTracker)) {
      state._toolUseTracker.addToolUse(agentMap.get(agentName), toolNames);
    }
    if (stateJson.currentAgentSpan) {
      if (!stateJson.trace) {
        logger_default.warn("Trace is not set, skipping tracing setup");
      }
      const trace = getGlobalTraceProvider().createTrace({
        traceId: stateJson.trace?.id,
        name: stateJson.trace?.workflow_name,
        groupId: stateJson.trace?.group_id ?? undefined,
        metadata: stateJson.trace?.metadata
      });
      state._currentAgentSpan = deserializeSpan(trace, stateJson.currentAgentSpan);
      state._trace = trace;
    }
    state._noActiveAgentRun = stateJson.noActiveAgentRun;
    state._inputGuardrailResults = stateJson.inputGuardrailResults;
    state._outputGuardrailResults = stateJson.outputGuardrailResults.map((r) => ({
      ...r,
      agent: agentMap.get(r.agent.name)
    }));
    state._currentStep = stateJson.currentStep;
    state._originalInput = stateJson.originalInput;
    state._modelResponses = stateJson.modelResponses.map(deserializeModelResponse);
    state._lastTurnResponse = stateJson.lastModelResponse ? deserializeModelResponse(stateJson.lastModelResponse) : undefined;
    state._generatedItems = stateJson.generatedItems.map((item) => deserializeItem(item, agentMap));
    state._currentTurnPersistedItemCount = stateJson.currentTurnPersistedItemCount ?? 0;
    state._lastProcessedResponse = stateJson.lastProcessedResponse ? await deserializeProcessedResponse(agentMap, state._currentAgent, state._context, stateJson.lastProcessedResponse) : undefined;
    if (stateJson.currentStep?.type === "next_step_handoff") {
      state._currentStep = {
        type: "next_step_handoff",
        newAgent: agentMap.get(stateJson.currentStep.newAgent.name)
      };
    }
    return state;
  }
}
function buildAgentMap(initialAgent) {
  const map4 = new Map;
  const queue2 = [initialAgent];
  while (queue2.length > 0) {
    const currentAgent = queue2.shift();
    if (map4.has(currentAgent.name)) {
      continue;
    }
    map4.set(currentAgent.name, currentAgent);
    for (const handoff2 of currentAgent.handoffs) {
      if (handoff2 instanceof Agent) {
        if (!map4.has(handoff2.name)) {
          queue2.push(handoff2);
        }
      } else if (handoff2.agent) {
        if (!map4.has(handoff2.agent.name)) {
          queue2.push(handoff2.agent);
        }
      }
    }
  }
  return map4;
}
function deserializeSpan(trace, serializedSpan) {
  const spanData = serializedSpan.span_data;
  const previousSpan = serializedSpan.previous_span ? deserializeSpan(trace, serializedSpan.previous_span) : undefined;
  const span = getGlobalTraceProvider().createSpan({
    spanId: serializedSpan.id,
    traceId: serializedSpan.trace_id,
    parentId: serializedSpan.parent_id ?? undefined,
    startedAt: serializedSpan.started_at ?? undefined,
    endedAt: serializedSpan.ended_at ?? undefined,
    data: spanData
  }, trace);
  span.previousSpan = previousSpan;
  return span;
}
function deserializeModelResponse(serializedModelResponse) {
  const usage = new Usage(serializedModelResponse.usage);
  return {
    usage,
    output: serializedModelResponse.output.map((item) => OutputModelItem.parse(item)),
    responseId: serializedModelResponse.responseId,
    providerData: serializedModelResponse.providerData
  };
}
function deserializeItem(serializedItem, agentMap) {
  switch (serializedItem.type) {
    case "message_output_item":
      return new RunMessageOutputItem(serializedItem.rawItem, agentMap.get(serializedItem.agent.name));
    case "tool_call_item":
      return new RunToolCallItem(serializedItem.rawItem, agentMap.get(serializedItem.agent.name));
    case "tool_call_output_item":
      return new RunToolCallOutputItem(serializedItem.rawItem, agentMap.get(serializedItem.agent.name), serializedItem.output);
    case "reasoning_item":
      return new RunReasoningItem(serializedItem.rawItem, agentMap.get(serializedItem.agent.name));
    case "handoff_call_item":
      return new RunHandoffCallItem(serializedItem.rawItem, agentMap.get(serializedItem.agent.name));
    case "handoff_output_item":
      return new RunHandoffOutputItem(serializedItem.rawItem, agentMap.get(serializedItem.sourceAgent.name), agentMap.get(serializedItem.targetAgent.name));
    case "tool_approval_item":
      return new RunToolApprovalItem(serializedItem.rawItem, agentMap.get(serializedItem.agent.name), serializedItem.toolName);
  }
}
async function deserializeProcessedResponse(agentMap, currentAgent, context, serializedProcessedResponse) {
  const allTools = await currentAgent.getAllTools(context);
  const tools = new Map(allTools.filter((tool2) => tool2.type === "function").map((tool2) => [tool2.name, tool2]));
  const computerTools = new Map(allTools.filter((tool2) => tool2.type === "computer").map((tool2) => [tool2.name, tool2]));
  const shellTools = new Map(allTools.filter((tool2) => tool2.type === "shell").map((tool2) => [tool2.name, tool2]));
  const applyPatchTools = new Map(allTools.filter((tool2) => tool2.type === "apply_patch").map((tool2) => [tool2.name, tool2]));
  const handoffs = new Map(currentAgent.handoffs.map((entry) => {
    if (entry instanceof Agent) {
      return [entry.name, handoff(entry)];
    }
    return [entry.toolName, entry];
  }));
  const result = {
    newItems: serializedProcessedResponse.newItems.map((item) => deserializeItem(item, agentMap)),
    toolsUsed: serializedProcessedResponse.toolsUsed,
    handoffs: serializedProcessedResponse.handoffs.map((handoff2) => {
      if (!handoffs.has(handoff2.handoff.toolName)) {
        throw new UserError(`Handoff ${handoff2.handoff.toolName} not found`);
      }
      return {
        toolCall: handoff2.toolCall,
        handoff: handoffs.get(handoff2.handoff.toolName)
      };
    }),
    functions: await Promise.all(serializedProcessedResponse.functions.map(async (functionCall) => {
      if (!tools.has(functionCall.tool.name)) {
        throw new UserError(`Tool ${functionCall.tool.name} not found`);
      }
      return {
        toolCall: functionCall.toolCall,
        tool: tools.get(functionCall.tool.name)
      };
    })),
    computerActions: serializedProcessedResponse.computerActions.map((computerAction) => {
      const toolName = computerAction.computer.name;
      if (!computerTools.has(toolName)) {
        throw new UserError(`Computer tool ${toolName} not found`);
      }
      return {
        toolCall: computerAction.toolCall,
        computer: computerTools.get(toolName)
      };
    }),
    shellActions: (serializedProcessedResponse.shellActions ?? []).map((shellAction) => {
      const toolName = shellAction.shell.name;
      if (!shellTools.has(toolName)) {
        throw new UserError(`Shell tool ${toolName} not found`);
      }
      return {
        toolCall: shellAction.toolCall,
        shell: shellTools.get(toolName)
      };
    }),
    applyPatchActions: (serializedProcessedResponse.applyPatchActions ?? []).map((applyPatchAction) => {
      const toolName = applyPatchAction.applyPatch.name;
      if (!applyPatchTools.has(toolName)) {
        throw new UserError(`Apply patch tool ${toolName} not found`);
      }
      return {
        toolCall: applyPatchAction.toolCall,
        applyPatch: applyPatchTools.get(toolName)
      };
    }),
    mcpApprovalRequests: (serializedProcessedResponse.mcpApprovalRequests ?? []).map((approvalRequest) => ({
      requestItem: new RunToolApprovalItem(approvalRequest.requestItem.rawItem, currentAgent),
      mcpTool: approvalRequest.mcpTool
    }))
  };
  return {
    ...result,
    hasToolsOrApprovalsToRun() {
      return result.handoffs.length > 0 || result.functions.length > 0 || result.mcpApprovalRequests.length > 0 || result.computerActions.length > 0 || result.shellActions.length > 0 || result.applyPatchActions.length > 0;
    }
  };
}

// node_modules/@openai/agents-core/dist/run.mjs
async function run(agent, input, options) {
  const runner = getDefaultRunner();
  if (options?.stream) {
    return await runner.run(agent, input, options);
  } else {
    return await runner.run(agent, input, options);
  }
}

class Runner extends RunHooks {
  config;
  constructor(config2 = {}) {
    super();
    this.config = {
      modelProvider: config2.modelProvider ?? getDefaultModelProvider(),
      model: config2.model,
      modelSettings: config2.modelSettings,
      handoffInputFilter: config2.handoffInputFilter,
      inputGuardrails: config2.inputGuardrails,
      outputGuardrails: config2.outputGuardrails,
      tracingDisabled: config2.tracingDisabled ?? false,
      traceIncludeSensitiveData: config2.traceIncludeSensitiveData ?? true,
      workflowName: config2.workflowName ?? "Agent workflow",
      traceId: config2.traceId,
      groupId: config2.groupId,
      traceMetadata: config2.traceMetadata,
      sessionInputCallback: config2.sessionInputCallback,
      callModelInputFilter: config2.callModelInputFilter
    };
    this.inputGuardrailDefs = (config2.inputGuardrails ?? []).map(defineInputGuardrail);
    this.outputGuardrailDefs = (config2.outputGuardrails ?? []).map(defineOutputGuardrail);
  }
  async run(agent, input, options = {
    stream: false,
    context: undefined
  }) {
    const resolvedOptions = options ?? { stream: false, context: undefined };
    const sessionInputCallback = resolvedOptions.sessionInputCallback ?? this.config.sessionInputCallback;
    const callModelInputFilter = resolvedOptions.callModelInputFilter ?? this.config.callModelInputFilter;
    const hasCallModelInputFilter = Boolean(callModelInputFilter);
    const effectiveOptions = {
      ...resolvedOptions,
      sessionInputCallback,
      callModelInputFilter
    };
    const serverManagesConversation = Boolean(effectiveOptions.conversationId) || Boolean(effectiveOptions.previousResponseId);
    const session = effectiveOptions.session;
    const resumingFromState = input instanceof RunState;
    let sessionInputOriginalSnapshot = session && resumingFromState ? [] : undefined;
    let sessionInputFilteredSnapshot = undefined;
    let sessionInputPendingWriteCounts = session && resumingFromState ? new Map : undefined;
    const recordSessionItemsForPersistence = (sourceItems, filteredItems) => {
      const pendingWriteCounts = sessionInputPendingWriteCounts;
      if (filteredItems !== undefined) {
        if (!pendingWriteCounts) {
          sessionInputFilteredSnapshot = filteredItems.map((item) => structuredClone(item));
          return;
        }
        const persistableItems = [];
        const sourceOccurrenceCounts = new WeakMap;
        for (const source of sourceItems) {
          if (!source || typeof source !== "object") {
            continue;
          }
          const nextCount = (sourceOccurrenceCounts.get(source) ?? 0) + 1;
          sourceOccurrenceCounts.set(source, nextCount);
        }
        const consumeAnyPendingWriteSlot = () => {
          for (const [key, remaining] of pendingWriteCounts) {
            if (remaining > 0) {
              pendingWriteCounts.set(key, remaining - 1);
              return true;
            }
          }
          return false;
        };
        for (let i = 0;i < filteredItems.length; i++) {
          const filteredItem = filteredItems[i];
          if (!filteredItem) {
            continue;
          }
          let allocated = false;
          const source = sourceItems[i];
          if (source && typeof source === "object") {
            const pendingOccurrences = (sourceOccurrenceCounts.get(source) ?? 0) - 1;
            sourceOccurrenceCounts.set(source, pendingOccurrences);
            if (pendingOccurrences > 0) {
              continue;
            }
            const sourceKey = getAgentInputItemKey(source);
            const remaining = pendingWriteCounts.get(sourceKey) ?? 0;
            if (remaining > 0) {
              pendingWriteCounts.set(sourceKey, remaining - 1);
              persistableItems.push(structuredClone(filteredItem));
              allocated = true;
              continue;
            }
          }
          const filteredKey = getAgentInputItemKey(filteredItem);
          const filteredRemaining = pendingWriteCounts.get(filteredKey) ?? 0;
          if (filteredRemaining > 0) {
            pendingWriteCounts.set(filteredKey, filteredRemaining - 1);
            persistableItems.push(structuredClone(filteredItem));
            allocated = true;
            continue;
          }
          if (!source && consumeAnyPendingWriteSlot()) {
            persistableItems.push(structuredClone(filteredItem));
            allocated = true;
          }
          if (!allocated && !source && sessionInputFilteredSnapshot === undefined) {
            persistableItems.push(structuredClone(filteredItem));
          }
        }
        if (persistableItems.length > 0 || sessionInputFilteredSnapshot === undefined) {
          sessionInputFilteredSnapshot = persistableItems;
        }
        return;
      }
      const filtered = [];
      if (!pendingWriteCounts) {
        for (const item of sourceItems) {
          if (!item) {
            continue;
          }
          filtered.push(structuredClone(item));
        }
      } else {
        for (const item of sourceItems) {
          if (!item) {
            continue;
          }
          const key = getAgentInputItemKey(item);
          const remaining = pendingWriteCounts.get(key) ?? 0;
          if (remaining <= 0) {
            continue;
          }
          pendingWriteCounts.set(key, remaining - 1);
          filtered.push(structuredClone(item));
        }
      }
      if (filtered.length > 0) {
        sessionInputFilteredSnapshot = filtered;
      } else if (sessionInputFilteredSnapshot === undefined) {
        sessionInputFilteredSnapshot = [];
      }
    };
    const resolveSessionItemsForPersistence = () => {
      if (sessionInputFilteredSnapshot !== undefined) {
        return sessionInputFilteredSnapshot;
      }
      if (hasCallModelInputFilter) {
        return;
      }
      return sessionInputOriginalSnapshot;
    };
    let preparedInput = input;
    if (!(preparedInput instanceof RunState)) {
      if (session && Array.isArray(preparedInput) && !sessionInputCallback) {
        throw new UserError("RunConfig.sessionInputCallback must be provided when using session history with list inputs.");
      }
      const prepared = await prepareInputItemsWithSession(preparedInput, session, sessionInputCallback, {
        includeHistoryInPreparedInput: !serverManagesConversation,
        preserveDroppedNewItems: serverManagesConversation
      });
      if (serverManagesConversation && session) {
        const sessionItems = prepared.sessionItems;
        if (sessionItems && sessionItems.length > 0) {
          preparedInput = sessionItems;
        } else {
          preparedInput = prepared.preparedInput;
        }
      } else {
        preparedInput = prepared.preparedInput;
      }
      if (session) {
        const items = prepared.sessionItems ?? [];
        sessionInputOriginalSnapshot = items.map((item) => structuredClone(item));
        sessionInputPendingWriteCounts = new Map;
        for (const item of items) {
          const key = getAgentInputItemKey(item);
          sessionInputPendingWriteCounts.set(key, (sessionInputPendingWriteCounts.get(key) ?? 0) + 1);
        }
      }
    }
    let ensureStreamInputPersisted;
    if (session && !serverManagesConversation) {
      let persisted = false;
      ensureStreamInputPersisted = async () => {
        if (persisted) {
          return;
        }
        const itemsToPersist = resolveSessionItemsForPersistence();
        if (!itemsToPersist || itemsToPersist.length === 0) {
          return;
        }
        persisted = true;
        await saveStreamInputToSession(session, itemsToPersist);
      };
    }
    const executeRun = async () => {
      if (effectiveOptions.stream) {
        const streamResult = await this.#runIndividualStream(agent, preparedInput, effectiveOptions, ensureStreamInputPersisted, recordSessionItemsForPersistence);
        return streamResult;
      }
      const runResult = await this.#runIndividualNonStream(agent, preparedInput, effectiveOptions, recordSessionItemsForPersistence);
      if (session && !serverManagesConversation) {
        await saveToSession(session, resolveSessionItemsForPersistence(), runResult);
      }
      return runResult;
    };
    if (preparedInput instanceof RunState && preparedInput._trace) {
      return withTrace(preparedInput._trace, async () => {
        if (preparedInput._currentAgentSpan) {
          setCurrentSpan(preparedInput._currentAgentSpan);
        }
        return executeRun();
      });
    }
    return getOrCreateTrace(async () => executeRun(), {
      traceId: this.config.traceId,
      name: this.config.workflowName,
      groupId: this.config.groupId,
      metadata: this.config.traceMetadata
    });
  }
  inputGuardrailDefs;
  outputGuardrailDefs;
  #getInputGuardrailDefinitions(state) {
    return this.inputGuardrailDefs.concat(state._currentAgent.inputGuardrails.map(defineInputGuardrail));
  }
  #splitInputGuardrails(state) {
    const guardrails = this.#getInputGuardrailDefinitions(state);
    const blocking = [];
    const parallel = [];
    for (const guardrail of guardrails) {
      if (guardrail.runInParallel === false) {
        blocking.push(guardrail);
      } else {
        parallel.push(guardrail);
      }
    }
    return { blocking, parallel };
  }
  async#resolveModelForAgent(agent) {
    const explictlyModelSet = agent.model !== undefined && agent.model !== Agent.DEFAULT_MODEL_PLACEHOLDER || this.config.model !== undefined && this.config.model !== Agent.DEFAULT_MODEL_PLACEHOLDER;
    let resolvedModel = selectModel(agent.model, this.config.model);
    if (typeof resolvedModel === "string") {
      resolvedModel = await this.config.modelProvider.getModel(resolvedModel);
    }
    return { model: resolvedModel, explictlyModelSet };
  }
  async#runIndividualNonStream(startingAgent, input, options, sessionInputUpdate) {
    return withNewSpanContext(async () => {
      const isResumedState = input instanceof RunState;
      const state = isResumedState ? input : new RunState(options.context instanceof RunContext ? options.context : new RunContext(options.context), input, startingAgent, options.maxTurns ?? DEFAULT_MAX_TURNS);
      const serverConversationTracker = options.conversationId || options.previousResponseId ? new ServerConversationTracker({
        conversationId: options.conversationId,
        previousResponseId: options.previousResponseId
      }) : undefined;
      if (serverConversationTracker && isResumedState) {
        serverConversationTracker.primeFromState({
          originalInput: state._originalInput,
          generatedItems: state._generatedItems,
          modelResponses: state._modelResponses
        });
      }
      try {
        while (true) {
          state._currentStep = state._currentStep ?? {
            type: "next_step_run_again"
          };
          if (state._currentStep.type === "next_step_interruption") {
            logger_default.debug("Continuing from interruption");
            if (!state._lastTurnResponse || !state._lastProcessedResponse) {
              throw new UserError("No model response found in previous state", state);
            }
            const turnResult = await resolveInterruptedTurn(state._currentAgent, state._originalInput, state._generatedItems, state._lastTurnResponse, state._lastProcessedResponse, this, state);
            state._toolUseTracker.addToolUse(state._currentAgent, state._lastProcessedResponse.toolsUsed);
            state._originalInput = turnResult.originalInput;
            state._generatedItems = turnResult.generatedItems;
            if (turnResult.nextStep.type === "next_step_run_again") {
              state._currentTurnPersistedItemCount = 0;
            }
            state._currentStep = turnResult.nextStep;
            if (turnResult.nextStep.type === "next_step_interruption") {
              return new RunResult(state);
            }
            continue;
          }
          if (state._currentStep.type === "next_step_run_again") {
            const artifacts = await prepareAgentArtifacts(state);
            state._currentTurn++;
            state._currentTurnPersistedItemCount = 0;
            if (state._currentTurn > state._maxTurns) {
              state._currentAgentSpan?.setError({
                message: "Max turns exceeded",
                data: { max_turns: state._maxTurns }
              });
              throw new MaxTurnsExceededError(`Max turns (${state._maxTurns}) exceeded`, state);
            }
            logger_default.debug(`Running agent ${state._currentAgent.name} (turn ${state._currentTurn})`);
            let parallelGuardrailPromise;
            if (state._currentTurn === 1) {
              const guardrails = this.#splitInputGuardrails(state);
              if (guardrails.blocking.length > 0) {
                await this.#runInputGuardrails(state, guardrails.blocking);
              }
              if (guardrails.parallel.length > 0) {
                parallelGuardrailPromise = this.#runInputGuardrails(state, guardrails.parallel);
                parallelGuardrailPromise.catch(() => {});
              }
            }
            const turnInput = serverConversationTracker ? serverConversationTracker.prepareInput(state._originalInput, state._generatedItems) : getTurnInput(state._originalInput, state._generatedItems);
            if (state._noActiveAgentRun) {
              state._currentAgent.emit("agent_start", state._context, state._currentAgent);
              this.emit("agent_start", state._context, state._currentAgent);
            }
            const preparedCall = await this.#prepareModelCall(state, options, artifacts, turnInput, serverConversationTracker, sessionInputUpdate);
            state._lastTurnResponse = await preparedCall.model.getResponse({
              systemInstructions: preparedCall.modelInput.instructions,
              prompt: preparedCall.prompt,
              ...preparedCall.explictlyModelSet ? { overridePromptModel: true } : {},
              input: preparedCall.modelInput.input,
              previousResponseId: preparedCall.previousResponseId,
              conversationId: preparedCall.conversationId,
              modelSettings: preparedCall.modelSettings,
              tools: preparedCall.serializedTools,
              toolsExplicitlyProvided: preparedCall.toolsExplicitlyProvided,
              outputType: convertAgentOutputTypeToSerializable(state._currentAgent.outputType),
              handoffs: preparedCall.serializedHandoffs,
              tracing: getTracing(this.config.tracingDisabled, this.config.traceIncludeSensitiveData),
              signal: options.signal
            });
            state._modelResponses.push(state._lastTurnResponse);
            state._context.usage.add(state._lastTurnResponse.usage);
            state._noActiveAgentRun = false;
            serverConversationTracker?.trackServerItems(state._lastTurnResponse);
            const processedResponse = processModelResponse(state._lastTurnResponse, state._currentAgent, preparedCall.tools, preparedCall.handoffs);
            state._lastProcessedResponse = processedResponse;
            const turnResult = await resolveTurnAfterModelResponse(state._currentAgent, state._originalInput, state._generatedItems, state._lastTurnResponse, state._lastProcessedResponse, this, state);
            state._toolUseTracker.addToolUse(state._currentAgent, state._lastProcessedResponse.toolsUsed);
            state._originalInput = turnResult.originalInput;
            state._generatedItems = turnResult.generatedItems;
            if (turnResult.nextStep.type === "next_step_run_again") {
              state._currentTurnPersistedItemCount = 0;
            }
            state._currentStep = turnResult.nextStep;
            if (parallelGuardrailPromise) {
              await parallelGuardrailPromise;
            }
          }
          if (state._currentStep && state._currentStep.type === "next_step_final_output") {
            await this.#runOutputGuardrails(state, state._currentStep.output);
            this.emit("agent_end", state._context, state._currentAgent, state._currentStep.output);
            state._currentAgent.emit("agent_end", state._context, state._currentStep.output);
            return new RunResult(state);
          } else if (state._currentStep && state._currentStep.type === "next_step_handoff") {
            state._currentAgent = state._currentStep.newAgent;
            if (state._currentAgentSpan) {
              state._currentAgentSpan.end();
              resetCurrentSpan();
              state._currentAgentSpan = undefined;
            }
            state._noActiveAgentRun = true;
            state._currentStep = { type: "next_step_run_again" };
          } else if (state._currentStep && state._currentStep.type === "next_step_interruption") {
            return new RunResult(state);
          } else {
            logger_default.debug("Running next loop");
          }
        }
      } catch (err) {
        if (state._currentAgentSpan) {
          state._currentAgentSpan.setError({
            message: "Error in agent run",
            data: { error: String(err) }
          });
        }
        throw err;
      } finally {
        if (state._currentAgentSpan) {
          if (state._currentStep?.type !== "next_step_interruption") {
            state._currentAgentSpan.end();
          }
          resetCurrentSpan();
        }
      }
    });
  }
  async#runStreamLoop(result, options, isResumedState, ensureStreamInputPersisted, sessionInputUpdate) {
    const serverManagesConversation = Boolean(options.conversationId) || Boolean(options.previousResponseId);
    const serverConversationTracker = serverManagesConversation ? new ServerConversationTracker({
      conversationId: options.conversationId,
      previousResponseId: options.previousResponseId
    }) : undefined;
    let handedInputToModel = false;
    let streamInputPersisted = false;
    const persistStreamInputIfNeeded = async () => {
      if (streamInputPersisted || !ensureStreamInputPersisted) {
        return;
      }
      await ensureStreamInputPersisted();
      streamInputPersisted = true;
    };
    if (serverConversationTracker && isResumedState) {
      serverConversationTracker.primeFromState({
        originalInput: result.state._originalInput,
        generatedItems: result.state._generatedItems,
        modelResponses: result.state._modelResponses
      });
    }
    try {
      while (true) {
        const currentAgent = result.state._currentAgent;
        result.state._currentStep = result.state._currentStep ?? {
          type: "next_step_run_again"
        };
        if (result.state._currentStep.type === "next_step_interruption") {
          logger_default.debug("Continuing from interruption");
          if (!result.state._lastTurnResponse || !result.state._lastProcessedResponse) {
            throw new UserError("No model response found in previous state", result.state);
          }
          const turnResult = await resolveInterruptedTurn(result.state._currentAgent, result.state._originalInput, result.state._generatedItems, result.state._lastTurnResponse, result.state._lastProcessedResponse, this, result.state);
          addStepToRunResult(result, turnResult);
          result.state._toolUseTracker.addToolUse(result.state._currentAgent, result.state._lastProcessedResponse.toolsUsed);
          result.state._originalInput = turnResult.originalInput;
          result.state._generatedItems = turnResult.generatedItems;
          if (turnResult.nextStep.type === "next_step_run_again") {
            result.state._currentTurnPersistedItemCount = 0;
          }
          result.state._currentStep = turnResult.nextStep;
          if (turnResult.nextStep.type === "next_step_interruption") {
            return;
          }
          continue;
        }
        if (result.state._currentStep.type === "next_step_run_again") {
          const artifacts = await prepareAgentArtifacts(result.state);
          result.state._currentTurn++;
          result.state._currentTurnPersistedItemCount = 0;
          if (result.state._currentTurn > result.state._maxTurns) {
            result.state._currentAgentSpan?.setError({
              message: "Max turns exceeded",
              data: { max_turns: result.state._maxTurns }
            });
            throw new MaxTurnsExceededError(`Max turns (${result.state._maxTurns}) exceeded`, result.state);
          }
          logger_default.debug(`Running agent ${currentAgent.name} (turn ${result.state._currentTurn})`);
          let guardrailError;
          let parallelGuardrailPromise;
          if (result.state._currentTurn === 1) {
            const guardrails = this.#splitInputGuardrails(result.state);
            if (guardrails.blocking.length > 0) {
              await this.#runInputGuardrails(result.state, guardrails.blocking);
            }
            if (guardrails.parallel.length > 0) {
              const promise4 = this.#runInputGuardrails(result.state, guardrails.parallel);
              parallelGuardrailPromise = promise4.catch((err) => {
                guardrailError = err;
                return [];
              });
            }
          }
          const turnInput = serverConversationTracker ? serverConversationTracker.prepareInput(result.input, result.newItems) : getTurnInput(result.input, result.newItems);
          if (result.state._noActiveAgentRun) {
            currentAgent.emit("agent_start", result.state._context, currentAgent);
            this.emit("agent_start", result.state._context, currentAgent);
          }
          let finalResponse = undefined;
          const preparedCall = await this.#prepareModelCall(result.state, options, artifacts, turnInput, serverConversationTracker, sessionInputUpdate);
          if (guardrailError) {
            throw guardrailError;
          }
          handedInputToModel = true;
          await persistStreamInputIfNeeded();
          for await (const event of preparedCall.model.getStreamedResponse({
            systemInstructions: preparedCall.modelInput.instructions,
            prompt: preparedCall.prompt,
            ...preparedCall.explictlyModelSet ? { overridePromptModel: true } : {},
            input: preparedCall.modelInput.input,
            previousResponseId: preparedCall.previousResponseId,
            conversationId: preparedCall.conversationId,
            modelSettings: preparedCall.modelSettings,
            tools: preparedCall.serializedTools,
            toolsExplicitlyProvided: preparedCall.toolsExplicitlyProvided,
            handoffs: preparedCall.serializedHandoffs,
            outputType: convertAgentOutputTypeToSerializable(currentAgent.outputType),
            tracing: getTracing(this.config.tracingDisabled, this.config.traceIncludeSensitiveData),
            signal: options.signal
          })) {
            if (guardrailError) {
              throw guardrailError;
            }
            if (event.type === "response_done") {
              const parsed = StreamEventResponseCompleted.parse(event);
              finalResponse = {
                usage: new Usage(parsed.response.usage),
                output: parsed.response.output,
                responseId: parsed.response.id
              };
            }
            if (result.cancelled) {
              return;
            }
            result._addItem(new RunRawModelStreamEvent(event));
          }
          if (parallelGuardrailPromise) {
            await parallelGuardrailPromise;
            if (guardrailError) {
              throw guardrailError;
            }
          }
          result.state._noActiveAgentRun = false;
          if (!finalResponse) {
            throw new ModelBehaviorError("Model did not produce a final response!", result.state);
          }
          result.state._lastTurnResponse = finalResponse;
          serverConversationTracker?.trackServerItems(finalResponse);
          result.state._modelResponses.push(result.state._lastTurnResponse);
          const processedResponse = processModelResponse(result.state._lastTurnResponse, currentAgent, preparedCall.tools, preparedCall.handoffs);
          result.state._lastProcessedResponse = processedResponse;
          const preToolItems = new Set(processedResponse.newItems);
          if (preToolItems.size > 0) {
            streamStepItemsToRunResult(result, processedResponse.newItems);
          }
          const turnResult = await resolveTurnAfterModelResponse(currentAgent, result.state._originalInput, result.state._generatedItems, result.state._lastTurnResponse, result.state._lastProcessedResponse, this, result.state);
          addStepToRunResult(result, turnResult, {
            skipItems: preToolItems
          });
          result.state._toolUseTracker.addToolUse(currentAgent, processedResponse.toolsUsed);
          result.state._originalInput = turnResult.originalInput;
          result.state._generatedItems = turnResult.generatedItems;
          if (turnResult.nextStep.type === "next_step_run_again") {
            result.state._currentTurnPersistedItemCount = 0;
          }
          result.state._currentStep = turnResult.nextStep;
        }
        if (result.state._currentStep.type === "next_step_final_output") {
          await this.#runOutputGuardrails(result.state, result.state._currentStep.output);
          await persistStreamInputIfNeeded();
          if (!serverManagesConversation) {
            await saveStreamResultToSession(options.session, result);
          }
          this.emit("agent_end", result.state._context, currentAgent, result.state._currentStep.output);
          currentAgent.emit("agent_end", result.state._context, result.state._currentStep.output);
          return;
        } else if (result.state._currentStep.type === "next_step_interruption") {
          await persistStreamInputIfNeeded();
          if (!serverManagesConversation) {
            await saveStreamResultToSession(options.session, result);
          }
          return;
        } else if (result.state._currentStep.type === "next_step_handoff") {
          result.state._currentAgent = result.state._currentStep?.newAgent;
          if (result.state._currentAgentSpan) {
            result.state._currentAgentSpan.end();
            resetCurrentSpan();
          }
          result.state._currentAgentSpan = undefined;
          result._addItem(new RunAgentUpdatedStreamEvent(result.state._currentAgent));
          result.state._noActiveAgentRun = true;
          result.state._currentStep = {
            type: "next_step_run_again"
          };
        } else {
          logger_default.debug("Running next loop");
        }
      }
    } catch (error47) {
      if (handedInputToModel && !streamInputPersisted) {
        await persistStreamInputIfNeeded();
      }
      if (result.state._currentAgentSpan) {
        result.state._currentAgentSpan.setError({
          message: "Error in agent run",
          data: { error: String(error47) }
        });
      }
      throw error47;
    } finally {
      if (result.state._currentAgentSpan) {
        if (result.state._currentStep?.type !== "next_step_interruption") {
          result.state._currentAgentSpan.end();
        }
        resetCurrentSpan();
      }
    }
  }
  async#runIndividualStream(agent, input, options, ensureStreamInputPersisted, sessionInputUpdate) {
    options = options ?? {};
    return withNewSpanContext(async () => {
      const isResumedState = input instanceof RunState;
      const state = isResumedState ? input : new RunState(options.context instanceof RunContext ? options.context : new RunContext(options.context), input, agent, options.maxTurns ?? DEFAULT_MAX_TURNS);
      const result = new StreamedRunResult({
        signal: options.signal,
        state
      });
      result.maxTurns = options.maxTurns ?? state._maxTurns;
      const streamLoopPromise = this.#runStreamLoop(result, options, isResumedState, ensureStreamInputPersisted, sessionInputUpdate).then(() => {
        result._done();
      }, (err) => {
        result._raiseError(err);
      });
      result._setStreamLoopPromise(streamLoopPromise);
      return result;
    });
  }
  async#runInputGuardrails(state, guardrailsOverride) {
    const guardrails = guardrailsOverride ?? this.#getInputGuardrailDefinitions(state);
    if (guardrails.length > 0) {
      const guardrailArgs = {
        agent: state._currentAgent,
        input: state._originalInput,
        context: state._context
      };
      try {
        const results = await Promise.all(guardrails.map(async (guardrail) => {
          return withGuardrailSpan(async (span) => {
            const result = await guardrail.run(guardrailArgs);
            span.spanData.triggered = result.output.tripwireTriggered;
            return result;
          }, { data: { name: guardrail.name } }, state._currentAgentSpan);
        }));
        state._inputGuardrailResults.push(...results);
        for (const result of results) {
          if (result.output.tripwireTriggered) {
            if (state._currentAgentSpan) {
              state._currentAgentSpan.setError({
                message: "Guardrail tripwire triggered",
                data: { guardrail: result.guardrail.name }
              });
            }
            throw new InputGuardrailTripwireTriggered(`Input guardrail triggered: ${JSON.stringify(result.output.outputInfo)}`, result, state);
          }
        }
        return results;
      } catch (e) {
        if (e instanceof InputGuardrailTripwireTriggered) {
          throw e;
        }
        state._currentTurn--;
        throw new GuardrailExecutionError(`Input guardrail failed to complete: ${e}`, e, state);
      }
    }
    return [];
  }
  async#runOutputGuardrails(state, output) {
    const guardrails = this.outputGuardrailDefs.concat(state._currentAgent.outputGuardrails.map(defineOutputGuardrail));
    if (guardrails.length > 0) {
      const agentOutput = state._currentAgent.processFinalOutput(output);
      const runOutput = getTurnInput([], state._generatedItems);
      const guardrailArgs = {
        agent: state._currentAgent,
        agentOutput,
        context: state._context,
        details: {
          modelResponse: state._lastTurnResponse,
          output: runOutput
        }
      };
      try {
        const results = await Promise.all(guardrails.map(async (guardrail) => {
          return withGuardrailSpan(async (span) => {
            const result = await guardrail.run(guardrailArgs);
            span.spanData.triggered = result.output.tripwireTriggered;
            return result;
          }, { data: { name: guardrail.name } }, state._currentAgentSpan);
        }));
        for (const result of results) {
          if (result.output.tripwireTriggered) {
            if (state._currentAgentSpan) {
              state._currentAgentSpan.setError({
                message: "Guardrail tripwire triggered",
                data: { guardrail: result.guardrail.name }
              });
            }
            throw new OutputGuardrailTripwireTriggered(`Output guardrail triggered: ${JSON.stringify(result.output.outputInfo)}`, result, state);
          }
        }
      } catch (e) {
        if (e instanceof OutputGuardrailTripwireTriggered) {
          throw e;
        }
        throw new GuardrailExecutionError(`Output guardrail failed to complete: ${e}`, e, state);
      }
    }
  }
  async#prepareModelCall(state, options, artifacts, turnInput, serverConversationTracker, sessionInputUpdate) {
    const { model, explictlyModelSet } = await this.#resolveModelForAgent(state._currentAgent);
    let modelSettings = {
      ...this.config.modelSettings,
      ...state._currentAgent.modelSettings
    };
    modelSettings = adjustModelSettingsForNonGPT5RunnerModel(explictlyModelSet, state._currentAgent.modelSettings, model, modelSettings);
    modelSettings = maybeResetToolChoice(state._currentAgent, state._toolUseTracker, modelSettings);
    const systemInstructions = await state._currentAgent.getSystemPrompt(state._context);
    const prompt = await state._currentAgent.getPrompt(state._context);
    const { modelInput, sourceItems, persistedItems, filterApplied } = await applyCallModelInputFilter(state._currentAgent, options.callModelInputFilter, state._context, turnInput, systemInstructions);
    serverConversationTracker?.markInputAsSent(sourceItems);
    sessionInputUpdate?.(sourceItems, filterApplied ? persistedItems : undefined);
    const previousResponseId = serverConversationTracker?.previousResponseId ?? options.previousResponseId;
    const conversationId = serverConversationTracker?.conversationId ?? options.conversationId;
    return {
      ...artifacts,
      model,
      explictlyModelSet,
      modelSettings,
      modelInput,
      prompt,
      previousResponseId,
      conversationId
    };
  }
}
function getTurnInput(originalInput, generatedItems) {
  const rawItems = generatedItems.filter((item) => item.type !== "tool_approval_item").map((item) => item.rawItem);
  return [...toAgentInputList(originalInput), ...rawItems];
}
var DEFAULT_MAX_TURNS = 10;
var _defaultRunner = undefined;
function getDefaultRunner() {
  if (_defaultRunner) {
    return _defaultRunner;
  }
  _defaultRunner = new Runner;
  return _defaultRunner;
}
function selectModel(agentModel, runConfigModel) {
  if (typeof agentModel === "string" && agentModel !== Agent.DEFAULT_MODEL_PLACEHOLDER || agentModel) {
    return agentModel;
  }
  return runConfigModel ?? agentModel ?? Agent.DEFAULT_MODEL_PLACEHOLDER;
}
function getTracing(tracingDisabled, traceIncludeSensitiveData) {
  if (tracingDisabled) {
    return false;
  }
  if (traceIncludeSensitiveData) {
    return true;
  }
  return "enabled_without_data";
}
async function applyCallModelInputFilter(agent, callModelInputFilter, context, inputItems, systemInstructions) {
  const cloneInputItems = (items, map4) => items.map((item) => {
    const cloned = structuredClone(item);
    if (map4 && cloned && typeof cloned === "object") {
      map4.set(cloned, item);
    }
    return cloned;
  });
  const cloneMap = new WeakMap;
  const originalPool = buildAgentInputPool(inputItems);
  const fallbackOriginals = [];
  for (const item of inputItems) {
    if (item && typeof item === "object") {
      fallbackOriginals.push(item);
    }
  }
  const removeFromFallback = (candidate) => {
    if (!candidate || typeof candidate !== "object") {
      return;
    }
    const index = fallbackOriginals.findIndex((original) => original === candidate);
    if (index !== -1) {
      fallbackOriginals.splice(index, 1);
    }
  };
  const takeFallbackOriginal = () => {
    const next = fallbackOriginals.shift();
    if (next) {
      removeAgentInputFromPool(originalPool, next);
    }
    return next;
  };
  const clonedBaseInput = cloneInputItems(inputItems, cloneMap);
  const base = {
    input: clonedBaseInput,
    instructions: systemInstructions
  };
  if (!callModelInputFilter) {
    return {
      modelInput: base,
      sourceItems: [...inputItems],
      persistedItems: [],
      filterApplied: false
    };
  }
  try {
    const result = await callModelInputFilter({
      modelData: base,
      agent,
      context: context.context
    });
    if (!result || !Array.isArray(result.input)) {
      throw new UserError("callModelInputFilter must return a ModelInputData object with an input array.");
    }
    const sourceItems = result.input.map((item) => {
      if (!item || typeof item !== "object") {
        return;
      }
      const original = cloneMap.get(item);
      if (original) {
        removeFromFallback(original);
        removeAgentInputFromPool(originalPool, original);
        return original;
      }
      const key = getAgentInputItemKey(item);
      const matchedByContent = takeAgentInputFromPool(originalPool, key);
      if (matchedByContent) {
        removeFromFallback(matchedByContent);
        return matchedByContent;
      }
      const fallback = takeFallbackOriginal();
      if (fallback) {
        return fallback;
      }
      return;
    });
    const clonedFilteredInput = cloneInputItems(result.input);
    return {
      modelInput: {
        input: clonedFilteredInput,
        instructions: typeof result.instructions === "undefined" ? systemInstructions : result.instructions
      },
      sourceItems,
      persistedItems: clonedFilteredInput.map((item) => structuredClone(item)),
      filterApplied: true
    };
  } catch (error47) {
    addErrorToCurrentSpan({
      message: "Error in callModelInputFilter",
      data: { error: String(error47) }
    });
    throw error47;
  }
}

class ServerConversationTracker {
  conversationId;
  previousResponseId;
  sentInitialInput = false;
  sentItems = new WeakSet;
  serverItems = new WeakSet;
  remainingInitialInput = null;
  constructor({ conversationId, previousResponseId }) {
    this.conversationId = conversationId ?? undefined;
    this.previousResponseId = previousResponseId ?? undefined;
  }
  primeFromState({ originalInput, generatedItems, modelResponses }) {
    if (this.sentInitialInput) {
      return;
    }
    for (const item of toAgentInputList(originalInput)) {
      if (item && typeof item === "object") {
        this.sentItems.add(item);
      }
    }
    this.sentInitialInput = true;
    this.remainingInitialInput = null;
    const latestResponse = modelResponses[modelResponses.length - 1];
    for (const response of modelResponses) {
      for (const item of response.output) {
        if (item && typeof item === "object") {
          this.serverItems.add(item);
        }
      }
    }
    if (!this.conversationId && latestResponse?.responseId) {
      this.previousResponseId = latestResponse.responseId;
    }
    for (const item of generatedItems) {
      const rawItem = item.rawItem;
      if (!rawItem || typeof rawItem !== "object") {
        continue;
      }
      if (this.serverItems.has(rawItem)) {
        this.sentItems.add(rawItem);
      }
    }
  }
  trackServerItems(modelResponse) {
    if (!modelResponse) {
      return;
    }
    for (const item of modelResponse.output) {
      if (item && typeof item === "object") {
        this.serverItems.add(item);
      }
    }
    if (!this.conversationId && modelResponse.responseId) {
      this.previousResponseId = modelResponse.responseId;
    }
  }
  prepareInput(originalInput, generatedItems) {
    const inputItems = [];
    if (!this.sentInitialInput) {
      const initialItems = toAgentInputList(originalInput);
      inputItems.push(...initialItems);
      this.remainingInitialInput = initialItems.filter((item) => Boolean(item) && typeof item === "object");
      this.sentInitialInput = true;
    } else if (this.remainingInitialInput && this.remainingInitialInput.length > 0) {
      inputItems.push(...this.remainingInitialInput);
    }
    for (const item of generatedItems) {
      if (item.type === "tool_approval_item") {
        continue;
      }
      const rawItem = item.rawItem;
      if (!rawItem || typeof rawItem !== "object") {
        continue;
      }
      if (this.sentItems.has(rawItem) || this.serverItems.has(rawItem)) {
        continue;
      }
      inputItems.push(rawItem);
    }
    return inputItems;
  }
  markInputAsSent(items) {
    if (!items.length) {
      return;
    }
    const delivered = new Set;
    for (const item of items) {
      if (!item || typeof item !== "object" || delivered.has(item)) {
        continue;
      }
      delivered.add(item);
      this.sentItems.add(item);
    }
    if (!this.remainingInitialInput || this.remainingInitialInput.length === 0) {
      return;
    }
    this.remainingInitialInput = this.remainingInitialInput.filter((item) => !delivered.has(item));
    if (this.remainingInitialInput.length === 0) {
      this.remainingInitialInput = null;
    }
  }
}
function adjustModelSettingsForNonGPT5RunnerModel(explictlyModelSet, agentModelSettings, runnerModel, modelSettings) {
  if (isGpt5Default() && explictlyModelSet && (typeof runnerModel !== "string" || !gpt5ReasoningSettingsRequired(runnerModel)) && (agentModelSettings.providerData?.reasoning || agentModelSettings.providerData?.text?.verbosity || agentModelSettings.providerData?.reasoning_effort)) {
    const copiedModelSettings = { ...modelSettings };
    delete copiedModelSettings.providerData?.reasoning;
    delete copiedModelSettings.providerData?.text?.verbosity;
    delete copiedModelSettings.providerData?.reasoning_effort;
    if (copiedModelSettings.reasoning) {
      delete copiedModelSettings.reasoning.effort;
      delete copiedModelSettings.reasoning.summary;
    }
    if (copiedModelSettings.text) {
      delete copiedModelSettings.text.verbosity;
    }
    return copiedModelSettings;
  }
  return modelSettings;
}
async function prepareAgentArtifacts(state) {
  const handoffs = await state._currentAgent.getEnabledHandoffs(state._context);
  const tools = await state._currentAgent.getAllTools(state._context);
  if (!state._currentAgentSpan) {
    const handoffNames = handoffs.map((h) => h.agentName);
    state._currentAgentSpan = createAgentSpan({
      data: {
        name: state._currentAgent.name,
        handoffs: handoffNames,
        tools: tools.map((t) => t.name),
        output_type: state._currentAgent.outputSchemaName
      }
    });
    state._currentAgentSpan.start();
    setCurrentSpan(state._currentAgentSpan);
  } else {
    state._currentAgentSpan.spanData.tools = tools.map((t) => t.name);
  }
  return {
    handoffs,
    tools,
    serializedHandoffs: handoffs.map((handoff2) => serializeHandoff(handoff2)),
    serializedTools: tools.map((tool2) => serializeTool(tool2)),
    toolsExplicitlyProvided: state._currentAgent.hasExplicitToolConfig()
  };
}
function getAgentInputItemKey(item) {
  return JSON.stringify(item, agentInputSerializationReplacer);
}
function buildAgentInputPool(items) {
  const pool = new Map;
  for (const item of items) {
    const key = getAgentInputItemKey(item);
    const existing = pool.get(key);
    if (existing) {
      existing.push(item);
    } else {
      pool.set(key, [item]);
    }
  }
  return pool;
}
function takeAgentInputFromPool(pool, key) {
  const candidates = pool.get(key);
  if (!candidates || candidates.length === 0) {
    return;
  }
  const [first] = candidates;
  candidates.shift();
  if (candidates.length === 0) {
    pool.delete(key);
  }
  return first;
}
function removeAgentInputFromPool(pool, item) {
  const key = getAgentInputItemKey(item);
  const candidates = pool.get(key);
  if (!candidates || candidates.length === 0) {
    return;
  }
  const index = candidates.findIndex((candidate) => candidate === item);
  if (index === -1) {
    return;
  }
  candidates.splice(index, 1);
  if (candidates.length === 0) {
    pool.delete(key);
  }
}
function agentInputSerializationReplacer(_key, value) {
  if (value instanceof ArrayBuffer) {
    return {
      __type: "ArrayBuffer",
      data: encodeUint8ArrayToBase64(new Uint8Array(value))
    };
  }
  if (isArrayBufferView(value)) {
    const view = value;
    return {
      __type: view.constructor.name,
      data: encodeUint8ArrayToBase64(new Uint8Array(view.buffer, view.byteOffset, view.byteLength))
    };
  }
  if (isNodeBuffer(value)) {
    const view = value;
    return {
      __type: "Buffer",
      data: encodeUint8ArrayToBase64(new Uint8Array(view.buffer, view.byteOffset, view.byteLength))
    };
  }
  if (isSerializedBufferSnapshot(value)) {
    return {
      __type: "Buffer",
      data: encodeUint8ArrayToBase64(Uint8Array.from(value.data))
    };
  }
  return value;
}
function toAgentInputList(originalInput) {
  if (typeof originalInput === "string") {
    return [{ type: "message", role: "user", content: originalInput }];
  }
  return [...originalInput];
}

// node_modules/@openai/agents-core/dist/result.mjs
class RunResultBase {
  state;
  constructor(state) {
    this.state = state;
  }
  get history() {
    return getTurnInput(this.input, this.newItems);
  }
  get output() {
    return getTurnInput([], this.newItems);
  }
  get input() {
    return this.state._originalInput;
  }
  get newItems() {
    return this.state._generatedItems;
  }
  get rawResponses() {
    return this.state._modelResponses;
  }
  get lastResponseId() {
    const responses = this.rawResponses;
    return responses && responses.length > 0 ? responses[responses.length - 1].responseId : undefined;
  }
  get lastAgent() {
    return this.state._currentAgent;
  }
  get inputGuardrailResults() {
    return this.state._inputGuardrailResults;
  }
  get outputGuardrailResults() {
    return this.state._outputGuardrailResults;
  }
  get interruptions() {
    if (this.state._currentStep?.type === "next_step_interruption") {
      return this.state._currentStep.data.interruptions;
    }
    return [];
  }
  get finalOutput() {
    if (this.state._currentStep?.type === "next_step_final_output") {
      return this.state._currentAgent.processFinalOutput(this.state._currentStep.output);
    }
    logger_default.warn("Accessed finalOutput before agent run is completed.");
    return;
  }
}

class RunResult extends RunResultBase {
  constructor(state) {
    super(state);
  }
}

class StreamedRunResult extends RunResultBase {
  get currentAgent() {
    return this.lastAgent;
  }
  currentTurn = 0;
  maxTurns;
  #error = null;
  #signal;
  #readableController;
  #readableStream;
  #completedPromise;
  #completedPromiseResolve;
  #completedPromiseReject;
  #cancelled = false;
  #streamLoopPromise;
  constructor(result = {}) {
    super(result.state);
    this.#signal = result.signal;
    this.#readableStream = new ReadableStream2({
      start: (controller) => {
        this.#readableController = controller;
      },
      cancel: () => {
        this.#cancelled = true;
      }
    });
    this.#completedPromise = new Promise((resolve, reject) => {
      this.#completedPromiseResolve = resolve;
      this.#completedPromiseReject = reject;
    });
    if (this.#signal) {
      const handleAbort = () => {
        if (this.#cancelled) {
          return;
        }
        this.#cancelled = true;
        const controller = this.#readableController;
        this.#readableController = undefined;
        if (this.#readableStream.locked) {
          if (controller) {
            try {
              controller.close();
            } catch (err) {
              logger_default.debug(`Failed to close readable stream on abort: ${err}`);
            }
          }
        } else {
          this.#readableStream.cancel(this.#signal?.reason).catch((err) => {
            logger_default.debug(`Failed to cancel readable stream on abort: ${err}`);
          });
        }
        this.#completedPromiseResolve?.();
      };
      if (this.#signal.aborted) {
        handleAbort();
      } else {
        this.#signal.addEventListener("abort", handleAbort, { once: true });
      }
    }
  }
  _addItem(item) {
    if (!this.cancelled) {
      this.#readableController?.enqueue(item);
    }
  }
  _done() {
    if (!this.cancelled && this.#readableController) {
      this.#readableController.close();
      this.#readableController = undefined;
      this.#completedPromiseResolve?.();
    }
  }
  _raiseError(err) {
    if (!this.cancelled && this.#readableController) {
      this.#readableController.error(err);
      this.#readableController = undefined;
    }
    this.#error = err;
    this.#completedPromiseReject?.(err);
    this.#completedPromise.catch((e) => {
      logger_default.debug(`Resulted in an error: ${e}`);
    });
  }
  get cancelled() {
    return this.#cancelled;
  }
  toStream() {
    return this.#readableStream;
  }
  get completed() {
    return this.#completedPromise;
  }
  get error() {
    return this.#error;
  }
  toTextStream(options = {}) {
    const stream = this.#readableStream.pipeThrough(new TransformStream2({
      transform(event, controller) {
        if (event.type === "raw_model_stream_event" && event.data.type === "output_text_delta") {
          const item = StreamEventTextStream.parse(event.data);
          controller.enqueue(item.delta);
        }
      }
    }));
    if (options.compatibleWithNodeStreams) {
      return Readable.fromWeb(stream);
    }
    return stream;
  }
  [Symbol.asyncIterator]() {
    return this.#readableStream[Symbol.asyncIterator]();
  }
  _setStreamLoopPromise(promise4) {
    this.#streamLoopPromise = promise4;
  }
  _getStreamLoopPromise() {
    return this.#streamLoopPromise;
  }
}

// node_modules/@openai/agents-core/dist/tracing/context.mjs
var _contextAsyncLocalStorage;
function getContextAsyncLocalStorage() {
  _contextAsyncLocalStorage ??= new AsyncLocalStorage;
  return _contextAsyncLocalStorage;
}
function getCurrentTrace() {
  const currentTrace = getContextAsyncLocalStorage().getStore();
  if (currentTrace?.trace) {
    return currentTrace.trace;
  }
  return null;
}
function getCurrentSpan() {
  const currentSpan = getContextAsyncLocalStorage().getStore();
  if (currentSpan?.span) {
    return currentSpan.span;
  }
  return null;
}
function _wrapFunctionWithTraceLifecycle(fn) {
  return async () => {
    const trace = getCurrentTrace();
    if (!trace) {
      throw new Error("No trace found");
    }
    await trace.start();
    const result = await fn(trace);
    if (result instanceof StreamedRunResult) {
      const streamLoopPromise = result._getStreamLoopPromise();
      if (streamLoopPromise) {
        streamLoopPromise.finally(() => trace.end());
        return result;
      }
    }
    await trace.end();
    return result;
  };
}
async function withTrace(trace, fn, options = {}) {
  const newTrace = typeof trace === "string" ? getGlobalTraceProvider().createTrace({
    ...options,
    name: trace
  }) : trace;
  return getContextAsyncLocalStorage().run({ trace: newTrace }, _wrapFunctionWithTraceLifecycle(fn));
}
async function getOrCreateTrace(fn, options = {}) {
  const currentTrace = getCurrentTrace();
  if (currentTrace) {
    return await fn();
  }
  const newTrace = getGlobalTraceProvider().createTrace(options);
  return getContextAsyncLocalStorage().run({ trace: newTrace }, _wrapFunctionWithTraceLifecycle(fn));
}
function setCurrentSpan(span) {
  const context = getContextAsyncLocalStorage().getStore();
  if (!context) {
    throw new Error("No existing trace found");
  }
  if (context.span) {
    context.span.previousSpan = context.previousSpan;
    context.previousSpan = context.span;
  }
  context.span = span;
  getContextAsyncLocalStorage().enterWith(context);
}
function resetCurrentSpan() {
  const context = getContextAsyncLocalStorage().getStore();
  if (context) {
    context.span = context.previousSpan;
    context.previousSpan = context.previousSpan?.previousSpan;
    getContextAsyncLocalStorage().enterWith(context);
  }
}
function addErrorToCurrentSpan(spanError) {
  const currentSpan = getCurrentSpan();
  if (currentSpan) {
    currentSpan.setError(spanError);
  }
}
function cloneCurrentContext(context) {
  return {
    trace: context.trace?.clone(),
    span: context.span?.clone(),
    previousSpan: context.previousSpan?.clone()
  };
}
function withNewSpanContext(fn) {
  const currentContext = getContextAsyncLocalStorage().getStore();
  if (!currentContext) {
    throw new Error("No existing trace found");
  }
  const copyOfContext = cloneCurrentContext(currentContext);
  return getContextAsyncLocalStorage().run(copyOfContext, fn);
}

// node_modules/@openai/agents-core/dist/tracing/processor.mjs
class ConsoleSpanExporter {
  async export(items) {
    if (tracing.disabled) {
      logger_default.debug("Tracing is disabled. Skipping export");
      return;
    }
    for (const item of items) {
      if (item.type === "trace") {
        console.log(`[Exporter] Export trace traceId=${item.traceId} name=${item.name}${item.groupId ? ` groupId=${item.groupId}` : ""}`);
      } else {
        console.log(`[Exporter] Export span: ${JSON.stringify(item)}`);
      }
    }
  }
}

class BatchTraceProcessor {
  #maxQueueSize;
  #maxBatchSize;
  #scheduleDelay;
  #exportTriggerSize;
  #exporter;
  #buffer = [];
  #timer;
  #timeout = null;
  #exportInProgress = false;
  #timeoutAbortController = null;
  constructor(exporter, {
    maxQueueSize = 1000,
    maxBatchSize = 100,
    scheduleDelay = 5000,
    exportTriggerRatio = 0.8
  } = {}) {
    this.#maxQueueSize = maxQueueSize;
    this.#maxBatchSize = maxBatchSize;
    this.#scheduleDelay = scheduleDelay;
    this.#exportTriggerSize = maxQueueSize * exportTriggerRatio;
    this.#exporter = exporter;
    this.#timer = timer;
    if (isTracingLoopRunningByDefault()) {
      this.start();
    } else {
      logger_default.debug("Automatic trace export loop is not supported in this environment. You need to manually call `getGlobalTraceProvider().forceFlush()` to export traces.");
    }
  }
  start() {
    this.#timeoutAbortController = new AbortController;
    this.#runExportLoop();
  }
  async#safeAddItem(item) {
    if (this.#buffer.length + 1 > this.#maxQueueSize) {
      logger_default.error("Dropping trace because buffer is full");
      return;
    }
    this.#buffer.push(item);
    if (this.#buffer.length > this.#exportTriggerSize) {
      await this.#exportBatches();
    }
  }
  #runExportLoop() {
    this.#timeout = this.#timer.setTimeout(async () => {
      await this.#exportBatches();
      this.#runExportLoop();
    }, this.#scheduleDelay);
    if (typeof this.#timeout.unref === "function") {
      this.#timeout.unref();
    }
  }
  async#exportBatches(force = false) {
    if (this.#buffer.length === 0) {
      return;
    }
    logger_default.debug(`Exporting batches. Force: ${force}. Buffer size: ${this.#buffer.length}`);
    if (force || this.#buffer.length < this.#maxBatchSize) {
      const toExport = [...this.#buffer];
      this.#buffer = [];
      this.#exportInProgress = true;
      await this.#exporter.export(toExport);
      this.#exportInProgress = false;
    } else if (this.#buffer.length > 0) {
      const batch = this.#buffer.splice(0, this.#maxBatchSize);
      this.#exportInProgress = true;
      await this.#exporter.export(batch);
      this.#exportInProgress = false;
    }
  }
  async onTraceStart(trace) {
    await this.#safeAddItem(trace);
  }
  async onTraceEnd(_trace) {}
  async onSpanStart(_span) {}
  async onSpanEnd(span) {
    await this.#safeAddItem(span);
  }
  async shutdown(timeout) {
    if (timeout) {
      this.#timer.setTimeout(() => {
        this.#timeoutAbortController?.abort();
      }, timeout);
    }
    logger_default.debug("Shutting down gracefully");
    while (this.#buffer.length > 0) {
      logger_default.debug(`Waiting for buffer to empty. Items left: ${this.#buffer.length}`);
      if (!this.#exportInProgress) {
        await this.#exportBatches(true);
      }
      if (this.#timeoutAbortController?.signal.aborted) {
        logger_default.debug("Timeout reached, force flushing");
        await this.#exportBatches(true);
        break;
      }
      await new Promise((resolve) => this.#timer.setTimeout(resolve, 500));
    }
    logger_default.debug("Buffer empty. Exiting");
    if (this.#timer && this.#timeout) {
      this.#timer.clearTimeout(this.#timeout);
    }
  }
  async forceFlush() {
    if (this.#buffer.length > 0) {
      await this.#exportBatches(true);
    }
  }
}

class MultiTracingProcessor {
  #processors = [];
  start() {
    for (const processor of this.#processors) {
      if (processor.start) {
        processor.start();
      }
    }
  }
  addTraceProcessor(processor) {
    this.#processors.push(processor);
  }
  setProcessors(processors) {
    logger_default.debug("Shutting down old processors");
    for (const processor of this.#processors) {
      processor.shutdown();
    }
    this.#processors = processors;
  }
  async onTraceStart(trace) {
    for (const processor of this.#processors) {
      await processor.onTraceStart(trace);
    }
  }
  async onTraceEnd(trace) {
    for (const processor of this.#processors) {
      await processor.onTraceEnd(trace);
    }
  }
  async onSpanStart(span) {
    for (const processor of this.#processors) {
      await processor.onSpanStart(span);
    }
  }
  async onSpanEnd(span) {
    for (const processor of this.#processors) {
      await processor.onSpanEnd(span);
    }
  }
  async shutdown(timeout) {
    for (const processor of this.#processors) {
      await processor.shutdown(timeout);
    }
  }
  async forceFlush() {
    for (const processor of this.#processors) {
      await processor.forceFlush();
    }
  }
}
var _defaultExporter = null;
var _defaultProcessor = null;
function defaultExporter() {
  if (!_defaultExporter) {
    _defaultExporter = new ConsoleSpanExporter;
  }
  return _defaultExporter;
}
function defaultProcessor() {
  if (!_defaultProcessor) {
    _defaultProcessor = new BatchTraceProcessor(defaultExporter());
  }
  return _defaultProcessor;
}

// node_modules/@openai/agents-core/dist/tracing/utils.mjs
function timeIso() {
  return new Date().toISOString();
}
function generateTraceId() {
  return `trace_${randomUUID().replace(/-/g, "")}`;
}
function generateSpanId() {
  return `span_${randomUUID().replace(/-/g, "").slice(0, 24)}`;
}
function removePrivateFields(obj) {
  return Object.fromEntries(Object.entries(obj).filter(([key]) => !key.startsWith("_")));
}

// node_modules/@openai/agents-core/dist/tracing/spans.mjs
class Span {
  type = "trace.span";
  #data;
  #traceId;
  #spanId;
  #parentId;
  #processor;
  #startedAt;
  #endedAt;
  #error;
  #previousSpan;
  constructor(options, processor) {
    this.#traceId = options.traceId;
    this.#spanId = options.spanId ?? generateSpanId();
    this.#data = options.data;
    this.#processor = processor;
    this.#parentId = options.parentId ?? null;
    this.#error = options.error ?? null;
    this.#startedAt = options.startedAt ?? null;
    this.#endedAt = options.endedAt ?? null;
  }
  get traceId() {
    return this.#traceId;
  }
  get spanData() {
    return this.#data;
  }
  get spanId() {
    return this.#spanId;
  }
  get parentId() {
    return this.#parentId;
  }
  get previousSpan() {
    return this.#previousSpan;
  }
  set previousSpan(span) {
    this.#previousSpan = span;
  }
  start() {
    if (this.#startedAt) {
      logger_default.warn("Span already started");
      return;
    }
    this.#startedAt = timeIso();
    this.#processor.onSpanStart(this);
  }
  end() {
    if (this.#endedAt) {
      logger_default.debug("Span already finished", this.spanData);
      return;
    }
    this.#endedAt = timeIso();
    this.#processor.onSpanEnd(this);
  }
  setError(error47) {
    this.#error = error47;
  }
  get error() {
    return this.#error;
  }
  get startedAt() {
    return this.#startedAt;
  }
  get endedAt() {
    return this.#endedAt;
  }
  clone() {
    const span = new Span({
      traceId: this.traceId,
      spanId: this.spanId,
      parentId: this.parentId ?? undefined,
      data: this.spanData,
      startedAt: this.#startedAt ?? undefined,
      endedAt: this.#endedAt ?? undefined,
      error: this.#error ?? undefined
    }, this.#processor);
    span.previousSpan = this.previousSpan?.clone();
    return span;
  }
  toJSON() {
    return {
      object: this.type,
      id: this.spanId,
      trace_id: this.traceId,
      parent_id: this.parentId,
      started_at: this.startedAt,
      ended_at: this.endedAt,
      span_data: removePrivateFields(this.spanData),
      error: this.error
    };
  }
}

class NoopSpan extends Span {
  constructor(data, processor) {
    super({ traceId: "no-op", spanId: "no-op", data }, processor);
  }
  start() {
    return;
  }
  end() {
    return;
  }
  setError() {
    return;
  }
  toJSON() {
    return null;
  }
}

// node_modules/@openai/agents-core/dist/tracing/traces.mjs
class Trace {
  type = "trace";
  traceId;
  name;
  groupId = null;
  metadata;
  #processor;
  #started;
  constructor(options, processor) {
    this.traceId = options.traceId ?? generateTraceId();
    this.name = options.name ?? "Agent workflow";
    this.groupId = options.groupId ?? null;
    this.metadata = options.metadata ?? {};
    this.#processor = processor ?? defaultProcessor();
    this.#started = options.started ?? false;
  }
  async start() {
    if (this.#started) {
      return;
    }
    this.#started = true;
    await this.#processor.onTraceStart(this);
  }
  async end() {
    if (!this.#started) {
      return;
    }
    this.#started = false;
    await this.#processor.onTraceEnd(this);
  }
  clone() {
    return new Trace({
      traceId: this.traceId,
      name: this.name,
      groupId: this.groupId ?? undefined,
      metadata: this.metadata,
      started: this.#started
    });
  }
  toJSON() {
    return {
      object: this.type,
      id: this.traceId,
      workflow_name: this.name,
      group_id: this.groupId,
      metadata: this.metadata
    };
  }
}

class NoopTrace extends Trace {
  constructor() {
    super({});
  }
  async start() {
    return;
  }
  async end() {
    return;
  }
  toJSON() {
    return null;
  }
}

// node_modules/@openai/agents-core/dist/tracing/provider.mjs
class TraceProvider {
  #multiProcessor;
  #disabled;
  constructor() {
    this.#multiProcessor = new MultiTracingProcessor;
    this.#disabled = tracing.disabled;
    this.#addCleanupListeners();
  }
  registerProcessor(processor) {
    this.#multiProcessor.addTraceProcessor(processor);
  }
  setProcessors(processors) {
    this.#multiProcessor.setProcessors(processors);
  }
  getCurrentTrace() {
    return getCurrentTrace();
  }
  getCurrentSpan() {
    return getCurrentSpan();
  }
  setDisabled(disabled) {
    this.#disabled = disabled;
  }
  startExportLoop() {
    this.#multiProcessor.start();
  }
  createTrace(traceOptions) {
    if (this.#disabled) {
      logger_default.debug("Tracing is disabled, Not creating trace %o", traceOptions);
      return new NoopTrace;
    }
    const traceId = traceOptions.traceId ?? generateTraceId();
    const name = traceOptions.name ?? "Agent workflow";
    logger_default.debug("Creating trace %s with name %s", traceId, name);
    return new Trace({ ...traceOptions, name, traceId }, this.#multiProcessor);
  }
  createSpan(spanOptions, parent) {
    if (this.#disabled || spanOptions.disabled) {
      logger_default.debug("Tracing is disabled, Not creating span %o", spanOptions);
      return new NoopSpan(spanOptions.data, this.#multiProcessor);
    }
    let parentId;
    let traceId;
    if (!parent) {
      const currentTrace = getCurrentTrace();
      const currentSpan = getCurrentSpan();
      if (!currentTrace) {
        logger_default.error("No active trace. Make sure to start a trace with `withTrace()` first. Returning NoopSpan.");
        return new NoopSpan(spanOptions.data, this.#multiProcessor);
      }
      if (currentSpan instanceof NoopSpan || currentTrace instanceof NoopTrace) {
        logger_default.debug(`Parent ${currentSpan} or ${currentTrace} is no-op, returning NoopSpan`);
        return new NoopSpan(spanOptions.data, this.#multiProcessor);
      }
      traceId = currentTrace.traceId;
      if (currentSpan) {
        logger_default.debug("Using parent span %s", currentSpan.spanId);
        parentId = currentSpan.spanId;
      } else {
        logger_default.debug("No parent span, using current trace %s", currentTrace.traceId);
      }
    } else if (parent instanceof Trace) {
      if (parent instanceof NoopTrace) {
        logger_default.debug("Parent trace is no-op, returning NoopSpan");
        return new NoopSpan(spanOptions.data, this.#multiProcessor);
      }
      traceId = parent.traceId;
    } else if (parent instanceof Span) {
      if (parent instanceof NoopSpan) {
        logger_default.debug("Parent span is no-op, returning NoopSpan");
        return new NoopSpan(spanOptions.data, this.#multiProcessor);
      }
      parentId = parent.spanId;
      traceId = parent.traceId;
    }
    if (!traceId) {
      logger_default.error("No traceId found. Make sure to start a trace with `withTrace()` first. Returning NoopSpan.");
      return new NoopSpan(spanOptions.data, this.#multiProcessor);
    }
    logger_default.debug(`Creating span ${JSON.stringify(spanOptions.data)} with id ${spanOptions.spanId ?? traceId}`);
    return new Span({
      ...spanOptions,
      traceId,
      parentId
    }, this.#multiProcessor);
  }
  async shutdown(timeout) {
    try {
      logger_default.debug("Shutting down tracing provider");
      await this.#multiProcessor.shutdown(timeout);
    } catch (error47) {
      logger_default.error("Error shutting down tracing provider %o", error47);
    }
  }
  #addCleanupListeners() {
    if (typeof process !== "undefined" && typeof process.on === "function") {
      const cleanup = async () => {
        const timeout = setTimeout(() => {
          console.warn("Cleanup timeout, forcing exit");
          process.exit(1);
        }, 5000);
        try {
          await this.shutdown();
        } finally {
          clearTimeout(timeout);
        }
      };
      process.on("beforeExit", cleanup);
      process.on("SIGINT", async () => {
        await cleanup();
        if (!hasOtherListenersForSignals("SIGINT")) {
          process.exit(130);
        }
      });
      process.on("SIGTERM", async () => {
        await cleanup();
        if (!hasOtherListenersForSignals("SIGTERM")) {
          process.exit(0);
        }
      });
      process.on("unhandledRejection", async (reason, promise4) => {
        logger_default.error("Unhandled rejection", reason, promise4);
        await cleanup();
        if (!hasOtherListenersForEvents("unhandledRejection")) {
          process.exit(1);
        }
      });
    }
  }
  async forceFlush() {
    await this.#multiProcessor.forceFlush();
  }
}
function hasOtherListenersForSignals(event) {
  return process.listeners(event).length > 1;
}
function hasOtherListenersForEvents(event) {
  return process.listeners(event).length > 1;
}
var GLOBAL_TRACE_PROVIDER = undefined;
function getGlobalTraceProvider() {
  if (!GLOBAL_TRACE_PROVIDER) {
    GLOBAL_TRACE_PROVIDER = new TraceProvider;
  }
  return GLOBAL_TRACE_PROVIDER;
}

// node_modules/@openai/agents-core/dist/tracing/index.mjs
function addTraceProcessor(processor) {
  getGlobalTraceProvider().registerProcessor(processor);
}
function setTraceProcessors(processors) {
  getGlobalTraceProvider().setProcessors(processors);
}

// node_modules/@openai/agents-core/dist/index.mjs
addTraceProcessor(defaultProcessor());

// node_modules/openai/internal/tslib.mjs
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

// node_modules/openai/internal/utils/uuid.mjs
var uuid42 = function() {
  const { crypto: crypto2 } = globalThis;
  if (crypto2?.randomUUID) {
    uuid42 = crypto2.randomUUID.bind(crypto2);
    return crypto2.randomUUID();
  }
  const u8 = new Uint8Array(1);
  const randomByte = crypto2 ? () => crypto2.getRandomValues(u8)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) => (+c ^ randomByte() & 15 >> +c / 4).toString(16));
};

// node_modules/openai/internal/utils/values.mjs
var startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL = (url2) => {
  return startsWithSchemeRegexp.test(url2);
};
var isArray = (val) => (isArray = Array.isArray, isArray(val));
var isReadonlyArray = isArray;
function maybeObj(x) {
  if (typeof x !== "object") {
    return {};
  }
  return x ?? {};
}
function isEmptyObj2(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function isObj(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj);
}
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n;
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return;
  }
};

// node_modules/openai/internal/utils/sleep.mjs
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// node_modules/openai/version.mjs
var VERSION = "6.10.0";

// node_modules/openai/internal/detect-platform.mjs
var isRunningInBrowser = () => {
  return typeof window !== "undefined" && typeof window.document !== "undefined" && typeof navigator !== "undefined";
};
function getDetectedPlatform() {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return "deno";
  }
  if (typeof EdgeRuntime !== "undefined") {
    return "edge";
  }
  if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
    return "node";
  }
  return "unknown";
}
var getPlatformProperties = () => {
  const detectedPlatform = getDetectedPlatform();
  if (detectedPlatform === "deno") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  }
  if (detectedPlatform === "node") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": normalizeArch(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
};

// node_modules/openai/internal/shims.mjs
function getDefaultFetch() {
  if (typeof fetch !== "undefined") {
    return fetch;
  }
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function makeReadableStream(...args) {
  const ReadableStream3 = globalThis.ReadableStream;
  if (typeof ReadableStream3 === "undefined") {
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  }
  return new ReadableStream3(...args);
}
function ReadableStreamFrom(iterable) {
  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
  return makeReadableStream({
    start() {},
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      await iter.return?.();
    }
  });
}
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: undefined };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function CancelReadableStream(stream) {
  if (stream === null || typeof stream !== "object")
    return;
  if (stream[Symbol.asyncIterator]) {
    await stream[Symbol.asyncIterator]().return?.();
    return;
  }
  const reader = stream.getReader();
  const cancelPromise = reader.cancel();
  reader.releaseLock();
  await cancelPromise;
}

// node_modules/openai/internal/request-options.mjs
var FallbackEncoder = ({ headers, body }) => {
  return {
    bodyHeaders: {
      "content-type": "application/json"
    },
    body: JSON.stringify(body)
  };
};

// node_modules/openai/internal/qs/formats.mjs
var default_format = "RFC3986";
var default_formatter = (v) => String(v);
var formatters = {
  RFC1738: (v) => String(v).replace(/%20/g, "+"),
  RFC3986: default_formatter
};
var RFC1738 = "RFC1738";

// node_modules/openai/internal/qs/utils.mjs
var has = (obj, key) => (has = Object.hasOwn ?? Function.prototype.call.bind(Object.prototype.hasOwnProperty), has(obj, key));
var hex_table = /* @__PURE__ */ (() => {
  const array4 = [];
  for (let i = 0;i < 256; ++i) {
    array4.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array4;
})();
var limit = 1024;
var encode3 = (str, _defaultEncoder, charset, _kind, format2) => {
  if (str.length === 0) {
    return str;
  }
  let string6 = str;
  if (typeof str === "symbol") {
    string6 = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string6 = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string6).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  let out = "";
  for (let j = 0;j < string6.length; j += limit) {
    const segment = string6.length >= limit ? string6.slice(j, j + limit) : string6;
    const arr2 = [];
    for (let i = 0;i < segment.length; ++i) {
      let c = segment.charCodeAt(i);
      if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format2 === RFC1738 && (c === 40 || c === 41)) {
        arr2[arr2.length] = segment.charAt(i);
        continue;
      }
      if (c < 128) {
        arr2[arr2.length] = hex_table[c];
        continue;
      }
      if (c < 2048) {
        arr2[arr2.length] = hex_table[192 | c >> 6] + hex_table[128 | c & 63];
        continue;
      }
      if (c < 55296 || c >= 57344) {
        arr2[arr2.length] = hex_table[224 | c >> 12] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
      arr2[arr2.length] = hex_table[240 | c >> 18] + hex_table[128 | c >> 12 & 63] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
    }
    out += arr2.join("");
  }
  return out;
};
function is_buffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
function maybe_map(val, fn) {
  if (isArray(val)) {
    const mapped = [];
    for (let i = 0;i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
}

// node_modules/openai/internal/qs/stringify.mjs
var array_prefix_generators = {
  brackets(prefix) {
    return String(prefix) + "[]";
  },
  comma: "comma",
  indices(prefix, key) {
    return String(prefix) + "[" + key + "]";
  },
  repeat(prefix) {
    return String(prefix);
  }
};
var push_to_array = function(arr2, value_or_array) {
  Array.prototype.push.apply(arr2, isArray(value_or_array) ? value_or_array : [value_or_array]);
};
var toISOString;
var defaults = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: encode3,
  encodeValuesOnly: false,
  format: default_format,
  formatter: default_formatter,
  indices: false,
  serializeDate(date8) {
    return (toISOString ?? (toISOString = Function.prototype.call.bind(Date.prototype.toISOString)))(date8);
  },
  skipNulls: false,
  strictNullHandling: false
};
function is_non_nullish_primitive(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
}
var sentinel = {};
function inner_stringify(object5, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder2, filter, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, sideChannel) {
  let obj = object5;
  let tmp_sc = sideChannel;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== undefined && !find_flag) {
    const pos = tmp_sc.get(object5);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate?.(obj);
  } else if (generateArrayPrefix === "comma" && isArray(obj)) {
    obj = maybe_map(obj, function(value) {
      if (value instanceof Date) {
        return serializeDate?.(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder2 && !encodeValuesOnly ? encoder2(prefix, defaults.encoder, charset, "key", format2) : prefix;
    }
    obj = "";
  }
  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
    if (encoder2) {
      const key_value = encodeValuesOnly ? prefix : encoder2(prefix, defaults.encoder, charset, "key", format2);
      return [
        formatter?.(key_value) + "=" + formatter?.(encoder2(obj, defaults.encoder, charset, "value", format2))
      ];
    }
    return [formatter?.(prefix) + "=" + formatter?.(String(obj))];
  }
  const values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === "comma" && isArray(obj)) {
    if (encodeValuesOnly && encoder2) {
      obj = maybe_map(obj, encoder2);
    }
    obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : undefined }];
  } else if (isArray(filter)) {
    obj_keys = filter;
  } else {
    const keys = Object.keys(obj);
    obj_keys = sort ? keys.sort(sort) : keys;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
  const adjusted_prefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
  if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
    return adjusted_prefix + "[]";
  }
  for (let j = 0;j < obj_keys.length; ++j) {
    const key = obj_keys[j];
    const value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    const key_prefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
    sideChannel.set(object5, step);
    const valueSideChannel = new WeakMap;
    valueSideChannel.set(sentinel, sideChannel);
    push_to_array(values, inner_stringify(value, key_prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder2, filter, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, valueSideChannel));
  }
  return values;
}
function normalize_stringify_options(opts = defaults) {
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  const charset = opts.charset || defaults.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  let format2 = default_format;
  if (typeof opts.format !== "undefined") {
    if (!has(formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  const formatter = formatters[format2];
  let filter = defaults.filter;
  if (typeof opts.filter === "function" || isArray(opts.filter)) {
    filter = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter,
    format: format2,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
}
function stringify2(object5, opts = {}) {
  let obj = object5;
  const options = normalize_stringify_options(opts);
  let obj_keys;
  let filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (isArray(options.filter)) {
    filter = options.filter;
    obj_keys = filter;
  }
  const keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj);
  }
  if (options.sort) {
    obj_keys.sort(options.sort);
  }
  const sideChannel = new WeakMap;
  for (let i = 0;i < obj_keys.length; ++i) {
    const key = obj_keys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    push_to_array(keys, inner_stringify(obj[key], key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
  }
  const joined = keys.join(options.delimiter);
  let prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
}
// node_modules/openai/internal/utils/bytes.mjs
function concatBytes(buffers) {
  let length = 0;
  for (const buffer of buffers) {
    length += buffer.length;
  }
  const output = new Uint8Array(length);
  let index = 0;
  for (const buffer of buffers) {
    output.set(buffer, index);
    index += buffer.length;
  }
  return output;
}
var encodeUTF8_;
function encodeUTF8(str) {
  let encoder2;
  return (encodeUTF8_ ?? (encoder2 = new globalThis.TextEncoder, encodeUTF8_ = encoder2.encode.bind(encoder2)))(str);
}
var decodeUTF8_;
function decodeUTF8(bytes) {
  let decoder;
  return (decodeUTF8_ ?? (decoder = new globalThis.TextDecoder, decodeUTF8_ = decoder.decode.bind(decoder)))(bytes);
}

// node_modules/openai/internal/decoders/line.mjs
var _LineDecoder_buffer;
var _LineDecoder_carriageReturnIndex;

class LineDecoder {
  constructor() {
    _LineDecoder_buffer.set(this, undefined);
    _LineDecoder_carriageReturnIndex.set(this, undefined);
    __classPrivateFieldSet(this, _LineDecoder_buffer, new Uint8Array, "f");
    __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    __classPrivateFieldSet(this, _LineDecoder_buffer, concatBytes([__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), binaryChunk]), "f");
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex(__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f"))) != null) {
      if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") == null) {
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, "f");
        continue;
      }
      if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
        lines.push(decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
        __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f")), "f");
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
        continue;
      }
      const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, endIndex));
      lines.push(line);
      __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(patternIndex.index), "f");
      __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
    }
    return lines;
  }
  flush() {
    if (!__classPrivateFieldGet(this, _LineDecoder_buffer, "f").length) {
      return [];
    }
    return this.decode(`
`);
  }
}
_LineDecoder_buffer = new WeakMap, _LineDecoder_carriageReturnIndex = new WeakMap;
LineDecoder.NEWLINE_CHARS = new Set([`
`, "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function findNewlineIndex(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i = startIndex ?? 0;i < buffer.length; i++) {
    if (buffer[i] === newline) {
      return { preceding: i, index: i + 1, carriage: false };
    }
    if (buffer[i] === carriage) {
      return { preceding: i, index: i + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0;i < buffer.length - 1; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}

// node_modules/openai/internal/utils/log.mjs
var levelNumbers = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
};
var parseLogLevel = (maybeLevel, sourceName, client2) => {
  if (!maybeLevel) {
    return;
  }
  if (hasOwn(levelNumbers, maybeLevel)) {
    return maybeLevel;
  }
  loggerFor(client2).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);
  return;
};
function noop() {}
function makeLogFn(fnLevel, logger2, logLevel) {
  if (!logger2 || levelNumbers[fnLevel] > levelNumbers[logLevel]) {
    return noop;
  } else {
    return logger2[fnLevel].bind(logger2);
  }
}
var noopLogger = {
  error: noop,
  warn: noop,
  info: noop,
  debug: noop
};
var cachedLoggers = /* @__PURE__ */ new WeakMap;
function loggerFor(client2) {
  const logger2 = client2.logger;
  const logLevel = client2.logLevel ?? "off";
  if (!logger2) {
    return noopLogger;
  }
  const cachedLogger = cachedLoggers.get(logger2);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn("error", logger2, logLevel),
    warn: makeLogFn("warn", logger2, logLevel),
    info: makeLogFn("info", logger2, logLevel),
    debug: makeLogFn("debug", logger2, logLevel)
  };
  cachedLoggers.set(logger2, [logLevel, levelLogger]);
  return levelLogger;
}
var formatRequestDetails = (details) => {
  if (details.options) {
    details.options = { ...details.options };
    delete details.options["headers"];
  }
  if (details.headers) {
    details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
      name,
      name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
    ]));
  }
  if ("retryOfRequestLogID" in details) {
    if (details.retryOfRequestLogID) {
      details.retryOf = details.retryOfRequestLogID;
    }
    delete details.retryOfRequestLogID;
  }
  return details;
};

// node_modules/openai/core/streaming.mjs
var _Stream_client;

class Stream {
  constructor(iterator, controller, client2) {
    this.iterator = iterator;
    _Stream_client.set(this, undefined);
    this.controller = controller;
    __classPrivateFieldSet(this, _Stream_client, client2, "f");
  }
  static fromSSEResponse(response, controller, client2) {
    let consumed = false;
    const logger2 = client2 ? loggerFor(client2) : console;
    async function* iterator() {
      if (consumed) {
        throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null || !sse.event.startsWith("thread.")) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              logger2.error(`Could not parse message into JSON:`, sse.data);
              logger2.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError(undefined, data.error, undefined, response.headers);
            }
            yield data;
          } else {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (sse.event == "error") {
              throw new APIError(undefined, data.error, data.message, undefined);
            }
            yield { event: sse.event, data };
          }
        }
        done = true;
      } catch (e) {
        if (isAbortError(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller, client2);
  }
  static fromReadableStream(readableStream, controller, client2) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder;
      const iter = ReadableStreamToAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (isAbortError(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller, client2);
  }
  [(_Stream_client = new WeakMap, Symbol.asyncIterator)]() {
    return this.iterator();
  }
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue2) => {
      return {
        next: () => {
          if (queue2.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue2.shift();
        }
      };
    };
    return [
      new Stream(() => teeIterator(left), this.controller, __classPrivateFieldGet(this, _Stream_client, "f")),
      new Stream(() => teeIterator(right), this.controller, __classPrivateFieldGet(this, _Stream_client, "f"))
    ];
  }
  toReadableStream() {
    const self2 = this;
    let iter;
    return makeReadableStream({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encodeUTF8(JSON.stringify(value) + `
`);
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        await iter.return?.();
      }
    });
  }
}
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
      throw new OpenAIError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
    }
    throw new OpenAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder;
  const lineDecoder = new LineDecoder;
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array;
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}

class SSEDecoder {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
}
function partition(str, delimiter) {
  const index = str.indexOf(delimiter);
  if (index !== -1) {
    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
  }
  return [str, "", ""];
}

// node_modules/openai/internal/parse.mjs
async function defaultParseResponse(client2, props) {
  const { response, requestLogID, retryOfRequestLogID, startTime } = props;
  const body = await (async () => {
    if (props.options.stream) {
      loggerFor(client2).debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller, client2);
      }
      return Stream.fromSSEResponse(response, props.controller, client2);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const mediaType = contentType?.split(";")[0]?.trim();
    const isJSON = mediaType?.includes("application/json") || mediaType?.endsWith("+json");
    if (isJSON) {
      const json2 = await response.json();
      return addRequestID(json2, response);
    }
    const text = await response.text();
    return text;
  })();
  loggerFor(client2).debug(`[${requestLogID}] response parsed`, formatRequestDetails({
    retryOfRequestLogID,
    url: response.url,
    status: response.status,
    body,
    durationMs: Date.now() - startTime
  }));
  return body;
}
function addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("x-request-id"),
    enumerable: false
  });
}

// node_modules/openai/core/api-promise.mjs
var _APIPromise_client;

class APIPromise extends Promise {
  constructor(client2, responsePromise, parseResponse2 = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse2;
    _APIPromise_client.set(this, undefined);
    __classPrivateFieldSet(this, _APIPromise_client, client2, "f");
  }
  _thenUnwrap(transform2) {
    return new APIPromise(__classPrivateFieldGet(this, _APIPromise_client, "f"), this.responsePromise, async (client2, props) => addRequestID(transform2(await this.parseResponse(client2, props), props), props.response));
  }
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("x-request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(__classPrivateFieldGet(this, _APIPromise_client, "f"), data));
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
}
_APIPromise_client = new WeakMap;

// node_modules/openai/core/pagination.mjs
var _AbstractPage_client;

class AbstractPage {
  constructor(client2, response, body, options) {
    _AbstractPage_client.set(this, undefined);
    __classPrivateFieldSet(this, _AbstractPage_client, client2, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageRequestOptions() != null;
  }
  async getNextPage() {
    const nextOptions = this.nextPageRequestOptions();
    if (!nextOptions) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async* iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async* [(_AbstractPage_client = new WeakMap, Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
}

class PagePromise extends APIPromise {
  constructor(client2, request, Page) {
    super(client2, request, async (client3, props) => new Page(client3, props.response, await defaultParseResponse(client3, props), props.options));
  }
  async* [Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
}

class Page extends AbstractPage {
  constructor(client2, response, body, options) {
    super(client2, response, body, options);
    this.data = body.data || [];
    this.object = body.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  nextPageRequestOptions() {
    return null;
  }
}

class CursorPage extends AbstractPage {
  constructor(client2, response, body, options) {
    super(client2, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    const data = this.getPaginatedItems();
    const id = data[data.length - 1]?.id;
    if (!id) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj(this.options.query),
        after: id
      }
    };
  }
}

class ConversationCursorPage extends AbstractPage {
  constructor(client2, response, body, options) {
    super(client2, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
    this.last_id = body.last_id || "";
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    const cursor = this.last_id;
    if (!cursor) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj(this.options.query),
        after: cursor
      }
    };
  }
}

// node_modules/openai/internal/uploads.mjs
var checkFileSupport = () => {
  if (typeof File === "undefined") {
    const { process: process4 } = globalThis;
    const isOldNode = typeof process4?.versions?.node === "string" && parseInt(process4.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function makeFile(fileBits, fileName, options) {
  checkFileSupport();
  return new File(fileBits, fileName ?? "unknown_file", options);
}
function getName(value) {
  return (typeof value === "object" && value !== null && (("name" in value) && value.name && String(value.name) || ("url" in value) && value.url && String(value.url) || ("filename" in value) && value.filename && String(value.filename) || ("path" in value) && value.path && String(value.path)) || "").split(/[\\/]/).pop() || undefined;
}
var isAsyncIterable2 = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var maybeMultipartFormRequestOptions = async (opts, fetch2) => {
  if (!hasUploadableValue(opts.body))
    return opts;
  return { ...opts, body: await createForm(opts.body, fetch2) };
};
var multipartFormRequestOptions = async (opts, fetch2) => {
  return { ...opts, body: await createForm(opts.body, fetch2) };
};
var supportsFormDataMap = /* @__PURE__ */ new WeakMap;
function supportsFormData(fetchObject) {
  const fetch2 = typeof fetchObject === "function" ? fetchObject : fetchObject.fetch;
  const cached2 = supportsFormDataMap.get(fetch2);
  if (cached2)
    return cached2;
  const promise4 = (async () => {
    try {
      const FetchResponse = "Response" in fetch2 ? fetch2.Response : (await fetch2("data:,")).constructor;
      const data = new FormData;
      if (data.toString() === await new FetchResponse(data).text()) {
        return false;
      }
      return true;
    } catch {
      return true;
    }
  })();
  supportsFormDataMap.set(fetch2, promise4);
  return promise4;
}
var createForm = async (body, fetch2) => {
  if (!await supportsFormData(fetch2)) {
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  }
  const form = new FormData;
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var isNamedBlob = (value) => value instanceof Blob && ("name" in value);
var isUploadable = (value) => typeof value === "object" && value !== null && (value instanceof Response || isAsyncIterable2(value) || isNamedBlob(value));
var hasUploadableValue = (value) => {
  if (isUploadable(value))
    return true;
  if (Array.isArray(value))
    return value.some(hasUploadableValue);
  if (value && typeof value === "object") {
    for (const k in value) {
      if (hasUploadableValue(value[k]))
        return true;
    }
  }
  return false;
};
var addFormValue = async (form, key, value) => {
  if (value === undefined)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (value instanceof Response) {
    form.append(key, makeFile([await value.blob()], getName(value)));
  } else if (isAsyncIterable2(value)) {
    form.append(key, makeFile([await new Response(ReadableStreamFrom(value)).blob()], getName(value)));
  } else if (isNamedBlob(value)) {
    form.append(key, value, getName(value));
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/openai/internal/to-file.mjs
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
async function toFile(value, name, options) {
  checkFileSupport();
  value = await value;
  if (isFileLike(value)) {
    if (value instanceof File) {
      return value;
    }
    return makeFile([await value.arrayBuffer()], value.name);
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop());
    return makeFile(await getBytes(blob), name, options);
  }
  const parts = await getBytes(value);
  name || (name = getName(value));
  if (!options?.type) {
    const type = parts.find((part) => typeof part === "object" && ("type" in part) && part.type);
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return makeFile(parts, name, options);
}
async function getBytes(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable2(value)) {
    for await (const chunk of value) {
      parts.push(...await getBytes(chunk));
    }
  } else {
    const constructor = value?.constructor?.name;
    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  if (typeof value !== "object" || value === null)
    return "";
  const props = Object.getOwnPropertyNames(value);
  return `; props: [${props.map((p) => `"${p}"`).join(", ")}]`;
}
// node_modules/openai/core/resource.mjs
class APIResource {
  constructor(client2) {
    this._client = client2;
  }
}

// node_modules/openai/internal/utils/path.mjs
function encodeURIPath(str) {
  return str.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
var EMPTY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));
var createPathTagFunction = (pathEncoder = encodeURIPath) => function path(statics, ...params) {
  if (statics.length === 1)
    return statics[0];
  let postPath = false;
  const invalidSegments = [];
  const path = statics.reduce((previousValue, currentValue, index) => {
    if (/[?#]/.test(currentValue)) {
      postPath = true;
    }
    const value = params[index];
    let encoded = (postPath ? encodeURIComponent : pathEncoder)("" + value);
    if (index !== params.length && (value == null || typeof value === "object" && value.toString === Object.getPrototypeOf(Object.getPrototypeOf(value.hasOwnProperty ?? EMPTY) ?? EMPTY)?.toString)) {
      encoded = value + "";
      invalidSegments.push({
        start: previousValue.length + currentValue.length,
        length: encoded.length,
        error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`
      });
    }
    return previousValue + currentValue + (index === params.length ? "" : encoded);
  }, "");
  const pathOnly = path.split(/[?#]/, 1)[0];
  const invalidSegmentPattern = /(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi;
  let match;
  while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {
    invalidSegments.push({
      start: match.index,
      length: match[0].length,
      error: `Value "${match[0]}" can't be safely passed as a path parameter`
    });
  }
  invalidSegments.sort((a, b) => a.start - b.start);
  if (invalidSegments.length > 0) {
    let lastEnd = 0;
    const underline = invalidSegments.reduce((acc, segment) => {
      const spaces = " ".repeat(segment.start - lastEnd);
      const arrows = "^".repeat(segment.length);
      lastEnd = segment.start + segment.length;
      return acc + spaces + arrows;
    }, "");
    throw new OpenAIError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e) => e.error).join(`
`)}
${path}
${underline}`);
  }
  return path;
};
var path = /* @__PURE__ */ createPathTagFunction(encodeURIPath);

// node_modules/openai/resources/chat/completions/messages.mjs
class Messages extends APIResource {
  list(completionID, query = {}, options) {
    return this._client.getAPIList(path`/chat/completions/${completionID}/messages`, CursorPage, { query, ...options });
  }
}

// node_modules/openai/lib/chatCompletionUtils.mjs
var isAssistantMessage = (message) => {
  return message?.role === "assistant";
};
var isToolMessage2 = (message) => {
  return message?.role === "tool";
};

// node_modules/openai/lib/EventStream.mjs
var _EventStream_instances;
var _EventStream_connectedPromise;
var _EventStream_resolveConnectedPromise;
var _EventStream_rejectConnectedPromise;
var _EventStream_endPromise;
var _EventStream_resolveEndPromise;
var _EventStream_rejectEndPromise;
var _EventStream_listeners;
var _EventStream_ended;
var _EventStream_errored;
var _EventStream_aborted;
var _EventStream_catchingPromiseCreated;
var _EventStream_handleError;

class EventStream {
  constructor() {
    _EventStream_instances.add(this);
    this.controller = new AbortController;
    _EventStream_connectedPromise.set(this, undefined);
    _EventStream_resolveConnectedPromise.set(this, () => {});
    _EventStream_rejectConnectedPromise.set(this, () => {});
    _EventStream_endPromise.set(this, undefined);
    _EventStream_resolveEndPromise.set(this, () => {});
    _EventStream_rejectEndPromise.set(this, () => {});
    _EventStream_listeners.set(this, {});
    _EventStream_ended.set(this, false);
    _EventStream_errored.set(this, false);
    _EventStream_aborted.set(this, false);
    _EventStream_catchingPromiseCreated.set(this, false);
    __classPrivateFieldSet(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _EventStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet(this, _EventStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet(this, _EventStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _EventStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet(this, _EventStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet(this, _EventStream_connectedPromise, "f").catch(() => {});
    __classPrivateFieldGet(this, _EventStream_endPromise, "f").catch(() => {});
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
    }, 0);
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet(this, _EventStream_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet(this, _EventStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet(this, _EventStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet(this, _EventStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  on(event, listener) {
    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  off(event, listener) {
    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  once(event, listener) {
    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet(this, _EventStream_endPromise, "f");
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet(this, _EventStream_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet(this, _EventStream_ended, true, "f");
      __classPrivateFieldGet(this, _EventStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error47 = args[0];
      if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error47);
      }
      __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, "f").call(this, error47);
      __classPrivateFieldGet(this, _EventStream_rejectEndPromise, "f").call(this, error47);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error47 = args[0];
      if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error47);
      }
      __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, "f").call(this, error47);
      __classPrivateFieldGet(this, _EventStream_rejectEndPromise, "f").call(this, error47);
      this._emit("end");
    }
  }
  _emitFinal() {}
}
_EventStream_connectedPromise = new WeakMap, _EventStream_resolveConnectedPromise = new WeakMap, _EventStream_rejectConnectedPromise = new WeakMap, _EventStream_endPromise = new WeakMap, _EventStream_resolveEndPromise = new WeakMap, _EventStream_rejectEndPromise = new WeakMap, _EventStream_listeners = new WeakMap, _EventStream_ended = new WeakMap, _EventStream_errored = new WeakMap, _EventStream_aborted = new WeakMap, _EventStream_catchingPromiseCreated = new WeakMap, _EventStream_instances = new WeakSet, _EventStream_handleError = function _EventStream_handleError2(error47) {
  __classPrivateFieldSet(this, _EventStream_errored, true, "f");
  if (error47 instanceof Error && error47.name === "AbortError") {
    error47 = new APIUserAbortError;
  }
  if (error47 instanceof APIUserAbortError) {
    __classPrivateFieldSet(this, _EventStream_aborted, true, "f");
    return this._emit("abort", error47);
  }
  if (error47 instanceof OpenAIError) {
    return this._emit("error", error47);
  }
  if (error47 instanceof Error) {
    const openAIError = new OpenAIError(error47.message);
    openAIError.cause = error47;
    return this._emit("error", openAIError);
  }
  return this._emit("error", new OpenAIError(String(error47)));
};

// node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}

// node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var _AbstractChatCompletionRunner_instances;
var _AbstractChatCompletionRunner_getFinalContent;
var _AbstractChatCompletionRunner_getFinalMessage;
var _AbstractChatCompletionRunner_getFinalFunctionToolCall;
var _AbstractChatCompletionRunner_getFinalFunctionToolCallResult;
var _AbstractChatCompletionRunner_calculateTotalUsage;
var _AbstractChatCompletionRunner_validateParams;
var _AbstractChatCompletionRunner_stringifyFunctionCallResult;
var DEFAULT_MAX_CHAT_COMPLETIONS = 10;

class AbstractChatCompletionRunner extends EventStream {
  constructor() {
    super(...arguments);
    _AbstractChatCompletionRunner_instances.add(this);
    this._chatCompletions = [];
    this.messages = [];
  }
  _addChatCompletion(chatCompletion) {
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message = chatCompletion.choices[0]?.message;
    if (message)
      this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    if (!("content" in message))
      message.content = null;
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if (isToolMessage2(message) && message.content) {
        this._emit("functionToolCallResult", message.content);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionToolCall", tool_call.function);
          }
        }
      }
    }
  }
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  async finalFunctionToolCall() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
  }
  async finalFunctionToolCallResult() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionToolCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionToolCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(client2, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await client2.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
  }
  async _runChatCompletion(client2, params, options) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(client2, params, options);
  }
  async _runTools(client2, params, options) {
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && tool_choice.type === "function" && tool_choice?.function?.name;
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const inputTools = params.tools.map((tool2) => {
      if (isAutoParsableTool(tool2)) {
        if (!tool2.$callback) {
          throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
        }
        return {
          type: "function",
          function: {
            function: tool2.$callback,
            name: tool2.function.name,
            description: tool2.function.description || "",
            parameters: tool2.function.parameters,
            parse: tool2.$parseRaw,
            strict: true
          }
        };
      }
      return tool2;
    });
    const functionsByName = {};
    for (const f of inputTools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] = f.function;
      }
    }
    const tools = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
      type: "function",
      function: {
        name: t.function.name || t.function.function.name,
        parameters: t.function.parameters,
        description: t.function.description,
        strict: t.function.strict
      }
    } : t) : undefined;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0;i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client2, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options);
      const message = chatCompletion.choices[0]?.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.tool_calls?.length) {
        return;
      }
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error47) {
          const content2 = error47 instanceof Error ? error47.message : String(error47);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
}
_AbstractChatCompletionRunner_instances = new WeakSet, _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
  return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
  let i = this.messages.length;
  while (i-- > 0) {
    const message = this.messages[i];
    if (isAssistantMessage(message)) {
      const ret = {
        ...message,
        content: message.content ?? null,
        refusal: message.refusal ?? null
      };
      return ret;
    }
  }
  throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionToolCall = function _AbstractChatCompletionRunner_getFinalFunctionToolCall2() {
  for (let i = this.messages.length - 1;i >= 0; i--) {
    const message = this.messages[i];
    if (isAssistantMessage(message) && message?.tool_calls?.length) {
      return message.tool_calls.filter((x) => x.type === "function").at(-1)?.function;
    }
  }
  return;
}, _AbstractChatCompletionRunner_getFinalFunctionToolCallResult = function _AbstractChatCompletionRunner_getFinalFunctionToolCallResult2() {
  for (let i = this.messages.length - 1;i >= 0; i--) {
    const message = this.messages[i];
    if (isToolMessage2(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => x.role === "assistant" && x.tool_calls?.some((y) => y.type === "function" && y.id === message.tool_call_id))) {
      return message.content;
    }
  }
  return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === undefined ? "undefined" : JSON.stringify(rawContent);
};

// node_modules/openai/lib/ChatCompletionRunner.mjs
class ChatCompletionRunner extends AbstractChatCompletionRunner {
  static runTools(client2, params, options) {
    const runner = new ChatCompletionRunner;
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client2, params, opts));
    return runner;
  }
  _addMessage(message, emit = true) {
    super._addMessage(message, emit);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
}

// node_modules/openai/_vendor/partial-json-parser/parser.mjs
var STR = 1;
var NUM = 2;
var ARR = 4;
var OBJ = 8;
var NULL = 16;
var BOOL = 32;
var NAN = 64;
var INFINITY = 128;
var MINUS_INFINITY = 256;
var INF = INFINITY | MINUS_INFINITY;
var SPECIAL = NULL | BOOL | INF | NAN;
var ATOM = STR | NUM | SPECIAL;
var COLLECTION = ARR | OBJ;
var ALL = ATOM | COLLECTION;
var Allow = {
  STR,
  NUM,
  ARR,
  OBJ,
  NULL,
  BOOL,
  NAN,
  INFINITY,
  MINUS_INFINITY,
  INF,
  SPECIAL,
  ATOM,
  COLLECTION,
  ALL
};

class PartialJSON extends Error {
}

class MalformedJSON extends Error {
}
function parseJSON(jsonString, allowPartial = Allow.ALL) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`expecting str, got ${typeof jsonString}`);
  }
  if (!jsonString.trim()) {
    throw new Error(`${jsonString} is empty`);
  }
  return _parseJSON(jsonString.trim(), allowPartial);
}
var _parseJSON = (jsonString, allow) => {
  const length = jsonString.length;
  let index = 0;
  const markPartialJSON = (msg) => {
    throw new PartialJSON(`${msg} at position ${index}`);
  };
  const throwMalformedError = (msg) => {
    throw new MalformedJSON(`${msg} at position ${index}`);
  };
  const parseAny = () => {
    skipBlank();
    if (index >= length)
      markPartialJSON("Unexpected end of input");
    if (jsonString[index] === '"')
      return parseStr();
    if (jsonString[index] === "{")
      return parseObj();
    if (jsonString[index] === "[")
      return parseArr();
    if (jsonString.substring(index, index + 4) === "null" || Allow.NULL & allow && length - index < 4 && "null".startsWith(jsonString.substring(index))) {
      index += 4;
      return null;
    }
    if (jsonString.substring(index, index + 4) === "true" || Allow.BOOL & allow && length - index < 4 && "true".startsWith(jsonString.substring(index))) {
      index += 4;
      return true;
    }
    if (jsonString.substring(index, index + 5) === "false" || Allow.BOOL & allow && length - index < 5 && "false".startsWith(jsonString.substring(index))) {
      index += 5;
      return false;
    }
    if (jsonString.substring(index, index + 8) === "Infinity" || Allow.INFINITY & allow && length - index < 8 && "Infinity".startsWith(jsonString.substring(index))) {
      index += 8;
      return Infinity;
    }
    if (jsonString.substring(index, index + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index && length - index < 9 && "-Infinity".startsWith(jsonString.substring(index))) {
      index += 9;
      return -Infinity;
    }
    if (jsonString.substring(index, index + 3) === "NaN" || Allow.NAN & allow && length - index < 3 && "NaN".startsWith(jsonString.substring(index))) {
      index += 3;
      return NaN;
    }
    return parseNum();
  };
  const parseStr = () => {
    const start = index;
    let escape2 = false;
    index++;
    while (index < length && (jsonString[index] !== '"' || escape2 && jsonString[index - 1] === "\\")) {
      escape2 = jsonString[index] === "\\" ? !escape2 : false;
      index++;
    }
    if (jsonString.charAt(index) == '"') {
      try {
        return JSON.parse(jsonString.substring(start, ++index - Number(escape2)));
      } catch (e) {
        throwMalformedError(String(e));
      }
    } else if (Allow.STR & allow) {
      try {
        return JSON.parse(jsonString.substring(start, index - Number(escape2)) + '"');
      } catch (e) {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
      }
    }
    markPartialJSON("Unterminated string literal");
  };
  const parseObj = () => {
    index++;
    skipBlank();
    const obj = {};
    try {
      while (jsonString[index] !== "}") {
        skipBlank();
        if (index >= length && Allow.OBJ & allow)
          return obj;
        const key = parseStr();
        skipBlank();
        index++;
        try {
          const value = parseAny();
          Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
        } catch (e) {
          if (Allow.OBJ & allow)
            return obj;
          else
            throw e;
        }
        skipBlank();
        if (jsonString[index] === ",")
          index++;
      }
    } catch (e) {
      if (Allow.OBJ & allow)
        return obj;
      else
        markPartialJSON("Expected '}' at end of object");
    }
    index++;
    return obj;
  };
  const parseArr = () => {
    index++;
    const arr2 = [];
    try {
      while (jsonString[index] !== "]") {
        arr2.push(parseAny());
        skipBlank();
        if (jsonString[index] === ",") {
          index++;
        }
      }
    } catch (e) {
      if (Allow.ARR & allow) {
        return arr2;
      }
      markPartialJSON("Expected ']' at end of array");
    }
    index++;
    return arr2;
  };
  const parseNum = () => {
    if (index === 0) {
      if (jsonString === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString);
      } catch (e) {
        if (Allow.NUM & allow) {
          try {
            if (jsonString[jsonString.length - 1] === ".")
              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
          } catch (e2) {}
        }
        throwMalformedError(String(e));
      }
    }
    const start = index;
    if (jsonString[index] === "-")
      index++;
    while (jsonString[index] && !",]}".includes(jsonString[index]))
      index++;
    if (index == length && !(Allow.NUM & allow))
      markPartialJSON("Unterminated number literal");
    try {
      return JSON.parse(jsonString.substring(start, index));
    } catch (e) {
      if (jsonString.substring(start, index) === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
      } catch (e2) {
        throwMalformedError(String(e2));
      }
    }
  };
  const skipBlank = () => {
    while (index < length && ` 
\r	`.includes(jsonString[index])) {
      index++;
    }
  };
  return parseAny();
};
var partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);
// node_modules/openai/lib/ChatCompletionStream.mjs
var _ChatCompletionStream_instances;
var _ChatCompletionStream_params;
var _ChatCompletionStream_choiceEventStates;
var _ChatCompletionStream_currentChatCompletionSnapshot;
var _ChatCompletionStream_beginRequest;
var _ChatCompletionStream_getChoiceEventState;
var _ChatCompletionStream_addChunk;
var _ChatCompletionStream_emitToolCallDoneEvent;
var _ChatCompletionStream_emitContentDoneEvents;
var _ChatCompletionStream_endRequest;
var _ChatCompletionStream_getAutoParseableResponseFormat;
var _ChatCompletionStream_accumulateChatCompletion;

class ChatCompletionStream extends AbstractChatCompletionRunner {
  constructor(params) {
    super();
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_params.set(this, undefined);
    _ChatCompletionStream_choiceEventStates.set(this, undefined);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, undefined);
    __classPrivateFieldSet(this, _ChatCompletionStream_params, params, "f");
    __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], "f");
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStream(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(client2, params, options) {
    const runner = new ChatCompletionStream(params);
    runner._run(() => runner._runChatCompletion(client2, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(client2, params, options) {
    super._createChatCompletion;
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream = await client2.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError;
    }
    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError;
    }
    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_params = new WeakMap, _ChatCompletionStream_choiceEventStates = new WeakMap, _ChatCompletionStream_currentChatCompletionSnapshot = new WeakMap, _ChatCompletionStream_instances = new WeakSet, _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest() {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, "f");
  }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState(choice) {
    let state = __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
    if (state) {
      return state;
    }
    state = {
      content_done: false,
      refusal_done: false,
      logprobs_content_done: false,
      logprobs_refusal_done: false,
      done_tool_calls: new Set,
      current_tool_call_index: null
    };
    __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
    return state;
  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk(chunk) {
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    for (const choice of chunk.choices) {
      const choiceSnapshot = completion.choices[choice.index];
      if (choice.delta.content != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.content) {
        this._emit("content", choice.delta.content, choiceSnapshot.message.content);
        this._emit("content.delta", {
          delta: choice.delta.content,
          snapshot: choiceSnapshot.message.content,
          parsed: choiceSnapshot.message.parsed
        });
      }
      if (choice.delta.refusal != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.refusal) {
        this._emit("refusal.delta", {
          delta: choice.delta.refusal,
          snapshot: choiceSnapshot.message.refusal
        });
      }
      if (choice.logprobs?.content != null && choiceSnapshot.message?.role === "assistant") {
        this._emit("logprobs.content.delta", {
          content: choice.logprobs?.content,
          snapshot: choiceSnapshot.logprobs?.content ?? []
        });
      }
      if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === "assistant") {
        this._emit("logprobs.refusal.delta", {
          refusal: choice.logprobs?.refusal,
          snapshot: choiceSnapshot.logprobs?.refusal ?? []
        });
      }
      const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.finish_reason) {
        __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
        if (state.current_tool_call_index != null) {
          __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
        }
      }
      for (const toolCall of choice.delta.tool_calls ?? []) {
        if (state.current_tool_call_index !== toolCall.index) {
          __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        state.current_tool_call_index = toolCall.index;
      }
      for (const toolCallDelta of choice.delta.tool_calls ?? []) {
        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];
        if (!toolCallSnapshot?.type) {
          continue;
        }
        if (toolCallSnapshot?.type === "function") {
          this._emit("tool_calls.function.arguments.delta", {
            name: toolCallSnapshot.function?.name,
            index: toolCallDelta.index,
            arguments: toolCallSnapshot.function.arguments,
            parsed_arguments: toolCallSnapshot.function.parsed_arguments,
            arguments_delta: toolCallDelta.function?.arguments ?? ""
          });
        } else {
          assertNever2(toolCallSnapshot?.type);
        }
      }
    }
  }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent(choiceSnapshot, toolCallIndex) {
    const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (state.done_tool_calls.has(toolCallIndex)) {
      return;
    }
    const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];
    if (!toolCallSnapshot) {
      throw new Error("no tool call snapshot");
    }
    if (!toolCallSnapshot.type) {
      throw new Error("tool call snapshot missing `type`");
    }
    if (toolCallSnapshot.type === "function") {
      const inputTool = __classPrivateFieldGet(this, _ChatCompletionStream_params, "f")?.tools?.find((tool2) => isChatCompletionFunctionTool(tool2) && tool2.function.name === toolCallSnapshot.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: toolCallSnapshot.function.name,
        index: toolCallIndex,
        arguments: toolCallSnapshot.function.arguments,
        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments) : null
      });
    } else {
      assertNever2(toolCallSnapshot.type);
    }
  }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents(choiceSnapshot) {
    const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (choiceSnapshot.message.content && !state.content_done) {
      state.content_done = true;
      const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
      this._emit("content.done", {
        content: choiceSnapshot.message.content,
        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
      });
    }
    if (choiceSnapshot.message.refusal && !state.refusal_done) {
      state.refusal_done = true;
      this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
    }
    if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {
      state.logprobs_content_done = true;
      this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
    }
    if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {
      state.logprobs_refusal_done = true;
      this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
    }
  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, "f");
    __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], "f");
    return finalizeChatCompletion(snapshot, __classPrivateFieldGet(this, _ChatCompletionStream_params, "f"));
  }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat() {
    const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_params, "f")?.response_format;
    if (isAutoParsableResponseFormat(responseFormat)) {
      return responseFormat;
    }
    return null;
  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion(chunk) {
    var _a2, _b, _c, _d;
    let snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest,
        choices: []
      }, "f");
    } else {
      Object.assign(snapshot, rest);
    }
    for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index];
      if (!choice) {
        choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };
      }
      if (logprobs) {
        if (!choice.logprobs) {
          choice.logprobs = Object.assign({}, logprobs);
        } else {
          const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
          assertIsEmpty(rest3);
          Object.assign(choice.logprobs, rest3);
          if (content2) {
            (_a2 = choice.logprobs).content ?? (_a2.content = []);
            choice.logprobs.content.push(...content2);
          }
          if (refusal2) {
            (_b = choice.logprobs).refusal ?? (_b.refusal = []);
            choice.logprobs.refusal.push(...refusal2);
          }
        }
      }
      if (finish_reason) {
        choice.finish_reason = finish_reason;
        if (__classPrivateFieldGet(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput(__classPrivateFieldGet(this, _ChatCompletionStream_params, "f"))) {
          if (finish_reason === "length") {
            throw new LengthFinishReasonError;
          }
          if (finish_reason === "content_filter") {
            throw new ContentFilterFinishReasonError;
          }
        }
      }
      Object.assign(choice, other);
      if (!delta)
        continue;
      const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
      assertIsEmpty(rest2);
      Object.assign(choice.message, rest2);
      if (refusal) {
        choice.message.refusal = (choice.message.refusal || "") + refusal;
      }
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_c = choice.message.function_call).arguments ?? (_c.arguments = "");
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (content) {
        choice.message.content = (choice.message.content || "") + content;
        if (!choice.message.refusal && __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
          choice.message.parsed = partialParse(choice.message.content);
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index2, id, type, function: fn, ...rest3 } of tool_calls) {
          const tool_call = (_d = choice.message.tool_calls)[index2] ?? (_d[index2] = {});
          Object.assign(tool_call, rest3);
          if (id)
            tool_call.id = id;
          if (type)
            tool_call.type = type;
          if (fn)
            tool_call.function ?? (tool_call.function = { name: fn.name ?? "", arguments: "" });
          if (fn?.name)
            tool_call.function.name = fn.name;
          if (fn?.arguments) {
            tool_call.function.arguments += fn.arguments;
            if (shouldParseToolCall(__classPrivateFieldGet(this, _ChatCompletionStream_params, "f"), tool_call)) {
              tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
            }
          }
        }
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(undefined);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: undefined, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: undefined, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: undefined, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
}
function finalizeChatCompletion(snapshot, params) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
  const completion = {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {
      if (!finish_reason) {
        throw new OpenAIError(`missing finish_reason for choice ${index}`);
      }
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role) {
        throw new OpenAIError(`missing role for choice ${index}`);
      }
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null) {
          throw new OpenAIError(`missing function_call.arguments for choice ${index}`);
        }
        if (!name) {
          throw new OpenAIError(`missing function_call.name for choice ${index}`);
        }
        return {
          ...choiceRest,
          message: {
            content,
            function_call: { arguments: args, name },
            role,
            refusal: message.refusal ?? null
          },
          finish_reason,
          index,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            refusal: message.refusal ?? null,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn || {};
              if (id2 == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id
${str(snapshot)}`);
              }
              if (type == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type
${str(snapshot)}`);
              }
              if (name == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name
${str(snapshot)}`);
              }
              if (args == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments
${str(snapshot)}`);
              }
              return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role, refusal: message.refusal ?? null },
        finish_reason,
        index,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
  return maybeParseChatCompletion(completion, params);
}
function str(x) {
  return JSON.stringify(x);
}
function assertIsEmpty(obj) {
  return;
}
function assertNever2(_x) {}

// node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
class ChatCompletionStreamingRunner extends ChatCompletionStream {
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStreamingRunner(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static runTools(client2, params, options) {
    const runner = new ChatCompletionStreamingRunner(params);
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client2, params, opts));
    return runner;
  }
}

// node_modules/openai/resources/chat/completions/completions.mjs
class Completions extends APIResource {
  constructor() {
    super(...arguments);
    this.messages = new Messages(this._client);
  }
  create(body, options) {
    return this._client.post("/chat/completions", { body, ...options, stream: body.stream ?? false });
  }
  retrieve(completionID, options) {
    return this._client.get(path`/chat/completions/${completionID}`, options);
  }
  update(completionID, body, options) {
    return this._client.post(path`/chat/completions/${completionID}`, { body, ...options });
  }
  list(query = {}, options) {
    return this._client.getAPIList("/chat/completions", CursorPage, { query, ...options });
  }
  delete(completionID, options) {
    return this._client.delete(path`/chat/completions/${completionID}`, options);
  }
  parse(body, options) {
    validateInputTools(body.tools);
    return this._client.chat.completions.create(body, {
      ...options,
      headers: {
        ...options?.headers,
        "X-Stainless-Helper-Method": "chat.completions.parse"
      }
    })._thenUnwrap((completion) => parseChatCompletion(completion, body));
  }
  runTools(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(this._client, body, options);
    }
    return ChatCompletionRunner.runTools(this._client, body, options);
  }
  stream(body, options) {
    return ChatCompletionStream.createChatCompletion(this._client, body, options);
  }
}
Completions.Messages = Messages;

// node_modules/openai/resources/chat/chat.mjs
class Chat extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this._client);
  }
}
Chat.Completions = Completions;
// node_modules/openai/internal/headers.mjs
var brand_privateNullableHeaders = /* @__PURE__ */ Symbol("brand.privateNullableHeaders");
function* iterateHeaders(headers) {
  if (!headers)
    return;
  if (brand_privateNullableHeaders in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name of nulls) {
      yield [name, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isReadonlyArray(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers ?? {});
  }
  for (let row of iter) {
    const name = row[0];
    if (typeof name !== "string")
      throw new TypeError("expected header name to be a string");
    const values = isReadonlyArray(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === undefined)
        continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name, null];
      }
      yield [name, value];
    }
  }
}
var buildHeaders = (newHeaders) => {
  const targetHeaders = new Headers;
  const nullHeaders = new Set;
  for (const headers of newHeaders) {
    const seenHeaders = new Set;
    for (const [name, value] of iterateHeaders(headers)) {
      const lowerName = name.toLowerCase();
      if (!seenHeaders.has(lowerName)) {
        targetHeaders.delete(name);
        seenHeaders.add(lowerName);
      }
      if (value === null) {
        targetHeaders.delete(name);
        nullHeaders.add(lowerName);
      } else {
        targetHeaders.append(name, value);
        nullHeaders.delete(lowerName);
      }
    }
  }
  return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };
};

// node_modules/openai/resources/audio/speech.mjs
class Speech extends APIResource {
  create(body, options) {
    return this._client.post("/audio/speech", {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "application/octet-stream" }, options?.headers]),
      __binaryResponse: true
    });
  }
}

// node_modules/openai/resources/audio/transcriptions.mjs
class Transcriptions extends APIResource {
  create(body, options) {
    return this._client.post("/audio/transcriptions", multipartFormRequestOptions({
      body,
      ...options,
      stream: body.stream ?? false,
      __metadata: { model: body.model }
    }, this._client));
  }
}

// node_modules/openai/resources/audio/translations.mjs
class Translations extends APIResource {
  create(body, options) {
    return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options, __metadata: { model: body.model } }, this._client));
  }
}

// node_modules/openai/resources/audio/audio.mjs
class Audio extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
}
Audio.Transcriptions = Transcriptions;
Audio.Translations = Translations;
Audio.Speech = Speech;
// node_modules/openai/resources/batches.mjs
class Batches extends APIResource {
  create(body, options) {
    return this._client.post("/batches", { body, ...options });
  }
  retrieve(batchID, options) {
    return this._client.get(path`/batches/${batchID}`, options);
  }
  list(query = {}, options) {
    return this._client.getAPIList("/batches", CursorPage, { query, ...options });
  }
  cancel(batchID, options) {
    return this._client.post(path`/batches/${batchID}/cancel`, options);
  }
}
// node_modules/openai/resources/beta/assistants.mjs
class Assistants extends APIResource {
  create(body, options) {
    return this._client.post("/assistants", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  retrieve(assistantID, options) {
    return this._client.get(path`/assistants/${assistantID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  update(assistantID, body, options) {
    return this._client.post(path`/assistants/${assistantID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  list(query = {}, options) {
    return this._client.getAPIList("/assistants", CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  delete(assistantID, options) {
    return this._client.delete(path`/assistants/${assistantID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
}

// node_modules/openai/resources/beta/realtime/sessions.mjs
class Sessions extends APIResource {
  create(body, options) {
    return this._client.post("/realtime/sessions", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
}

// node_modules/openai/resources/beta/realtime/transcription-sessions.mjs
class TranscriptionSessions extends APIResource {
  create(body, options) {
    return this._client.post("/realtime/transcription_sessions", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
}

// node_modules/openai/resources/beta/realtime/realtime.mjs
class Realtime extends APIResource {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions(this._client);
    this.transcriptionSessions = new TranscriptionSessions(this._client);
  }
}
Realtime.Sessions = Sessions;
Realtime.TranscriptionSessions = TranscriptionSessions;

// node_modules/openai/resources/beta/chatkit/sessions.mjs
class Sessions2 extends APIResource {
  create(body, options) {
    return this._client.post("/chatkit/sessions", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  cancel(sessionID, options) {
    return this._client.post(path`/chatkit/sessions/${sessionID}/cancel`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
}

// node_modules/openai/resources/beta/chatkit/threads.mjs
class Threads extends APIResource {
  retrieve(threadID, options) {
    return this._client.get(path`/chatkit/threads/${threadID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  list(query = {}, options) {
    return this._client.getAPIList("/chatkit/threads", ConversationCursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  delete(threadID, options) {
    return this._client.delete(path`/chatkit/threads/${threadID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  listItems(threadID, query = {}, options) {
    return this._client.getAPIList(path`/chatkit/threads/${threadID}/items`, ConversationCursorPage, { query, ...options, headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers]) });
  }
}

// node_modules/openai/resources/beta/chatkit/chatkit.mjs
class ChatKit extends APIResource {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions2(this._client);
    this.threads = new Threads(this._client);
  }
}
ChatKit.Sessions = Sessions2;
ChatKit.Threads = Threads;

// node_modules/openai/resources/beta/threads/messages.mjs
class Messages2 extends APIResource {
  create(threadID, body, options) {
    return this._client.post(path`/threads/${threadID}/messages`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  retrieve(messageID, params, options) {
    const { thread_id } = params;
    return this._client.get(path`/threads/${thread_id}/messages/${messageID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  update(messageID, params, options) {
    const { thread_id, ...body } = params;
    return this._client.post(path`/threads/${thread_id}/messages/${messageID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  list(threadID, query = {}, options) {
    return this._client.getAPIList(path`/threads/${threadID}/messages`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  delete(messageID, params, options) {
    const { thread_id } = params;
    return this._client.delete(path`/threads/${thread_id}/messages/${messageID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
}

// node_modules/openai/resources/beta/threads/runs/steps.mjs
class Steps extends APIResource {
  retrieve(stepID, params, options) {
    const { thread_id, run_id, ...query } = params;
    return this._client.get(path`/threads/${thread_id}/runs/${run_id}/steps/${stepID}`, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  list(runID, params, options) {
    const { thread_id, ...query } = params;
    return this._client.getAPIList(path`/threads/${thread_id}/runs/${runID}/steps`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
}
// node_modules/openai/internal/utils/base64.mjs
var toFloat32Array = (base64Str) => {
  if (typeof Buffer !== "undefined") {
    const buf = Buffer.from(base64Str, "base64");
    return Array.from(new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT));
  } else {
    const binaryStr = atob(base64Str);
    const len = binaryStr.length;
    const bytes = new Uint8Array(len);
    for (let i = 0;i < len; i++) {
      bytes[i] = binaryStr.charCodeAt(i);
    }
    return Array.from(new Float32Array(bytes.buffer));
  }
};
// node_modules/openai/internal/utils/env.mjs
var readEnv = (env2) => {
  if (typeof globalThis.process !== "undefined") {
    return globalThis.process.env?.[env2]?.trim() ?? undefined;
  }
  if (typeof globalThis.Deno !== "undefined") {
    return globalThis.Deno.env?.get?.(env2)?.trim();
  }
  return;
};
// node_modules/openai/lib/AssistantStream.mjs
var _AssistantStream_instances;
var _a2;
var _AssistantStream_events;
var _AssistantStream_runStepSnapshots;
var _AssistantStream_messageSnapshots;
var _AssistantStream_messageSnapshot;
var _AssistantStream_finalRun;
var _AssistantStream_currentContentIndex;
var _AssistantStream_currentContent;
var _AssistantStream_currentToolCallIndex;
var _AssistantStream_currentToolCall;
var _AssistantStream_currentEvent;
var _AssistantStream_currentRunSnapshot;
var _AssistantStream_currentRunStepSnapshot;
var _AssistantStream_addEvent;
var _AssistantStream_endRequest;
var _AssistantStream_handleMessage;
var _AssistantStream_handleRunStep;
var _AssistantStream_handleEvent;
var _AssistantStream_accumulateRunStep;
var _AssistantStream_accumulateMessage;
var _AssistantStream_accumulateContent;
var _AssistantStream_handleRun;

class AssistantStream extends EventStream {
  constructor() {
    super(...arguments);
    _AssistantStream_instances.add(this);
    _AssistantStream_events.set(this, []);
    _AssistantStream_runStepSnapshots.set(this, {});
    _AssistantStream_messageSnapshots.set(this, {});
    _AssistantStream_messageSnapshot.set(this, undefined);
    _AssistantStream_finalRun.set(this, undefined);
    _AssistantStream_currentContentIndex.set(this, undefined);
    _AssistantStream_currentContent.set(this, undefined);
    _AssistantStream_currentToolCallIndex.set(this, undefined);
    _AssistantStream_currentToolCall.set(this, undefined);
    _AssistantStream_currentEvent.set(this, undefined);
    _AssistantStream_currentRunSnapshot.set(this, undefined);
    _AssistantStream_currentRunStepSnapshot.set(this, undefined);
  }
  [(_AssistantStream_events = new WeakMap, _AssistantStream_runStepSnapshots = new WeakMap, _AssistantStream_messageSnapshots = new WeakMap, _AssistantStream_messageSnapshot = new WeakMap, _AssistantStream_finalRun = new WeakMap, _AssistantStream_currentContentIndex = new WeakMap, _AssistantStream_currentContent = new WeakMap, _AssistantStream_currentToolCallIndex = new WeakMap, _AssistantStream_currentToolCall = new WeakMap, _AssistantStream_currentEvent = new WeakMap, _AssistantStream_currentRunSnapshot = new WeakMap, _AssistantStream_currentRunStepSnapshot = new WeakMap, _AssistantStream_instances = new WeakSet, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(undefined);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: undefined, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: undefined, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: undefined, done: true };
      }
    };
  }
  static fromReadableStream(stream) {
    const runner = new _a2;
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError;
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
  static createToolAssistantStream(runId, runs, params, options) {
    const runner = new _a2;
    runner._run(() => runner._runToolAssistantStream(runId, runs, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createToolAssistantStream(run2, runId, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run2.submitToolOutputs(runId, body, {
      ...options,
      signal: this.controller.signal
    });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError;
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static createThreadAssistantStream(params, thread, options) {
    const runner = new _a2;
    runner._run(() => runner._threadAssistantStream(params, thread, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  static createAssistantStream(threadId, runs, params, options) {
    const runner = new _a2;
    runner._run(() => runner._runAssistantStream(threadId, runs, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  currentEvent() {
    return __classPrivateFieldGet(this, _AssistantStream_currentEvent, "f");
  }
  currentRun() {
    return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, "f");
  }
  currentMessageSnapshot() {
    return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f");
  }
  currentRunStepSnapshot() {
    return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, "f");
  }
  async finalRunSteps() {
    await this.done();
    return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f"));
  }
  async finalMessages() {
    await this.done();
    return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f"));
  }
  async finalRun() {
    await this.done();
    if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run was not received.");
    return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
  }
  async _createThreadAssistantStream(thread, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError;
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  async _createAssistantStream(run2, threadId, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run2.create(threadId, body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError;
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static accumulateDelta(acc, delta) {
    for (const [key, deltaValue] of Object.entries(delta)) {
      if (!acc.hasOwnProperty(key)) {
        acc[key] = deltaValue;
        continue;
      }
      let accValue = acc[key];
      if (accValue === null || accValue === undefined) {
        acc[key] = deltaValue;
        continue;
      }
      if (key === "index" || key === "type") {
        acc[key] = deltaValue;
        continue;
      }
      if (typeof accValue === "string" && typeof deltaValue === "string") {
        accValue += deltaValue;
      } else if (typeof accValue === "number" && typeof deltaValue === "number") {
        accValue += deltaValue;
      } else if (isObj(accValue) && isObj(deltaValue)) {
        accValue = this.accumulateDelta(accValue, deltaValue);
      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
        if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
          accValue.push(...deltaValue);
          continue;
        }
        for (const deltaEntry of deltaValue) {
          if (!isObj(deltaEntry)) {
            throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
          }
          const index = deltaEntry["index"];
          if (index == null) {
            console.error(deltaEntry);
            throw new Error("Expected array delta entry to have an `index` property");
          }
          if (typeof index !== "number") {
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index}`);
          }
          const accEntry = accValue[index];
          if (accEntry == null) {
            accValue.push(deltaEntry);
          } else {
            accValue[index] = this.accumulateDelta(accEntry, deltaEntry);
          }
        }
        continue;
      } else {
        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
      }
      acc[key] = accValue;
    }
    return acc;
  }
  _addRun(run2) {
    return run2;
  }
  async _threadAssistantStream(params, thread, options) {
    return await this._createThreadAssistantStream(thread, params, options);
  }
  async _runAssistantStream(threadId, runs, params, options) {
    return await this._createAssistantStream(runs, threadId, params, options);
  }
  async _runToolAssistantStream(runId, runs, params, options) {
    return await this._createToolAssistantStream(runs, runId, params, options);
  }
}
_a2 = AssistantStream, _AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
  if (this.ended)
    return;
  __classPrivateFieldSet(this, _AssistantStream_currentEvent, event, "f");
  __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
  switch (event.event) {
    case "thread.created":
      break;
    case "thread.run.created":
    case "thread.run.queued":
    case "thread.run.in_progress":
    case "thread.run.requires_action":
    case "thread.run.completed":
    case "thread.run.incomplete":
    case "thread.run.failed":
    case "thread.run.cancelling":
    case "thread.run.cancelled":
    case "thread.run.expired":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
      break;
    case "thread.run.step.created":
    case "thread.run.step.in_progress":
    case "thread.run.step.delta":
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
      break;
    case "thread.message.created":
    case "thread.message.in_progress":
    case "thread.message.delta":
    case "thread.message.completed":
    case "thread.message.incomplete":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
      break;
    case "error":
      throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    default:
      assertNever3(event);
  }
}, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
  if (this.ended) {
    throw new OpenAIError(`stream has ended, this shouldn't happen`);
  }
  if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
    throw Error("Final run has not been received");
  return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
  const [accumulatedMessage, newContent] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
  __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
  __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
  for (const content of newContent) {
    const snapshotContent = accumulatedMessage.content[content.index];
    if (snapshotContent?.type == "text") {
      this._emit("textCreated", snapshotContent.text);
    }
  }
  switch (event.event) {
    case "thread.message.created":
      this._emit("messageCreated", event.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      this._emit("messageDelta", event.data.delta, accumulatedMessage);
      if (event.data.delta.content) {
        for (const content of event.data.delta.content) {
          if (content.type == "text" && content.text) {
            let textDelta = content.text;
            let snapshot = accumulatedMessage.content[content.index];
            if (snapshot && snapshot.type == "text") {
              this._emit("textDelta", textDelta, snapshot.text);
            } else {
              throw Error("The snapshot associated with this text delta is not text or missing");
            }
          }
          if (content.index != __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")) {
            if (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f")) {
              switch (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f").type) {
                case "text":
                  this._emit("textDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
            __classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index, "f");
          }
          __classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
        }
      }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f") !== undefined) {
        const currentContent = event.data.content[__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")];
        if (currentContent) {
          switch (currentContent.type) {
            case "image_file":
              this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
              break;
            case "text":
              this._emit("textDone", currentContent.text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
              break;
          }
        }
      }
      if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f")) {
        this._emit("messageDone", event.data);
      }
      __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, undefined, "f");
  }
}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
  const accumulatedRunStep = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
  __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
  switch (event.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", event.data);
      break;
    case "thread.run.step.delta":
      const delta = event.data.delta;
      if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
        for (const toolCall of delta.step_details.tool_calls) {
          if (toolCall.index == __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, "f")) {
            this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
          } else {
            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
            }
            __classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
            __classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"))
              this._emit("toolCallCreated", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
          }
        }
      }
      this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, undefined, "f");
      const details = event.data.step_details;
      if (details.type == "tool_calls") {
        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, "f");
        }
      }
      this._emit("runStepDone", event.data, accumulatedRunStep);
      break;
    case "thread.run.step.in_progress":
      break;
  }
}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
  __classPrivateFieldGet(this, _AssistantStream_events, "f").push(event);
  this._emit("event", event);
}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
  switch (event.event) {
    case "thread.run.step.created":
      __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      return event.data;
    case "thread.run.step.delta":
      let snapshot = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      if (!snapshot) {
        throw Error("Received a RunStepDelta before creation of a snapshot");
      }
      let data = event.data;
      if (data.delta) {
        const accumulated = _a2.accumulateDelta(snapshot, data.delta);
        __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
      }
      return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      break;
  }
  if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
    return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
  throw new Error("No snapshot available");
}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
  let newContent = [];
  switch (event.event) {
    case "thread.message.created":
      return [event.data, newContent];
    case "thread.message.delta":
      if (!snapshot) {
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      }
      let data = event.data;
      if (data.delta.content) {
        for (const contentElement of data.delta.content) {
          if (contentElement.index in snapshot.content) {
            let currentContent = snapshot.content[contentElement.index];
            snapshot.content[contentElement.index] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
          } else {
            snapshot.content[contentElement.index] = contentElement;
            newContent.push(contentElement);
          }
        }
      }
      return [snapshot, newContent];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (snapshot) {
        return [snapshot, newContent];
      } else {
        throw Error("Received thread message event with no existing snapshot");
      }
  }
  throw Error("Tried to accumulate a non-message event");
}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
  return _a2.accumulateDelta(currentContent, contentElement);
}, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
  __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data, "f");
  switch (event.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
    case "thread.run.incomplete":
      __classPrivateFieldSet(this, _AssistantStream_finalRun, event.data, "f");
      if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
        this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
        __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, "f");
      }
      break;
    case "thread.run.cancelling":
      break;
  }
};
function assertNever3(_x) {}

// node_modules/openai/resources/beta/threads/runs/runs.mjs
class Runs extends APIResource {
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  create(threadID, params, options) {
    const { include, ...body } = params;
    return this._client.post(path`/threads/${threadID}/runs`, {
      query: { include },
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
      stream: params.stream ?? false
    });
  }
  retrieve(runID, params, options) {
    const { thread_id } = params;
    return this._client.get(path`/threads/${thread_id}/runs/${runID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  update(runID, params, options) {
    const { thread_id, ...body } = params;
    return this._client.post(path`/threads/${thread_id}/runs/${runID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  list(threadID, query = {}, options) {
    return this._client.getAPIList(path`/threads/${threadID}/runs`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  cancel(runID, params, options) {
    const { thread_id } = params;
    return this._client.post(path`/threads/${thread_id}/runs/${runID}/cancel`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  async createAndPoll(threadId, body, options) {
    const run2 = await this.create(threadId, body, options);
    return await this.poll(run2.id, { thread_id: threadId }, options);
  }
  createAndStream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  async poll(runId, params, options) {
    const headers = buildHeaders([
      options?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? undefined
      }
    ]);
    while (true) {
      const { data: run2, response } = await this.retrieve(runId, params, {
        ...options,
        headers: { ...options?.headers, ...headers }
      }).withResponse();
      switch (run2.status) {
        case "queued":
        case "in_progress":
        case "cancelling":
          let sleepInterval = 5000;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return run2;
      }
    }
  }
  stream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  submitToolOutputs(runID, params, options) {
    const { thread_id, ...body } = params;
    return this._client.post(path`/threads/${thread_id}/runs/${runID}/submit_tool_outputs`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
      stream: params.stream ?? false
    });
  }
  async submitToolOutputsAndPoll(runId, params, options) {
    const run2 = await this.submitToolOutputs(runId, params, options);
    return await this.poll(run2.id, params, options);
  }
  submitToolOutputsStream(runId, params, options) {
    return AssistantStream.createToolAssistantStream(runId, this._client.beta.threads.runs, params, options);
  }
}
Runs.Steps = Steps;

// node_modules/openai/resources/beta/threads/threads.mjs
class Threads2 extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs(this._client);
    this.messages = new Messages2(this._client);
  }
  create(body = {}, options) {
    return this._client.post("/threads", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  retrieve(threadID, options) {
    return this._client.get(path`/threads/${threadID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  update(threadID, body, options) {
    return this._client.post(path`/threads/${threadID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  delete(threadID, options) {
    return this._client.delete(path`/threads/${threadID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  createAndRun(body, options) {
    return this._client.post("/threads/runs", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
      stream: body.stream ?? false
    });
  }
  async createAndRunPoll(body, options) {
    const run2 = await this.createAndRun(body, options);
    return await this.runs.poll(run2.id, { thread_id: run2.thread_id }, options);
  }
  createAndRunStream(body, options) {
    return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
  }
}
Threads2.Runs = Runs;
Threads2.Messages = Messages2;

// node_modules/openai/resources/beta/beta.mjs
class Beta extends APIResource {
  constructor() {
    super(...arguments);
    this.realtime = new Realtime(this._client);
    this.chatkit = new ChatKit(this._client);
    this.assistants = new Assistants(this._client);
    this.threads = new Threads2(this._client);
  }
}
Beta.Realtime = Realtime;
Beta.ChatKit = ChatKit;
Beta.Assistants = Assistants;
Beta.Threads = Threads2;
// node_modules/openai/resources/completions.mjs
class Completions2 extends APIResource {
  create(body, options) {
    return this._client.post("/completions", { body, ...options, stream: body.stream ?? false });
  }
}
// node_modules/openai/resources/containers/files/content.mjs
class Content extends APIResource {
  retrieve(fileID, params, options) {
    const { container_id } = params;
    return this._client.get(path`/containers/${container_id}/files/${fileID}/content`, {
      ...options,
      headers: buildHeaders([{ Accept: "application/binary" }, options?.headers]),
      __binaryResponse: true
    });
  }
}

// node_modules/openai/resources/containers/files/files.mjs
class Files extends APIResource {
  constructor() {
    super(...arguments);
    this.content = new Content(this._client);
  }
  create(containerID, body, options) {
    return this._client.post(path`/containers/${containerID}/files`, multipartFormRequestOptions({ body, ...options }, this._client));
  }
  retrieve(fileID, params, options) {
    const { container_id } = params;
    return this._client.get(path`/containers/${container_id}/files/${fileID}`, options);
  }
  list(containerID, query = {}, options) {
    return this._client.getAPIList(path`/containers/${containerID}/files`, CursorPage, {
      query,
      ...options
    });
  }
  delete(fileID, params, options) {
    const { container_id } = params;
    return this._client.delete(path`/containers/${container_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
}
Files.Content = Content;

// node_modules/openai/resources/containers/containers.mjs
class Containers extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files(this._client);
  }
  create(body, options) {
    return this._client.post("/containers", { body, ...options });
  }
  retrieve(containerID, options) {
    return this._client.get(path`/containers/${containerID}`, options);
  }
  list(query = {}, options) {
    return this._client.getAPIList("/containers", CursorPage, { query, ...options });
  }
  delete(containerID, options) {
    return this._client.delete(path`/containers/${containerID}`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
}
Containers.Files = Files;
// node_modules/openai/resources/conversations/items.mjs
class Items extends APIResource {
  create(conversationID, params, options) {
    const { include, ...body } = params;
    return this._client.post(path`/conversations/${conversationID}/items`, {
      query: { include },
      body,
      ...options
    });
  }
  retrieve(itemID, params, options) {
    const { conversation_id, ...query } = params;
    return this._client.get(path`/conversations/${conversation_id}/items/${itemID}`, { query, ...options });
  }
  list(conversationID, query = {}, options) {
    return this._client.getAPIList(path`/conversations/${conversationID}/items`, ConversationCursorPage, { query, ...options });
  }
  delete(itemID, params, options) {
    const { conversation_id } = params;
    return this._client.delete(path`/conversations/${conversation_id}/items/${itemID}`, options);
  }
}

// node_modules/openai/resources/conversations/conversations.mjs
class Conversations extends APIResource {
  constructor() {
    super(...arguments);
    this.items = new Items(this._client);
  }
  create(body = {}, options) {
    return this._client.post("/conversations", { body, ...options });
  }
  retrieve(conversationID, options) {
    return this._client.get(path`/conversations/${conversationID}`, options);
  }
  update(conversationID, body, options) {
    return this._client.post(path`/conversations/${conversationID}`, { body, ...options });
  }
  delete(conversationID, options) {
    return this._client.delete(path`/conversations/${conversationID}`, options);
  }
}
Conversations.Items = Items;
// node_modules/openai/resources/embeddings.mjs
class Embeddings extends APIResource {
  create(body, options) {
    const hasUserProvidedEncodingFormat = !!body.encoding_format;
    let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : "base64";
    if (hasUserProvidedEncodingFormat) {
      loggerFor(this._client).debug("embeddings/user defined encoding_format:", body.encoding_format);
    }
    const response = this._client.post("/embeddings", {
      body: {
        ...body,
        encoding_format
      },
      ...options
    });
    if (hasUserProvidedEncodingFormat) {
      return response;
    }
    loggerFor(this._client).debug("embeddings/decoding base64 embeddings from base64");
    return response._thenUnwrap((response2) => {
      if (response2 && response2.data) {
        response2.data.forEach((embeddingBase64Obj) => {
          const embeddingBase64Str = embeddingBase64Obj.embedding;
          embeddingBase64Obj.embedding = toFloat32Array(embeddingBase64Str);
        });
      }
      return response2;
    });
  }
}
// node_modules/openai/resources/evals/runs/output-items.mjs
class OutputItems extends APIResource {
  retrieve(outputItemID, params, options) {
    const { eval_id, run_id } = params;
    return this._client.get(path`/evals/${eval_id}/runs/${run_id}/output_items/${outputItemID}`, options);
  }
  list(runID, params, options) {
    const { eval_id, ...query } = params;
    return this._client.getAPIList(path`/evals/${eval_id}/runs/${runID}/output_items`, CursorPage, { query, ...options });
  }
}

// node_modules/openai/resources/evals/runs/runs.mjs
class Runs2 extends APIResource {
  constructor() {
    super(...arguments);
    this.outputItems = new OutputItems(this._client);
  }
  create(evalID, body, options) {
    return this._client.post(path`/evals/${evalID}/runs`, { body, ...options });
  }
  retrieve(runID, params, options) {
    const { eval_id } = params;
    return this._client.get(path`/evals/${eval_id}/runs/${runID}`, options);
  }
  list(evalID, query = {}, options) {
    return this._client.getAPIList(path`/evals/${evalID}/runs`, CursorPage, {
      query,
      ...options
    });
  }
  delete(runID, params, options) {
    const { eval_id } = params;
    return this._client.delete(path`/evals/${eval_id}/runs/${runID}`, options);
  }
  cancel(runID, params, options) {
    const { eval_id } = params;
    return this._client.post(path`/evals/${eval_id}/runs/${runID}`, options);
  }
}
Runs2.OutputItems = OutputItems;

// node_modules/openai/resources/evals/evals.mjs
class Evals extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs2(this._client);
  }
  create(body, options) {
    return this._client.post("/evals", { body, ...options });
  }
  retrieve(evalID, options) {
    return this._client.get(path`/evals/${evalID}`, options);
  }
  update(evalID, body, options) {
    return this._client.post(path`/evals/${evalID}`, { body, ...options });
  }
  list(query = {}, options) {
    return this._client.getAPIList("/evals", CursorPage, { query, ...options });
  }
  delete(evalID, options) {
    return this._client.delete(path`/evals/${evalID}`, options);
  }
}
Evals.Runs = Runs2;
// node_modules/openai/resources/files.mjs
class Files2 extends APIResource {
  create(body, options) {
    return this._client.post("/files", multipartFormRequestOptions({ body, ...options }, this._client));
  }
  retrieve(fileID, options) {
    return this._client.get(path`/files/${fileID}`, options);
  }
  list(query = {}, options) {
    return this._client.getAPIList("/files", CursorPage, { query, ...options });
  }
  delete(fileID, options) {
    return this._client.delete(path`/files/${fileID}`, options);
  }
  content(fileID, options) {
    return this._client.get(path`/files/${fileID}/content`, {
      ...options,
      headers: buildHeaders([{ Accept: "application/binary" }, options?.headers]),
      __binaryResponse: true
    });
  }
  async waitForProcessing(id, { pollInterval = 5000, maxWait = 30 * 60 * 1000 } = {}) {
    const TERMINAL_STATES = new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file2 = await this.retrieve(id);
    while (!file2.status || !TERMINAL_STATES.has(file2.status)) {
      await sleep(pollInterval);
      file2 = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file2;
  }
}
// node_modules/openai/resources/fine-tuning/methods.mjs
class Methods extends APIResource {
}

// node_modules/openai/resources/fine-tuning/alpha/graders.mjs
class Graders extends APIResource {
  run(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/run", { body, ...options });
  }
  validate(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/validate", { body, ...options });
  }
}

// node_modules/openai/resources/fine-tuning/alpha/alpha.mjs
class Alpha extends APIResource {
  constructor() {
    super(...arguments);
    this.graders = new Graders(this._client);
  }
}
Alpha.Graders = Graders;

// node_modules/openai/resources/fine-tuning/checkpoints/permissions.mjs
class Permissions extends APIResource {
  create(fineTunedModelCheckpoint, body, options) {
    return this._client.getAPIList(path`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, Page, { body, method: "post", ...options });
  }
  retrieve(fineTunedModelCheckpoint, query = {}, options) {
    return this._client.get(path`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, {
      query,
      ...options
    });
  }
  delete(permissionID, params, options) {
    const { fine_tuned_model_checkpoint } = params;
    return this._client.delete(path`/fine_tuning/checkpoints/${fine_tuned_model_checkpoint}/permissions/${permissionID}`, options);
  }
}

// node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.mjs
class Checkpoints extends APIResource {
  constructor() {
    super(...arguments);
    this.permissions = new Permissions(this._client);
  }
}
Checkpoints.Permissions = Permissions;

// node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs
class Checkpoints2 extends APIResource {
  list(fineTuningJobID, query = {}, options) {
    return this._client.getAPIList(path`/fine_tuning/jobs/${fineTuningJobID}/checkpoints`, CursorPage, { query, ...options });
  }
}

// node_modules/openai/resources/fine-tuning/jobs/jobs.mjs
class Jobs extends APIResource {
  constructor() {
    super(...arguments);
    this.checkpoints = new Checkpoints2(this._client);
  }
  create(body, options) {
    return this._client.post("/fine_tuning/jobs", { body, ...options });
  }
  retrieve(fineTuningJobID, options) {
    return this._client.get(path`/fine_tuning/jobs/${fineTuningJobID}`, options);
  }
  list(query = {}, options) {
    return this._client.getAPIList("/fine_tuning/jobs", CursorPage, { query, ...options });
  }
  cancel(fineTuningJobID, options) {
    return this._client.post(path`/fine_tuning/jobs/${fineTuningJobID}/cancel`, options);
  }
  listEvents(fineTuningJobID, query = {}, options) {
    return this._client.getAPIList(path`/fine_tuning/jobs/${fineTuningJobID}/events`, CursorPage, { query, ...options });
  }
  pause(fineTuningJobID, options) {
    return this._client.post(path`/fine_tuning/jobs/${fineTuningJobID}/pause`, options);
  }
  resume(fineTuningJobID, options) {
    return this._client.post(path`/fine_tuning/jobs/${fineTuningJobID}/resume`, options);
  }
}
Jobs.Checkpoints = Checkpoints2;

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
class FineTuning extends APIResource {
  constructor() {
    super(...arguments);
    this.methods = new Methods(this._client);
    this.jobs = new Jobs(this._client);
    this.checkpoints = new Checkpoints(this._client);
    this.alpha = new Alpha(this._client);
  }
}
FineTuning.Methods = Methods;
FineTuning.Jobs = Jobs;
FineTuning.Checkpoints = Checkpoints;
FineTuning.Alpha = Alpha;
// node_modules/openai/resources/graders/grader-models.mjs
class GraderModels extends APIResource {
}

// node_modules/openai/resources/graders/graders.mjs
class Graders2 extends APIResource {
  constructor() {
    super(...arguments);
    this.graderModels = new GraderModels(this._client);
  }
}
Graders2.GraderModels = GraderModels;
// node_modules/openai/resources/images.mjs
class Images extends APIResource {
  createVariation(body, options) {
    return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options }, this._client));
  }
  edit(body, options) {
    return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options, stream: body.stream ?? false }, this._client));
  }
  generate(body, options) {
    return this._client.post("/images/generations", { body, ...options, stream: body.stream ?? false });
  }
}
// node_modules/openai/resources/models.mjs
class Models extends APIResource {
  retrieve(model, options) {
    return this._client.get(path`/models/${model}`, options);
  }
  list(options) {
    return this._client.getAPIList("/models", Page, options);
  }
  delete(model, options) {
    return this._client.delete(path`/models/${model}`, options);
  }
}
// node_modules/openai/resources/moderations.mjs
class Moderations extends APIResource {
  create(body, options) {
    return this._client.post("/moderations", { body, ...options });
  }
}
// node_modules/openai/resources/realtime/calls.mjs
class Calls extends APIResource {
  accept(callID, body, options) {
    return this._client.post(path`/realtime/calls/${callID}/accept`, {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
  hangup(callID, options) {
    return this._client.post(path`/realtime/calls/${callID}/hangup`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
  refer(callID, body, options) {
    return this._client.post(path`/realtime/calls/${callID}/refer`, {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
  reject(callID, body = {}, options) {
    return this._client.post(path`/realtime/calls/${callID}/reject`, {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
}

// node_modules/openai/resources/realtime/client-secrets.mjs
class ClientSecrets extends APIResource {
  create(body, options) {
    return this._client.post("/realtime/client_secrets", { body, ...options });
  }
}

// node_modules/openai/resources/realtime/realtime.mjs
class Realtime2 extends APIResource {
  constructor() {
    super(...arguments);
    this.clientSecrets = new ClientSecrets(this._client);
    this.calls = new Calls(this._client);
  }
}
Realtime2.ClientSecrets = ClientSecrets;
Realtime2.Calls = Calls;
// node_modules/openai/lib/responses/ResponseStream.mjs
var _ResponseStream_instances;
var _ResponseStream_params;
var _ResponseStream_currentResponseSnapshot;
var _ResponseStream_finalResponse;
var _ResponseStream_beginRequest;
var _ResponseStream_addEvent;
var _ResponseStream_endRequest;
var _ResponseStream_accumulateResponse;

class ResponseStream extends EventStream {
  constructor(params) {
    super();
    _ResponseStream_instances.add(this);
    _ResponseStream_params.set(this, undefined);
    _ResponseStream_currentResponseSnapshot.set(this, undefined);
    _ResponseStream_finalResponse.set(this, undefined);
    __classPrivateFieldSet(this, _ResponseStream_params, params, "f");
  }
  static createResponse(client2, params, options) {
    const runner = new ResponseStream(params);
    runner._run(() => runner._createOrRetrieveResponse(client2, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createOrRetrieveResponse(client2, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_beginRequest).call(this);
    let stream;
    let starting_after = null;
    if ("response_id" in params) {
      stream = await client2.responses.retrieve(params.response_id, { stream: true }, { ...options, signal: this.controller.signal, stream: true });
      starting_after = params.starting_after ?? null;
    } else {
      stream = await client2.responses.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    }
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_addEvent).call(this, event, starting_after);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError;
    }
    return __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_endRequest).call(this);
  }
  [(_ResponseStream_params = new WeakMap, _ResponseStream_currentResponseSnapshot = new WeakMap, _ResponseStream_finalResponse = new WeakMap, _ResponseStream_instances = new WeakSet, _ResponseStream_beginRequest = function _ResponseStream_beginRequest() {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, undefined, "f");
  }, _ResponseStream_addEvent = function _ResponseStream_addEvent(event, starting_after) {
    if (this.ended)
      return;
    const maybeEmit = (name, event2) => {
      if (starting_after == null || event2.sequence_number > starting_after) {
        this._emit(name, event2);
      }
    };
    const response = __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_accumulateResponse).call(this, event);
    maybeEmit("event", event);
    switch (event.type) {
      case "response.output_text.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          maybeEmit("response.output_text.delta", {
            ...event,
            snapshot: content.text
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          maybeEmit("response.function_call_arguments.delta", {
            ...event,
            snapshot: output.arguments
          });
        }
        break;
      }
      default:
        maybeEmit(event.type, event);
        break;
    }
  }, _ResponseStream_endRequest = function _ResponseStream_endRequest() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any events`);
    }
    __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, undefined, "f");
    const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet(this, _ResponseStream_params, "f"));
    __classPrivateFieldSet(this, _ResponseStream_finalResponse, parsedResponse, "f");
    return parsedResponse;
  }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse(event) {
    let snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      if (event.type !== "response.created") {
        throw new OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);
      }
      snapshot = __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
      return snapshot;
    }
    switch (event.type) {
      case "response.output_item.added": {
        snapshot.output.push(event.item);
        break;
      }
      case "response.content_part.added": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        const type = output.type;
        const part = event.part;
        if (type === "message" && part.type !== "reasoning_text") {
          output.content.push(part);
        } else if (type === "reasoning" && part.type === "reasoning_text") {
          if (!output.content) {
            output.content = [];
          }
          output.content.push(part);
        }
        break;
      }
      case "response.output_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          output.arguments += event.delta;
        }
        break;
      }
      case "response.reasoning_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "reasoning") {
          const content = output.content?.[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "reasoning_text") {
            throw new OpenAIError(`expected content to be 'reasoning_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.completed": {
        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
        break;
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(undefined);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: undefined, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((event2) => event2 ? { value: event2, done: false } : { value: undefined, done: true });
        }
        const event = pushQueue.shift();
        return { value: event, done: false };
      },
      return: async () => {
        this.abort();
        return { value: undefined, done: true };
      }
    };
  }
  async finalResponse() {
    await this.done();
    const response = __classPrivateFieldGet(this, _ResponseStream_finalResponse, "f");
    if (!response)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return response;
  }
}
function finalizeResponse(snapshot, params) {
  return maybeParseResponse(snapshot, params);
}

// node_modules/openai/resources/responses/input-items.mjs
class InputItems extends APIResource {
  list(responseID, query = {}, options) {
    return this._client.getAPIList(path`/responses/${responseID}/input_items`, CursorPage, { query, ...options });
  }
}

// node_modules/openai/resources/responses/input-tokens.mjs
class InputTokens extends APIResource {
  count(body = {}, options) {
    return this._client.post("/responses/input_tokens", { body, ...options });
  }
}

// node_modules/openai/resources/responses/responses.mjs
class Responses extends APIResource {
  constructor() {
    super(...arguments);
    this.inputItems = new InputItems(this._client);
    this.inputTokens = new InputTokens(this._client);
  }
  create(body, options) {
    return this._client.post("/responses", { body, ...options, stream: body.stream ?? false })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  retrieve(responseID, query = {}, options) {
    return this._client.get(path`/responses/${responseID}`, {
      query,
      ...options,
      stream: query?.stream ?? false
    })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  delete(responseID, options) {
    return this._client.delete(path`/responses/${responseID}`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
  parse(body, options) {
    return this._client.responses.create(body, options)._thenUnwrap((response) => parseResponse(response, body));
  }
  stream(body, options) {
    return ResponseStream.createResponse(this._client, body, options);
  }
  cancel(responseID, options) {
    return this._client.post(path`/responses/${responseID}/cancel`, options);
  }
  compact(body = {}, options) {
    return this._client.post("/responses/compact", { body, ...options });
  }
}
Responses.InputItems = InputItems;
Responses.InputTokens = InputTokens;
// node_modules/openai/resources/uploads/parts.mjs
class Parts extends APIResource {
  create(uploadID, body, options) {
    return this._client.post(path`/uploads/${uploadID}/parts`, multipartFormRequestOptions({ body, ...options }, this._client));
  }
}

// node_modules/openai/resources/uploads/uploads.mjs
class Uploads extends APIResource {
  constructor() {
    super(...arguments);
    this.parts = new Parts(this._client);
  }
  create(body, options) {
    return this._client.post("/uploads", { body, ...options });
  }
  cancel(uploadID, options) {
    return this._client.post(path`/uploads/${uploadID}/cancel`, options);
  }
  complete(uploadID, body, options) {
    return this._client.post(path`/uploads/${uploadID}/complete`, { body, ...options });
  }
}
Uploads.Parts = Parts;
// node_modules/openai/lib/Util.mjs
var allSettledWithThrow = async (promises) => {
  const results = await Promise.allSettled(promises);
  const rejected = results.filter((result) => result.status === "rejected");
  if (rejected.length) {
    for (const result of rejected) {
      console.error(result.reason);
    }
    throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
  }
  const values2 = [];
  for (const result of results) {
    if (result.status === "fulfilled") {
      values2.push(result.value);
    }
  }
  return values2;
};

// node_modules/openai/resources/vector-stores/file-batches.mjs
class FileBatches extends APIResource {
  create(vectorStoreID, body, options) {
    return this._client.post(path`/vector_stores/${vectorStoreID}/file_batches`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  retrieve(batchID, params, options) {
    const { vector_store_id } = params;
    return this._client.get(path`/vector_stores/${vector_store_id}/file_batches/${batchID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  cancel(batchID, params, options) {
    const { vector_store_id } = params;
    return this._client.post(path`/vector_stores/${vector_store_id}/file_batches/${batchID}/cancel`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  async createAndPoll(vectorStoreId, body, options) {
    const batch = await this.create(vectorStoreId, body);
    return await this.poll(vectorStoreId, batch.id, options);
  }
  listFiles(batchID, params, options) {
    const { vector_store_id, ...query } = params;
    return this._client.getAPIList(path`/vector_stores/${vector_store_id}/file_batches/${batchID}/files`, CursorPage, { query, ...options, headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]) });
  }
  async poll(vectorStoreID, batchID, options) {
    const headers = buildHeaders([
      options?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? undefined
      }
    ]);
    while (true) {
      const { data: batch, response } = await this.retrieve(batchID, { vector_store_id: vectorStoreID }, {
        ...options,
        headers
      }).withResponse();
      switch (batch.status) {
        case "in_progress":
          let sleepInterval = 5000;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return batch;
      }
    }
  }
  async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
    if (files == null || files.length == 0) {
      throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
    }
    const configuredConcurrency = options?.maxConcurrency ?? 5;
    const concurrencyLimit = Math.min(configuredConcurrency, files.length);
    const client2 = this._client;
    const fileIterator = files.values();
    const allFileIds = [...fileIds];
    async function processFiles(iterator) {
      for (let item of iterator) {
        const fileObj = await client2.files.create({ file: item, purpose: "assistants" }, options);
        allFileIds.push(fileObj.id);
      }
    }
    const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
    await allSettledWithThrow(workers);
    return await this.createAndPoll(vectorStoreId, {
      file_ids: allFileIds
    });
  }
}

// node_modules/openai/resources/vector-stores/files.mjs
class Files3 extends APIResource {
  create(vectorStoreID, body, options) {
    return this._client.post(path`/vector_stores/${vectorStoreID}/files`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  retrieve(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.get(path`/vector_stores/${vector_store_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  update(fileID, params, options) {
    const { vector_store_id, ...body } = params;
    return this._client.post(path`/vector_stores/${vector_store_id}/files/${fileID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  list(vectorStoreID, query = {}, options) {
    return this._client.getAPIList(path`/vector_stores/${vectorStoreID}/files`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  delete(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.delete(path`/vector_stores/${vector_store_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  async createAndPoll(vectorStoreId, body, options) {
    const file2 = await this.create(vectorStoreId, body, options);
    return await this.poll(vectorStoreId, file2.id, options);
  }
  async poll(vectorStoreID, fileID, options) {
    const headers = buildHeaders([
      options?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? undefined
      }
    ]);
    while (true) {
      const fileResponse = await this.retrieve(fileID, {
        vector_store_id: vectorStoreID
      }, { ...options, headers }).withResponse();
      const file2 = fileResponse.data;
      switch (file2.status) {
        case "in_progress":
          let sleepInterval = 5000;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        case "failed":
        case "completed":
          return file2;
      }
    }
  }
  async upload(vectorStoreId, file2, options) {
    const fileInfo = await this._client.files.create({ file: file2, purpose: "assistants" }, options);
    return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
  }
  async uploadAndPoll(vectorStoreId, file2, options) {
    const fileInfo = await this.upload(vectorStoreId, file2, options);
    return await this.poll(vectorStoreId, fileInfo.id, options);
  }
  content(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.getAPIList(path`/vector_stores/${vector_store_id}/files/${fileID}/content`, Page, { ...options, headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]) });
  }
}

// node_modules/openai/resources/vector-stores/vector-stores.mjs
class VectorStores extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files3(this._client);
    this.fileBatches = new FileBatches(this._client);
  }
  create(body, options) {
    return this._client.post("/vector_stores", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  retrieve(vectorStoreID, options) {
    return this._client.get(path`/vector_stores/${vectorStoreID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  update(vectorStoreID, body, options) {
    return this._client.post(path`/vector_stores/${vectorStoreID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  list(query = {}, options) {
    return this._client.getAPIList("/vector_stores", CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  delete(vectorStoreID, options) {
    return this._client.delete(path`/vector_stores/${vectorStoreID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  search(vectorStoreID, body, options) {
    return this._client.getAPIList(path`/vector_stores/${vectorStoreID}/search`, Page, {
      body,
      method: "post",
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
}
VectorStores.Files = Files3;
VectorStores.FileBatches = FileBatches;
// node_modules/openai/resources/videos.mjs
class Videos extends APIResource {
  create(body, options) {
    return this._client.post("/videos", maybeMultipartFormRequestOptions({ body, ...options }, this._client));
  }
  retrieve(videoID, options) {
    return this._client.get(path`/videos/${videoID}`, options);
  }
  list(query = {}, options) {
    return this._client.getAPIList("/videos", ConversationCursorPage, { query, ...options });
  }
  delete(videoID, options) {
    return this._client.delete(path`/videos/${videoID}`, options);
  }
  downloadContent(videoID, query = {}, options) {
    return this._client.get(path`/videos/${videoID}/content`, {
      query,
      ...options,
      headers: buildHeaders([{ Accept: "application/binary" }, options?.headers]),
      __binaryResponse: true
    });
  }
  remix(videoID, body, options) {
    return this._client.post(path`/videos/${videoID}/remix`, maybeMultipartFormRequestOptions({ body, ...options }, this._client));
  }
}
// node_modules/openai/resources/webhooks.mjs
var _Webhooks_instances;
var _Webhooks_validateSecret;
var _Webhooks_getRequiredHeader;

class Webhooks extends APIResource {
  constructor() {
    super(...arguments);
    _Webhooks_instances.add(this);
  }
  async unwrap(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
    await this.verifySignature(payload, headers, secret, tolerance);
    return JSON.parse(payload);
  }
  async verifySignature(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
    if (typeof crypto === "undefined" || typeof crypto.subtle.importKey !== "function" || typeof crypto.subtle.verify !== "function") {
      throw new Error("Webhook signature verification is only supported when the `crypto` global is defined");
    }
    __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_validateSecret).call(this, secret);
    const headersObj = buildHeaders([headers]).values;
    const signatureHeader = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-signature");
    const timestamp = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-timestamp");
    const webhookId = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-id");
    const timestampSeconds = parseInt(timestamp, 10);
    if (isNaN(timestampSeconds)) {
      throw new InvalidWebhookSignatureError("Invalid webhook timestamp format");
    }
    const nowSeconds = Math.floor(Date.now() / 1000);
    if (nowSeconds - timestampSeconds > tolerance) {
      throw new InvalidWebhookSignatureError("Webhook timestamp is too old");
    }
    if (timestampSeconds > nowSeconds + tolerance) {
      throw new InvalidWebhookSignatureError("Webhook timestamp is too new");
    }
    const signatures = signatureHeader.split(" ").map((part) => part.startsWith("v1,") ? part.substring(3) : part);
    const decodedSecret = secret.startsWith("whsec_") ? Buffer.from(secret.replace("whsec_", ""), "base64") : Buffer.from(secret, "utf-8");
    const signedPayload = webhookId ? `${webhookId}.${timestamp}.${payload}` : `${timestamp}.${payload}`;
    const key = await crypto.subtle.importKey("raw", decodedSecret, { name: "HMAC", hash: "SHA-256" }, false, ["verify"]);
    for (const signature of signatures) {
      try {
        const signatureBytes = Buffer.from(signature, "base64");
        const isValid2 = await crypto.subtle.verify("HMAC", key, signatureBytes, new TextEncoder().encode(signedPayload));
        if (isValid2) {
          return;
        }
      } catch {
        continue;
      }
    }
    throw new InvalidWebhookSignatureError("The given webhook signature does not match the expected signature");
  }
}
_Webhooks_instances = new WeakSet, _Webhooks_validateSecret = function _Webhooks_validateSecret2(secret) {
  if (typeof secret !== "string" || secret.length === 0) {
    throw new Error(`The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function`);
  }
}, _Webhooks_getRequiredHeader = function _Webhooks_getRequiredHeader2(headers, name) {
  if (!headers) {
    throw new Error(`Headers are required`);
  }
  const value = headers.get(name);
  if (value === null || value === undefined) {
    throw new Error(`Missing required header: ${name}`);
  }
  return value;
};
// node_modules/openai/client.mjs
var _OpenAI_instances;
var _a3;
var _OpenAI_encoder;
var _OpenAI_baseURLOverridden;

class OpenAI {
  constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = readEnv("OPENAI_ORG_ID") ?? null, project = readEnv("OPENAI_PROJECT_ID") ?? null, webhookSecret = readEnv("OPENAI_WEBHOOK_SECRET") ?? null, ...opts } = {}) {
    _OpenAI_instances.add(this);
    _OpenAI_encoder.set(this, undefined);
    this.completions = new Completions2(this);
    this.chat = new Chat(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files2(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.graders = new Graders2(this);
    this.vectorStores = new VectorStores(this);
    this.webhooks = new Webhooks(this);
    this.beta = new Beta(this);
    this.batches = new Batches(this);
    this.uploads = new Uploads(this);
    this.responses = new Responses(this);
    this.realtime = new Realtime2(this);
    this.conversations = new Conversations(this);
    this.evals = new Evals(this);
    this.containers = new Containers(this);
    this.videos = new Videos(this);
    if (apiKey === undefined) {
      throw new OpenAIError("Missing credentials. Please pass an `apiKey`, or set the `OPENAI_API_KEY` environment variable.");
    }
    const options = {
      apiKey,
      organization,
      project,
      webhookSecret,
      ...opts,
      baseURL: baseURL || `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new OpenAI({ apiKey, dangerouslyAllowBrowser: true });

https://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety
`);
    }
    this.baseURL = options.baseURL;
    this.timeout = options.timeout ?? _a3.DEFAULT_TIMEOUT;
    this.logger = options.logger ?? console;
    const defaultLogLevel = "warn";
    this.logLevel = defaultLogLevel;
    this.logLevel = parseLogLevel(options.logLevel, "ClientOptions.logLevel", this) ?? parseLogLevel(readEnv("OPENAI_LOG"), "process.env['OPENAI_LOG']", this) ?? defaultLogLevel;
    this.fetchOptions = options.fetchOptions;
    this.maxRetries = options.maxRetries ?? 2;
    this.fetch = options.fetch ?? getDefaultFetch();
    __classPrivateFieldSet(this, _OpenAI_encoder, FallbackEncoder, "f");
    this._options = options;
    this.apiKey = typeof apiKey === "string" ? apiKey : "Missing Key";
    this.organization = organization;
    this.project = project;
    this.webhookSecret = webhookSecret;
  }
  withOptions(options) {
    const client2 = new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      organization: this.organization,
      project: this.project,
      webhookSecret: this.webhookSecret,
      ...options
    });
    return client2;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values: values2, nulls }) {
    return;
  }
  async authHeaders(opts) {
    return buildHeaders([{ Authorization: `Bearer ${this.apiKey}` }]);
  }
  stringifyQuery(query) {
    return stringify2(query, { arrayFormat: "brackets" });
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid42()}`;
  }
  makeStatusError(status, error47, message, headers) {
    return APIError.generate(status, error47, message, headers);
  }
  async _callApiKey() {
    const apiKey = this._options.apiKey;
    if (typeof apiKey !== "function")
      return false;
    let token;
    try {
      token = await apiKey();
    } catch (err) {
      if (err instanceof OpenAIError)
        throw err;
      throw new OpenAIError(`Failed to get token from 'apiKey' function: ${err.message}`, { cause: err });
    }
    if (typeof token !== "string" || !token) {
      throw new OpenAIError(`Expected 'apiKey' function argument to return a string but it returned ${token}`);
    }
    this.apiKey = token;
    return true;
  }
  buildURL(path2, query, defaultBaseURL) {
    const baseURL = !__classPrivateFieldGet(this, _OpenAI_instances, "m", _OpenAI_baseURLOverridden).call(this) && defaultBaseURL || this.baseURL;
    const url2 = isAbsoluteURL(path2) ? new URL(path2) : new URL(baseURL + (baseURL.endsWith("/") && path2.startsWith("/") ? path2.slice(1) : path2));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj2(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url2.search = this.stringifyQuery(query);
    }
    return url2.toString();
  }
  async prepareOptions(options) {
    await this._callApiKey();
  }
  async prepareRequest(request, { url: url2, options }) {}
  get(path2, opts) {
    return this.methodRequest("get", path2, opts);
  }
  post(path2, opts) {
    return this.methodRequest("post", path2, opts);
  }
  patch(path2, opts) {
    return this.methodRequest("patch", path2, opts);
  }
  put(path2, opts) {
    return this.methodRequest("put", path2, opts);
  }
  delete(path2, opts) {
    return this.methodRequest("delete", path2, opts);
  }
  methodRequest(method, path2, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => {
      return { method, path: path2, ...opts2 };
    }));
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this, this.makeRequest(options, remainingRetries, undefined));
  }
  async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url: url2, timeout } = await this.buildRequest(options, {
      retryCount: maxRetries - retriesRemaining
    });
    await this.prepareRequest(req, { url: url2, options });
    const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
    const retryLogStr = retryOfRequestLogID === undefined ? "" : `, retryOf: ${retryOfRequestLogID}`;
    const startTime = Date.now();
    loggerFor(this).debug(`[${requestLogID}] sending request`, formatRequestDetails({
      retryOfRequestLogID,
      method: options.method,
      url: url2,
      options,
      headers: req.headers
    }));
    if (options.signal?.aborted) {
      throw new APIUserAbortError;
    }
    const controller = new AbortController;
    const response = await this.fetchWithTimeout(url2, req, timeout, controller).catch(castToError);
    const headersTime = Date.now();
    if (response instanceof globalThis.Error) {
      const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
      if (options.signal?.aborted) {
        throw new APIUserAbortError;
      }
      const isTimeout = isAbortError(response) || /timed? ?out/i.test(String(response) + ("cause" in response ? String(response.cause) : ""));
      if (retriesRemaining) {
        loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
        loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, formatRequestDetails({
          retryOfRequestLogID,
          url: url2,
          durationMs: headersTime - startTime,
          message: response.message
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID);
      }
      loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
      loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, formatRequestDetails({
        retryOfRequestLogID,
        url: url2,
        durationMs: headersTime - startTime,
        message: response.message
      }));
      if (isTimeout) {
        throw new APIConnectionTimeoutError;
      }
      throw new APIConnectionError({ cause: response });
    }
    const specialHeaders = [...response.headers.entries()].filter(([name]) => name === "x-request-id").map(([name, value]) => ", " + name + ": " + JSON.stringify(value)).join("");
    const responseInfo = `[${requestLogID}${retryLogStr}${specialHeaders}] ${req.method} ${url2} ${response.ok ? "succeeded" : "failed"} with status ${response.status} in ${headersTime - startTime}ms`;
    if (!response.ok) {
      const shouldRetry = await this.shouldRetry(response);
      if (retriesRemaining && shouldRetry) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        await CancelReadableStream(response.body);
        loggerFor(this).info(`${responseInfo} - ${retryMessage2}`);
        loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage2})`, formatRequestDetails({
          retryOfRequestLogID,
          url: response.url,
          status: response.status,
          headers: response.headers,
          durationMs: headersTime - startTime
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);
      }
      const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
      loggerFor(this).info(`${responseInfo} - ${retryMessage}`);
      const errText = await response.text().catch((err2) => castToError(err2).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? undefined : errText;
      loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({
        retryOfRequestLogID,
        url: response.url,
        status: response.status,
        headers: response.headers,
        message: errMessage,
        durationMs: Date.now() - startTime
      }));
      const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
      throw err;
    }
    loggerFor(this).info(responseInfo);
    loggerFor(this).debug(`[${requestLogID}] response start`, formatRequestDetails({
      retryOfRequestLogID,
      url: response.url,
      status: response.status,
      headers: response.headers,
      durationMs: headersTime - startTime
    }));
    return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
  }
  getAPIList(path2, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path: path2, ...opts });
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null, undefined);
    return new PagePromise(this, request, Page2);
  }
  async fetchWithTimeout(url2, init, ms, controller) {
    const { signal, method, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const isReadableBody = globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream || typeof options.body === "object" && options.body !== null && Symbol.asyncIterator in options.body;
    const fetchOptions = {
      signal: controller.signal,
      ...isReadableBody ? { duplex: "half" } : {},
      method: "GET",
      ...options
    };
    if (method) {
      fetchOptions.method = method.toUpperCase();
    }
    try {
      return await this.fetch.call(undefined, url2, fetchOptions);
    } finally {
      clearTimeout(timeout);
    }
  }
  async shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders?.get("retry-after-ms");
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders?.get("retry-after");
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1000;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1, requestLogID);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1000;
  }
  async buildRequest(inputOptions, { retryCount = 0 } = {}) {
    const options = { ...inputOptions };
    const { method, path: path2, query, defaultBaseURL } = options;
    const url2 = this.buildURL(path2, query, defaultBaseURL);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    options.timeout = options.timeout ?? this.timeout;
    const { bodyHeaders, body } = this.buildBody({ options });
    const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
    const req = {
      method,
      headers: reqHeaders,
      ...options.signal && { signal: options.signal },
      ...globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" },
      ...body && { body },
      ...this.fetchOptions ?? {},
      ...options.fetchOptions ?? {}
    };
    return { req, url: url2, timeout: options.timeout };
  }
  async buildHeaders({ options, method, bodyHeaders, retryCount }) {
    let idempotencyHeaders = {};
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
    }
    const headers = buildHeaders([
      idempotencyHeaders,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(retryCount),
        ...options.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options.timeout / 1000)) } : {},
        ...getPlatformHeaders(),
        "OpenAI-Organization": this.organization,
        "OpenAI-Project": this.project
      },
      await this.authHeaders(options),
      this._options.defaultHeaders,
      bodyHeaders,
      options.headers
    ]);
    this.validateHeaders(headers);
    return headers.values;
  }
  buildBody({ options: { body, headers: rawHeaders } }) {
    if (!body) {
      return { bodyHeaders: undefined, body: undefined };
    }
    const headers = buildHeaders([rawHeaders]);
    if (ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && headers.values.has("content-type") || globalThis.Blob && body instanceof globalThis.Blob || body instanceof FormData || body instanceof URLSearchParams || globalThis.ReadableStream && body instanceof globalThis.ReadableStream) {
      return { bodyHeaders: undefined, body };
    } else if (typeof body === "object" && ((Symbol.asyncIterator in body) || (Symbol.iterator in body) && ("next" in body) && typeof body.next === "function")) {
      return { bodyHeaders: undefined, body: ReadableStreamFrom(body) };
    } else {
      return __classPrivateFieldGet(this, _OpenAI_encoder, "f").call(this, { body, headers });
    }
  }
}
_a3 = OpenAI, _OpenAI_encoder = new WeakMap, _OpenAI_instances = new WeakSet, _OpenAI_baseURLOverridden = function _OpenAI_baseURLOverridden2() {
  return this.baseURL !== "https://api.openai.com/v1";
};
OpenAI.OpenAI = _a3;
OpenAI.DEFAULT_TIMEOUT = 600000;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
OpenAI.InvalidWebhookSignatureError = InvalidWebhookSignatureError;
OpenAI.toFile = toFile;
OpenAI.Completions = Completions2;
OpenAI.Chat = Chat;
OpenAI.Embeddings = Embeddings;
OpenAI.Files = Files2;
OpenAI.Images = Images;
OpenAI.Audio = Audio;
OpenAI.Moderations = Moderations;
OpenAI.Models = Models;
OpenAI.FineTuning = FineTuning;
OpenAI.Graders = Graders2;
OpenAI.VectorStores = VectorStores;
OpenAI.Webhooks = Webhooks;
OpenAI.Beta = Beta;
OpenAI.Batches = Batches;
OpenAI.Uploads = Uploads;
OpenAI.Responses = Responses;
OpenAI.Realtime = Realtime2;
OpenAI.Conversations = Conversations;
OpenAI.Evals = Evals;
OpenAI.Containers = Containers;
OpenAI.Videos = Videos;
// node_modules/openai/azure.mjs
var _deployments_endpoints = new Set([
  "/completions",
  "/chat/completions",
  "/embeddings",
  "/audio/transcriptions",
  "/audio/translations",
  "/audio/speech",
  "/images/generations",
  "/batches",
  "/images/edits"
]);
// node_modules/@openai/agents-openai/dist/metadata.mjs
var METADATA = {
  name: "@openai/agents-openai",
  version: "0.3.4",
  versions: {
    "@openai/agents-openai": "0.3.4",
    "@openai/agents-core": "workspace:*",
    openai: "^6"
  }
};
var metadata_default = METADATA;

// node_modules/@openai/agents-openai/dist/defaults.mjs
var DEFAULT_OPENAI_API = "responses";
var _defaultOpenAIAPI = DEFAULT_OPENAI_API;
var _defaultOpenAIClient;
var _defaultOpenAIKey = undefined;
var _defaultTracingApiKey = undefined;
function getTracingExportApiKey() {
  return _defaultTracingApiKey ?? loadEnv().OPENAI_API_KEY;
}
function shouldUseResponsesByDefault() {
  return _defaultOpenAIAPI === "responses";
}
function getDefaultOpenAIClient() {
  return _defaultOpenAIClient;
}
function getDefaultOpenAIKey() {
  return _defaultOpenAIKey ?? loadEnv().OPENAI_API_KEY;
}
var HEADERS = {
  "User-Agent": `Agents/JavaScript ${metadata_default.version}`
};

// node_modules/@openai/agents-openai/dist/logger.mjs
var logger2 = getLogger("openai-agents:openai");
var logger_default2 = logger2;

// node_modules/@openai/agents-openai/dist/tools.mjs
var WebSearchStatus = exports_external2.enum(["in_progress", "completed", "searching", "failed"]).default("failed");
var FileSearchStatus = exports_external2.enum(["in_progress", "completed", "searching", "failed", "incomplete"]).default("failed");
var CodeInterpreterStatus = exports_external2.enum(["in_progress", "completed", "interpreting"]).default("in_progress");
var ImageGenerationStatus = exports_external2.enum(["in_progress", "completed", "generating", "failed"]).default("failed");

// node_modules/@openai/agents-openai/dist/utils/providerData.mjs
function camelOrSnakeToSnakeCase(providerData) {
  if (!providerData || typeof providerData !== "object" || Array.isArray(providerData)) {
    return providerData;
  }
  const result = {};
  for (const [key, value] of Object.entries(providerData)) {
    const snakeKey = key.replace(/([A-Z])/g, "_$1").toLowerCase();
    result[snakeKey] = camelOrSnakeToSnakeCase(value);
  }
  return result;
}

// node_modules/@openai/agents-openai/dist/openaiResponsesModel.mjs
var HostedToolChoice = exports_external2.enum([
  "file_search",
  "web_search",
  "web_search_preview",
  "code_interpreter",
  "image_generation",
  "mcp",
  "computer_use_preview",
  "shell",
  "apply_patch"
]);
var DefaultToolChoice = exports_external2.enum(["auto", "required", "none"]);
function getToolChoice(toolChoice) {
  if (typeof toolChoice === "undefined") {
    return;
  }
  const resultDefaultCheck = DefaultToolChoice.safeParse(toolChoice);
  if (resultDefaultCheck.success) {
    return resultDefaultCheck.data;
  }
  const result = HostedToolChoice.safeParse(toolChoice);
  if (result.success) {
    return { type: result.data };
  }
  return { type: "function", name: toolChoice };
}
function getResponseFormat(outputType, otherProperties) {
  if (outputType === "text") {
    return otherProperties;
  }
  return {
    ...otherProperties,
    format: outputType
  };
}
function normalizeFunctionCallOutputForRequest(output) {
  if (typeof output === "string") {
    return output;
  }
  if (Array.isArray(output)) {
    return output.map(convertStructuredOutputToRequestItem);
  }
  if (isRecord2(output) && typeof output.type === "string") {
    if (output.type === "text" && typeof output.text === "string") {
      return output.text;
    }
    if (output.type === "image" || output.type === "file") {
      const structuredItems = convertLegacyToolOutputContent(output);
      return structuredItems.map(convertStructuredOutputToRequestItem);
    }
  }
  return String(output);
}
function convertLegacyToolOutputContent(output) {
  if (output.type === "text") {
    const structured = {
      type: "input_text",
      text: output.text
    };
    if (output.providerData) {
      structured.providerData = output.providerData;
    }
    return [structured];
  }
  if (output.type === "image") {
    const structured = {
      type: "input_image"
    };
    if (output.detail) {
      structured.detail = output.detail;
    }
    const legacyImageUrl = output.imageUrl;
    const legacyFileId = output.fileId;
    const dataValue = output.data;
    if (typeof output.image === "string" && output.image.length > 0) {
      structured.image = output.image;
    } else if (isRecord2(output.image)) {
      const imageObj = output.image;
      const inlineMediaType = getImageInlineMediaType(imageObj);
      if (typeof imageObj.url === "string" && imageObj.url.length > 0) {
        structured.image = imageObj.url;
      } else if (typeof imageObj.data === "string" && imageObj.data.length > 0) {
        structured.image = formatInlineData(imageObj.data, inlineMediaType);
      } else if (imageObj.data instanceof Uint8Array && imageObj.data.length > 0) {
        structured.image = formatInlineData(imageObj.data, inlineMediaType);
      } else {
        const referencedId = typeof imageObj.fileId === "string" && imageObj.fileId.length > 0 && imageObj.fileId || (typeof imageObj.id === "string" && imageObj.id.length > 0 ? imageObj.id : undefined);
        if (referencedId) {
          structured.image = { id: referencedId };
        }
      }
    } else if (typeof legacyImageUrl === "string" && legacyImageUrl.length > 0) {
      structured.image = legacyImageUrl;
    } else if (typeof legacyFileId === "string" && legacyFileId.length > 0) {
      structured.image = { id: legacyFileId };
    } else {
      let base64Data;
      if (typeof dataValue === "string" && dataValue.length > 0) {
        base64Data = dataValue;
      } else if (dataValue instanceof Uint8Array && dataValue.length > 0) {
        base64Data = encodeUint8ArrayToBase64(dataValue);
      }
      if (base64Data) {
        structured.image = base64Data;
      }
    }
    if (output.providerData) {
      structured.providerData = output.providerData;
    }
    return [structured];
  }
  if (output.type === "file") {
    const structured = {
      type: "input_file"
    };
    const fileValue = output.file ?? output.file;
    if (typeof fileValue === "string") {
      structured.file = fileValue;
    } else if (isRecord2(fileValue)) {
      if (typeof fileValue.data === "string" && fileValue.data.length > 0) {
        structured.file = formatInlineData(fileValue.data, fileValue.mediaType ?? "text/plain");
      } else if (fileValue.data instanceof Uint8Array && fileValue.data.length > 0) {
        structured.file = formatInlineData(fileValue.data, fileValue.mediaType ?? "text/plain");
      } else if (typeof fileValue.url === "string" && fileValue.url.length > 0) {
        structured.file = { url: fileValue.url };
      } else {
        const referencedId = typeof fileValue.id === "string" && fileValue.id.length > 0 && fileValue.id || (typeof fileValue.fileId === "string" && fileValue.fileId.length > 0 ? fileValue.fileId : undefined);
        if (referencedId) {
          structured.file = { id: referencedId };
        }
      }
      if (typeof fileValue.filename === "string" && fileValue.filename.length > 0) {
        structured.filename = fileValue.filename;
      }
    }
    if (!structured.file) {
      const legacy = normalizeLegacyFileFromOutput(output);
      if (legacy.file) {
        structured.file = legacy.file;
      }
      if (legacy.filename) {
        structured.filename = legacy.filename;
      }
    }
    if (output.providerData) {
      structured.providerData = output.providerData;
    }
    return [structured];
  }
  throw new UserError(`Unsupported tool output type: ${JSON.stringify(output)}`);
}
function convertStructuredOutputToRequestItem(item) {
  if (item.type === "input_text") {
    return {
      type: "input_text",
      text: item.text
    };
  }
  if (item.type === "input_image") {
    const result = { type: "input_image" };
    const imageValue = item.image ?? item.imageUrl;
    if (typeof imageValue === "string") {
      result.image_url = imageValue;
    } else if (isRecord2(imageValue) && typeof imageValue.id === "string") {
      result.file_id = imageValue.id;
    }
    const legacyFileId = item.fileId;
    if (typeof legacyFileId === "string") {
      result.file_id = legacyFileId;
    }
    if (item.detail) {
      result.detail = item.detail;
    }
    return result;
  }
  if (item.type === "input_file") {
    const result = { type: "input_file" };
    if (typeof item.file === "string") {
      const value = item.file.trim();
      if (value.startsWith("data:")) {
        result.file_data = value;
      } else if (value.startsWith("http://") || value.startsWith("https://")) {
        result.file_url = value;
      } else if (/^[A-Za-z0-9+/=]+$/.test(value)) {
        result.file_data = value;
      } else {
        result.file_url = value;
      }
    } else if (item.file && typeof item.file === "object" && "id" in item.file && typeof item.file.id === "string") {
      result.file_id = item.file.id;
    } else if (item.file && typeof item.file === "object" && "url" in item.file && typeof item.file.url === "string") {
      result.file_url = item.file.url;
    }
    const legacyFileData = item.fileData;
    if (typeof legacyFileData === "string") {
      result.file_data = legacyFileData;
    }
    const legacyFileUrl = item.fileUrl;
    if (typeof legacyFileUrl === "string") {
      result.file_url = legacyFileUrl;
    }
    const legacyFileId = item.fileId;
    if (typeof legacyFileId === "string") {
      result.file_id = legacyFileId;
    }
    if (item.filename) {
      result.filename = item.filename;
    }
    return result;
  }
  throw new UserError(`Unsupported structured tool output: ${JSON.stringify(item)}`);
}
function convertResponseFunctionCallOutputItemToStructured(item) {
  if (item.type === "input_text") {
    return {
      type: "input_text",
      text: item.text
    };
  }
  if (item.type === "input_image") {
    const structured = { type: "input_image" };
    if (typeof item.image_url === "string" && item.image_url.length > 0) {
      structured.image = item.image_url;
    } else if (typeof item.file_id === "string" && item.file_id.length > 0) {
      structured.image = { id: item.file_id };
    } else {
      logger_default2.debug(`Skipped the "input_image" output item from a tool call result because the OpenAI Conversations API response didn't include the required property (image_url or file_id).`);
      return null;
    }
    if (item.detail) {
      structured.detail = item.detail;
    }
    return structured;
  }
  if (item.type === "input_file") {
    const structured = { type: "input_file" };
    if (typeof item.file_id === "string" && item.file_id.length > 0) {
      structured.file = { id: item.file_id };
    } else if (typeof item.file_url === "string" && item.file_url.length > 0) {
      structured.file = { url: item.file_url };
    } else if (typeof item.file_data === "string" && item.file_data.length > 0) {
      structured.file = item.file_data;
    }
    if (item.filename) {
      structured.filename = item.filename;
    }
    return structured;
  }
  const exhaustive = item;
  throw new UserError(`Unsupported structured tool output: ${JSON.stringify(exhaustive)}`);
}
function convertFunctionCallOutputToProtocol(output) {
  if (typeof output === "string") {
    return output;
  }
  if (Array.isArray(output)) {
    return output.map(convertResponseFunctionCallOutputItemToStructured).filter((s) => s !== null);
  }
  return "";
}
function normalizeLegacyFileFromOutput(value) {
  const filename = typeof value.filename === "string" && value.filename.length > 0 ? value.filename : undefined;
  const referencedId = (typeof value.id === "string" && value.id.length > 0 && value.id) ?? (typeof value.fileId === "string" && value.fileId.length > 0 ? value.fileId : undefined);
  if (referencedId) {
    return { file: { id: referencedId }, filename };
  }
  if (typeof value.fileUrl === "string" && value.fileUrl.length > 0) {
    return { file: { url: value.fileUrl }, filename };
  }
  if (typeof value.fileData === "string" && value.fileData.length > 0) {
    return {
      file: formatInlineData(value.fileData, value.mediaType ?? "text/plain"),
      filename
    };
  }
  if (value.fileData instanceof Uint8Array && value.fileData.length > 0) {
    return {
      file: formatInlineData(value.fileData, value.mediaType ?? "text/plain"),
      filename
    };
  }
  return {};
}
function isRecord2(value) {
  return typeof value === "object" && value !== null;
}
function getImageInlineMediaType(source) {
  if (typeof source.mediaType === "string" && source.mediaType.length > 0) {
    return source.mediaType;
  }
  return;
}
function formatInlineData(data, mediaType) {
  const base645 = typeof data === "string" ? data : encodeUint8ArrayToBase64(data);
  return mediaType ? `data:${mediaType};base64,${base645}` : base645;
}
function getTools(tools, handoffs) {
  const openaiTools = [];
  const include = [];
  for (const tool2 of tools) {
    const { tool: openaiTool, include: openaiIncludes } = converTool(tool2);
    openaiTools.push(openaiTool);
    if (openaiIncludes && openaiIncludes.length > 0) {
      for (const item of openaiIncludes) {
        include.push(item);
      }
    }
  }
  return {
    tools: [...openaiTools, ...handoffs.map(getHandoffTool)],
    include
  };
}
function converTool(tool2) {
  if (tool2.type === "function") {
    return {
      tool: {
        type: "function",
        name: tool2.name,
        description: tool2.description,
        parameters: tool2.parameters,
        strict: tool2.strict
      },
      include: undefined
    };
  } else if (tool2.type === "computer") {
    return {
      tool: {
        type: "computer_use_preview",
        environment: tool2.environment,
        display_width: tool2.dimensions[0],
        display_height: tool2.dimensions[1]
      },
      include: undefined
    };
  } else if (tool2.type === "shell") {
    return {
      tool: {
        type: "shell"
      },
      include: undefined
    };
  } else if (tool2.type === "apply_patch") {
    return {
      tool: {
        type: "apply_patch"
      },
      include: undefined
    };
  } else if (tool2.type === "hosted_tool") {
    if (tool2.providerData?.type === "web_search") {
      return {
        tool: {
          type: "web_search",
          user_location: tool2.providerData.user_location,
          filters: tool2.providerData.filters,
          search_context_size: tool2.providerData.search_context_size
        },
        include: undefined
      };
    } else if (tool2.providerData?.type === "web_search_preview") {
      return {
        tool: {
          type: "web_search_preview",
          user_location: tool2.providerData.user_location,
          search_context_size: tool2.providerData.search_context_size
        },
        include: undefined
      };
    } else if (tool2.providerData?.type === "file_search") {
      return {
        tool: {
          type: "file_search",
          vector_store_ids: tool2.providerData.vector_store_ids || (typeof tool2.providerData.vector_store_id === "string" ? [tool2.providerData.vector_store_id] : tool2.providerData.vector_store_id),
          max_num_results: tool2.providerData.max_num_results,
          ranking_options: tool2.providerData.ranking_options,
          filters: tool2.providerData.filters
        },
        include: tool2.providerData.include_search_results ? ["file_search_call.results"] : undefined
      };
    } else if (tool2.providerData?.type === "code_interpreter") {
      return {
        tool: {
          type: "code_interpreter",
          container: tool2.providerData.container
        },
        include: undefined
      };
    } else if (tool2.providerData?.type === "image_generation") {
      return {
        tool: {
          type: "image_generation",
          background: tool2.providerData.background,
          input_fidelity: tool2.providerData.input_fidelity,
          input_image_mask: tool2.providerData.input_image_mask,
          model: tool2.providerData.model,
          moderation: tool2.providerData.moderation,
          output_compression: tool2.providerData.output_compression,
          output_format: tool2.providerData.output_format,
          partial_images: tool2.providerData.partial_images,
          quality: tool2.providerData.quality,
          size: tool2.providerData.size
        },
        include: undefined
      };
    } else if (tool2.providerData?.type === "mcp") {
      return {
        tool: {
          type: "mcp",
          server_label: tool2.providerData.server_label,
          server_url: tool2.providerData.server_url,
          connector_id: tool2.providerData.connector_id,
          authorization: tool2.providerData.authorization,
          allowed_tools: tool2.providerData.allowed_tools,
          headers: tool2.providerData.headers,
          require_approval: convertMCPRequireApproval(tool2.providerData.require_approval)
        },
        include: undefined
      };
    } else if (tool2.providerData) {
      return {
        tool: tool2.providerData,
        include: undefined
      };
    }
  }
  throw new Error(`Unsupported tool type: ${JSON.stringify(tool2)}`);
}
function convertMCPRequireApproval(requireApproval) {
  if (requireApproval === "never" || requireApproval === undefined) {
    return "never";
  }
  if (requireApproval === "always") {
    return "always";
  }
  return {
    never: { tool_names: requireApproval.never?.tool_names },
    always: { tool_names: requireApproval.always?.tool_names }
  };
}
function getHandoffTool(handoff2) {
  return {
    name: handoff2.toolName,
    description: handoff2.toolDescription,
    parameters: handoff2.inputJsonSchema,
    strict: handoff2.strictJsonSchema,
    type: "function"
  };
}
function getInputMessageContent(entry) {
  if (entry.type === "input_text") {
    return {
      type: "input_text",
      text: entry.text,
      ...camelOrSnakeToSnakeCase(entry.providerData)
    };
  } else if (entry.type === "input_image") {
    const imageEntry = {
      type: "input_image",
      detail: entry.detail ?? "auto"
    };
    if (typeof entry.image === "string") {
      imageEntry.image_url = entry.image;
    } else if (entry.image && "id" in entry.image) {
      imageEntry.file_id = entry.image.id;
    } else if (typeof entry.imageUrl === "string") {
      imageEntry.image_url = entry.imageUrl;
    } else if (typeof entry.fileId === "string") {
      imageEntry.file_id = entry.fileId;
    }
    return {
      ...imageEntry,
      ...camelOrSnakeToSnakeCase(entry.providerData)
    };
  } else if (entry.type === "input_file") {
    const fileEntry = {
      type: "input_file"
    };
    if (typeof entry.file === "string") {
      if (entry.file.startsWith("data:")) {
        fileEntry.file_data = entry.file;
      } else if (entry.file.startsWith("https://")) {
        fileEntry.file_url = entry.file;
      } else {
        throw new UserError(`Unsupported string data for file input. If you're trying to pass an uploaded file's ID, use an object with the ID property instead.`);
      }
    } else if (entry.file && typeof entry.file === "object" && "id" in entry.file) {
      fileEntry.file_id = entry.file.id;
    } else if (entry.file && typeof entry.file === "object" && "url" in entry.file) {
      fileEntry.file_url = entry.file.url;
    }
    const legacyFileData = entry.fileData;
    if (typeof legacyFileData === "string") {
      fileEntry.file_data = legacyFileData;
    }
    const legacyFileUrl = entry.fileUrl;
    if (typeof legacyFileUrl === "string") {
      fileEntry.file_url = legacyFileUrl;
    }
    const legacyFileId = entry.fileId;
    if (typeof legacyFileId === "string") {
      fileEntry.file_id = legacyFileId;
    }
    if (entry.filename) {
      fileEntry.filename = entry.filename;
    }
    return {
      ...fileEntry,
      ...camelOrSnakeToSnakeCase(entry.providerData)
    };
  }
  throw new UserError(`Unsupported input content type: ${JSON.stringify(entry)}`);
}
function getOutputMessageContent(entry) {
  if (entry.type === "output_text") {
    return {
      type: "output_text",
      text: entry.text,
      annotations: [],
      ...camelOrSnakeToSnakeCase(entry.providerData)
    };
  }
  if (entry.type === "refusal") {
    return {
      type: "refusal",
      refusal: entry.refusal,
      ...camelOrSnakeToSnakeCase(entry.providerData)
    };
  }
  throw new UserError(`Unsupported output content type: ${JSON.stringify(entry)}`);
}
function getMessageItem(item) {
  if (item.role === "system") {
    return {
      id: item.id,
      role: "system",
      content: item.content,
      ...camelOrSnakeToSnakeCase(item.providerData)
    };
  }
  if (item.role === "user") {
    if (typeof item.content === "string") {
      return {
        id: item.id,
        role: "user",
        content: item.content,
        ...camelOrSnakeToSnakeCase(item.providerData)
      };
    }
    return {
      id: item.id,
      role: "user",
      content: item.content.map(getInputMessageContent),
      ...camelOrSnakeToSnakeCase(item.providerData)
    };
  }
  if (item.role === "assistant") {
    const assistantMessage = {
      type: "message",
      id: item.id,
      role: "assistant",
      content: item.content.map(getOutputMessageContent),
      status: item.status,
      ...camelOrSnakeToSnakeCase(item.providerData)
    };
    return assistantMessage;
  }
  throw new UserError(`Unsupported item ${JSON.stringify(item)}`);
}
function isMessageItem(item) {
  if (item.type === "message") {
    return true;
  }
  if (typeof item.type === "undefined" && typeof item.role === "string") {
    return true;
  }
  return false;
}
function getPrompt(prompt) {
  if (!prompt) {
    return;
  }
  const transformedVariables = {};
  for (const [key, value] of Object.entries(prompt.variables ?? {})) {
    if (typeof value === "string") {
      transformedVariables[key] = value;
    } else if (typeof value === "object") {
      transformedVariables[key] = getInputMessageContent(value);
    }
  }
  return {
    id: prompt.promptId,
    version: prompt.version,
    variables: transformedVariables
  };
}
function getInputItems(input) {
  if (typeof input === "string") {
    return [
      {
        role: "user",
        content: input
      }
    ];
  }
  return input.map((item) => {
    if (isMessageItem(item)) {
      return getMessageItem(item);
    }
    if (item.type === "function_call") {
      const entry = {
        id: item.id,
        type: "function_call",
        name: item.name,
        call_id: item.callId,
        arguments: item.arguments,
        status: item.status,
        ...camelOrSnakeToSnakeCase(item.providerData)
      };
      return entry;
    }
    if (item.type === "function_call_result") {
      const normalizedOutput = normalizeFunctionCallOutputForRequest(item.output);
      const entry = {
        type: "function_call_output",
        id: item.id,
        call_id: item.callId,
        output: normalizedOutput,
        status: item.status,
        ...camelOrSnakeToSnakeCase(item.providerData)
      };
      return entry;
    }
    if (item.type === "reasoning") {
      const entry = {
        id: item.id,
        type: "reasoning",
        summary: item.content.map((content) => ({
          type: "summary_text",
          text: content.text,
          ...camelOrSnakeToSnakeCase(content.providerData)
        })),
        encrypted_content: item.providerData?.encryptedContent,
        ...camelOrSnakeToSnakeCase(item.providerData)
      };
      return entry;
    }
    if (item.type === "computer_call") {
      const entry = {
        type: "computer_call",
        call_id: item.callId,
        id: item.id,
        action: item.action,
        status: item.status,
        pending_safety_checks: [],
        ...camelOrSnakeToSnakeCase(item.providerData)
      };
      return entry;
    }
    if (item.type === "computer_call_result") {
      const entry = {
        type: "computer_call_output",
        id: item.id,
        call_id: item.callId,
        output: buildResponseOutput(item),
        status: item.providerData?.status,
        acknowledged_safety_checks: item.providerData?.acknowledgedSafetyChecks,
        ...camelOrSnakeToSnakeCase(item.providerData)
      };
      return entry;
    }
    if (item.type === "shell_call") {
      const action = {
        commands: item.action.commands,
        timeout_ms: typeof item.action.timeoutMs === "number" ? item.action.timeoutMs : null,
        max_output_length: typeof item.action.maxOutputLength === "number" ? item.action.maxOutputLength : null
      };
      const entry = {
        type: "shell_call",
        id: item.id,
        call_id: item.callId,
        status: item.status ?? "in_progress",
        action
      };
      return entry;
    }
    if (item.type === "shell_call_output") {
      const shellOutputs = item.output;
      const sanitizedOutputs = shellOutputs.map((entry2) => {
        const outcome = entry2?.outcome;
        const exitCode = outcome?.type === "exit" ? outcome.exitCode : null;
        return {
          stdout: typeof entry2?.stdout === "string" ? entry2.stdout : "",
          stderr: typeof entry2?.stderr === "string" ? entry2.stderr : "",
          outcome: outcome?.type === "timeout" ? { type: "timeout" } : { type: "exit", exit_code: exitCode ?? 0 }
        };
      });
      const entry = {
        type: "shell_call_output",
        call_id: item.callId,
        output: sanitizedOutputs,
        id: item.id ?? undefined
      };
      if (typeof item.maxOutputLength === "number") {
        entry.max_output_length = item.maxOutputLength;
      }
      return entry;
    }
    if (item.type === "apply_patch_call") {
      if (!item.operation) {
        throw new UserError("apply_patch_call missing operation");
      }
      const entry = {
        type: "apply_patch_call",
        id: item.id ?? undefined,
        call_id: item.callId,
        status: item.status ?? "in_progress",
        operation: item.operation
      };
      return entry;
    }
    if (item.type === "apply_patch_call_output") {
      const entry = {
        type: "apply_patch_call_output",
        id: item.id ?? undefined,
        call_id: item.callId,
        status: item.status ?? "completed",
        output: item.output ?? undefined
      };
      return entry;
    }
    if (item.type === "hosted_tool_call") {
      if (item.providerData?.type === "web_search_call" || item.providerData?.type === "web_search") {
        const entry = {
          ...camelOrSnakeToSnakeCase(item.providerData),
          type: "web_search_call",
          id: item.id,
          status: WebSearchStatus.parse(item.status ?? "failed")
        };
        return entry;
      }
      if (item.providerData?.type === "file_search_call" || item.providerData?.type === "file_search") {
        const entry = {
          ...camelOrSnakeToSnakeCase(item.providerData),
          type: "file_search_call",
          id: item.id,
          status: FileSearchStatus.parse(item.status ?? "failed"),
          queries: item.providerData?.queries ?? [],
          results: item.providerData?.results
        };
        return entry;
      }
      if (item.providerData?.type === "code_interpreter_call" || item.providerData?.type === "code_interpreter") {
        const entry = {
          ...camelOrSnakeToSnakeCase(item.providerData),
          type: "code_interpreter_call",
          id: item.id,
          code: item.providerData?.code ?? "",
          outputs: item.providerData?.outputs ?? item.providerData?.results ?? [],
          status: CodeInterpreterStatus.parse(item.status ?? "failed"),
          container_id: item.providerData?.container_id
        };
        return entry;
      }
      if (item.providerData?.type === "image_generation_call" || item.providerData?.type === "image_generation") {
        const entry = {
          ...camelOrSnakeToSnakeCase(item.providerData),
          type: "image_generation_call",
          id: item.id,
          result: item.providerData?.result ?? null,
          status: ImageGenerationStatus.parse(item.status ?? "failed")
        };
        return entry;
      }
      if (item.providerData?.type === "mcp_list_tools" || item.name === "mcp_list_tools") {
        const providerData = item.providerData;
        const entry = {
          ...camelOrSnakeToSnakeCase(item.providerData),
          type: "mcp_list_tools",
          id: item.id,
          tools: camelOrSnakeToSnakeCase(providerData.tools),
          server_label: providerData.server_label,
          error: providerData.error
        };
        return entry;
      } else if (item.providerData?.type === "mcp_approval_request" || item.name === "mcp_approval_request") {
        const providerData = item.providerData;
        const entry = {
          ...camelOrSnakeToSnakeCase(item.providerData),
          type: "mcp_approval_request",
          id: providerData.id ?? item.id,
          name: providerData.name,
          arguments: providerData.arguments,
          server_label: providerData.server_label
        };
        return entry;
      } else if (item.providerData?.type === "mcp_approval_response" || item.name === "mcp_approval_response") {
        const providerData = item.providerData;
        const entry = {
          ...camelOrSnakeToSnakeCase(providerData),
          type: "mcp_approval_response",
          id: providerData.id,
          approve: providerData.approve,
          approval_request_id: providerData.approval_request_id,
          reason: providerData.reason
        };
        return entry;
      } else if (item.providerData?.type === "mcp_call" || item.name === "mcp_call") {
        const providerData = item.providerData;
        const entry = {
          ...camelOrSnakeToSnakeCase(providerData),
          type: "mcp_call",
          id: providerData.id ?? item.id,
          name: providerData.name,
          arguments: providerData.arguments,
          server_label: providerData.server_label,
          error: providerData.error
        };
        return entry;
      }
      throw new UserError(`Unsupported built-in tool call type: ${JSON.stringify(item)}`);
    }
    if (item.type === "unknown") {
      return {
        ...camelOrSnakeToSnakeCase(item.providerData),
        id: item.id
      };
    }
    const exhaustive = item;
    throw new UserError(`Unsupported item ${JSON.stringify(exhaustive)}`);
  });
}
function buildResponseOutput(item) {
  return {
    type: "computer_screenshot",
    image_url: item.output.data
  };
}
function convertToMessageContentItem(item) {
  if (item.type === "output_text") {
    const { type, text, ...remainingItem } = item;
    return {
      type,
      text,
      ...remainingItem
    };
  }
  if (item.type === "refusal") {
    const { type, refusal, ...remainingItem } = item;
    return {
      type,
      refusal,
      ...remainingItem
    };
  }
  throw new Error(`Unsupported message content type: ${JSON.stringify(item)}`);
}
function convertToOutputItem(items) {
  return items.map((item) => {
    if (item.type === "message") {
      const { id, type, role, content, status, ...providerData } = item;
      return {
        id,
        type,
        role,
        content: content.map(convertToMessageContentItem),
        status,
        providerData
      };
    } else if (item.type === "file_search_call" || item.type === "web_search_call" || item.type === "image_generation_call" || item.type === "code_interpreter_call") {
      const { status, ...remainingItem } = item;
      let outputData = undefined;
      if ("result" in remainingItem && remainingItem.result !== null) {
        outputData = remainingItem.result;
        delete remainingItem.result;
      }
      const output = {
        type: "hosted_tool_call",
        id: item.id,
        name: item.type,
        status,
        output: outputData,
        providerData: remainingItem
      };
      return output;
    } else if (item.type === "function_call") {
      const { call_id, name, status, arguments: args, ...providerData } = item;
      const output = {
        type: "function_call",
        id: item.id,
        callId: call_id,
        name,
        status,
        arguments: args,
        providerData
      };
      return output;
    } else if (item.type === "function_call_output") {
      const { call_id, status, output: rawOutput, name: toolName, function_name: functionName, ...providerData } = item;
      const output = {
        type: "function_call_result",
        id: item.id,
        callId: call_id,
        name: toolName ?? functionName ?? call_id,
        status: status ?? "completed",
        output: convertFunctionCallOutputToProtocol(rawOutput),
        providerData
      };
      return output;
    } else if (item.type === "computer_call") {
      const { call_id, status, action, ...providerData } = item;
      const output = {
        type: "computer_call",
        id: item.id,
        callId: call_id,
        status,
        action,
        providerData
      };
      return output;
    } else if (item.type === "shell_call") {
      const { call_id, status, action, ...providerData } = item;
      const shellAction = {
        commands: Array.isArray(action?.commands) ? action.commands : []
      };
      const timeout = action?.timeout_ms;
      if (typeof timeout === "number") {
        shellAction.timeoutMs = timeout;
      }
      const maxOutputLength = action?.max_output_length;
      if (typeof maxOutputLength === "number") {
        shellAction.maxOutputLength = maxOutputLength;
      }
      const output = {
        type: "shell_call",
        id: item.id ?? undefined,
        callId: call_id,
        status: status ?? "in_progress",
        action: shellAction,
        providerData
      };
      return output;
    } else if (item.type === "shell_call_output") {
      const { call_id, output: responseOutput, max_output_length, ...providerData } = item;
      let normalizedOutput = [];
      if (Array.isArray(responseOutput)) {
        normalizedOutput = responseOutput.map((entry) => ({
          stdout: typeof entry?.stdout === "string" ? entry.stdout : "",
          stderr: typeof entry?.stderr === "string" ? entry.stderr : "",
          outcome: entry?.outcome?.type === "timeout" ? { type: "timeout" } : {
            type: "exit",
            exitCode: typeof entry?.outcome?.exit_code === "number" ? entry.outcome.exit_code : null
          }
        }));
      }
      const output = {
        type: "shell_call_output",
        id: item.id ?? undefined,
        callId: call_id,
        output: normalizedOutput,
        providerData
      };
      if (typeof max_output_length === "number") {
        output.maxOutputLength = max_output_length;
      }
      return output;
    } else if (item.type === "apply_patch_call") {
      const { call_id, status, operation, ...providerData } = item;
      if (!operation) {
        throw new UserError("apply_patch_call missing operation");
      }
      let normalizedOperation;
      switch (operation.type) {
        case "create_file":
          normalizedOperation = {
            type: "create_file",
            path: operation.path,
            diff: operation.diff
          };
          break;
        case "delete_file":
          normalizedOperation = {
            type: "delete_file",
            path: operation.path
          };
          break;
        case "update_file":
          normalizedOperation = {
            type: "update_file",
            path: operation.path,
            diff: operation.diff
          };
          break;
        default:
          throw new UserError("Unknown apply_patch operation type");
      }
      const output = {
        type: "apply_patch_call",
        id: item.id ?? undefined,
        callId: call_id,
        status: status ?? "in_progress",
        operation: normalizedOperation,
        providerData
      };
      return output;
    } else if (item.type === "apply_patch_call_output") {
      const { call_id, status, output: responseOutput, ...providerData } = item;
      const output = {
        type: "apply_patch_call_output",
        id: item.id ?? undefined,
        callId: call_id,
        status,
        output: typeof responseOutput === "string" ? responseOutput : undefined,
        providerData
      };
      return output;
    } else if (item.type === "mcp_list_tools") {
      const { ...providerData } = item;
      const output = {
        type: "hosted_tool_call",
        id: item.id,
        name: item.type,
        status: "completed",
        output: undefined,
        providerData
      };
      return output;
    } else if (item.type === "mcp_approval_request") {
      const { ...providerData } = item;
      const output = {
        type: "hosted_tool_call",
        id: item.id,
        name: "mcp_approval_request",
        status: "completed",
        output: undefined,
        providerData
      };
      return output;
    } else if (item.type === "mcp_call") {
      const { output: outputData, ...providerData } = item;
      const output = {
        type: "hosted_tool_call",
        id: item.id,
        name: item.type,
        status: "completed",
        output: outputData || undefined,
        providerData
      };
      return output;
    } else if (item.type === "reasoning") {
      const { summary, ...providerData } = item;
      const output = {
        type: "reasoning",
        id: item.id,
        content: summary.map((content) => {
          const { text, ...remainingContent } = content;
          return {
            type: "input_text",
            text,
            providerData: remainingContent
          };
        }),
        providerData
      };
      return output;
    }
    return {
      type: "unknown",
      id: item.id,
      providerData: item
    };
  });
}
class OpenAIResponsesModel {
  #client;
  #model;
  constructor(client2, model) {
    this.#client = client2;
    this.#model = model;
  }
  async#fetchResponse(request, stream) {
    const input = getInputItems(request.input);
    const { tools, include } = getTools(request.tools, request.handoffs);
    const toolChoice = getToolChoice(request.modelSettings.toolChoice);
    const { text, ...restOfProviderData } = request.modelSettings.providerData ?? {};
    if (request.modelSettings.reasoning) {
      restOfProviderData.reasoning = {
        ...request.modelSettings.reasoning,
        ...restOfProviderData.reasoning
      };
    }
    let mergedText = text;
    if (request.modelSettings.text) {
      mergedText = { ...request.modelSettings.text, ...text };
    }
    const responseFormat = getResponseFormat(request.outputType, mergedText);
    const prompt = getPrompt(request.prompt);
    let parallelToolCalls = undefined;
    if (typeof request.modelSettings.parallelToolCalls === "boolean") {
      if (request.modelSettings.parallelToolCalls && tools.length === 0) {
        throw new Error("Parallel tool calls are not supported without tools");
      }
      parallelToolCalls = request.modelSettings.parallelToolCalls;
    }
    const shouldSendModel = !request.prompt || request.overridePromptModel === true;
    const shouldSendTools = tools.length > 0 || request.toolsExplicitlyProvided === true || !request.prompt;
    const requestData = {
      ...shouldSendModel ? { model: this.#model } : {},
      instructions: normalizeInstructions(request.systemInstructions),
      input,
      include,
      ...shouldSendTools ? { tools } : {},
      previous_response_id: request.previousResponseId,
      conversation: request.conversationId,
      prompt,
      temperature: request.modelSettings.temperature,
      top_p: request.modelSettings.topP,
      truncation: request.modelSettings.truncation,
      max_output_tokens: request.modelSettings.maxTokens,
      tool_choice: toolChoice,
      parallel_tool_calls: parallelToolCalls,
      stream,
      text: responseFormat,
      store: request.modelSettings.store,
      prompt_cache_retention: request.modelSettings.promptCacheRetention,
      ...restOfProviderData
    };
    if (logger_default2.dontLogModelData) {
      logger_default2.debug("Calling LLM");
    } else {
      logger_default2.debug(`Calling LLM. Request data: ${JSON.stringify(requestData, null, 2)}`);
    }
    const response = await this.#client.responses.create(requestData, {
      headers: HEADERS,
      signal: request.signal
    });
    if (logger_default2.dontLogModelData) {
      logger_default2.debug("Response received");
    } else {
      logger_default2.debug(`Response received: ${JSON.stringify(response, null, 2)}`);
    }
    return response;
  }
  async getResponse(request) {
    const response = await withResponseSpan(async (span) => {
      const response2 = await this.#fetchResponse(request, false);
      if (request.tracing) {
        span.spanData.response_id = response2.id;
        span.spanData._input = request.input;
        span.spanData._response = response2;
      }
      return response2;
    });
    const output = {
      usage: new Usage({
        inputTokens: response.usage?.input_tokens ?? 0,
        outputTokens: response.usage?.output_tokens ?? 0,
        totalTokens: response.usage?.total_tokens ?? 0,
        inputTokensDetails: { ...response.usage?.input_tokens_details },
        outputTokensDetails: { ...response.usage?.output_tokens_details }
      }),
      output: convertToOutputItem(response.output),
      responseId: response.id,
      providerData: response
    };
    return output;
  }
  async* getStreamedResponse(request) {
    const span = request.tracing ? createResponseSpan() : undefined;
    try {
      if (span) {
        span.start();
        setCurrentSpan(span);
        if (request.tracing === true) {
          span.spanData._input = request.input;
        }
      }
      const response = await this.#fetchResponse(request, true);
      let finalResponse;
      for await (const event of response) {
        if (event.type === "response.created") {
          yield {
            type: "response_started",
            providerData: {
              ...event
            }
          };
        } else if (event.type === "response.completed") {
          finalResponse = event.response;
          const { response: response2, ...remainingEvent } = event;
          const { output, usage, id, ...remainingResponse } = response2;
          yield {
            type: "response_done",
            response: {
              id,
              output: convertToOutputItem(output),
              usage: {
                inputTokens: usage?.input_tokens ?? 0,
                outputTokens: usage?.output_tokens ?? 0,
                totalTokens: usage?.total_tokens ?? 0,
                inputTokensDetails: {
                  ...usage?.input_tokens_details
                },
                outputTokensDetails: {
                  ...usage?.output_tokens_details
                }
              },
              providerData: remainingResponse
            },
            providerData: remainingEvent
          };
          yield {
            type: "model",
            event
          };
        } else if (event.type === "response.output_text.delta") {
          const { delta, ...remainingEvent } = event;
          yield {
            type: "output_text_delta",
            delta,
            providerData: remainingEvent
          };
        }
        yield {
          type: "model",
          event
        };
      }
      if (request.tracing && span && finalResponse) {
        span.spanData.response_id = finalResponse.id;
        span.spanData._response = finalResponse;
      }
    } catch (error47) {
      if (span) {
        span.setError({
          message: "Error streaming response",
          data: {
            error: request.tracing ? String(error47) : error47 instanceof Error ? error47.name : undefined
          }
        });
      }
      throw error47;
    } finally {
      if (span) {
        span.end();
        resetCurrentSpan();
      }
    }
  }
}
function normalizeInstructions(instructions) {
  if (typeof instructions === "string") {
    if (instructions.trim() === "") {
      return;
    }
    return instructions;
  }
  return;
}

// node_modules/@openai/agents-openai/dist/openaiChatCompletionsStreaming.mjs
async function* convertChatCompletionsStreamToResponses(response, stream) {
  let usage = undefined;
  const state = {
    started: false,
    text_content_index_and_output: null,
    refusal_content_index_and_output: null,
    function_calls: {},
    reasoning: ""
  };
  for await (const chunk of stream) {
    if (!state.started) {
      state.started = true;
      yield {
        type: "response_started",
        providerData: {
          ...chunk
        }
      };
    }
    yield {
      type: "model",
      event: chunk
    };
    usage = chunk.usage || undefined;
    if (!chunk.choices?.[0]?.delta)
      continue;
    const delta = chunk.choices[0].delta;
    if (delta.content) {
      if (!state.text_content_index_and_output) {
        state.text_content_index_and_output = [
          !state.refusal_content_index_and_output ? 0 : 1,
          { text: "", type: "output_text", providerData: { annotations: [] } }
        ];
      }
      yield {
        type: "output_text_delta",
        delta: delta.content,
        providerData: {
          ...chunk
        }
      };
      state.text_content_index_and_output[1].text += delta.content;
    }
    if ("reasoning" in delta && delta.reasoning && typeof delta.reasoning === "string") {
      state.reasoning += delta.reasoning;
    }
    if ("refusal" in delta && delta.refusal) {
      if (!state.refusal_content_index_and_output) {
        state.refusal_content_index_and_output = [
          !state.text_content_index_and_output ? 0 : 1,
          { refusal: "", type: "refusal" }
        ];
      }
      state.refusal_content_index_and_output[1].refusal += delta.refusal;
    }
    if (delta.tool_calls) {
      for (const tc_delta of delta.tool_calls) {
        if (!(tc_delta.index in state.function_calls)) {
          state.function_calls[tc_delta.index] = {
            id: FAKE_ID,
            arguments: "",
            name: "",
            type: "function_call",
            callId: ""
          };
        }
        const tc_function = tc_delta.function;
        state.function_calls[tc_delta.index].arguments += tc_function?.arguments || "";
        state.function_calls[tc_delta.index].name += tc_function?.name || "";
        state.function_calls[tc_delta.index].callId += tc_delta.id || "";
      }
    }
  }
  const outputs = [];
  if (state.reasoning) {
    outputs.push({
      type: "reasoning",
      content: [],
      rawContent: [{ type: "reasoning_text", text: state.reasoning }]
    });
  }
  if (state.text_content_index_and_output || state.refusal_content_index_and_output) {
    const assistant_msg = {
      id: FAKE_ID,
      content: [],
      role: "assistant",
      type: "message",
      status: "completed"
    };
    if (state.text_content_index_and_output) {
      assistant_msg.content.push(state.text_content_index_and_output[1]);
    }
    if (state.refusal_content_index_and_output) {
      assistant_msg.content.push(state.refusal_content_index_and_output[1]);
    }
    outputs.push(assistant_msg);
  }
  for (const function_call of Object.values(state.function_calls)) {
    if (function_call.arguments.startsWith("{}{")) {
      function_call.arguments = function_call.arguments.slice(2);
    }
    outputs.push(function_call);
  }
  const finalEvent = {
    type: "response_done",
    response: {
      id: response.id,
      usage: {
        inputTokens: usage?.prompt_tokens ?? 0,
        outputTokens: usage?.completion_tokens ?? 0,
        totalTokens: usage?.total_tokens ?? 0,
        inputTokensDetails: {
          cached_tokens: usage?.prompt_tokens_details?.cached_tokens ?? 0
        },
        outputTokensDetails: {
          reasoning_tokens: usage?.completion_tokens_details?.reasoning_tokens ?? 0
        }
      },
      output: outputs
    }
  };
  yield finalEvent;
}

// node_modules/@openai/agents-openai/dist/openaiChatCompletionsConverter.mjs
function convertToolChoice(toolChoice) {
  if (toolChoice == undefined || toolChoice == null)
    return;
  if (toolChoice === "auto" || toolChoice === "required" || toolChoice === "none")
    return toolChoice;
  return {
    type: "function",
    function: { name: toolChoice }
  };
}
function extractAllAssistantContent(content) {
  if (typeof content === "string") {
    return content;
  }
  const out = [];
  for (const c of content) {
    if (c.type === "output_text") {
      out.push({
        type: "text",
        text: c.text,
        ...c.providerData
      });
    } else if (c.type === "refusal") {
      out.push({
        type: "refusal",
        refusal: c.refusal,
        ...c.providerData
      });
    } else if (c.type === "audio" || c.type === "image") {
      continue;
    } else {
      const exhaustive = c;
      throw new Error(`Unknown content: ${JSON.stringify(exhaustive)}`);
    }
  }
  return out;
}
function extractAllUserContent(content) {
  if (typeof content === "string") {
    return content;
  }
  const out = [];
  for (const c of content) {
    if (c.type === "input_text") {
      out.push({ type: "text", text: c.text, ...c.providerData });
    } else if (c.type === "input_image") {
      const imageSource = typeof c.image === "string" ? c.image : typeof c.imageUrl === "string" ? c.imageUrl : undefined;
      if (!imageSource) {
        throw new Error(`Only image URLs are supported for input_image: ${JSON.stringify(c)}`);
      }
      const { image_url, ...rest } = c.providerData || {};
      out.push({
        type: "image_url",
        image_url: {
          url: imageSource,
          ...image_url
        },
        ...rest
      });
    } else if (c.type === "input_file") {
      throw new Error(`File uploads are not supported for chat completions: ${JSON.stringify(c)}`);
    } else if (c.type === "audio") {
      const { input_audio, ...rest } = c.providerData || {};
      out.push({
        type: "input_audio",
        input_audio: {
          data: c.audio,
          ...input_audio
        },
        ...rest
      });
    } else {
      const exhaustive = c;
      throw new Error(`Unknown content: ${JSON.stringify(exhaustive)}`);
    }
  }
  return out;
}
function isMessageItem2(item) {
  if (item.type === "message") {
    return true;
  }
  if (typeof item.type === "undefined" && typeof item.role === "string") {
    return true;
  }
  return false;
}
function itemsToMessages(items) {
  if (typeof items === "string") {
    return [{ role: "user", content: items }];
  }
  const result = [];
  let currentAssistantMsg = null;
  const flushAssistantMessage = () => {
    if (currentAssistantMsg) {
      if (!currentAssistantMsg.tool_calls || currentAssistantMsg.tool_calls.length === 0) {
        delete currentAssistantMsg.tool_calls;
      }
      result.push(currentAssistantMsg);
      currentAssistantMsg = null;
    }
  };
  const ensureAssistantMessage = () => {
    if (!currentAssistantMsg) {
      currentAssistantMsg = { role: "assistant", tool_calls: [] };
    }
    return currentAssistantMsg;
  };
  for (const item of items) {
    if (isMessageItem2(item)) {
      const { content, role, providerData } = item;
      flushAssistantMessage();
      if (role === "assistant") {
        const assistant2 = {
          role: "assistant",
          content: extractAllAssistantContent(content),
          ...providerData
        };
        if (Array.isArray(content)) {
          const audio = content.find((c) => c.type === "audio");
          if (audio) {
            assistant2.audio = {
              id: "",
              ...audio.providerData
            };
          }
        }
        result.push(assistant2);
      } else if (role === "user") {
        result.push({
          role,
          content: extractAllUserContent(content),
          ...providerData
        });
      } else if (role === "system") {
        result.push({
          role: "system",
          content,
          ...providerData
        });
      }
    } else if (item.type === "reasoning") {
      const asst = ensureAssistantMessage();
      asst.reasoning = item.rawContent?.[0]?.text;
      continue;
    } else if (item.type === "hosted_tool_call") {
      if (item.name === "file_search_call") {
        const asst = ensureAssistantMessage();
        const toolCalls = asst.tool_calls ?? [];
        const fileSearch = item;
        const { function: functionData, ...rest } = fileSearch.providerData ?? {};
        const { arguments: argumentData, ...remainingFunctionData } = functionData ?? {};
        toolCalls.push({
          id: fileSearch.id || "",
          type: "function",
          function: {
            name: "file_search_call",
            arguments: JSON.stringify({
              queries: fileSearch.providerData?.queries ?? [],
              status: fileSearch.status,
              ...argumentData
            }),
            ...remainingFunctionData
          },
          ...rest
        });
        asst.tool_calls = toolCalls;
        continue;
      } else {
        throw new UserError("Hosted tool calls are not supported for chat completions. Got item: " + JSON.stringify(item));
      }
    } else if (item.type === "computer_call" || item.type === "computer_call_result" || item.type === "shell_call" || item.type === "shell_call_output" || item.type === "apply_patch_call" || item.type === "apply_patch_call_output") {
      throw new UserError("Computer use calls are not supported for chat completions. Got item: " + JSON.stringify(item));
    } else if (item.type === "function_call") {
      const asst = ensureAssistantMessage();
      const toolCalls = asst.tool_calls ?? [];
      const funcCall = item;
      toolCalls.push({
        id: funcCall.callId,
        type: "function",
        function: {
          name: funcCall.name,
          arguments: funcCall.arguments ?? "{}"
        }
      });
      asst.tool_calls = toolCalls;
    } else if (item.type === "function_call_result") {
      flushAssistantMessage();
      const funcOutput = item;
      const toolContent = normalizeFunctionCallOutputForChat(funcOutput.output);
      result.push({
        role: "tool",
        tool_call_id: funcOutput.callId,
        content: toolContent,
        ...funcOutput.providerData
      });
    } else if (item.type === "unknown") {
      result.push({
        ...item.providerData
      });
    } else {
      const exhaustive = item;
      throw new Error(`Unknown item type: ${JSON.stringify(exhaustive)}`);
    }
  }
  flushAssistantMessage();
  return result;
}
function normalizeFunctionCallOutputForChat(output) {
  if (typeof output === "string") {
    return output;
  }
  if (Array.isArray(output)) {
    const textOnly = output.every((item) => item.type === "input_text");
    if (!textOnly) {
      throw new UserError("Only text tool outputs are supported for chat completions.");
    }
    return output.map((item) => item.text).join("");
  }
  if (isRecord3(output) && output.type === "text" && typeof output.text === "string") {
    return output.text;
  }
  throw new UserError("Only text tool outputs are supported for chat completions. Got item: " + JSON.stringify(output));
}
function isRecord3(value) {
  return typeof value === "object" && value !== null;
}
function toolToOpenAI(tool2) {
  if (tool2.type === "function") {
    return {
      type: "function",
      function: {
        name: tool2.name,
        description: tool2.description || "",
        parameters: tool2.parameters,
        strict: tool2.strict
      }
    };
  }
  throw new Error(`Hosted tools are not supported with the ChatCompletions API. Got tool type: ${tool2.type}, tool: ${JSON.stringify(tool2)}`);
}
function convertHandoffTool(handoff2) {
  return {
    type: "function",
    function: {
      name: handoff2.toolName,
      description: handoff2.toolDescription || "",
      parameters: handoff2.inputJsonSchema
    }
  };
}

// node_modules/@openai/agents-openai/dist/openaiChatCompletionsModel.mjs
var FAKE_ID = "FAKE_ID";
function hasReasoningContent(message) {
  return "reasoning" in message && typeof message.reasoning === "string" && message.reasoning !== "";
}

class OpenAIChatCompletionsModel {
  #client;
  #model;
  constructor(client2, model) {
    this.#client = client2;
    this.#model = model;
  }
  async getResponse(request) {
    const response = await withGenerationSpan(async (span) => {
      span.spanData.model = this.#model;
      span.spanData.model_config = request.modelSettings ? {
        temperature: request.modelSettings.temperature,
        top_p: request.modelSettings.topP,
        frequency_penalty: request.modelSettings.frequencyPenalty,
        presence_penalty: request.modelSettings.presencePenalty,
        reasoning_effort: request.modelSettings.reasoning?.effort,
        verbosity: request.modelSettings.text?.verbosity
      } : { base_url: this.#client.baseURL };
      const response2 = await this.#fetchResponse(request, span, false);
      if (span && request.tracing === true) {
        span.spanData.output = [response2];
      }
      return response2;
    });
    const output = [];
    if (response.choices && response.choices[0]) {
      const message = response.choices[0].message;
      if (hasReasoningContent(message)) {
        output.push({
          type: "reasoning",
          content: [],
          rawContent: [
            {
              type: "reasoning_text",
              text: message.reasoning
            }
          ]
        });
      }
      if (message.content !== undefined && message.content !== null && !(message.tool_calls && message.content === "")) {
        const { content, ...rest } = message;
        output.push({
          id: response.id,
          type: "message",
          role: "assistant",
          content: [
            {
              type: "output_text",
              text: content || "",
              providerData: rest
            }
          ],
          status: "completed"
        });
      } else if (message.refusal) {
        const { refusal, ...rest } = message;
        output.push({
          id: response.id,
          type: "message",
          role: "assistant",
          content: [
            {
              type: "refusal",
              refusal: refusal || "",
              providerData: rest
            }
          ],
          status: "completed"
        });
      } else if (message.audio) {
        const { data, ...remainingAudioData } = message.audio;
        output.push({
          id: response.id,
          type: "message",
          role: "assistant",
          content: [
            {
              type: "audio",
              audio: data,
              providerData: remainingAudioData
            }
          ],
          status: "completed"
        });
      } else if (message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            const { id: callId, ...remainingToolCallData } = tool_call;
            const { arguments: args, name, ...remainingFunctionData } = tool_call.function;
            output.push({
              id: response.id,
              type: "function_call",
              arguments: args,
              name,
              callId,
              status: "completed",
              providerData: {
                ...remainingToolCallData,
                ...remainingFunctionData
              }
            });
          }
        }
      }
    }
    const modelResponse = {
      usage: response.usage ? new Usage(toResponseUsage(response.usage)) : new Usage,
      output,
      responseId: response.id,
      providerData: response
    };
    return modelResponse;
  }
  async* getStreamedResponse(request) {
    const span = request.tracing ? createGenerationSpan() : undefined;
    try {
      if (span) {
        span.start();
        setCurrentSpan(span);
      }
      const stream = await this.#fetchResponse(request, span, true);
      const response = {
        id: FAKE_ID,
        created: Math.floor(Date.now() / 1000),
        model: this.#model,
        object: "chat.completion",
        choices: [],
        usage: {
          prompt_tokens: 0,
          completion_tokens: 0,
          total_tokens: 0
        }
      };
      for await (const event of convertChatCompletionsStreamToResponses(response, stream)) {
        if (event.type === "response_done" && response.usage?.total_tokens === 0) {
          response.usage = {
            prompt_tokens: event.response.usage.inputTokens,
            completion_tokens: event.response.usage.outputTokens,
            total_tokens: event.response.usage.totalTokens,
            prompt_tokens_details: Array.isArray(event.response.usage.inputTokensDetails) ? event.response.usage.inputTokensDetails[0] : event.response.usage.inputTokensDetails,
            completion_tokens_details: Array.isArray(event.response.usage.outputTokensDetails) ? event.response.usage.outputTokensDetails[0] : event.response.usage.outputTokensDetails
          };
        }
        yield event;
      }
      if (span && response && request.tracing === true) {
        span.spanData.output = [response];
      }
    } catch (error47) {
      if (span) {
        span.setError({
          message: "Error streaming response",
          data: {
            error: request.tracing === true ? String(error47) : error47 instanceof Error ? error47.name : undefined
          }
        });
      }
      throw error47;
    } finally {
      if (span) {
        span.end();
        resetCurrentSpan();
      }
    }
  }
  async#fetchResponse(request, span, stream) {
    const tools = [];
    if (request.tools) {
      for (const tool2 of request.tools) {
        tools.push(toolToOpenAI(tool2));
      }
    }
    if (request.handoffs) {
      for (const handoff2 of request.handoffs) {
        tools.push(convertHandoffTool(handoff2));
      }
    }
    const responseFormat = getResponseFormat2(request.outputType);
    let parallelToolCalls = undefined;
    if (typeof request.modelSettings.parallelToolCalls === "boolean") {
      if (request.modelSettings.parallelToolCalls && tools.length === 0) {
        throw new Error("Parallel tool calls are not supported without tools");
      }
      parallelToolCalls = request.modelSettings.parallelToolCalls;
    }
    const messages = itemsToMessages(request.input);
    if (request.systemInstructions) {
      messages.unshift({
        content: request.systemInstructions,
        role: "system"
      });
    }
    if (span && request.tracing === true) {
      span.spanData.input = messages;
    }
    const providerData = request.modelSettings.providerData ?? {};
    if (request.modelSettings.reasoning && request.modelSettings.reasoning.effort) {
      providerData.reasoning_effort = request.modelSettings.reasoning.effort;
    }
    if (request.modelSettings.text && request.modelSettings.text.verbosity) {
      providerData.verbosity = request.modelSettings.text.verbosity;
    }
    const requestData = {
      model: this.#model,
      messages,
      tools: tools.length ? tools : undefined,
      temperature: request.modelSettings.temperature,
      top_p: request.modelSettings.topP,
      frequency_penalty: request.modelSettings.frequencyPenalty,
      presence_penalty: request.modelSettings.presencePenalty,
      max_tokens: request.modelSettings.maxTokens,
      tool_choice: convertToolChoice(request.modelSettings.toolChoice),
      response_format: responseFormat,
      parallel_tool_calls: parallelToolCalls,
      stream,
      store: request.modelSettings.store,
      prompt_cache_retention: request.modelSettings.promptCacheRetention,
      ...providerData
    };
    if (logger_default2.dontLogModelData) {
      logger_default2.debug("Calling LLM");
    } else {
      logger_default2.debug(`Calling LLM. Request data: ${JSON.stringify(requestData, null, 2)}`);
    }
    const completion = await this.#client.chat.completions.create(requestData, {
      headers: HEADERS,
      signal: request.signal
    });
    if (logger_default2.dontLogModelData) {
      logger_default2.debug("Response received");
    } else {
      logger_default2.debug(`Response received: ${JSON.stringify(completion, null, 2)}`);
    }
    return completion;
  }
}
function getResponseFormat2(outputType) {
  if (outputType === "text") {
    return { type: "text" };
  }
  if (outputType.type === "json_schema") {
    return {
      type: "json_schema",
      json_schema: {
        name: outputType.name,
        strict: outputType.strict,
        schema: outputType.schema
      }
    };
  }
  return { type: "json_object" };
}
function toResponseUsage(usage) {
  return {
    requests: 1,
    input_tokens: usage.prompt_tokens,
    output_tokens: usage.completion_tokens,
    total_tokens: usage.total_tokens,
    input_tokens_details: {
      cached_tokens: usage.prompt_tokens_details?.cached_tokens || 0
    },
    output_tokens_details: {
      reasoning_tokens: usage.completion_tokens_details?.reasoning_tokens || 0
    }
  };
}

// node_modules/@openai/agents-openai/dist/openaiProvider.mjs
class OpenAIProvider {
  #client;
  #useResponses;
  #options;
  constructor(options = {}) {
    this.#options = options;
    if (this.#options.openAIClient) {
      if (this.#options.apiKey) {
        throw new Error("Cannot provide both apiKey and openAIClient");
      }
      if (this.#options.baseURL) {
        throw new Error("Cannot provide both baseURL and openAIClient");
      }
      this.#client = this.#options.openAIClient;
    }
    this.#useResponses = this.#options.useResponses;
  }
  #getClient() {
    if (!this.#client) {
      this.#client = getDefaultOpenAIClient() ?? new OpenAI({
        apiKey: this.#options.apiKey ?? getDefaultOpenAIKey(),
        baseURL: this.#options.baseURL,
        organization: this.#options.organization,
        project: this.#options.project
      });
    }
    return this.#client;
  }
  async getModel(modelName) {
    const model = modelName || getDefaultModel();
    const useResponses = this.#useResponses ?? shouldUseResponsesByDefault();
    if (useResponses) {
      return new OpenAIResponsesModel(this.#getClient(), model);
    }
    return new OpenAIChatCompletionsModel(this.#getClient(), model);
  }
}
// node_modules/@openai/agents-openai/dist/openaiTracingExporter.mjs
class OpenAITracingExporter {
  #options;
  constructor(options = {}) {
    this.#options = {
      apiKey: options.apiKey ?? undefined,
      organization: options.organization ?? "",
      project: options.project ?? "",
      endpoint: options.endpoint ?? "https://api.openai.com/v1/traces/ingest",
      maxRetries: options.maxRetries ?? 3,
      baseDelay: options.baseDelay ?? 1000,
      maxDelay: options.maxDelay ?? 30000
    };
  }
  async export(items, signal) {
    const apiKey = this.#options.apiKey ?? getTracingExportApiKey();
    if (!apiKey) {
      logger_default2.error("No API key provided for OpenAI tracing exporter. Exports will be skipped");
      return;
    }
    const payload = {
      data: items.map((items2) => items2.toJSON()).filter((item) => !!item)
    };
    let attempts = 0;
    let delay = this.#options.baseDelay;
    while (attempts < this.#options.maxRetries) {
      try {
        const response = await fetch(this.#options.endpoint, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${apiKey}`,
            "OpenAI-Beta": "traces=v1",
            ...HEADERS
          },
          body: JSON.stringify(payload),
          signal
        });
        if (response.ok) {
          logger_default2.debug(`Exported ${payload.data.length} items`);
          return;
        }
        if (response.status >= 400 && response.status < 500) {
          logger_default2.error(`[non-fatal] Tracing client error ${response.status}: ${await response.text()}`);
          return;
        }
        logger_default2.warn(`[non-fatal] Tracing: server error ${response.status}, retrying.`);
      } catch (error47) {
        logger_default2.error("[non-fatal] Tracing: request failed: ", error47);
      }
      if (signal?.aborted) {
        logger_default2.error("Tracing: request aborted");
        return;
      }
      const sleepTime = delay + Math.random() * 0.1 * delay;
      await new Promise((resolve) => setTimeout(resolve, sleepTime));
      delay = Math.min(delay * 2, this.#options.maxDelay);
      attempts++;
    }
    logger_default2.error(`Tracing: failed to export traces after ${this.#options.maxRetries} attempts`);
  }
}
function setDefaultOpenAITracingExporter() {
  const exporter = new OpenAITracingExporter;
  const processor = new BatchTraceProcessor(exporter);
  setTraceProcessors([processor]);
}
// node_modules/@openai/agents-openai/dist/memory/openaiConversationsSession.mjs
async function startOpenAIConversationsSession(client2) {
  const resolvedClient = client2 ?? resolveClient({});
  const response = await resolvedClient.conversations.create({ items: [] });
  return response.id;
}

class OpenAIConversationsSession {
  #client;
  #conversationId;
  constructor(options = {}) {
    this.#client = resolveClient(options);
    this.#conversationId = options.conversationId;
  }
  get sessionId() {
    return this.#conversationId;
  }
  async getSessionId() {
    if (!this.#conversationId) {
      this.#conversationId = await startOpenAIConversationsSession(this.#client);
    }
    return this.#conversationId;
  }
  async getItems(limit2) {
    const conversationId = await this.getSessionId();
    const toAgentItems = (item) => {
      if (item.type === "message" && item.role === "user") {
        const message = item;
        return [
          {
            id: item.id,
            type: "message",
            role: "user",
            content: (message.content ?? []).map((c) => {
              if (c.type === "input_text") {
                return { type: "input_text", text: c.text };
              } else if (c.type === "input_image") {
                if (c.image_url) {
                  return { type: "input_image", image: c.image_url };
                } else if (c.file_id) {
                  return { type: "input_image", image: { id: c.file_id } };
                }
              } else if (c.type === "input_file") {
                if (c.file_data) {
                  const fileItem = {
                    type: "input_file",
                    file: c.file_data
                  };
                  if (c.filename) {
                    fileItem.filename = c.filename;
                  }
                  return fileItem;
                }
                if (c.file_url) {
                  const fileItem = {
                    type: "input_file",
                    file: c.file_url
                  };
                  if (c.filename) {
                    fileItem.filename = c.filename;
                  }
                  return fileItem;
                } else if (c.file_id) {
                  const fileItem = {
                    type: "input_file",
                    file: { id: c.file_id }
                  };
                  if (c.filename) {
                    fileItem.filename = c.filename;
                  }
                  return fileItem;
                }
              }
              return null;
            }).filter((c) => c !== null)
          }
        ];
      }
      const outputItems = item.output;
      if (isResponseOutputItemArray(outputItems)) {
        return convertToOutputItem(outputItems);
      }
      return convertToOutputItem([item]);
    };
    if (limit2 === undefined) {
      const items = [];
      const iterator2 = this.#client.conversations.items.list(conversationId, {
        order: "asc"
      });
      for await (const item of iterator2) {
        items.push(...toAgentItems(item));
      }
      return items;
    }
    if (limit2 <= 0) {
      return [];
    }
    const itemGroups = [];
    let total = 0;
    const iterator = this.#client.conversations.items.list(conversationId, {
      limit: limit2,
      order: "desc"
    });
    for await (const item of iterator) {
      const group = toAgentItems(item);
      if (!group.length) {
        continue;
      }
      itemGroups.push(group);
      total += group.length;
      if (total >= limit2) {
        break;
      }
    }
    const orderedItems = [];
    for (let index = itemGroups.length - 1;index >= 0; index -= 1) {
      orderedItems.push(...itemGroups[index]);
    }
    if (orderedItems.length > limit2) {
      orderedItems.splice(0, orderedItems.length - limit2);
    }
    return orderedItems;
  }
  async addItems(items) {
    if (!items.length) {
      return;
    }
    const conversationId = await this.getSessionId();
    await this.#client.conversations.items.create(conversationId, {
      items: getInputItems(items)
    });
  }
  async popItem() {
    const conversationId = await this.getSessionId();
    const [latest] = await this.getItems(1);
    if (!latest) {
      return;
    }
    const itemId = latest.id;
    if (itemId) {
      await this.#client.conversations.items.delete(itemId, {
        conversation_id: conversationId
      });
    }
    return latest;
  }
  async clearSession() {
    if (!this.#conversationId) {
      return;
    }
    await this.#client.conversations.delete(this.#conversationId);
    this.#conversationId = undefined;
  }
}
var INPUT_CONTENT_TYPES = new Set([
  "input_text",
  "input_image",
  "input_file",
  "input_audio"
]);
function isObject3(value) {
  return typeof value === "object" && value !== null;
}
function isResponseOutputItemArray(value) {
  if (!Array.isArray(value) || value.length === 0) {
    return false;
  }
  return value.every((entry) => {
    if (!isObject3(entry)) {
      return false;
    }
    const type = entry.type;
    if (typeof type !== "string") {
      return false;
    }
    if (INPUT_CONTENT_TYPES.has(type)) {
      return false;
    }
    return !type.startsWith("input_");
  });
}
function resolveClient(options) {
  if (options.client) {
    return options.client;
  }
  return getDefaultOpenAIClient() ?? new OpenAI({
    apiKey: options.apiKey ?? getDefaultOpenAIKey(),
    baseURL: options.baseURL,
    organization: options.organization,
    project: options.project
  });
}
// node_modules/@openai/agents-realtime/dist/metadata.mjs
var METADATA2 = {
  name: "@openai/agents-realtime",
  version: "0.3.4",
  versions: {
    "@openai/agents-realtime": "0.3.4",
    "@openai/agents-core": "workspace:*"
  }
};
var metadata_default2 = METADATA2;

// node_modules/@openai/agents-realtime/dist/utils.mjs
function base64ToArrayBuffer(base645) {
  const binaryString = atob(base645);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0;i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
}
function arrayBufferToBase64(arrayBuffer) {
  const binaryString = String.fromCharCode(...new Uint8Array(arrayBuffer));
  return btoa(binaryString);
}
function getLastTextFromAudioOutputMessage(item) {
  if (typeof item === "undefined" || item === null || typeof item !== "object" || !("type" in item) || typeof item.type !== "string" || !item.type) {
    return;
  }
  if (item.type !== "message") {
    return;
  }
  if (!("content" in item) || !Array.isArray(item.content) || item.content.length < 1) {
    return;
  }
  const lastContentItem = item.content[item.content.length - 1];
  if (!("type" in lastContentItem) || typeof lastContentItem.type !== "string") {
    return;
  }
  if (lastContentItem.type === "output_text") {
    return typeof lastContentItem.text === "string" ? lastContentItem.text : undefined;
  }
  if (lastContentItem.type === "output_audio") {
    return typeof lastContentItem.transcript === "string" ? lastContentItem.transcript : undefined;
  }
  return;
}
function diffRealtimeHistory(oldHistory, newHistory) {
  const removals = oldHistory.filter((item) => !newHistory.some((newItem) => newItem.itemId === item.itemId));
  const additions = newHistory.filter((item) => !oldHistory.some((oldItem) => oldItem.itemId === item.itemId));
  const updates = newHistory.filter((item) => oldHistory.some((oldItem) => oldItem.itemId === item.itemId && JSON.stringify(oldItem) !== JSON.stringify(item)));
  return {
    removals,
    additions,
    updates
  };
}
function hasWebRTCSupport() {
  if (typeof window === "undefined") {
    return false;
  }
  return typeof window["RTCPeerConnection"] !== "undefined";
}
function removeAudioFromContent(item) {
  if (item.role === "system") {
    return item;
  }
  if (item.role === "assistant") {
    return {
      ...item,
      content: item.content.map((entry) => {
        if (entry.type === "output_audio") {
          return {
            ...entry,
            audio: null
          };
        }
        return entry;
      })
    };
  }
  if (item.role === "user") {
    return {
      ...item,
      content: item.content.map((entry) => {
        if (entry.type === "input_audio") {
          return {
            ...entry,
            audio: null
          };
        }
        return entry;
      })
    };
  }
  return item;
}
function preserveAssistantAudioTranscripts(existing, incoming) {
  if (existing.role !== "assistant" || incoming.role !== "assistant") {
    return incoming;
  }
  const mergedContent = incoming.content.map((entry, index) => {
    if (entry.type !== "output_audio") {
      return entry;
    }
    const transcriptMissing = typeof entry.transcript !== "string" || entry.transcript.length === 0;
    if (!transcriptMissing) {
      return entry;
    }
    const previousEntry = existing.content[index];
    if (previousEntry && previousEntry.type === "output_audio" && typeof previousEntry.transcript === "string" && previousEntry.transcript.length > 0) {
      return {
        ...entry,
        transcript: previousEntry.transcript
      };
    }
    return entry;
  });
  return {
    ...incoming,
    content: mergedContent
  };
}
function updateRealtimeHistory(history, event, shouldIncludeAudioData) {
  if (event.type === "conversation.item.input_audio_transcription.completed") {
    return history.map((item) => {
      if (item.itemId === event.item_id && item.type === "message" && "role" in item && item.role === "user") {
        const updatedContent = item.content.map((entry) => {
          if (entry.type === "input_audio") {
            return {
              ...entry,
              transcript: event.transcript
            };
          }
          return entry;
        });
        return {
          ...item,
          content: updatedContent,
          status: "completed"
        };
      }
      return item;
    });
  }
  const newEvent = !shouldIncludeAudioData && event.type === "message" ? removeAudioFromContent(event) : event;
  const existingIndex = history.findIndex((item) => item.itemId === event.itemId);
  if (existingIndex !== -1) {
    const existingItem = history[existingIndex];
    const mergedEvent = newEvent.type === "message" && existingItem.type === "message" ? preserveAssistantAudioTranscripts(existingItem, newEvent) : newEvent;
    return history.map((item, idx) => {
      if (idx === existingIndex) {
        return mergedEvent;
      }
      if (!shouldIncludeAudioData && item.type === "message") {
        return removeAudioFromContent(item);
      }
      return item;
    });
  } else if (event.previousItemId) {
    const prevIndex = history.findIndex((item) => item.itemId === event.previousItemId);
    if (prevIndex !== -1) {
      return [
        ...history.slice(0, prevIndex + 1),
        newEvent,
        ...history.slice(prevIndex + 1)
      ];
    } else {
      return [...history, newEvent];
    }
  } else {
    return [...history, newEvent];
  }
}
var HEADERS2 = {
  "User-Agent": `Agents/JavaScript ${metadata_default2.version}`,
  "X-OpenAI-Agents-SDK": `openai-agents-sdk.${metadata_default2.version}`
};
var WEBSOCKET_META = `openai-agents-sdk.${metadata_default2.version}`;
function realtimeApprovalItemToApprovalItem(agent, item) {
  const { name, arguments: args, ...rest } = item;
  return new RunToolApprovalItem({
    type: "hosted_tool_call",
    name,
    arguments: JSON.stringify(args),
    status: "in_progress",
    providerData: {
      ...rest
    }
  }, agent);
}
function approvalItemToRealtimeApprovalItem(item) {
  if (item.rawItem.type !== "function_call" && item.rawItem.type !== "hosted_tool_call") {
    throw new Error("Invalid approval item type for Realtime MCP approval request");
  }
  const { name, arguments: args, providerData } = item.rawItem;
  const { itemId, serverLabel, ...rest } = providerData ?? {};
  if (!itemId || !serverLabel) {
    throw new Error("Invalid approval item for Realtime MCP approval request");
  }
  return {
    type: "mcp_approval_request",
    itemId,
    serverLabel,
    ...rest,
    name,
    arguments: args ? JSON.parse(args) : {},
    approved: null
  };
}
// node_modules/@openai/agents-realtime/dist/guardrail.mjs
function getRealtimeGuardrailSettings(settings) {
  return {
    debounceTextLength: settings.debounceTextLength ?? 100
  };
}
function defineRealtimeOutputGuardrail({ policyHint: policyHintInput, ...options }) {
  const baseGuardrail = defineOutputGuardrail(options);
  const policyHint = policyHintInput ?? baseGuardrail.name;
  return {
    ...baseGuardrail,
    policyHint,
    run: async (args) => {
      const result = await baseGuardrail.run(args);
      return {
        ...result,
        guardrail: { ...result.guardrail, policyHint }
      };
    }
  };
}
function getRealtimeGuardrailFeedbackMessage(result) {
  return `
\u26A0\uFE0F Your last answer was blocked. 
Failed Guardrail Reason: ${result.guardrail.policyHint}. 
Failure Details: ${JSON.stringify(result.output.outputInfo ?? {})}. 
Please respond again following policy. Apologize for not being able to answer the question (while avoiding the specific reason) and divert discussion back to an approved topic immediately and not invite more discussion.
`.trim();
}

// node_modules/@openai/agents-realtime/dist/clientMessages.mjs
function isDefined(key, object5) {
  return key in object5 && typeof object5[key] !== "undefined";
}
function isDeprecatedConfig(config2) {
  return isDefined("modalities", config2) || isDefined("inputAudioFormat", config2) || isDefined("outputAudioFormat", config2) || isDefined("inputAudioTranscription", config2) || isDefined("turnDetection", config2) || isDefined("inputAudioNoiseReduction", config2) || isDefined("speed", config2);
}
function toNewSessionConfig(config2) {
  if (!isDeprecatedConfig(config2)) {
    const inputConfig = config2.audio?.input ? {
      format: normalizeAudioFormat(config2.audio.input.format),
      noiseReduction: config2.audio.input.noiseReduction ?? null,
      transcription: config2.audio.input.transcription,
      turnDetection: config2.audio.input.turnDetection
    } : undefined;
    const requestedOutputVoice = config2.audio?.output?.voice ?? config2.voice;
    const outputConfig = config2.audio?.output || typeof requestedOutputVoice !== "undefined" ? {
      format: normalizeAudioFormat(config2.audio?.output?.format),
      voice: requestedOutputVoice,
      speed: config2.audio?.output?.speed
    } : undefined;
    return {
      model: config2.model,
      instructions: config2.instructions,
      toolChoice: config2.toolChoice,
      tools: config2.tools,
      tracing: config2.tracing,
      providerData: config2.providerData,
      prompt: config2.prompt,
      outputModalities: config2.outputModalities,
      audio: inputConfig || outputConfig ? {
        input: inputConfig,
        output: outputConfig
      } : undefined
    };
  }
  return {
    model: config2.model,
    instructions: config2.instructions,
    toolChoice: config2.toolChoice,
    tools: config2.tools,
    tracing: config2.tracing,
    providerData: config2.providerData,
    prompt: config2.prompt,
    outputModalities: config2.modalities,
    audio: {
      input: {
        format: normalizeAudioFormat(config2.inputAudioFormat),
        noiseReduction: config2.inputAudioNoiseReduction ?? null,
        transcription: config2.inputAudioTranscription,
        turnDetection: config2.turnDetection
      },
      output: {
        format: normalizeAudioFormat(config2.outputAudioFormat),
        voice: config2.voice,
        speed: config2.speed
      }
    }
  };
}
function normalizeAudioFormat(format2) {
  if (!format2)
    return;
  if (typeof format2 === "object")
    return format2;
  const f = String(format2);
  if (f === "pcm16")
    return { type: "audio/pcm", rate: 24000 };
  if (f === "g711_ulaw")
    return { type: "audio/pcmu" };
  if (f === "g711_alaw")
    return { type: "audio/pcma" };
  return { type: "audio/pcm", rate: 24000 };
}

// node_modules/@openai/agents-realtime/dist/items.mjs
var baseItemSchema = exports_external2.object({
  itemId: exports_external2.string()
});
var realtimeMessageItemSchema = exports_external2.discriminatedUnion("role", [
  exports_external2.object({
    itemId: exports_external2.string(),
    previousItemId: exports_external2.string().nullable().optional(),
    type: exports_external2.literal("message"),
    role: exports_external2.literal("system"),
    content: exports_external2.array(exports_external2.object({ type: exports_external2.literal("input_text"), text: exports_external2.string() }))
  }),
  exports_external2.object({
    itemId: exports_external2.string(),
    previousItemId: exports_external2.string().nullable().optional(),
    type: exports_external2.literal("message"),
    role: exports_external2.literal("user"),
    status: exports_external2.enum(["in_progress", "completed"]),
    content: exports_external2.array(exports_external2.object({ type: exports_external2.literal("input_text"), text: exports_external2.string() }).or(exports_external2.object({
      type: exports_external2.literal("input_audio"),
      audio: exports_external2.string().nullable().optional(),
      transcript: exports_external2.string().nullable()
    })))
  }),
  exports_external2.object({
    itemId: exports_external2.string(),
    previousItemId: exports_external2.string().nullable().optional(),
    type: exports_external2.literal("message"),
    role: exports_external2.literal("assistant"),
    status: exports_external2.enum(["in_progress", "completed", "incomplete"]),
    content: exports_external2.array(exports_external2.object({ type: exports_external2.literal("output_text"), text: exports_external2.string() }).or(exports_external2.object({
      type: exports_external2.literal("output_audio"),
      audio: exports_external2.string().nullable().optional(),
      transcript: exports_external2.string().nullable().optional()
    })))
  })
]);
var realtimeToolCallItem = exports_external2.object({
  itemId: exports_external2.string(),
  previousItemId: exports_external2.string().nullable().optional(),
  type: exports_external2.literal("function_call"),
  status: exports_external2.enum(["in_progress", "completed", "incomplete"]),
  arguments: exports_external2.string(),
  name: exports_external2.string(),
  output: exports_external2.string().nullable()
});
var realtimeMcpCallItem = exports_external2.object({
  itemId: exports_external2.string(),
  previousItemId: exports_external2.string().nullable().optional(),
  type: exports_external2.enum(["mcp_call", "mcp_tool_call"]),
  status: exports_external2.enum(["in_progress", "completed", "incomplete"]),
  arguments: exports_external2.string(),
  name: exports_external2.string(),
  output: exports_external2.string().nullable()
});
var realtimeMcpCallApprovalRequestItem = exports_external2.object({
  itemId: exports_external2.string(),
  type: exports_external2.literal("mcp_approval_request"),
  serverLabel: exports_external2.string(),
  name: exports_external2.string(),
  arguments: exports_external2.record(exports_external2.string(), exports_external2.any()),
  approved: exports_external2.boolean().optional().nullable()
});

// node_modules/@openai/agents-realtime/dist/logger.mjs
var logger3 = getLogger("openai-agents:realtime");
var logger_default3 = logger3;

// node_modules/@openai/agents-realtime/dist/openaiRealtimeEvents.mjs
var realtimeResponse = exports_external2.object({
  id: exports_external2.string().optional().nullable(),
  conversation_id: exports_external2.string().optional().nullable(),
  max_output_tokens: exports_external2.number().or(exports_external2.literal("inf")).optional().nullable(),
  metadata: exports_external2.record(exports_external2.string(), exports_external2.any()).optional().nullable(),
  output_modalities: exports_external2.array(exports_external2.string()).optional().nullable(),
  object: exports_external2.literal("realtime.response").optional().nullable(),
  output: exports_external2.array(exports_external2.any()).optional().nullable(),
  audio: exports_external2.object({
    output: exports_external2.object({
      format: exports_external2.any().optional().nullable(),
      voice: exports_external2.string().optional().nullable()
    }).optional().nullable()
  }).optional().nullable(),
  status: exports_external2.enum(["completed", "incomplete", "failed", "cancelled", "in_progress"]).optional().nullable(),
  status_details: exports_external2.record(exports_external2.string(), exports_external2.any()).optional().nullable(),
  usage: exports_external2.object({
    input_tokens: exports_external2.number().optional(),
    input_token_details: exports_external2.record(exports_external2.string(), exports_external2.any()).optional().nullable(),
    output_tokens: exports_external2.number().optional(),
    output_token_details: exports_external2.record(exports_external2.string(), exports_external2.any()).optional().nullable()
  }).optional().nullable()
});
var conversationItemContentSchema = exports_external2.object({
  id: exports_external2.string().optional(),
  audio: exports_external2.string().nullable().optional(),
  text: exports_external2.string().nullable().optional(),
  transcript: exports_external2.string().nullable().optional(),
  type: exports_external2.union([
    exports_external2.literal("input_text"),
    exports_external2.literal("input_audio"),
    exports_external2.literal("item_reference"),
    exports_external2.literal("output_text"),
    exports_external2.literal("output_audio")
  ])
});
var conversationItemSchema = exports_external2.object({
  id: exports_external2.string().optional(),
  arguments: exports_external2.string().optional(),
  call_id: exports_external2.string().optional(),
  content: exports_external2.array(conversationItemContentSchema).optional(),
  name: exports_external2.string().optional(),
  output: exports_external2.string().nullable().optional(),
  role: exports_external2.enum(["user", "assistant", "system"]).optional(),
  status: exports_external2.enum(["completed", "incomplete", "in_progress"]).optional(),
  type: exports_external2.enum([
    "message",
    "function_call",
    "function_call_output",
    "mcp_list_tools",
    "mcp_tool_call",
    "mcp_call",
    "mcp_approval_request",
    "mcp_approval_response"
  ]).optional(),
  approval_request_id: exports_external2.string().nullable().optional(),
  approve: exports_external2.boolean().nullable().optional(),
  reason: exports_external2.string().nullable().optional(),
  server_label: exports_external2.string().optional(),
  error: exports_external2.any().nullable().optional(),
  tools: exports_external2.array(exports_external2.object({
    name: exports_external2.string(),
    description: exports_external2.string(),
    input_schema: exports_external2.record(exports_external2.any()).optional()
  }).passthrough()).optional()
}).passthrough();
var conversationCreatedEventSchema = exports_external2.object({
  type: exports_external2.literal("conversation.created"),
  event_id: exports_external2.string(),
  conversation: exports_external2.object({
    id: exports_external2.string().optional(),
    object: exports_external2.literal("realtime.conversation").optional()
  })
});
var conversationItemAddedEventSchema = exports_external2.object({
  type: exports_external2.literal("conversation.item.added"),
  event_id: exports_external2.string(),
  item: conversationItemSchema,
  previous_item_id: exports_external2.string().nullable().optional()
});
var conversationItemDoneEventSchema = exports_external2.object({
  type: exports_external2.literal("conversation.item.done"),
  event_id: exports_external2.string(),
  item: conversationItemSchema,
  previous_item_id: exports_external2.string().nullable().optional()
});
var conversationItemDeletedEventSchema = exports_external2.object({
  type: exports_external2.literal("conversation.item.deleted"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string()
});
var conversationItemInputAudioTranscriptionCompletedEventSchema = exports_external2.object({
  type: exports_external2.literal("conversation.item.input_audio_transcription.completed"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string(),
  content_index: exports_external2.number(),
  transcript: exports_external2.string(),
  logprobs: exports_external2.array(exports_external2.any()).nullable().optional()
});
var conversationItemInputAudioTranscriptionDeltaEventSchema = exports_external2.object({
  type: exports_external2.literal("conversation.item.input_audio_transcription.delta"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string(),
  content_index: exports_external2.number().optional(),
  delta: exports_external2.string().optional(),
  logprobs: exports_external2.array(exports_external2.any()).nullable().optional()
});
var conversationItemInputAudioTranscriptionFailedEventSchema = exports_external2.object({
  type: exports_external2.literal("conversation.item.input_audio_transcription.failed"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string(),
  content_index: exports_external2.number(),
  error: exports_external2.object({
    code: exports_external2.string().optional(),
    message: exports_external2.string().optional(),
    param: exports_external2.string().optional(),
    type: exports_external2.string().optional()
  })
});
var conversationItemRetrievedEventSchema = exports_external2.object({
  type: exports_external2.literal("conversation.item.retrieved"),
  event_id: exports_external2.string(),
  item: conversationItemSchema
});
var conversationItemTruncatedEventSchema = exports_external2.object({
  type: exports_external2.literal("conversation.item.truncated"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string(),
  audio_end_ms: exports_external2.number(),
  content_index: exports_external2.number()
});
var conversationItemCreateEventSchema = exports_external2.object({
  type: exports_external2.literal("conversation.item.create"),
  item: conversationItemSchema,
  event_id: exports_external2.string().optional(),
  previous_item_id: exports_external2.string().nullable().optional()
});
var conversationItemDeleteEventSchema = exports_external2.object({
  type: exports_external2.literal("conversation.item.delete"),
  item_id: exports_external2.string(),
  event_id: exports_external2.string().optional()
});
var conversationItemRetrieveEventSchema = exports_external2.object({
  type: exports_external2.literal("conversation.item.retrieve"),
  item_id: exports_external2.string(),
  event_id: exports_external2.string().optional()
});
var conversationItemTruncateEventSchema = exports_external2.object({
  type: exports_external2.literal("conversation.item.truncate"),
  item_id: exports_external2.string(),
  audio_end_ms: exports_external2.number(),
  content_index: exports_external2.number(),
  event_id: exports_external2.string().optional()
});
var errorEventSchema = exports_external2.object({
  type: exports_external2.literal("error"),
  event_id: exports_external2.string().optional(),
  error: exports_external2.any().optional()
});
var inputAudioBufferClearedEventSchema = exports_external2.object({
  type: exports_external2.literal("input_audio_buffer.cleared"),
  event_id: exports_external2.string()
});
var inputAudioBufferAppendEventSchema = exports_external2.object({
  type: exports_external2.literal("input_audio_buffer.append"),
  audio: exports_external2.string(),
  event_id: exports_external2.string().optional()
});
var inputAudioBufferClearEventSchema = exports_external2.object({
  type: exports_external2.literal("input_audio_buffer.clear"),
  event_id: exports_external2.string().optional()
});
var inputAudioBufferCommitEventSchema = exports_external2.object({
  type: exports_external2.literal("input_audio_buffer.commit"),
  event_id: exports_external2.string().optional()
});
var inputAudioBufferCommittedEventSchema = exports_external2.object({
  type: exports_external2.literal("input_audio_buffer.committed"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string(),
  previous_item_id: exports_external2.string().nullable().optional()
});
var inputAudioBufferSpeechStartedEventSchema = exports_external2.object({
  type: exports_external2.literal("input_audio_buffer.speech_started"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string(),
  audio_start_ms: exports_external2.number()
});
var inputAudioBufferSpeechStoppedEventSchema = exports_external2.object({
  type: exports_external2.literal("input_audio_buffer.speech_stopped"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string(),
  audio_end_ms: exports_external2.number()
});
var outputAudioBufferStartedEventSchema = exports_external2.object({
  type: exports_external2.literal("output_audio_buffer.started"),
  event_id: exports_external2.string()
}).passthrough();
var outputAudioBufferStoppedEventSchema = exports_external2.object({
  type: exports_external2.literal("output_audio_buffer.stopped"),
  event_id: exports_external2.string()
}).passthrough();
var outputAudioBufferClearedEventSchema = exports_external2.object({
  type: exports_external2.literal("output_audio_buffer.cleared"),
  event_id: exports_external2.string()
});
var rateLimitsUpdatedEventSchema = exports_external2.object({
  type: exports_external2.literal("rate_limits.updated"),
  event_id: exports_external2.string(),
  rate_limits: exports_external2.array(exports_external2.object({
    limit: exports_external2.number().optional(),
    name: exports_external2.enum(["requests", "tokens"]).optional(),
    remaining: exports_external2.number().optional(),
    reset_seconds: exports_external2.number().optional()
  }))
});
var responseAudioDeltaEventSchema = exports_external2.object({
  type: exports_external2.literal("response.output_audio.delta"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string(),
  content_index: exports_external2.number(),
  delta: exports_external2.string(),
  output_index: exports_external2.number(),
  response_id: exports_external2.string()
});
var responseAudioDoneEventSchema = exports_external2.object({
  type: exports_external2.literal("response.output_audio.done"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string(),
  content_index: exports_external2.number(),
  output_index: exports_external2.number(),
  response_id: exports_external2.string()
});
var responseAudioTranscriptDeltaEventSchema = exports_external2.object({
  type: exports_external2.literal("response.output_audio_transcript.delta"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string(),
  content_index: exports_external2.number(),
  delta: exports_external2.string(),
  output_index: exports_external2.number(),
  response_id: exports_external2.string()
});
var responseAudioTranscriptDoneEventSchema = exports_external2.object({
  type: exports_external2.literal("response.output_audio_transcript.done"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string(),
  content_index: exports_external2.number(),
  transcript: exports_external2.string(),
  output_index: exports_external2.number(),
  response_id: exports_external2.string()
});
var responseContentPartAddedEventSchema = exports_external2.object({
  type: exports_external2.literal("response.content_part.added"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string(),
  content_index: exports_external2.number(),
  output_index: exports_external2.number(),
  response_id: exports_external2.string(),
  part: exports_external2.object({
    audio: exports_external2.string().optional(),
    text: exports_external2.string().optional(),
    transcript: exports_external2.string().optional(),
    type: exports_external2.enum(["text", "audio"]).optional()
  })
});
var responseContentPartDoneEventSchema = exports_external2.object({
  type: exports_external2.literal("response.content_part.done"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string(),
  content_index: exports_external2.number(),
  output_index: exports_external2.number(),
  response_id: exports_external2.string(),
  part: exports_external2.object({
    audio: exports_external2.string().optional(),
    text: exports_external2.string().optional(),
    transcript: exports_external2.string().optional(),
    type: exports_external2.enum(["text", "audio"]).optional()
  })
});
var responseCreatedEventSchema = exports_external2.object({
  type: exports_external2.literal("response.created"),
  event_id: exports_external2.string(),
  response: realtimeResponse
});
var responseDoneEventSchema = exports_external2.object({
  type: exports_external2.literal("response.done"),
  event_id: exports_external2.string(),
  response: realtimeResponse
});
var responseFunctionCallArgumentsDeltaEventSchema = exports_external2.object({
  type: exports_external2.literal("response.function_call_arguments.delta"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string(),
  call_id: exports_external2.string(),
  delta: exports_external2.string(),
  output_index: exports_external2.number(),
  response_id: exports_external2.string()
});
var responseFunctionCallArgumentsDoneEventSchema = exports_external2.object({
  type: exports_external2.literal("response.function_call_arguments.done"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string(),
  call_id: exports_external2.string(),
  arguments: exports_external2.string(),
  output_index: exports_external2.number(),
  response_id: exports_external2.string()
});
var responseOutputItemAddedEventSchema = exports_external2.object({
  type: exports_external2.literal("response.output_item.added"),
  event_id: exports_external2.string(),
  item: conversationItemSchema,
  output_index: exports_external2.number(),
  response_id: exports_external2.string()
});
var responseOutputItemDoneEventSchema = exports_external2.object({
  type: exports_external2.literal("response.output_item.done"),
  event_id: exports_external2.string(),
  item: conversationItemSchema,
  output_index: exports_external2.number(),
  response_id: exports_external2.string()
});
var responseTextDeltaEventSchema = exports_external2.object({
  type: exports_external2.literal("response.output_text.delta"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string(),
  content_index: exports_external2.number(),
  delta: exports_external2.string(),
  output_index: exports_external2.number(),
  response_id: exports_external2.string()
});
var responseTextDoneEventSchema = exports_external2.object({
  type: exports_external2.literal("response.output_text.done"),
  event_id: exports_external2.string(),
  item_id: exports_external2.string(),
  content_index: exports_external2.number(),
  text: exports_external2.string(),
  output_index: exports_external2.number(),
  response_id: exports_external2.string()
});
var sessionCreatedEventSchema = exports_external2.object({
  type: exports_external2.literal("session.created"),
  event_id: exports_external2.string(),
  session: exports_external2.any()
});
var sessionUpdatedEventSchema = exports_external2.object({
  type: exports_external2.literal("session.updated"),
  event_id: exports_external2.string(),
  session: exports_external2.any()
});
var responseCancelEventSchema = exports_external2.object({
  type: exports_external2.literal("response.cancel"),
  event_id: exports_external2.string().optional(),
  response_id: exports_external2.string().optional()
});
var responseCreateEventSchema = exports_external2.object({
  type: exports_external2.literal("response.create"),
  event_id: exports_external2.string().optional(),
  response: exports_external2.any().optional()
});
var sessionUpdateEventSchema = exports_external2.object({
  type: exports_external2.literal("session.update"),
  event_id: exports_external2.string().optional(),
  session: exports_external2.any()
});
var mcpListToolsInProgressEventSchema = exports_external2.object({
  type: exports_external2.literal("mcp_list_tools.in_progress"),
  event_id: exports_external2.string().optional(),
  item_id: exports_external2.string().optional()
});
var mcpListToolsCompletedEventSchema = exports_external2.object({
  type: exports_external2.literal("mcp_list_tools.completed"),
  event_id: exports_external2.string().optional(),
  item_id: exports_external2.string().optional()
});
var responseMcpCallArgumentsDeltaEventSchema = exports_external2.object({
  type: exports_external2.literal("response.mcp_call_arguments.delta"),
  event_id: exports_external2.string(),
  response_id: exports_external2.string(),
  item_id: exports_external2.string(),
  output_index: exports_external2.number(),
  delta: exports_external2.string(),
  obfuscation: exports_external2.string()
});
var responseMcpCallArgumentsDoneEventSchema = exports_external2.object({
  type: exports_external2.literal("response.mcp_call_arguments.done"),
  event_id: exports_external2.string(),
  response_id: exports_external2.string(),
  item_id: exports_external2.string(),
  output_index: exports_external2.number(),
  arguments: exports_external2.string()
});
var responseMcpCallInProgressEventSchema = exports_external2.object({
  type: exports_external2.literal("response.mcp_call.in_progress"),
  event_id: exports_external2.string(),
  output_index: exports_external2.number(),
  item_id: exports_external2.string()
});
var responseMcpCallCompletedEventSchema = exports_external2.object({
  type: exports_external2.literal("response.mcp_call.completed"),
  event_id: exports_external2.string(),
  output_index: exports_external2.number(),
  item_id: exports_external2.string()
});
var mcpListToolsFailedEventSchema = exports_external2.object({
  type: exports_external2.literal("mcp_list_tools.failed"),
  event_id: exports_external2.string().optional(),
  item_id: exports_external2.string().optional()
});
var genericEventSchema = exports_external2.object({
  type: exports_external2.string(),
  event_id: exports_external2.string().optional().nullable()
}).passthrough();
var realtimeServerEventSchema = exports_external2.discriminatedUnion("type", [
  conversationCreatedEventSchema,
  conversationItemAddedEventSchema,
  conversationItemDoneEventSchema,
  conversationItemDeletedEventSchema,
  conversationItemInputAudioTranscriptionCompletedEventSchema,
  conversationItemInputAudioTranscriptionDeltaEventSchema,
  conversationItemInputAudioTranscriptionFailedEventSchema,
  conversationItemRetrievedEventSchema,
  conversationItemTruncatedEventSchema,
  errorEventSchema,
  inputAudioBufferClearedEventSchema,
  inputAudioBufferCommittedEventSchema,
  inputAudioBufferSpeechStartedEventSchema,
  inputAudioBufferSpeechStoppedEventSchema,
  outputAudioBufferStartedEventSchema,
  outputAudioBufferStoppedEventSchema,
  outputAudioBufferClearedEventSchema,
  rateLimitsUpdatedEventSchema,
  responseAudioDeltaEventSchema,
  responseAudioDoneEventSchema,
  responseAudioTranscriptDeltaEventSchema,
  responseAudioTranscriptDoneEventSchema,
  responseContentPartAddedEventSchema,
  responseContentPartDoneEventSchema,
  responseCreatedEventSchema,
  responseDoneEventSchema,
  responseFunctionCallArgumentsDeltaEventSchema,
  responseFunctionCallArgumentsDoneEventSchema,
  responseOutputItemAddedEventSchema,
  responseOutputItemDoneEventSchema,
  responseTextDeltaEventSchema,
  responseTextDoneEventSchema,
  sessionCreatedEventSchema,
  sessionUpdatedEventSchema,
  mcpListToolsInProgressEventSchema,
  mcpListToolsCompletedEventSchema,
  mcpListToolsFailedEventSchema,
  responseMcpCallArgumentsDeltaEventSchema,
  responseMcpCallArgumentsDoneEventSchema,
  responseMcpCallInProgressEventSchema,
  responseMcpCallCompletedEventSchema
]);
var realtimeClientEventSchema = exports_external2.discriminatedUnion("type", [
  conversationItemCreateEventSchema,
  conversationItemDeleteEventSchema,
  conversationItemRetrieveEventSchema,
  conversationItemTruncateEventSchema,
  inputAudioBufferAppendEventSchema,
  inputAudioBufferClearEventSchema,
  inputAudioBufferCommitEventSchema,
  responseCancelEventSchema,
  responseCreateEventSchema,
  sessionUpdateEventSchema
]);
function parseRealtimeEvent(event) {
  const raw = JSON.parse(event.data.toString());
  const parsed = realtimeServerEventSchema.safeParse(raw);
  if (!parsed.success) {
    const genericParsed = genericEventSchema.safeParse(raw);
    if (genericParsed.success) {
      return { data: genericParsed.data, isGeneric: true };
    }
    return { data: null, isGeneric: true };
  }
  return { data: parsed.data, isGeneric: false };
}

// node_modules/@openai/agents-realtime/dist/openaiRealtimeBase.mjs
var DEFAULT_OPENAI_REALTIME_MODEL = "gpt-realtime";
var DEFAULT_OPENAI_REALTIME_SESSION_CONFIG = {
  outputModalities: ["audio"],
  audio: {
    input: {
      format: { type: "audio/pcm", rate: 24000 },
      transcription: { model: "gpt-4o-mini-transcribe" },
      turnDetection: { type: "semantic_vad" },
      noiseReduction: null
    },
    output: {
      format: { type: "audio/pcm", rate: 24000 },
      speed: 1
    }
  }
};

class OpenAIRealtimeBase extends EventEmitterDelegate {
  #model;
  #apiKey;
  #tracingConfig = null;
  #rawSessionConfig = null;
  eventEmitter = new EventEmitter;
  constructor(options = {}) {
    super();
    this.#model = options.model ?? DEFAULT_OPENAI_REALTIME_MODEL;
    this.#apiKey = options.apiKey;
  }
  get currentModel() {
    return this.#model;
  }
  set currentModel(model) {
    this.#model = model;
  }
  _afterAudioDoneEvent() {}
  get _rawSessionConfig() {
    return this.#rawSessionConfig ?? null;
  }
  async _getApiKey(options) {
    const apiKey = options.apiKey ?? this.#apiKey;
    if (typeof apiKey === "function") {
      return await apiKey();
    }
    return apiKey;
  }
  _onMessage(event) {
    const { data: parsed, isGeneric } = parseRealtimeEvent(event);
    if (parsed === null) {
      return;
    }
    this.emit("*", parsed);
    if (isGeneric) {
      return;
    }
    if (parsed.type === "error") {
      this.emit("error", { type: "error", error: parsed });
    } else {
      this.emit(parsed.type, parsed);
    }
    if (parsed.type === "response.created") {
      this.emit("turn_started", {
        type: "response_started",
        providerData: {
          ...parsed
        }
      });
      return;
    }
    if (parsed.type === "session.updated") {
      this.#rawSessionConfig = parsed.session;
    }
    if (parsed.type === "response.done") {
      const response = responseDoneEventSchema.safeParse(parsed);
      if (!response.success) {
        logger_default3.error("Error parsing response done event", response.error);
        return;
      }
      const inputTokens = response.data.response.usage?.input_tokens ?? 0;
      const outputTokens = response.data.response.usage?.output_tokens ?? 0;
      const totalTokens = inputTokens + outputTokens;
      const usage = new Usage({
        inputTokens,
        inputTokensDetails: response.data.response.usage?.input_token_details ?? {},
        outputTokens,
        outputTokensDetails: response.data.response.usage?.output_token_details ?? {},
        totalTokens
      });
      this.emit("usage_update", usage);
      this.emit("turn_done", {
        type: "response_done",
        response: {
          id: response.data.response.id ?? "",
          output: response.data.response.output ?? [],
          usage: {
            inputTokens,
            inputTokensDetails: response.data.response.usage?.input_token_details ?? {},
            outputTokens,
            outputTokensDetails: response.data.response.usage?.output_token_details ?? {},
            totalTokens
          }
        }
      });
      return;
    }
    if (parsed.type === "response.output_audio.done") {
      this.emit("audio_done");
      this._afterAudioDoneEvent();
      return;
    }
    if (parsed.type === "conversation.item.deleted") {
      this.emit("item_deleted", {
        itemId: parsed.item_id
      });
      return;
    }
    if (parsed.type === "conversation.item.input_audio_transcription.completed" || parsed.type === "conversation.item.truncated") {
      this.sendEvent({
        type: "conversation.item.retrieve",
        item_id: parsed.item_id
      });
      return;
    }
    if (parsed.type === "conversation.item.input_audio_transcription.delta" || parsed.type === "response.output_text.delta" || parsed.type === "response.output_audio_transcript.delta" || parsed.type === "response.function_call_arguments.delta") {
      if (parsed.type === "response.output_audio_transcript.delta") {
        this.emit("audio_transcript_delta", {
          type: "transcript_delta",
          delta: parsed.delta,
          itemId: parsed.item_id,
          responseId: parsed.response_id
        });
      }
      return;
    }
    if (parsed.type === "conversation.item.added" || parsed.type === "conversation.item.done" || parsed.type === "conversation.item.retrieved") {
      if (parsed.item.type === "mcp_list_tools" && parsed.type === "conversation.item.done") {
        const serverLabel = parsed.item.server_label ?? "";
        const tools = parsed.item.tools ?? [];
        try {
          this.emit("mcp_tools_listed", {
            serverLabel,
            tools
          });
        } catch (err) {
          logger_default3.error("Error emitting mcp_tools_listed", err, parsed.item);
        }
        return;
      }
      if (parsed.item.type === "message") {
        const previousItemId = parsed.type === "conversation.item.added" || parsed.type === "conversation.item.done" ? parsed.previous_item_id : null;
        const item = realtimeMessageItemSchema.parse({
          itemId: parsed.item.id,
          previousItemId,
          type: parsed.item.type,
          role: parsed.item.role,
          content: parsed.item.content,
          status: parsed.item.status
        });
        this.emit("item_update", item);
        return;
      }
      if (parsed.item.type === "mcp_approval_request" && parsed.type === "conversation.item.done") {
        const item = parsed.item;
        const mcpApprovalRequest = realtimeMcpCallApprovalRequestItem.parse({
          itemId: item.id,
          type: item.type,
          serverLabel: item.server_label,
          name: item.name,
          arguments: JSON.parse(item.arguments || "{}"),
          approved: item.approved
        });
        this.emit("item_update", mcpApprovalRequest);
        this.emit("mcp_approval_request", mcpApprovalRequest);
        return;
      }
      if (parsed.item.type === "mcp_tool_call" || parsed.item.type === "mcp_call") {
        const status = parsed.type === "conversation.item.done" ? "completed" : "in_progress";
        const mcpCall = realtimeMcpCallItem.parse({
          itemId: parsed.item.id,
          type: parsed.item.type,
          status,
          arguments: parsed.item.arguments,
          name: parsed.item.name,
          output: parsed.item.output
        });
        this.emit("item_update", mcpCall);
        if (parsed.type === "conversation.item.done") {
          this.emit("mcp_tool_call_completed", mcpCall);
        }
        return;
      }
    }
    if (parsed.type === "response.mcp_call.in_progress") {
      const item = parsed;
      this.sendEvent({
        type: "conversation.item.retrieve",
        item_id: item.item_id
      });
      return;
    }
    if (parsed.type === "mcp_list_tools.in_progress") {
      const item = parsed;
      if (item.item_id) {
        this.sendEvent({
          type: "conversation.item.retrieve",
          item_id: item.item_id
        });
      }
      return;
    }
    if (parsed.type === "response.output_item.done" || parsed.type === "response.output_item.added") {
      const item = parsed.item;
      if (item.type === "function_call" && item.status === "completed") {
        const toolCall = realtimeToolCallItem.parse({
          itemId: item.id,
          type: item.type,
          status: "in_progress",
          arguments: item.arguments,
          name: item.name,
          output: null
        });
        this.emit("item_update", toolCall);
        this.emit("function_call", {
          id: item.id,
          type: "function_call",
          callId: item.call_id ?? "",
          arguments: item.arguments ?? "",
          name: item.name ?? ""
        });
        return;
      }
      if (item.type === "mcp_tool_call" || item.type === "mcp_call") {
        const mcpCall = realtimeMcpCallItem.parse({
          itemId: item.id,
          type: item.type,
          status: parsed.type === "response.output_item.done" ? "completed" : "in_progress",
          arguments: item.arguments,
          name: item.name,
          output: item.output
        });
        this.emit("item_update", mcpCall);
        return;
      }
      if (item.type === "message") {
        const realtimeItem = realtimeMessageItemSchema.parse({
          itemId: parsed.item.id,
          type: parsed.item.type,
          role: parsed.item.role,
          content: parsed.item.content,
          status: parsed.type === "response.output_item.done" ? item.status ?? "completed" : item.status ?? "in_progress"
        });
        this.emit("item_update", realtimeItem);
        return;
      }
    }
  }
  _onError(error47) {
    this.emit("error", {
      type: "error",
      error: error47
    });
  }
  _onOpen() {
    this.emit("connected");
  }
  _onClose() {
    this.emit("disconnected");
  }
  sendMessage(message, otherEventData, { triggerResponse = true } = {}) {
    const content = typeof message === "string" ? [
      {
        type: "input_text",
        text: message
      }
    ] : message.content.map((content2) => {
      if (content2.type === "input_image") {
        return {
          type: "input_image",
          image_url: content2.image,
          ...content2.providerData ?? {}
        };
      }
      return content2;
    });
    this.sendEvent({
      type: "conversation.item.create",
      item: {
        type: "message",
        role: "user",
        content
      },
      ...otherEventData
    });
    if (triggerResponse) {
      this.sendEvent({
        type: "response.create"
      });
    }
  }
  addImage(image, { triggerResponse = true } = {}) {
    this.sendMessage({
      type: "message",
      role: "user",
      content: [{ type: "input_image", image }]
    }, {}, { triggerResponse });
  }
  _getMergedSessionConfig(config2) {
    const newConfig = toNewSessionConfig(config2);
    const sessionData = {
      type: "realtime",
      instructions: newConfig.instructions,
      model: newConfig.model ?? this.#model,
      output_modalities: newConfig.outputModalities ?? DEFAULT_OPENAI_REALTIME_SESSION_CONFIG.outputModalities,
      audio: {
        input: {
          format: newConfig.audio?.input?.format ?? DEFAULT_OPENAI_REALTIME_SESSION_CONFIG.audio?.input?.format,
          noise_reduction: newConfig.audio?.input?.noiseReduction ?? DEFAULT_OPENAI_REALTIME_SESSION_CONFIG.audio?.input?.noiseReduction,
          transcription: newConfig.audio?.input?.transcription ?? DEFAULT_OPENAI_REALTIME_SESSION_CONFIG.audio?.input?.transcription,
          turn_detection: OpenAIRealtimeBase.buildTurnDetectionConfig(newConfig.audio?.input?.turnDetection) ?? DEFAULT_OPENAI_REALTIME_SESSION_CONFIG.audio?.input?.turnDetection
        },
        output: {
          format: newConfig.audio?.output?.format ?? DEFAULT_OPENAI_REALTIME_SESSION_CONFIG.audio?.output?.format,
          voice: newConfig.audio?.output?.voice ?? DEFAULT_OPENAI_REALTIME_SESSION_CONFIG.audio?.output?.voice,
          speed: newConfig.audio?.output?.speed ?? DEFAULT_OPENAI_REALTIME_SESSION_CONFIG.audio?.output?.speed
        }
      },
      tool_choice: newConfig.toolChoice ?? DEFAULT_OPENAI_REALTIME_SESSION_CONFIG.toolChoice,
      ...newConfig.providerData ?? {}
    };
    if (newConfig.prompt) {
      sessionData.prompt = {
        id: newConfig.prompt.promptId,
        version: newConfig.prompt.version,
        variables: newConfig.prompt.variables
      };
    }
    if (newConfig.tools && newConfig.tools.length > 0) {
      sessionData.tools = newConfig.tools.map((tool2) => ({
        ...tool2,
        strict: undefined
      }));
    }
    return sessionData;
  }
  buildSessionPayload(config2) {
    return this._getMergedSessionConfig(config2);
  }
  static buildTurnDetectionConfig(c) {
    if (typeof c === "undefined") {
      return;
    }
    const { type, createResponse, create_response, eagerness, interruptResponse, interrupt_response, prefixPaddingMs, prefix_padding_ms, silenceDurationMs, silence_duration_ms, threshold, idleTimeoutMs, idle_timeout_ms, ...rest } = c;
    const config2 = {
      type,
      create_response: createResponse ? createResponse : create_response,
      eagerness,
      interrupt_response: interruptResponse ? interruptResponse : interrupt_response,
      prefix_padding_ms: prefixPaddingMs ? prefixPaddingMs : prefix_padding_ms,
      silence_duration_ms: silenceDurationMs ? silenceDurationMs : silence_duration_ms,
      idle_timeout_ms: idleTimeoutMs ? idleTimeoutMs : idle_timeout_ms,
      threshold,
      ...rest
    };
    Object.keys(config2).forEach((key) => {
      if (config2[key] === undefined)
        delete config2[key];
    });
    return Object.keys(config2).length > 0 ? config2 : undefined;
  }
  set _tracingConfig(tracingConfig) {
    this.#tracingConfig = tracingConfig;
  }
  _updateTracingConfig(tracingConfig) {
    if (typeof this.#tracingConfig === "undefined") {
      this.#tracingConfig = null;
    }
    if (tracingConfig === "auto") {
      this.sendEvent({
        type: "session.update",
        session: {
          type: "realtime",
          tracing: "auto"
        }
      });
      return;
    }
    if (this.#tracingConfig !== null && typeof this.#tracingConfig !== "string" && typeof tracingConfig !== "string") {
      logger_default3.warn("Tracing config is already set, skipping setting it again. This likely happens when you already set a tracing config on session creation.");
      return;
    }
    if (tracingConfig === null) {
      logger_default3.debug("Disabling tracing for this session. It cannot be turned on for this session from this point on.");
      this.sendEvent({
        type: "session.update",
        session: {
          type: "realtime",
          tracing: null
        }
      });
      return;
    }
    if (this.#tracingConfig === null || typeof this.#tracingConfig === "string") {
      this.sendEvent({
        type: "session.update",
        session: {
          type: "realtime",
          tracing: tracingConfig
        }
      });
      return;
    }
    if (tracingConfig?.group_id !== this.#tracingConfig?.group_id || tracingConfig?.metadata !== this.#tracingConfig?.metadata || tracingConfig?.workflow_name !== this.#tracingConfig?.workflow_name) {
      logger_default3.warn("Mismatch in tracing config. Ignoring the new tracing config. This likely happens when you already set a tracing config on session creation. Current tracing config: %s, new tracing config: %s", JSON.stringify(this.#tracingConfig), JSON.stringify(tracingConfig));
      return;
    }
    this.sendEvent({
      type: "session.update",
      session: {
        type: "realtime",
        tracing: tracingConfig
      }
    });
  }
  updateSessionConfig(config2) {
    const sessionData = this.buildSessionPayload(config2);
    this.sendEvent({
      type: "session.update",
      session: sessionData
    });
  }
  sendFunctionCallOutput(toolCall, output, startResponse = true) {
    this.sendEvent({
      type: "conversation.item.create",
      item: {
        type: "function_call_output",
        output,
        call_id: toolCall.callId
      }
    });
    try {
      const item = realtimeToolCallItem.parse({
        itemId: toolCall.id,
        previousItemId: toolCall.previousItemId,
        type: "function_call",
        status: "completed",
        arguments: toolCall.arguments,
        name: toolCall.name,
        output
      });
      this.emit("item_update", item);
    } catch (error47) {
      logger_default3.error("Error parsing tool call item", error47, toolCall);
    }
    if (startResponse) {
      this.sendEvent({
        type: "response.create"
      });
    }
  }
  sendAudio(audio, { commit = false } = {}) {
    this.sendEvent({
      type: "input_audio_buffer.append",
      audio: arrayBufferToBase64(audio)
    });
    if (commit) {
      this.sendEvent({
        type: "input_audio_buffer.commit"
      });
    }
  }
  resetHistory(oldHistory, newHistory) {
    const { removals, additions, updates } = diffRealtimeHistory(oldHistory, newHistory);
    const removalIds = new Set(removals.map((item) => item.itemId));
    for (const update of updates) {
      removalIds.add(update.itemId);
    }
    if (removalIds.size > 0) {
      for (const itemId of removalIds) {
        this.sendEvent({
          type: "conversation.item.delete",
          item_id: itemId
        });
      }
    }
    const additionsAndUpdates = [...additions, ...updates];
    for (const addition of additionsAndUpdates) {
      if (addition.type === "message") {
        const itemEntry = {
          type: "message",
          role: addition.role,
          content: addition.content,
          id: addition.itemId
        };
        if (addition.role !== "system" && addition.status) {
          itemEntry.status = addition.status;
        }
        this.sendEvent({
          type: "conversation.item.create",
          item: itemEntry
        });
      } else if (addition.type === "function_call") {
        logger_default3.warn("Function calls cannot be manually added or updated at the moment. Ignoring.");
      }
    }
  }
  sendMcpResponse(approvalRequest, approved) {
    this.sendEvent({
      type: "conversation.item.create",
      previous_item_id: approvalRequest.itemId,
      item: {
        type: "mcp_approval_response",
        approval_request_id: approvalRequest.itemId,
        approve: approved
      }
    });
  }
}

// node_modules/@openai/agents-realtime/dist/openaiRealtimeWebRtc.mjs
class OpenAIRealtimeWebRTC extends OpenAIRealtimeBase {
  options;
  #url;
  #state = {
    status: "disconnected",
    peerConnection: undefined,
    dataChannel: undefined,
    callId: undefined
  };
  #useInsecureApiKey;
  #ongoingResponse = false;
  #muted = false;
  constructor(options = {}) {
    if (typeof RTCPeerConnection === "undefined") {
      throw new Error("WebRTC is not supported in this environment");
    }
    super(options);
    this.options = options;
    this.#url = options.baseUrl ?? `https://api.openai.com/v1/realtime/calls`;
    this.#useInsecureApiKey = options.useInsecureApiKey ?? false;
  }
  get callId() {
    return this.#state.callId;
  }
  get status() {
    return this.#state.status;
  }
  get connectionState() {
    return this.#state;
  }
  get muted() {
    return this.#muted;
  }
  async connect(options) {
    if (this.#state.status === "connected") {
      return;
    }
    if (this.#state.status === "connecting") {
      logger_default3.warn("Realtime connection already in progress. Please await original promise");
    }
    const model = options.model ?? this.currentModel;
    this.currentModel = model;
    const baseUrl = options.url ?? this.#url;
    const apiKey = await this._getApiKey(options);
    const isClientKey = typeof apiKey === "string" && apiKey.startsWith("ek_");
    if (isBrowserEnvironment() && !this.#useInsecureApiKey && !isClientKey) {
      throw new UserError("Using the WebRTC connection in a browser environment requires an ephemeral client key. If you need to use a regular API key, use the WebSocket transport or set the `useInsecureApiKey` option to true.");
    }
    return new Promise(async (resolve, reject) => {
      try {
        const userSessionConfig = {
          ...options.initialSessionConfig || {},
          model: this.currentModel
        };
        const connectionUrl = new URL(baseUrl);
        let peerConnection = new RTCPeerConnection;
        const dataChannel = peerConnection.createDataChannel("oai-events");
        let callId = undefined;
        const attachConnectionStateHandler = (connection) => {
          connection.onconnectionstatechange = () => {
            switch (connection.connectionState) {
              case "disconnected":
              case "failed":
              case "closed":
                this.close();
                break;
            }
          };
        };
        attachConnectionStateHandler(peerConnection);
        this.#state = {
          status: "connecting",
          peerConnection,
          dataChannel,
          callId
        };
        this.emit("connection_change", this.#state.status);
        dataChannel.addEventListener("open", () => {
          this.#state = {
            status: "connected",
            peerConnection,
            dataChannel,
            callId
          };
          this.updateSessionConfig(userSessionConfig);
          this.emit("connection_change", this.#state.status);
          this._onOpen();
          resolve();
        });
        dataChannel.addEventListener("error", (event) => {
          this.close();
          this._onError(event);
          reject(event);
        });
        dataChannel.addEventListener("message", (event) => {
          this._onMessage(event);
          const { data: parsed, isGeneric } = parseRealtimeEvent(event);
          if (!parsed || isGeneric) {
            return;
          }
          if (parsed.type === "response.created") {
            this.#ongoingResponse = true;
          } else if (parsed.type === "response.done") {
            this.#ongoingResponse = false;
          }
          if (parsed.type === "session.created") {
            this._tracingConfig = parsed.session.tracing;
            const tracingConfig = typeof userSessionConfig.tracing === "undefined" ? "auto" : userSessionConfig.tracing;
            this._updateTracingConfig(tracingConfig);
          }
        });
        const audioElement = this.options.audioElement ?? document.createElement("audio");
        audioElement.autoplay = true;
        peerConnection.ontrack = (event) => {
          audioElement.srcObject = event.streams[0];
        };
        const stream = this.options.mediaStream ?? await navigator.mediaDevices.getUserMedia({
          audio: true
        });
        peerConnection.addTrack(stream.getAudioTracks()[0]);
        if (this.options.changePeerConnection) {
          const originalPeerConnection = peerConnection;
          peerConnection = await this.options.changePeerConnection(peerConnection);
          if (originalPeerConnection !== peerConnection) {
            originalPeerConnection.onconnectionstatechange = null;
          }
          attachConnectionStateHandler(peerConnection);
          this.#state = { ...this.#state, peerConnection };
        }
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        if (!offer.sdp) {
          throw new Error("Failed to create offer");
        }
        const sdpResponse = await fetch(connectionUrl, {
          method: "POST",
          body: offer.sdp,
          headers: {
            "Content-Type": "application/sdp",
            Authorization: `Bearer ${apiKey}`,
            "X-OpenAI-Agents-SDK": HEADERS2["X-OpenAI-Agents-SDK"]
          }
        });
        callId = sdpResponse.headers?.get("Location")?.split("/").pop();
        this.#state = { ...this.#state, callId };
        const answer = {
          type: "answer",
          sdp: await sdpResponse.text()
        };
        await peerConnection.setRemoteDescription(answer);
      } catch (error47) {
        this.close();
        this._onError(error47);
        reject(error47);
      }
    });
  }
  sendEvent(event) {
    if (!this.#state.dataChannel || this.#state.dataChannel.readyState !== "open") {
      throw new Error("WebRTC data channel is not connected. Make sure you call `connect()` before sending events.");
    }
    this.#state.dataChannel.send(JSON.stringify(event));
  }
  mute(muted) {
    this.#muted = muted;
    if (this.#state.peerConnection) {
      const peerConnection = this.#state.peerConnection;
      peerConnection.getSenders().forEach((sender) => {
        if (sender.track) {
          sender.track.enabled = !muted;
        }
      });
    }
  }
  _afterAudioDoneEvent() {
    this.#ongoingResponse = false;
  }
  close() {
    if (this.#state.dataChannel) {
      this.#state.dataChannel.close();
    }
    if (this.#state.peerConnection) {
      const peerConnection = this.#state.peerConnection;
      peerConnection.onconnectionstatechange = null;
      peerConnection.getSenders().forEach((sender) => {
        sender.track?.stop();
      });
      peerConnection.close();
    }
    if (this.#state.status !== "disconnected") {
      this.#state = {
        status: "disconnected",
        peerConnection: undefined,
        dataChannel: undefined,
        callId: undefined
      };
      this.emit("connection_change", this.#state.status);
      this._onClose();
    }
  }
  interrupt() {
    if (this.#ongoingResponse) {
      this.sendEvent({
        type: "response.cancel"
      });
      this.#ongoingResponse = false;
    }
    this.sendEvent({
      type: "output_audio_buffer.clear"
    });
  }
}

// node_modules/@openai/agents-realtime/dist/shims/shims-node.mjs
import { WebSocket } from "ws";
function isBrowserEnvironment2() {
  return false;
}
var useWebSocketProtocols = false;

// node_modules/@openai/agents-realtime/dist/openaiRealtimeWebsocket.mjs
class OpenAIRealtimeWebSocket extends OpenAIRealtimeBase {
  #apiKey;
  #url;
  #defaultUrl;
  #state = {
    status: "disconnected",
    websocket: undefined
  };
  #useInsecureApiKey;
  #currentItemId;
  #currentAudioContentIndex;
  _firstAudioTimestamp;
  _audioLengthMs = 0;
  #ongoingResponse = false;
  #createWebSocket;
  #skipOpenEventListeners;
  #resetAudioPlaybackState() {
    this.#currentItemId = undefined;
    this._firstAudioTimestamp = undefined;
    this._audioLengthMs = 0;
    this.#currentAudioContentIndex = undefined;
  }
  constructor(options = {}) {
    super(options);
    this.#url = options.url;
    this.#defaultUrl = options.url;
    this.#useInsecureApiKey = options.useInsecureApiKey ?? false;
    this.#createWebSocket = options.createWebSocket;
    this.#skipOpenEventListeners = options.skipOpenEventListeners ?? false;
  }
  getCommonRequestHeaders() {
    return HEADERS2;
  }
  get status() {
    return this.#state.status;
  }
  get connectionState() {
    return this.#state;
  }
  get muted() {
    return null;
  }
  get currentItemId() {
    return this.#currentItemId;
  }
  _onAudio(audioEvent) {
    this.emit("audio", audioEvent);
  }
  _afterAudioDoneEvent() {
    this.#resetAudioPlaybackState();
  }
  async#setupWebSocket(resolve, reject, sessionConfig) {
    if (this.#state.websocket) {
      resolve();
      return;
    }
    if (!this.#apiKey) {
      throw new UserError("API key is not set. Please call `connect()` with an API key first.");
    }
    if (isBrowserEnvironment2() && !this.#apiKey.startsWith("ek_") && !this.#useInsecureApiKey) {
      throw new UserError("Using the WebSocket connection in a browser environment requires an ephemeral client key. If you have to use a regular API key, set the `useInsecureApiKey` option to true.");
    }
    let ws = null;
    if (this.#createWebSocket) {
      ws = await this.#createWebSocket({
        url: this.#url,
        apiKey: this.#apiKey
      });
    } else {
      const websocketArguments = useWebSocketProtocols ? [
        "realtime",
        "openai-insecure-api-key." + this.#apiKey,
        WEBSOCKET_META
      ] : {
        headers: {
          Authorization: `Bearer ${this.#apiKey}`,
          ...this.getCommonRequestHeaders()
        }
      };
      ws = new WebSocket(this.#url, websocketArguments);
    }
    this.#state = {
      status: "connecting",
      websocket: ws
    };
    this.emit("connection_change", this.#state.status);
    const onSocketOpenReady = () => {
      this.#state = {
        status: "connected",
        websocket: ws
      };
      this.emit("connection_change", this.#state.status);
      this._onOpen();
      resolve();
    };
    if (this.#skipOpenEventListeners === true) {
      onSocketOpenReady();
    } else {
      ws.addEventListener("open", onSocketOpenReady);
    }
    ws.addEventListener("error", (error47) => {
      this._onError(error47);
      this.#state = {
        status: "disconnected",
        websocket: undefined
      };
      this.emit("connection_change", this.#state.status);
      reject(error47);
    });
    ws.addEventListener("message", (message) => {
      this._onMessage(message);
      const { data: parsed, isGeneric } = parseRealtimeEvent(message);
      if (!parsed || isGeneric) {
        return;
      }
      if (parsed.type === "response.output_audio.delta") {
        this.#currentAudioContentIndex = parsed.content_index;
        this.#currentItemId = parsed.item_id;
        if (this._firstAudioTimestamp === undefined) {
          this._firstAudioTimestamp = Date.now();
          this._audioLengthMs = 0;
        }
        const buff = base64ToArrayBuffer(parsed.delta);
        const fmt = this._rawSessionConfig?.audio?.output?.format;
        if (fmt && typeof fmt === "object") {
          const t = fmt.type;
          if (t === "audio/pcmu" || t === "audio/pcma") {
            this._audioLengthMs += buff.byteLength / 8;
          } else if (t === "audio/pcm") {
            const rate = fmt.rate ?? 24000;
            this._audioLengthMs += buff.byteLength / 2 / rate * 1000;
          } else {
            this._audioLengthMs += buff.byteLength / 24 / 2;
          }
        } else if (typeof fmt === "string") {
          if (fmt.startsWith("g711_")) {
            this._audioLengthMs += buff.byteLength / 8;
          } else {
            this._audioLengthMs += buff.byteLength / 24 / 2;
          }
        } else {
          this._audioLengthMs += buff.byteLength / 24 / 2;
        }
        const audioEvent = {
          type: "audio",
          data: buff,
          responseId: parsed.response_id
        };
        this._onAudio(audioEvent);
      } else if (parsed.type === "input_audio_buffer.speech_started") {
        const automaticResponseCancellationEnabled = this._rawSessionConfig?.audio?.input?.turn_detection?.interrupt_response ?? false;
        this.interrupt(!automaticResponseCancellationEnabled);
      } else if (parsed.type === "response.created") {
        this.#ongoingResponse = true;
      } else if (parsed.type === "response.done") {
        this.#ongoingResponse = false;
      } else if (parsed.type === "session.created") {
        this._tracingConfig = parsed.session.tracing;
        const tracingConfig = typeof sessionConfig.tracing === "undefined" ? "auto" : sessionConfig.tracing;
        this._updateTracingConfig(tracingConfig);
      }
    });
    ws.addEventListener("close", () => {
      this.#state = {
        status: "disconnected",
        websocket: undefined
      };
      this.emit("connection_change", this.#state.status);
      this._onClose();
    });
  }
  async connect(options) {
    const model = options.model ?? this.currentModel;
    this.currentModel = model;
    this.#apiKey = await this._getApiKey(options);
    const callId = options.callId;
    let url2;
    if (options.url) {
      url2 = options.url;
      this.#defaultUrl = options.url;
    } else if (callId) {
      url2 = `wss://api.openai.com/v1/realtime?call_id=${callId}`;
    } else if (this.#defaultUrl) {
      url2 = this.#defaultUrl;
    } else {
      url2 = `wss://api.openai.com/v1/realtime?model=${this.currentModel}`;
    }
    this.#url = url2;
    const sessionConfig = {
      ...options.initialSessionConfig || {},
      model: this.currentModel
    };
    await new Promise((resolve, reject) => {
      this.#setupWebSocket(resolve, reject, sessionConfig).catch(reject);
    });
    await this.updateSessionConfig(sessionConfig);
  }
  sendEvent(event) {
    if (!this.#state.websocket) {
      throw new Error("WebSocket is not connected. Make sure you call `connect()` before sending events.");
    }
    this.#state.websocket.send(JSON.stringify(event));
  }
  close() {
    this.#state.websocket?.close();
    this.#currentItemId = undefined;
    this._firstAudioTimestamp = undefined;
    this._audioLengthMs = 0;
    this.#currentAudioContentIndex = undefined;
  }
  mute(_muted) {
    throw new Error("Mute is not supported for the WebSocket transport. You have to mute the audio input yourself.");
  }
  sendAudio(audio, options = {}) {
    if (this.#state.status === "connected") {
      super.sendAudio(audio, options);
    }
  }
  _cancelResponse() {
    if (this.#ongoingResponse) {
      this.sendEvent({
        type: "response.cancel"
      });
      this.#ongoingResponse = false;
    }
  }
  _interrupt(elapsedTime, cancelOngoingResponse = true) {
    if (elapsedTime < 0) {
      return;
    }
    if (cancelOngoingResponse) {
      this._cancelResponse();
    }
    const length = this._audioLengthMs ?? Number.POSITIVE_INFINITY;
    const audio_end_ms = Math.max(0, Math.floor(Math.min(elapsedTime, length)));
    this.emit("audio_interrupted");
    this.sendEvent({
      type: "conversation.item.truncate",
      item_id: this.#currentItemId,
      content_index: this.#currentAudioContentIndex,
      audio_end_ms
    });
  }
  interrupt(cancelOngoingResponse = true) {
    if (!this.#currentItemId || typeof this._firstAudioTimestamp !== "number") {
      return;
    }
    const elapsedTime = Date.now() - this._firstAudioTimestamp;
    if (elapsedTime >= 0) {
      this._interrupt(elapsedTime, cancelOngoingResponse);
    }
    this.#resetAudioPlaybackState();
  }
}

// node_modules/@openai/agents-realtime/dist/tool.mjs
var BACKGROUND_RESULT_SYMBOL = Symbol("backgroundResult");
function isBackgroundResult(result) {
  return typeof result === "object" && result !== null && BACKGROUND_RESULT_SYMBOL in result;
}
function isValidRealtimeTool(tool2) {
  return tool2.type === "function" || tool2.type === "hosted_tool" && tool2.name === "hosted_mcp";
}
function toRealtimeToolDefinition(tool2) {
  if (tool2.type === "function") {
    return tool2;
  }
  if (tool2.type === "hosted_tool" && tool2.name === "hosted_mcp") {
    const serverUrl = tool2.providerData.server_url && tool2.providerData.server_url.length > 0 ? tool2.providerData.server_url : undefined;
    return {
      type: "mcp",
      server_label: tool2.providerData.server_label,
      server_url: serverUrl,
      headers: tool2.providerData.headers,
      allowed_tools: tool2.providerData.allowed_tools,
      require_approval: tool2.providerData.require_approval
    };
  }
  throw new UserError(`Invalid tool type: ${tool2}`);
}

// node_modules/@openai/agents-realtime/dist/realtimeSession.mjs
function cloneDefaultSessionConfig() {
  return JSON.parse(JSON.stringify(DEFAULT_OPENAI_REALTIME_SESSION_CONFIG));
}

class RealtimeSession extends EventEmitter {
  initialAgent;
  options;
  #transport;
  #currentAgent;
  #currentTools;
  #context;
  #outputGuardrails = [];
  #outputGuardrailSettings;
  #transcribedTextDeltas = {};
  #history = [];
  #shouldIncludeAudioData;
  #interruptedByGuardrail = {};
  #audioStarted = false;
  #allMcpToolsByServer = new Map;
  #availableMcpTools = [];
  #lastSessionConfig = cloneDefaultSessionConfig();
  #automaticallyTriggerResponseForMcpToolCalls = true;
  constructor(initialAgent, options = {}) {
    super();
    this.initialAgent = initialAgent;
    this.options = options;
    if (typeof options.transport === "undefined" && hasWebRTCSupport() || options.transport === "webrtc") {
      this.#transport = new OpenAIRealtimeWebRTC;
    } else if (options.transport === "websocket" || typeof options.transport === "undefined") {
      this.#transport = new OpenAIRealtimeWebSocket;
    } else {
      this.#transport = options.transport;
    }
    this.#currentAgent = initialAgent;
    this.#context = new RunContext({
      ...options.context ?? {},
      history: this.#history
    });
    this.#outputGuardrails = (options.outputGuardrails ?? []).map(defineRealtimeOutputGuardrail);
    this.#outputGuardrailSettings = getRealtimeGuardrailSettings(options.outputGuardrailSettings ?? {});
    this.#shouldIncludeAudioData = options.historyStoreAudio ?? false;
    this.#automaticallyTriggerResponseForMcpToolCalls = options.automaticallyTriggerResponseForMcpToolCalls ?? true;
  }
  get transport() {
    return this.#transport;
  }
  get currentAgent() {
    return this.#currentAgent;
  }
  get usage() {
    return this.#context.usage;
  }
  get context() {
    return this.#context;
  }
  get muted() {
    return this.#transport.muted;
  }
  get history() {
    return this.#history;
  }
  get availableMcpTools() {
    return this.#availableMcpTools;
  }
  async#setCurrentAgent(agent) {
    this.#currentAgent = agent;
    const handoffs = await this.#currentAgent.getEnabledHandoffs(this.#context);
    const handoffTools = handoffs.map((handoff2) => handoff2.getHandoffAsFunctionTool());
    const allTools = (await this.#currentAgent.getAllTools(this.#context)).filter(isValidRealtimeTool).map(toRealtimeToolDefinition);
    const hasToolsDefined = typeof this.#currentAgent.tools !== "undefined" || typeof this.#currentAgent.mcpServers !== "undefined";
    const hasHandoffsDefined = handoffs.length > 0;
    this.#currentTools = hasToolsDefined || hasHandoffsDefined ? [...allTools, ...handoffTools] : undefined;
    this.#updateAvailableMcpTools();
  }
  async#getSessionConfig(additionalConfig = {}) {
    const overridesConfig = additionalConfig ?? {};
    const optionsConfig = this.options.config ?? {};
    const instructions = await this.#currentAgent.getSystemPrompt(this.#context);
    const getAudioOutputVoiceOverride = (config2) => {
      const audioConfig = config2.audio;
      return audioConfig?.output?.voice;
    };
    const tracingConfig = this.options.tracingDisabled ? null : this.options.workflowName ? {
      workflow_name: this.options.workflowName
    } : "auto";
    if (tracingConfig !== null && tracingConfig !== "auto") {
      if (this.options.groupId) {
        tracingConfig.group_id = this.options.groupId;
      }
      if (this.options.traceMetadata) {
        tracingConfig.metadata = this.options.traceMetadata;
      }
    } else if (this.options.groupId || this.options.traceMetadata) {
      logger_default3.warn("In order to set traceMetadata or a groupId you need to specify a workflowName.");
    }
    const audioOutputVoiceOverride = getAudioOutputVoiceOverride(overridesConfig) ?? getAudioOutputVoiceOverride(optionsConfig);
    const topLevelVoiceOverride = overridesConfig.voice ?? optionsConfig.voice;
    const resolvedVoice = typeof audioOutputVoiceOverride !== "undefined" ? audioOutputVoiceOverride : typeof topLevelVoiceOverride !== "undefined" ? topLevelVoiceOverride : this.#currentAgent.voice;
    const base = {
      ...this.#lastSessionConfig ?? {},
      ...optionsConfig,
      ...overridesConfig
    };
    const fullConfig = {
      ...base,
      instructions,
      voice: resolvedVoice,
      model: this.options.model,
      tools: this.#currentTools,
      tracing: tracingConfig,
      prompt: typeof this.#currentAgent.prompt === "function" ? await this.#currentAgent.prompt(this.#context, this.#currentAgent) : this.#currentAgent.prompt
    };
    this.#lastSessionConfig = fullConfig;
    return fullConfig;
  }
  async getInitialSessionConfig(overrides = {}) {
    await this.#setCurrentAgent(this.initialAgent);
    return this.#getSessionConfig({
      ...this.options.config ?? {},
      ...overrides ?? {}
    });
  }
  static async computeInitialSessionConfig(agent, options = {}, overrides = {}) {
    const session = new RealtimeSession(agent, options);
    try {
      return await session.getInitialSessionConfig(overrides);
    } finally {
      session.close();
    }
  }
  async updateAgent(newAgent) {
    this.#currentAgent.emit("agent_handoff", this.#context, newAgent);
    this.emit("agent_handoff", this.#context, this.#currentAgent, newAgent);
    await this.#setCurrentAgent(newAgent);
    await this.#transport.updateSessionConfig(await this.#getSessionConfig());
    return newAgent;
  }
  async#handleHandoff(toolCall, handoff2) {
    const newAgent = await handoff2.onInvokeHandoff(this.#context, toolCall.arguments);
    this.#currentAgent.emit("agent_handoff", this.#context, newAgent);
    this.emit("agent_handoff", this.#context, this.#currentAgent, newAgent);
    await this.#setCurrentAgent(newAgent);
    await this.#transport.updateSessionConfig(await this.#getSessionConfig());
    const output = getTransferMessage(newAgent);
    this.#transport.sendFunctionCallOutput(toolCall, output, true);
    return newAgent;
  }
  async#handleFunctionToolCall(toolCall, tool2) {
    this.#context.context.history = JSON.parse(JSON.stringify(this.#history));
    let parsedArgs = toolCall.arguments;
    if (tool2.parameters) {
      if (isZodObject(tool2.parameters)) {
        parsedArgs = tool2.parameters.parse(parsedArgs);
      } else {
        parsedArgs = JSON.parse(parsedArgs);
      }
    }
    const needsApproval = await tool2.needsApproval(this.#context, parsedArgs, toolCall.callId);
    if (needsApproval) {
      const approval = this.context.isToolApproved({
        toolName: tool2.name,
        callId: toolCall.callId
      });
      if (approval === false) {
        this.emit("agent_tool_start", this.#context, this.#currentAgent, tool2, {
          toolCall
        });
        this.#currentAgent.emit("agent_tool_start", this.#context, tool2, {
          toolCall
        });
        const result2 = "Tool execution was not approved.";
        this.#transport.sendFunctionCallOutput(toolCall, result2, true);
        this.emit("agent_tool_end", this.#context, this.#currentAgent, tool2, result2, { toolCall });
        this.#currentAgent.emit("agent_tool_end", this.#context, tool2, result2, {
          toolCall
        });
        return;
      } else if (typeof approval === "undefined") {
        this.emit("tool_approval_requested", this.#context, this.#currentAgent, {
          type: "function_approval",
          tool: tool2,
          approvalItem: new RunToolApprovalItem(toolCall, this.#currentAgent)
        });
        return;
      }
    }
    this.emit("agent_tool_start", this.#context, this.#currentAgent, tool2, {
      toolCall
    });
    this.#currentAgent.emit("agent_tool_start", this.#context, tool2, {
      toolCall
    });
    this.#context.context.history = JSON.parse(JSON.stringify(this.#history));
    const result = await tool2.invoke(this.#context, toolCall.arguments, {
      toolCall
    });
    let stringResult;
    if (isBackgroundResult(result)) {
      stringResult = toSmartString(result.content);
      this.#transport.sendFunctionCallOutput(toolCall, stringResult, false);
    } else {
      stringResult = toSmartString(result);
      this.#transport.sendFunctionCallOutput(toolCall, stringResult, true);
    }
    this.emit("agent_tool_end", this.#context, this.#currentAgent, tool2, stringResult, { toolCall });
    this.#currentAgent.emit("agent_tool_end", this.#context, tool2, stringResult, { toolCall });
  }
  async#handleFunctionCall(toolCall) {
    const enabledHandoffs = await this.#currentAgent.getEnabledHandoffs(this.#context);
    const handoffMap = new Map(enabledHandoffs.map((handoff2) => [handoff2.toolName, handoff2]));
    const allTools = await this.#currentAgent.getAllTools(this.#context);
    const functionToolMap = new Map(allTools.map((tool2) => [tool2.name, tool2]));
    const possibleHandoff = handoffMap.get(toolCall.name);
    if (possibleHandoff) {
      await this.#handleHandoff(toolCall, possibleHandoff);
    } else {
      const functionTool = functionToolMap.get(toolCall.name);
      if (functionTool && functionTool.type === "function") {
        await this.#handleFunctionToolCall(toolCall, functionTool);
      } else {
        throw new ModelBehaviorError(`Tool ${toolCall.name} not found`);
      }
    }
  }
  async#runOutputGuardrails(output, responseId, itemId) {
    if (this.#outputGuardrails.length === 0) {
      return;
    }
    const guardrailArgs = {
      agent: this.#currentAgent,
      agentOutput: output,
      context: this.#context
    };
    const results = await Promise.all(this.#outputGuardrails.map((guardrail) => guardrail.run(guardrailArgs)));
    const firstTripwireTriggered = results.find((result) => result.output.tripwireTriggered);
    if (firstTripwireTriggered) {
      if (this.#interruptedByGuardrail[responseId]) {
        return;
      }
      this.#interruptedByGuardrail[responseId] = true;
      const error47 = new OutputGuardrailTripwireTriggered(`Output guardrail triggered: ${JSON.stringify(firstTripwireTriggered.output.outputInfo)}`, firstTripwireTriggered);
      this.emit("guardrail_tripped", this.#context, this.#currentAgent, error47, {
        itemId
      });
      this.interrupt();
      const feedbackText = getRealtimeGuardrailFeedbackMessage(firstTripwireTriggered);
      this.sendMessage(feedbackText);
      return;
    }
  }
  #setEventListeners() {
    this.#transport.on("*", (event) => {
      this.emit("transport_event", event);
      if (event.type === "conversation.item.input_audio_transcription.completed") {
        try {
          const completedEvent = event;
          this.#history = updateRealtimeHistory(this.#history, completedEvent, this.#shouldIncludeAudioData);
          this.#context.context.history = this.#history;
          this.emit("history_updated", this.#history);
        } catch (err) {
          this.emit("error", {
            type: "error",
            error: err
          });
        }
      }
    });
    this.#transport.on("mcp_tools_listed", ({ serverLabel, tools }) => {
      try {
        this.#allMcpToolsByServer.set(serverLabel, tools ?? []);
        this.#updateAvailableMcpTools();
      } catch (err) {
        this.emit("error", { type: "error", error: err });
      }
    });
    this.#transport.on("audio", (event) => {
      if (!this.#audioStarted) {
        this.#audioStarted = true;
        this.emit("audio_start", this.#context, this.#currentAgent);
      }
      this.emit("audio", event);
    });
    this.#transport.on("turn_started", () => {
      this.#audioStarted = false;
      this.emit("agent_start", this.#context, this.#currentAgent);
      this.#currentAgent.emit("agent_start", this.#context, this.#currentAgent);
    });
    this.#transport.on("turn_done", (event) => {
      const item = event.response.output[event.response.output.length - 1];
      const textOutput = getLastTextFromAudioOutputMessage(item) ?? "";
      const itemId = item?.id ?? "";
      this.emit("agent_end", this.#context, this.#currentAgent, textOutput);
      this.#currentAgent.emit("agent_end", this.#context, textOutput);
      this.#runOutputGuardrails(textOutput, event.response.id, itemId);
    });
    this.#transport.on("audio_done", () => {
      if (this.#audioStarted) {
        this.#audioStarted = false;
      }
      this.emit("audio_stopped", this.#context, this.#currentAgent);
    });
    let lastRunIndex = 0;
    let lastItemId;
    this.#transport.on("audio_transcript_delta", (event) => {
      try {
        const delta = event.delta;
        const itemId = event.itemId;
        const responseId = event.responseId;
        if (lastItemId !== itemId) {
          lastItemId = itemId;
          lastRunIndex = 0;
        }
        const currentText = this.#transcribedTextDeltas[itemId] ?? "";
        const newText = currentText + delta;
        this.#transcribedTextDeltas[itemId] = newText;
        if (this.#outputGuardrailSettings.debounceTextLength < 0) {
          return;
        }
        const newRunIndex = Math.floor(newText.length / this.#outputGuardrailSettings.debounceTextLength);
        if (newRunIndex > lastRunIndex) {
          lastRunIndex = newRunIndex;
          this.#runOutputGuardrails(newText, responseId, itemId);
        }
      } catch (err) {
        this.emit("error", {
          type: "error",
          error: err
        });
      }
    });
    this.#transport.on("item_update", (event) => {
      try {
        const isNew = !this.#history.some((item) => item.itemId === event.itemId);
        this.#history = updateRealtimeHistory(this.#history, event, this.#shouldIncludeAudioData);
        this.#context.context.history = this.#history;
        if (isNew) {
          const addedItem = this.#history.find((item) => item.itemId === event.itemId);
          if (addedItem) {
            this.emit("history_added", addedItem);
          }
        }
        this.emit("history_updated", this.#history);
      } catch (err) {
        this.emit("error", {
          type: "error",
          error: err
        });
      }
    });
    this.#transport.on("item_deleted", (event) => {
      try {
        this.#history = this.#history.filter((item) => item.itemId !== event.itemId);
        this.#context.context.history = this.#history;
        this.emit("history_updated", this.#history);
      } catch (err) {
        this.emit("error", {
          type: "error",
          error: err
        });
      }
    });
    this.#transport.on("function_call", async (event) => {
      try {
        await this.#handleFunctionCall(event);
      } catch (error47) {
        logger_default3.error("Error handling function call", error47);
        this.emit("error", {
          type: "error",
          error: error47
        });
      }
    });
    this.#transport.on("usage_update", (usage) => {
      this.#context.usage.add(usage);
    });
    this.#transport.on("audio_interrupted", () => {
      if (this.#audioStarted) {
        this.#audioStarted = false;
      }
      this.emit("audio_interrupted", this.#context, this.#currentAgent);
    });
    this.#transport.on("error", (error47) => {
      this.emit("error", error47);
    });
    this.#transport.on("mcp_tool_call_completed", (toolCall) => {
      this.emit("mcp_tool_call_completed", this.#context, this.#currentAgent, toolCall);
      if (this.#automaticallyTriggerResponseForMcpToolCalls) {
        this.#transport.sendEvent({
          type: "response.create"
        });
      }
    });
    this.#transport.on("mcp_approval_request", (approvalRequest) => {
      this.emit("tool_approval_requested", this.#context, this.#currentAgent, {
        type: "mcp_approval_request",
        approvalItem: realtimeApprovalItemToApprovalItem(this.#currentAgent, approvalRequest)
      });
    });
  }
  #updateAvailableMcpTools() {
    const activeMcpConfigs = this.#currentTools?.filter((t) => t.type === "mcp");
    const allowedFromConfig = (cfg) => {
      const allowed = cfg.allowed_tools;
      if (!allowed)
        return;
      if (Array.isArray(allowed))
        return allowed;
      if (allowed && Array.isArray(allowed.tool_names))
        return allowed.tool_names;
      return;
    };
    const dedupByName = new Map;
    for (const cfg of activeMcpConfigs) {
      const tools = this.#allMcpToolsByServer.get(cfg.server_label) ?? [];
      const allowed = allowedFromConfig(cfg);
      for (const tool2 of tools) {
        if (allowed && !allowed.includes(tool2.name))
          continue;
        if (!dedupByName.has(tool2.name)) {
          dedupByName.set(tool2.name, tool2);
        }
      }
    }
    const next = Array.from(dedupByName.values());
    const prev = this.#availableMcpTools;
    const changed = prev.length !== next.length || JSON.stringify(prev.map((t) => t.name).sort()) !== JSON.stringify(next.map((t) => t.name).sort());
    if (changed) {
      this.#availableMcpTools = next;
      this.emit("mcp_tools_changed", this.#availableMcpTools);
    }
  }
  async connect(options) {
    await this.#setCurrentAgent(this.initialAgent);
    this.#setEventListeners();
    await this.#transport.connect({
      apiKey: options.apiKey ?? this.options.apiKey,
      model: this.options.model,
      url: options.url,
      callId: options.callId,
      initialSessionConfig: await this.#getSessionConfig(this.options.config)
    });
    this.#history = [];
    this.emit("history_updated", this.#history);
  }
  updateHistory(newHistory) {
    let updatedHistory;
    if (typeof newHistory === "function") {
      updatedHistory = newHistory(this.#history);
    } else {
      updatedHistory = newHistory;
    }
    this.#transport.resetHistory(this.#history, updatedHistory);
  }
  sendMessage(message, otherEventData = {}) {
    this.#transport.sendMessage(message, otherEventData);
  }
  addImage(image, { triggerResponse = true } = {}) {
    this.#transport.addImage(image, { triggerResponse });
  }
  mute(muted) {
    this.#transport.mute(muted);
  }
  close() {
    this.#interruptedByGuardrail = {};
    this.#transport.close();
  }
  sendAudio(audio, options = {}) {
    this.#transport.sendAudio(audio, options);
  }
  interrupt() {
    this.#transport.interrupt();
  }
  async approve(approvalItem, options = { alwaysApprove: false }) {
    this.#context.approveTool(approvalItem, options);
    const toolName = approvalItem.toolName ?? approvalItem.rawItem.name;
    const tool2 = this.#currentAgent.tools.find((tool3) => tool3.name === toolName);
    if (tool2 && tool2.type === "function" && approvalItem.rawItem.type === "function_call") {
      await this.#handleFunctionToolCall(approvalItem.rawItem, tool2);
    } else if (approvalItem.rawItem.type === "hosted_tool_call") {
      if (options.alwaysApprove) {
        logger_default3.warn("Always approving MCP tools is not supported. Use the allowed tools configuration instead.");
      }
      const mcpApprovalRequest = approvalItemToRealtimeApprovalItem(approvalItem);
      this.#transport.sendMcpResponse(mcpApprovalRequest, true);
    } else {
      throw new ModelBehaviorError(`Tool ${toolName ?? "unknown"} not found`);
    }
  }
  async reject(approvalItem, options = { alwaysReject: false }) {
    this.#context.rejectTool(approvalItem, options);
    const toolName = approvalItem.toolName ?? approvalItem.rawItem.name;
    const tool2 = this.#currentAgent.tools.find((tool3) => tool3.name === toolName);
    if (tool2 && tool2.type === "function" && approvalItem.rawItem.type === "function_call") {
      await this.#handleFunctionToolCall(approvalItem.rawItem, tool2);
    } else if (approvalItem.rawItem.type === "hosted_tool_call") {
      if (options.alwaysReject) {
        logger_default3.warn("Always rejecting MCP tools is not supported. Use the allowed tools configuration instead.");
      }
      const mcpApprovalRequest = approvalItemToRealtimeApprovalItem(approvalItem);
      this.#transport.sendMcpResponse(mcpApprovalRequest, false);
    } else {
      throw new ModelBehaviorError(`Tool ${toolName ?? "unknown"} not found`);
    }
  }
}
// node_modules/@openai/agents/dist/index.mjs
setDefaultModelProvider(new OpenAIProvider);
setDefaultOpenAITracingExporter();

// src/agents/plannerAgent.ts
init_v4();

// src/agents/constants.ts
var AgentType;
((AgentType2) => {
  AgentType2["FinancialAnalystAgent"] = "FinancialAnalystAgent";
  AgentType2["NewsAnalystAgent"] = "NewsAnalystAgent";
  AgentType2["WriterAgent"] = "WriterAgent";
})(AgentType ||= {});

// src/agents/plannerAgent.ts
var plannerPrompt = [
  "You are a research planning coordinator.",
  "Coordinate market research by delegating to specialized agents:",
  "- FinancialAnalystAgent: For stock data analysis",
  "- NewsAnalystAgent: For news gathering and analysis",
  "- WriterAgent: For compiling final report",
  "Always send your plan first, then handoff to appropriate agent.",
  "Always handoff to a single agent at a time.",
  "Use TERMINATE when research is complete."
].join(" ");
var leadAgentSchema = exports_external2.object({
  client: exports_external2.string().describe("The client to research"),
  completed: exports_external2.boolean().describe("Whether the research is complete"),
  output: exports_external2.string().nullish().optional().describe("Final research result"),
  tasks: exports_external2.array(exports_external2.object({
    name: exports_external2.enum(AgentType).describe("next subagent name"),
    input: exports_external2.string().describe("Specific search query or instruction for the subagent")
  }))
});
var plannerAgent = new Agent({
  name: "FinancialPlannerAgent",
  instructions: plannerPrompt,
  model: "gpt-5-mini",
  outputType: leadAgentSchema
});

// src/agents/context.ts
function buildPromptWithContext(contextBuilder) {
  return async function(runContext) {
    return contextBuilder(runContext);
  };
}

// src/agents/newsAnalyst.ts
var prompt = buildPromptWithContext((appContext) => [
  "You are an elite Financial News Analyst specialized in market sentiment and catalyst identification.",
  'Note: When using Massive tools, prices are split-adjusted. Always use "get_today_date" first to establish the current timeframe.',
  `Using the Massive "list_ticker_news" tool, gather news for ${appContext.context.stockCode}. Filter out duplicates and low-value press releases.`,
  "Analyze the gathered data for:",
  "  - **Sentiment Score**: Determine a sentiment score (0-100, where 0 is extreme fear, 100 is extreme greed).",
  "  - **Catalysts**: Identify specific events (e.g., Earnings, FDA approval, Mergers, Macro shifts).",
  '  - **Time Horizon**: Tag each key insight as "Short-term" (Price shock), "Mid-term" (Trend), or "Long-term" (Fundamental).',
  "Every claim must have a citation (URL or Source Name)."
].join(" "));
var newsAnalystAgent = new Agent({
  name: "NewsAnalystAgent",
  instructions: prompt,
  model: "gpt-5.2"
});

// src/agents/writer.ts
init_v4();
var prompt2 = buildPromptWithContext((app) => [
  "You are an elite Investment Analyst and Lead Editor acting as a single-threaded autonomous agent.",
  `Your goal is to conduct deep market research on stock ${app.context.stockCode} and produce a "Short/Mid/Long-term Investment Analysis Report" in Traditional Chinese (\u7E41\u9AD4\u4E2D\u6587).`,
  'Note: When using Massive tools, prices are already stock split adjusted. Always use "get_today_date" first to anchor your analysis.',
  "## EXECUTION STEPS (Follow these strictly):",
  "**Step 1: News & Sentiment Analysis**",
  '- Use "list_ticker_news" (or equivalent tool) to gather recent news.',
  "- Filter out duplicates and low-value press releases.",
  "- **Action**: Determine a sentiment score (0-100) and identify key catalysts (e.g., Earnings, Macro, Regulatory).",
  "- Classify news impacts into Short-term (shock) vs. Long-term (fundamental).",
  "**Step 2: Technical Analysis**",
  '- Use "get_historical_prices" (OHLCV) or equivalent tools.',
  "- **Short-term (Daily)**: Check Momentum (RSI/MACD logic) and Volume spikes.",
  "- **Mid-term (Weekly)**: Identify Trends (MA20/MA50) and Patterns.",
  "- **Long-term (Monthly)**: Assess Macro Trend vs MA200.",
  "- **Action**: Calculate specific Support/Resistance levels and Stop-Loss zones.",
  "**Step 3: Synthesis & Reporting**",
  '- Cross-reference Step 1 & Step 2. (e.g., "News is bullish but Price is hitting resistance").',
  "- Write the final report in Markdown format.",
  "- Ensure the tone is professional, objective, and actionable.",
  "## Final Report Structure (Markdown):",
  "  - **Part 1: \u5E02\u5834\u60C5\u7DD2\u8207\u6D88\u606F\u9762\u5206\u6790** (Include Sentiment Score & Catalysts)",
  "  - **Part 2: \u77ED\u4E2D\u9577\u671F\u6280\u8853\u5206\u6790** (Include OHLCV insights & Trends)",
  "  - **Part 3: \u64CD\u4F5C\u5EFA\u8B70\u8207\u7B56\u7565** (Synthesized verdict with specific Entry/Profit/Stop-Loss levels)",
  '    - Explicitly state: "\u77ED\u7DDA(1-4\u9031)", "\u4E2D\u7DDA(1-3\u6708)", "\u9577\u7DDA(\u534A\u5E74\u4EE5\u4E0A)" strategies.',
  "Output MUST be in Traditional Chinese (\u7E41\u9AD4\u4E2D\u6587).",
  'Do not hallucinate data. If data is missing, state "Insufficient Data".'
].join(`
`));
var FinancialReportData = exports_external2.object({
  short_summary: exports_external2.string().describe("A short 2-3 sentence executive summary."),
  markdown_report: exports_external2.string().describe("The full markdown report.")
});
var writerAgent = new Agent({
  name: "WriterAgent",
  instructions: prompt2,
  model: "gpt-5.2",
  modelSettings: {
    temperature: 0.3,
    topP: 1,
    frequencyPenalty: 0,
    presencePenalty: 0,
    parallelToolCalls: true,
    maxTokens: 4096
  },
  outputType: FinancialReportData
});

// src/agents/financialAnalyst.ts
var prompt3 = buildPromptWithContext((appContext) => [
  "You are a Senior Technical Analyst and Quantitative Researcher. Your specialty is interpreting OHLCV data to identify trends and trading signals.",
  'Note: When using Massive tools, prices are already stock split adjusted. Always use "get_today_date" first to anchor your analysis.',
  "Use the latest available data. Double-check your math when calculating percentages or spreads.",
  `Analyze ${appContext.context.stockCode} technical structure across three timeframes using available tools:`,
  "  - **Short-term (Daily)**: Focus on Momentum (RSI, MACD), Volume spikes, and immediate Support/Resistance levels.",
  "  - **Mid-term (Weekly)**: Analyze Trend direction using MA20 & MA50. Look for chart patterns (e.g., Double Bottom, Head & Shoulders).",
  "  - **Long-term (Monthly)**: Assess the major trend relative to the MA200 and year-to-date performance.",
  'Do not just list numbers. Interpret them. (e.g., "Price is above MA50, indicating a bullish mid-term trend").',
  "Explicitly identify Key Levels: Entry Zone, Profit Target, and Stop Loss suggestions based on volatility."
].join(" "));
var financialAnalystAgent = new Agent({
  name: "FinancialAnalystAgent",
  instructions: prompt3,
  model: "gpt-5.2"
});

// src/agents/agentGroup.ts
class AgentGroup {
  plannerAgent;
  financialAnalystAgent;
  newsAnalystAgent;
  writerAgent;
  constructor(plannerAgent2, financialAnalystAgent2, newsAnalystAgent2, writerAgent2) {
    this.plannerAgent = plannerAgent2;
    this.financialAnalystAgent = financialAnalystAgent2;
    this.newsAnalystAgent = newsAnalystAgent2;
    this.writerAgent = writerAgent2;
    this.setupAgentSettings();
  }
  get allAgents() {
    return [this.plannerAgent, this.financialAnalystAgent, this.newsAnalystAgent, this.writerAgent];
  }
  async run(query, context) {
    console.log("connecting to MCP servers");
    await this.connectMCPServers();
    console.log("connected to MCP servers.");
    try {
      const result = await run(writerAgent, query, {
        context
      });
      const parsed = FinancialReportData.safeParse(result.finalOutput);
      if (!parsed.success) {
        throw new Error(`Failed to parse output: ${parsed.error.message}`);
      }
      return result.finalOutput;
    } finally {
      await this.closeMCPServers();
    }
  }
  async connectMCPServers() {
    for (const agent of this.allAgents) {
      for (const mcpServer of agent.mcpServers) {
        await mcpServer.connect();
      }
    }
  }
  async closeMCPServers() {
    for (const agent of this.allAgents) {
      for (const mcpServer of agent.mcpServers) {
        await mcpServer.close();
      }
    }
  }
  setupAgentSettings() {
    const massiveMCPServer = this.getMassiveMCPServer();
    this.writerAgent.mcpServers.push(massiveMCPServer);
  }
  getMassiveMCPServer() {
    return new MCPServerStdio({
      name: "Massive",
      command: "uvx",
      args: [
        "--from",
        "git+https://github.com/massive-com/mcp_massive@v0.7.0",
        "mcp_massive"
      ],
      env: {
        MASSIVE_API_KEY: process.env.MASSIVE_API_KEY
      }
    });
  }
}
var createAgentGroup = () => {
  return new AgentGroup(plannerAgent, financialAnalystAgent, newsAnalystAgent, writerAgent);
};

// src/main.ts
var telegramBot = new TelegramBot;
var agentGroup = createAgentGroup();
var service = new Service(telegramBot, agentGroup);
await service.start();
process.once("SIGINT", gracefulShutdown);
process.once("SIGTERM", gracefulShutdown);
function gracefulShutdown(signal) {
  service.stop(signal).then(() => process.exit(0));
}
